<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GitHub+jsDelivr+PicGo搭建免费、快速图床</title>
    <link href="/2020/02/07/GitHub+jsDelivr+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E3%80%81%E5%BF%AB%E9%80%9F%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/02/07/GitHub+jsDelivr+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E3%80%81%E5%BF%AB%E9%80%9F%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>1.相信不少朋友写markdown博客时，想插入一些图片，会采用本地存储方式，需要手动设置路径并把图片上传，这样稍显麻烦，所以可以考虑将图片上传至图床生成 URL，直接在markdown 引入url。</p><p>2.可是呢，现在国内用的各种图床，例如：微博图床、Imgur、七牛云、又拍云、腾讯云COS、阿里云OSS等都有各种限制，不是收费就是出了防外链。免费的也有SM.MS，不过假如哪天需要收费或者关闭服务了，Blog上的图片只能GG了。</p><p>3.使用GitHub仓库创建一个图床，存在的问题是国内访问github的速度不是很快，可以利用jsDelivr CDN加速访问（jsDelivr 是一个免费开源的 CDN 解决方案）。jsDelivr是首个「打通中国大陆与海外的免费CDN服务」，网页开发者无须担心中国防火墙问题而影响体验。</p><h3 id="实际搭建"><a href="#实际搭建" class="headerlink" title="实际搭建"></a>实际搭建</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>首先得在<code>GitHub</code>创建一个<strong>存放图片</strong>的仓库，这个无须多言。不会的<a href="https://wiki.jikexueyuan.com/project/github-basics/creat-new-repo.html" target="_blank" rel="noopener">点此链接</a>查看如何创建。</p><h4 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h4><p>①访问<a href="https://github.com/settings/tokens，点击`Generate" target="_blank" rel="noopener">https://github.com/settings/tokens，点击`Generate</a> new token`按钮。</p><p><img src="/images/jsdelivr/1.jpg" srcset="/img/loading.gif" alt></p><p>②填入<code>Note</code>，这里就叫PicGo好了，并勾选<code>repo</code> 。</p><p><img src="/images/jsdelivr/2.jpg" srcset="/img/loading.gif" alt></p><p>③滚动到最下面点击<code>Generate token</code>。</p><p><img src="/images/jsdelivr/3.jpg" srcset="/img/loading.gif" alt></p><p>④然后就将生成的<code>token</code>复制下来，后面在<code>PicGo</code>配置的时候会用到。</p><p><img src="/images/jsdelivr/4.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>如果没有复制就离开了此页面，是需要再生成一次的。进入之前输入的<code>Note</code>中会有一个<code>Regenerate token</code>，重新再点击生成一次即可。</p></blockquote><h4 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h4><p>①首先下载安装<code>PicGo</code>软件，Mac与Win都支持。下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p><p>②然后打开<code>PicGo</code>，进入到<code>图床设置</code>-&gt;<code>github图床</code>进行如下配置：</p><p><img src="/images/jsdelivr/5.jpg" srcset="/img/loading.gif" alt></p><p>这里需要注意一下：</p><ul><li>设定仓库名：填写你的仓库名称，格式：用户名/仓库名</li><li>设定分支名：仓库的分支名，一般填写master就行</li><li>设定Token：之前复制下来的token</li><li>指定存储路径：图片在仓库中的存储路径，img/可自定义名称</li><li>设定自定义域名：访问图片的域名，例：<a href="https://cdn.jsdelivr.net/gh/miqilin21/static@master" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/miqilin21/static@master</a></li><li>gh:代表GitHub</li><li>miqilin21/static:用户名/仓库名</li><li>@master:分支名称</li></ul><p>一个完整的图片路径如下，比如存放名为12jiqiao.jpg的图片：</p><pre><code>https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/12jiqiao.jpg</code></pre><p>到这里你就可以搞定了，接下来你可以通过 PicGo 方便地上传图片了，它支持拖拽、点击、剪贴板上传，上传到 Github 仓库后，你就可以复制 PicGo 相册里的图片链接啦。</p><p><img src="/images/jsdelivr/6.jpg" srcset="/img/loading.gif" alt></p><p>当然，你也可以通过 Git 命令，将本地图片批量上传到 Github 对应的仓库上，再替换成原文中的图片链接地址，以完成图片迁移的工作。</p><blockquote><p>关于PicGo的使用，请参考<a href="https://picgo.github.io/PicGo-Doc/zh/" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>整个过程算比较简单，创建 Github 仓库，并获取 token，填入 PicGo 配置，上传图片即可完成。GitHub+jsDelivr+PicGo搭建的图片有这样的好处：</p><ul><li>在 Github 存储图片，利于博主对于图片的掌控，并且Github 仓库的容量有 1G 的上限，对个人博客来说绰绰有余。</li><li>使用 jsDelivr 加速静态文件访问，能够优化博客体验。</li><li>使用 PicGo 的原因是因为能够方便地将上传图片到 Github，并直接获取 jsDelivr 的加速后的图片地址。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端必备英语词汇，你了解多少呢？</title>
    <link href="/2020/01/21/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%E5%91%A2/"/>
    <url>/2020/01/21/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%E5%91%A2/</url>
    
    <content type="html"><![CDATA[<p>掌握前端开发过程中常用的英语词汇还是非常有必要的，现整理出一些前端英语词汇，希望对从事前端的你有所帮助。</p><h2 id="前端常用英语词汇表"><a href="#前端常用英语词汇表" class="headerlink" title="前端常用英语词汇表"></a>前端常用英语词汇表</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>abstraction 抽象、抽象物、抽象性</p><p>access 存取、访问</p><p>account 账户</p><p>action 动作</p><p>activate 激活</p><p>adapter 适配器</p><p>address 地址</p><p>advanced 高级的</p><p>aggregation 聚合、聚集</p><p>algorithm 算法</p><p>alias 别名</p><p>align 排列、对齐</p><p>allocate 分配、配置</p><p>allocator 分配器、配置器</p><p>annotation 注解、评注</p><p>anonymous function 匿名函数</p><p>append 附加</p><p>application 应用、应用程序</p><p>architecture 架构、体系结构</p><p>argument 参数</p><p>array 数组</p><p>arrow 箭头</p><p>assert(ion) 断言</p><p>assign 赋值</p><p>assignment 赋值、分配</p><p>associated 相关的、相关联的</p><p>asynchronous 异步的</p><p>attribute 特性、属性</p><p>augmented 扩充</p><p>authentication 验证</p><p>authorization 授权</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>background 背景、后台（进程）</p><p>backup 备份</p><p>backup device 备份设备</p><p>backup file 备份文件</p><p>backward compatible 向后兼容、向下兼容</p><p>base class 基类</p><p>batch 批处理、批量</p><p>binary tree 二叉树</p><p>binding 绑定</p><p>block 块、区块、语句块</p><p>bound 边界</p><p>brace 花括弧、花括号</p><p>bracket 方括弧、方括号</p><p>buffer 缓冲区</p><p>bug 缺陷错误</p><p>build 编译</p><p>built-in 内建、内置</p><p>business 业务、商务</p><p>business logic 业务逻辑</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>cache 缓存</p><p>call 调用</p><p>callback 回调</p><p>case 分支</p><p>casting 转型、造型转换</p><p>catalog 目录</p><p>chain 链</p><p>character 字符</p><p>chunk 块</p><p>class 类</p><p>class declaration 类声明</p><p>class definition 类定义</p><p>class hierachy 类层次结构</p><p>classification 分类</p><p>clause 子句</p><p>cleanup 清理、清除</p><p>client 客户、客户端</p><p>clipboard 剪贴板</p><p>clone 克隆</p><p>closure 闭包</p><p>collection 集合</p><p>column 行</p><p>command-line 命令行</p><p>command-line interface, CLI 命令行界面</p><p>comment 注释</p><p>commit 提交</p><p>communication 通讯</p><p>compatible 兼容</p><p>compile 编译</p><p>compiler 编译器</p><p>complexity 复杂度</p><p>component 组件</p><p>compression 压缩</p><p>concept 概念</p><p>concrete 具体</p><p>concurrency 并发</p><p>configuration 配置、组态</p><p>connection 连接</p><p>console 控制台</p><p>constant 常量</p><p>construct 构件、成分、概念、构造</p><p>container 容器</p><p>context 环境、上下文</p><p>control 控件</p><p>copy 拷贝、复制</p><p>cover 覆盖、涵盖</p><p>create/creation 创建、生成</p><p>cube 多维数据集</p><p>currying 柯里化</p><p>cursor 光标</p><p>custom 定制</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>data 数据</p><p>data structure 数据结构</p><p>data type 数据类型</p><p>database 数据库</p><p>dataset 数据集</p><p>deallocate 归还</p><p>debug 调试</p><p>debugger 调试器</p><p>decay 退化</p><p>declaration 声明</p><p>deconstruction 解构</p><p>deduction 推导</p><p>default 缺省、默认值</p><p>defer 推迟</p><p>definition 定义</p><p>delegate/delegation 委托</p><p>deploy 部署</p><p>derived 派生</p><p>design pattern 设计模式</p><p>destructuring 解构</p><p>dialog 对话框</p><p>digest 摘要</p><p>digital 数字的</p><p>directory 目录</p><p>disk 盘</p><p>dispatch 调度、分派、派发</p><p>document 文档</p><p>driver 驱动</p><p>dump 转储</p><p>dynamic binding 动态绑定</p><p>dynamic scope 动态作用域</p><p>dynamic type 动态类型</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>efficiency 效率</p><p>encapsulation 封装</p><p>engine 引擎</p><p>entity 实体</p><p>enum(enumeration) 枚举</p><p>equal 相等</p><p>escape character 转义符</p><p>evaluate 评估</p><p>event 事件</p><p>event driven 事件驱动</p><p>evidence 证据</p><p>excaption 异常</p><p>exception handling 异常处理</p><p>exit 退出</p><p>expendable 可扩展的</p><p>explicit 显式</p><p>export 导出</p><p>extensibility 可扩展性</p><p>extent 范围、程度</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>feature 特征、特性、功能</p><p>fetch 提取</p><p>field 字段</p><p>file 文件</p><p>filter 筛选</p><p>finalization 终结</p><p>firewall 防火墙</p><p>flag 标记</p><p>flush 刷新</p><p>form 窗体</p><p>formal parameter 形参</p><p>forward 转发</p><p>forward declaration 前置声明</p><p>framework 框架</p><p>function 函数</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>GC(Garbage collection) 垃圾回收机制</p><p>generate 生成</p><p>generic 泛化的、一般的、通用的</p><p>genericity 泛型</p><p>global 全局的</p><p>global declaration 全局声明</p><p>grant 授权</p><p>group 组、群</p><p>graphical user interface, GUI 图形用户界面</p><p>GUID(Globally Unique Identifier) 全球唯一标识符</p><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>hack 破解</p><p>handle 处理器、处理程序</p><p>hash tables 哈希表</p><p>heap 堆</p><p>hyperlink 超链接</p><p>HyperText Markup Language, HTML 超文本标记语言</p><p>HyperText Transfer Protocol, HTTP 超文本传输协议</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>implement 实现</p><p>implicit 隐式</p><p>import 导入</p><p>indent 缩进</p><p>infinite loop 无线循环</p><p>inheritance 继承</p><p>initialize 初始化</p><p>inline 内联</p><p>instances 实例</p><p>integrate 集成</p><p>interacts 交互</p><p>interface 接口</p><p>interpret 解释</p><p>invoke 调用</p><p>iterate 迭代</p><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>justify 两端对齐</p><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>keywords 关键字</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>lexical 词法的</p><p>lexical scope 词法作用域</p><p>library 库</p><p>list 列表</p><p>literal 字面</p><p>load 加载</p><p>local 局部的</p><p>local variable 局部变量</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>macro 宏</p><p>memory 内存</p><p>memory leaks 内存泄漏</p><p>micro 微</p><p>middleware 中间件</p><p>model 模型</p><p>modifier 修饰符</p><p>module 模块</p><p>mutable 可变的</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>namespace 命名空间</p><p>native 本地的</p><p>nested 嵌套</p><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>object 对象</p><p>object-oriented 面向对象</p><p>object-oriented programming 面向对象编程</p><p>operating system, OS 操作系统</p><p>operation 操作、操作行为 </p><p>operator 运算子、操作符</p><p>optimization 优化</p><p>option 选项</p><p>ordinary 常规的</p><p>orthogonality 正交性</p><p>overflow 溢出</p><p>overload 重载</p><p>override 改写、覆写</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>package 包</p><p>palette 调色盘、组件盘、工具箱</p><p>parallel 平行、并行</p><p>parameter 参数</p><p>parent class 父类</p><p>parentheses 括号</p><p>parse 解析</p><p>parser 解析器</p><p>pass by address 传址、按址传递</p><p>pass by reference 传引用、按引用传递</p><p>pass by value 传值、按值传递</p><p>pattern 模式</p><p>performance 性能</p><p>pixel 像素</p><p>placeholder 占位符</p><p>pointer 指标、指针</p><p>polymorphism 多态</p><p>primitive type 原生类型</p><p>priority 优先级</p><p>procedure 过程</p><p>profile 评测</p><p>property 属性</p><p>protocol 协议</p><p>prototype 原型</p><p>pseudo code 伪码</p><h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><p>qualified 修饰的 </p><p>qualifier 修饰符</p><p>query 查询</p><p>queue 队列</p><p>quote 引用</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>radian 弧度</p><p>radio button 圆钮、单选按钮</p><p>random number 随机数</p><p>recursion 递归</p><p>refactor 重构 </p><p>reference 引用</p><p>register 寄存器</p><p>regular expression 正则表达式</p><p>represent 表现</p><p>request 请求</p><p>resolve 解析</p><p>resolution 解析度</p><p>routine 例程</p><p>routing 路由</p><h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><p>save 储存</p><p>scaffold 脚手架</p><p>scope 作用域</p><p>scripting language 脚本语言</p><p>semantics 语义</p><p>semicolon 分号</p><p>sequence 序列</p><p>server 服务器</p><p>stack 栈</p><p>statement 语句、陈述</p><p>static type 静态类型</p><p>status 状态</p><p>superclass 基类</p><p>superfluous 多余的</p><p>symbol 符号</p><p>syntax 语法</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>table 表格</p><p>tag 标签</p><p>target 目标</p><p>template 模版</p><p>thread 线程</p><p>throw 抛出</p><p>traverse 遍历</p><p>trigger 触发器</p><p>type 类型</p><h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><p>user interface, UI 用户界面</p><p>unqualfied 未修饰的</p><p>uptime 运行时间</p><p>Uniform Resource Locator, URL 统一资源定位符</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>validate 验证</p><p>variable 变量</p><p>view 视图</p><p>virtual machine    虚拟机    </p><p>virtual memory    虚内存</p><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><p>warning message 警告信息</p><p>wildcard 通配符</p><p>window 窗口</p><p>wrapper 包装器</p>]]></content>
    
    
    <categories>
      
      <category>前端相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语术语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之运行机制（Event Loop）</title>
    <link href="/2020/01/14/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/01/14/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>有了一定JavaScript基础的朋友们一定知道，JS里有三座大山，分别指：原型与原型链，作用域与闭包，异步。在之前的JavaScript系列文章里，我就总结了JS前两座（原型、作用域），有兴趣的朋友可以翻阅之前的系列文章，而第三座（异步）也该做一个总结了，这篇文章的目的就是通过了解JS执行顺序及机制，来更好地理顺代码中的一些异步操作。  </p><h3 id="单线程的问题"><a href="#单线程的问题" class="headerlink" title="单线程的问题"></a>单线程的问题</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事，不像诸如Java等多线程语言一样能同时进行多个任务和流程。</p><p>其中JS引擎中负责解释和执行JavaScript代码的线程只有一个，叫它<strong>主线程</strong>。</p><p>但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们<strong>工作线程</strong>。</p><p>但因单线程随之<strong>所带来的问题</strong>是，所有任务都需要排队，上一个任务没执行完，下一个任务就会一直等待，会导致任务执行阻塞。具体的例子是：在浏览器中，要向服务器发送 ajax 请求，http 通信有延迟，而且等待返回数据的时间也未知，那线程就无法处理其他任务了，页面可能长时间会无法接受响应。</p><p>另外，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起，直到 JS 程序执行完成，才会接着执行。因此如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p>所以 JS 用异步任务 (asynchronous callback) 去解决这些<strong>问题</strong>。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>写基础系列文章的过程中经常能碰到<strong>同步</strong>(Synchronous)与<strong>异步</strong>(Asynchronous)的概念，这也是初学JavaScript时容易搞混的特性之一。</p><p>两者容易搞混我觉得很大的原因出在Synchronous在国内被翻译成了「<strong>同步</strong>」，光看字面意思会认为「<strong>同步</strong>」就是「所有动作同时进行」，但事实上<strong>刚好相反</strong>。</p><p>要快速理解同步异步 ， 直接先看一段代码：</p><pre><code class="javascript">console.log(&#39;1&#39;);console.log(&#39;2&#39;);/*打印出12*/</code></pre><p>这段代码的实现就叫做<strong>同步</strong>，也就是说按照顺序一步一步来处理，做完第一件事情之后，再去做下一件事情。</p><p>再来看另一段代码：</p><pre><code class="javascript">console.log(&#39;1&#39;);setTimeout(function () {  console.log(&#39;2&#39;);},1000)console.log(&#39;3&#39;);/*打印出132*/</code></pre><p>这段代码的实现就叫做<strong>异步</strong>，也就是说不完全按照顺序去做，如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要通过一定的手段等待一段时间去得到，这样也就不耽搁时间。</p><p>所以说JavaScript的同步代码比较好理解，而其优势之一是其如何处理异步代码。异步代码会被放入一个事件队列（下面会讲到），等到所有其他代码执行后才进行，而不会阻塞线程，接下来将重点介绍<strong>异步</strong>。</p><h3 id="异步过程是如何形成的？"><a href="#异步过程是如何形成的？" class="headerlink" title="异步过程是如何形成的？"></a>异步过程是如何形成的？</h3><p>简单的总结一下，一个异步过程通常是这样的：</p><ol><li>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；</li><li>主线程可以继续执行后面的代码，同时工作线程执行异步任务；</li><li>工作线程完成工作后，通知主线程；</li><li>主线程收到通知后，执行一定的动作(调用回调函数)。</li></ol><p>异步函数通常具有以下的形式：</p><pre><code class="javascript">A(argus..., callbackFn)</code></pre><p>其中，函数A可以叫做异步过程的发起函数，也叫做异步任务注册函数。<code>argus</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p><p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p><ul><li>发起函数(或叫注册函数)<code>A</code></li><li>回调函数<code>callbackFn</code></li></ul><p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。</p><p>举一个栗子：</p><pre><code class="javascript">setTimeout(fn, 1000);</code></pre><p>其中的<code>setTimeout</code>就是异步过程的发起函数，<code>fn</code>是回调函数。</p><p>注意：前面说的形式<code>A(argus..., callbackFn)</code>只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：</p><pre><code class="javascript">var request = new XMLHttpRequest();request.open(&#39;GET&#39;, url);request.send(); // 发起函数request.onreadystatechange = xxx; // 添加回调函数</code></pre><p>这种形式的发起函数和回调函数就是分离的。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>上面提到了异步任务完成后，会通知主线程，以 <code>callback</code> 的方式获取结果或者执行回调。但是如果当前的主线程是忙碌的，异步任务的信号无法接收到怎么办呢？所以还需要一个地方保存这些 <code>callback</code>，也就是<strong>任务队列（task queue）</strong>。</p><p>那么这里就要具体提提JavaScript 异步执行的<strong>运行机制</strong>了，先用一张图来表现整个过程：</p><p><img src="/images/eventloop/1.jpg" srcset="/img/loading.gif" alt></p><p>上图的完整过程就是：所有同步任务都在主线程上执行，形成一个执行栈，当执行栈遇到异步任务时（浏览器通常是调用 WebAPIs，常见的有 <code>XMLHttpRequest</code>，<code>setTimeout</code>，事件回调等），不会等待，而是继续执行往下执行。而异步任务就会以各种方式，把 <code>callback</code> 加入任务队列中。一旦执行栈中的所有同步任务执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个 <code>callback</code> 任务放入到栈中执行。结束后栈内被清空，还会再去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，而这种循环的机制，就称之为<strong>事件循环</strong>（Event Loop）。</p><h3 id="Event-Loop-事件循环"><a href="#Event-Loop-事件循环" class="headerlink" title="Event Loop(事件循环)"></a>Event Loop(事件循环)</h3><p>事件循环可不是像上面一样一句两句就能讲清的，并且暂时不讨论node.js的Event Loop执行机制，以下关于浏览器的Event Loop执行机制，那在完全了解 Event Loop 之前，还需了解一下宏任务与微任务，因为任务队列又分为<code>macrotask</code>（宏任务）与<code>microtask</code>（微任务），在 ES2015 中 <code>macrotask</code> 即指 Task，而 <code>microtask</code> 则是指代 Job。</p><ul><li>宏任务大概包括：<code>script</code>(整体代码), <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>（Nodejs环境）, <code>I/O</code>, <code>UI rendering</code>。</li><li>微任务大概包括: <code>process.nextTick</code>（Nodejs环境）, <code>Promise</code>, <code>Object.observe</code>(已废弃), <code>MutationObserver</code>(html5新特性)。</li></ul><p>关于<code>macrotask</code>和<code>microtask</code>的理解，得结合事件循坏的机制，下面这张图就可以说是介绍得很清楚了。</p><p><img src="/images/eventloop/2.jpg" srcset="/img/loading.gif" alt></p><p>事件循环的顺序，决定了JavaScript代码的执行顺序，一次事件循环的步骤简单总结起来就是：</p><ol><li>检查<code>macrotask</code>队列是否为空，非空则到步骤2，为空则到步骤3；</li><li>执行<code>macrotask</code>中的一个任务；</li><li>继续检查<code>microtask</code>队列是否为空，非空则到步骤4，否则到步骤5；</li><li>取出<code>microtask</code>中的任务执行，执行完成返回到步骤3；</li><li>检查是否需要进行视图更新，需要则进行更新，否则进行下一轮的事件循环；</li></ol><p>上面这么多文字表述是不是有点晦涩难懂，那我们通过2个demo例子来逐步理解<strong>事件循环</strong>的具体顺序吧：</p><pre><code class="javascript">//demo1console.log(1);//setTimeout1setTimeout(()=&gt;{    console.log(2);    Promise.resolve().then(data =&gt; {        console.log(3);    });}); //setTimeout2setTimeout(()=&gt;{    console.log(4);}); Promise.resolve().then(data=&gt;{    console.log(5);});// 1，5，2，3，4</code></pre><p>我们来说明一下, JS引擎是如何执行这段代码的：</p><ol><li>主线程上遇到<code>console.log(1)</code>同步代码，执行，输出’1’。</li><li>接着遇到<code>setTimeout1</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在<strong>下</strong>一次的事件循环中执行)。</li><li>接着遇到<code>setTimeout2</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在<strong>下下</strong>一次的事件循环中执行)。</li><li>首先检查微任务队列, 即 <code>microtask</code>队列，发现此队列不为空，执行第一个<code>promise</code>的<code>then</code>回调，输出 ‘5’。</li><li>此时<code>microtask</code>队列为空，进入下一个事件循环, 检查宏任务队列，发现有 <code>setTimeout1</code>的回调函数，立即执行回调函数输出 ‘2’,检查<code>microtask</code> 队列，发现队列不为空，执行<code>promise</code>的<code>then</code>回调，输出’3’，<code>microtask</code>队列为空，进入下一个事件循环。</li><li>检查宏任务队列，发现有 <code>setTimeout2</code>的回调函数, 立即执行回调函数输出’4’。</li></ol><p>再思考一下下面代码的执行顺序：</p><pre><code class="javascript">//demo2console.log(1);//setTimeout1setTimeout(function () {    console.log(2);}, 0);//setTimeout2setTimeout(function () {    console.log(3);    //setTimeout3    setTimeout(function () {        console.log(4);    });    Promise.resolve().then(function () {        console.log(5);    });}, 200);//Promise1Promise.resolve().then(function () {    console.log(6);}).then(function () {    console.log(7);});//Promise2Promise.resolve().then(function () {    console.log(8);});console.log(9);// 1，9，6，8，7，2，3，5，4</code></pre><p>我们来说明一下, JS引擎是如何执行这段代码的：</p><ol><li>首先顺序执行完主进程上的同步任务，第一句和最后一句的<code>console.log</code>。</li><li>接着遇到<code>setTimeout1</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在<strong>下</strong>一次的事件循环中执行)；</li><li>接着遇到<code>setTimeout2</code>，它的作用是在 200ms 后将回调函数放到宏任务队列中(这个任务在<strong>下下</strong>一次的事件循环中执行)；</li><li>同步任务执行完之后，首先检查微任务队列, 即 <code>microtask</code>队列，发现此队列不为空，执行第一个<code>promise</code>的<code>then</code>回调，输出 ‘6’，然后执行第二个<code>promise</code>的<code>then</code>回调，输出’8’，由于第一个<code>promise</code>的<code>.then()</code>的返回依然是<code>promise</code>，所以第二个<code>.then()</code>会放到<code>microtask</code>队列继续执行，输出 ‘7’;</li><li>此时<code>microtask</code>队列为空，进入下一个事件循环, 检查宏任务队列，发现有 <code>setTimeout1</code> 的回调函数，立即执行回调函数输出 ‘2’,检查<code>microtask</code> 队列，队列为空，进入下一次事件循环；</li><li>检查宏任务队列，发现有 <code>setTimeout2</code> 的回调函数, 立即执行回调函数输出’3’；</li><li>接着遇到<code>setTimeout3</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)，检查微任务队列，即 <code>microtask</code> 队列，发现此队列不为空，执行<code>promise</code>的<code>then</code>回调，输出’5’；</li><li>此时<code>microtask</code>队列为空，进入下一个事件循环，检查宏任务队列，发现有 <code>setTimeout3</code> 的回调函数，立即执行回调函数输出，输出’4’。至此代码执行结束。</li></ol><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>这里再补一道面试题，如何执行这段代码的过程就不详细说明了，朋友们自行去体会：</p><pre><code class="javascript">console.log(&#39;1&#39;);setTimeout(function() {    console.log(&#39;2&#39;);    process.nextTick(function() {        console.log(&#39;3&#39;);    })    new Promise(function(resolve) {        console.log(&#39;4&#39;);        resolve();    }).then(function() {        console.log(&#39;5&#39;)    })})process.nextTick(function() {    console.log(&#39;6&#39;);})new Promise(function(resolve) {    console.log(&#39;7&#39;);    resolve();}).then(function() {    console.log(&#39;8&#39;)})setTimeout(function() {    console.log(&#39;9&#39;);    process.nextTick(function() {        console.log(&#39;10&#39;);    })    new Promise(function(resolve) {        console.log(&#39;11&#39;);        resolve();    }).then(function() {        console.log(&#39;12&#39;)    })})// 1，7，6，8，2，4，3，5，9，11，10，12// node环境下的事件监听依赖libuv驱动I/O库与前端环境不完全相同，输出顺序可能会有误差</code></pre><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="https://blog.csdn.net/leftfist/article/details/41891407" target="_blank" rel="noopener">Node.js机制及原理理解初步</a></li><li><a href="http://lynnelv.github.io/js-event-loop-nodejs" target="_blank" rel="noopener">深入理解js事件循环机制（Node.js篇）</a></li></ul><p>后续自己也会追加一篇关于Node.js的事件循环机制的文章。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>运行机制</tag>
      
      <tag>Event Loop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之深入理解对象属性</title>
    <link href="/2020/01/03/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/"/>
    <url>/2020/01/03/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://zhuanlan.zhihu.com/p/64928794" target="_blank" rel="noopener">《谈谈JavaScript中对象建立(Object)》</a>这一文中，我们曾经简单地介绍过对象及其创建方式。在今天这一篇文章当中呢，我们要更深入地来理解JavaScript的对象与其他编程语言的对象有何差异。</p><p>开始介绍之前先来复习一下。</p><p>之前说过，所有原始类型(Primitives) 以外的值都是对象，原始类型有以下几种：</p><ul><li><code>string</code></li><li><code>number</code></li><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>symbol</code> (ES6 新增)</li></ul><p>除了上述这些以外的类型，都是对象。</p><h3 id="JavaScript-真是一门面向对象的编程语言吗？"><a href="#JavaScript-真是一门面向对象的编程语言吗？" class="headerlink" title="JavaScript 真是一门面向对象的编程语言吗？"></a>JavaScript 真是一门面向对象的编程语言吗？</h3><p>在过去JS语言的发展中，这个话题已经被讨论过无数次，有人说它是，也有人说它不那么像是。就像一个使用Java或C#或者其他面向对象开发语言的开发者接触JavaScript的时候，他总会抱怨JavaScript太混乱、没有类型、结构也不好，还有很多奇奇怪怪的地方，它的对象支持也是微乎其微，因此他绝对不是一个面向对象编程的语言。</p><p>但JavaScript 确实是一门面向对象的编程语言，只是它与其他语言很大不同的地方是，它的继承方法是通过”prototype” 来实现的。其余大多数的面向对象的编程语言（比如Java）是以「类」为基础的(<code>class-based</code>) ，但JavaScript 没有<code>class</code>、没有<code>extends</code> ，却可以通过「原型」(<code>prototype-based</code>) 来建立起对象之间的继承关系。</p><p>PS：ES6虽然新增了<code>class</code>语法，但仍然属于<code>prototype-based</code>的继承。<code>class</code>实质上只是通过简洁的语法来建立对象和处理继承的语法糖。</p><h3 id="JavaScript-自定义对象"><a href="#JavaScript-自定义对象" class="headerlink" title="JavaScript 自定义对象"></a>JavaScript 自定义对象</h3><p>先前曾介绍过，在JavaScript创建对象我们可以通过<code>new</code>关键字：</p><pre><code class="javascript">var person = new Object();person.name = &#39;mike&#39;;</code></pre><p>或是直接用大括号<code>{ }</code>，即可创建起一个新的对象：</p><pre><code class="javascript">var person = {  name: &#39;mike&#39;};</code></pre><h3 id="理解JavaScript构造函数"><a href="#理解JavaScript构造函数" class="headerlink" title="理解JavaScript构造函数"></a>理解JavaScript构造函数</h3><p>虽然JavaScript没有<code>class</code>的语法，但如果你希望JavaScript也能像其他面向对象编程语言一样有类似<code>class</code>的语法时，可以怎么做呢？由于函数也是个对象，所以可以借用来当作「构造函数」来建立其他对象：</p><pre><code class="javascript">function Person( name, age, gender ){  this.name = name;  this.age = age;  this.gender = gender;  this.greeting = function(){    console.log(&#39;Hello! My name is &#39; + this.name + &#39;.&#39;);  };}var mike = new Person( &#39;Mike&#39;, 28, &#39;male&#39;);mike.greeting();      // &quot;Hello! My name is Mike.&quot;var jay = new Person( &#39;Jay&#39;, 18, &#39;male&#39;);jay.greeting();      // &quot;Hello! My name is Jay.&quot;</code></pre><p>像这样，我们建立了一个<code>Person</code>构造函数(Constructor) ，然后就可以通过<code>new</code>关键字来建立各种对应的对象。</p><p>为什么JavaScript明明没有<code>class</code>却可以通过<code>new</code>一个函数来建立对象？这里简单拆解一下流程：</p><pre><code class="javascript">function Person( name, age, gender ){  // 和上面一致，这里省略}var mike = new Person( &#39;Mike&#39;, 28, &#39;male&#39;);/*===&gt; var mike = {};===&gt; Person.call(mike, &#39;Mike&#39;, 28, &#39;male&#39;);*/</code></pre><p>通过<code>new Person(...)</code>这个动作，返回的对象会有<code>name</code>, <code>age</code>, <code>gender</code>以及<code>greeting</code>属性，而JavaScript会在背景执行<code>Person.call</code>方法，将<code>mike</code>作为<code>this</code>的参考对象，然后把这些属性通通新增到<code>mike</code>对象中。</p><p>但是，即使是通过构造函数（Constructor）建立的对象，这个对象的属性仍然可以通过<code>.</code>来公开存取：</p><pre><code class="javascript">function Person( name, age, gender ){  // 和上面一致，这里省略}var mike = new Person( &#39;Mike&#39;, 28, &#39;male&#39;);console.log( mike.age );    // 32// 因为是公开属性，所以可以很无耻地开放修改mike.age = 18;console.log(mike.age );    // 18</code></pre><h3 id="属性描述符-Property-descriptor"><a href="#属性描述符-Property-descriptor" class="headerlink" title="属性描述符(Property descriptor)"></a>属性描述符(Property descriptor)</h3><p>从ES5开始，我们可以通过新的对象模型来控制对象属性的存取、删除、列举等功能。这些特殊的属性，我们将它称为「<strong>属性描述符</strong>」（Property descriptor）。</p><p><strong>属性描述符</strong>一共可以分为六种：</p><ol><li><code>value</code>: 属性的值</li><li><code>writable</code>:定义属性是否可以改变，如果是<code>false</code>那就是只可读属性。</li><li><code>enumerable</code>:定义对象内的属性是否可以通过<code>for-in</code>语法来迭代。</li><li><code>configurable</code>:定义属性是否可以被删除、或修改属性内的<code>writable</code>、<code>enumerable</code>及<code>configurable</code>设定。</li><li><code>get</code>: 对象属性的getter function。</li><li><code>set</code>: 对象属性的setter function。</li></ol><p>上述除了<code>value</code>之外的值都可以不设定，<code>writable</code>、<code>enumerable</code>及<code>configurable</code>的默认值是<code>false</code>，而<code>get</code>与<code>set</code>如果没有特别指定则是<code>undefined</code>，并且前四种属性不能和<code>get</code>与<code>set</code>混用，否则会抛出错误。</p><p>这些「属性描述符」必须要通过ES5所提供的<code>Object.defineProperty()</code>来处理。</p><h3 id="Object-defineProperty-与Object-getOwnPropertyDescriptor"><a href="#Object-defineProperty-与Object-getOwnPropertyDescriptor" class="headerlink" title="Object.defineProperty 与Object.getOwnPropertyDescriptor"></a>Object.defineProperty 与Object.getOwnPropertyDescriptor</h3><p>我们可以通过<code>Object.defineProperty</code>来定义对象的属性描述，用法：<code>Object.defineProperty(obj, prop, descriptor)</code>。</p><p>其中：<code>obj</code>-&gt;要在其上定义属性的对象；<code>prop</code>-&gt;要定义或修改的属性的名称；<code>descriptor</code>-&gt;将被定义或修改的属性描述符。</p><p>下面通过实际范例来解释：</p><p>一般来说，要建立一个简单对象，我们可以用这样方式：</p><pre><code class="javascript">var person = {  name: &#39;mike&#39;};</code></pre><p>当然，我们也可以通过<code>Object.defineProperty</code>来定义对象<code>person</code>的属性：</p><pre><code class="javascript">var person = {};Object.defineProperty(person, &#39;name&#39;, {  value: &#39;mike&#39;});</code></pre><p>这样的方式与直接指定对象字面属性是一样的结果。</p><p>然后，我们可以用<code>Object.getOwnPropertyDescriptor()</code>来检查对象属性描述器的状态：</p><pre><code class="javascript">var person = {};Object.defineProperty(person, &#39;name&#39;, {  value: &#39;mike&#39;});Object.getOwnPropertyDescriptor(person, &#39;name&#39;);</code></pre><p><img src="/images/object2/1.jpg" srcset="/img/loading.gif" alt></p><p>可以看到在默认的情况下，<code>writable</code>、<code>enumerable</code>及<code>configurable</code>都是<code>false</code>。</p><pre><code class="javascript">var person2 = {  name: &#39;mike&#39;};console.log(Object.getOwnPropertyDescriptor(person2, &#39;name&#39;));</code></pre><p><img src="/images/object2/2.jpg" srcset="/img/loading.gif" alt></p><p>而通过字面式创建对象建立的属性，默认值则会是<code>true</code>。</p><p><code>defineProperty</code>可以针对对象一次设定多个属性描述：</p><pre><code class="javascript">Object.defineProperty(person, &#39;name&#39;, {  value: &#39;mike&#39;,  writable: false,  enumerable: false,  configurable: false});</code></pre><p>或是分别设定：</p><pre><code class="javascript">Object.defineProperty(person, &#39;name&#39;, {  enumerable: true});</code></pre><p>这些都是合法的做法。</p><p>假设我们已经定义<code>person.name</code>属性描述<code>configurable</code>为<code>false</code>的情况：</p><pre><code class="javascript">var person = {};Object.defineProperty(person, &#39;name&#39;, {  value: &#39;mike&#39;,  writable: false,  enumerable: false,  configurable: false});</code></pre><p>那么此时，我们再去执行删除属性的行为：</p><pre><code class="javascript">delete person.name;   // it will return false</code></pre><p>虽然不会出错，但是你会发现执行结果会返回<code>false</code>，且<code>person</code>对象的<code>name</code>属性依然存在。同样地，当<code>writable</code>为<code>true</code>时，你去尝试删除属性「值」的时候，你会发现结果是无效的。</p><p>要注意的是，上面这些行为，若是在「严格模式」下则会发生<code>TypeError</code>的错误。</p><h3 id="属性的get-与set-方法"><a href="#属性的get-与set-方法" class="headerlink" title="属性的get 与set 方法"></a>属性的get 与set 方法</h3><p>在本文的开始，我们介绍了早期在ES5以前通过<code>this.getXXX()</code>与<code>this.setXXX()</code>来作为<code>get</code>与<code>set</code>的存取方法。</p><p>而现在ES5提供了<code>Object.defineProperty()</code>之后，我们可以更直观地来处理这些方法：</p><pre><code class="javascript">var person = {};Object.defineProperty(person, &#39;name&#39;, {  get: function(){    console.log(&#39;get&#39;);    return this._name_;  },  set: function(name){    console.log(&#39;set&#39;);    this._name_ = name;  }});</code></pre><p>像这样，我们可以分别为<code>name</code>属性去定义<code>get</code>与<code>set</code>方法，而实际上，我们是通过了另一个属性<code>_name_</code>来作为<code>name</code>属性的封装。要注意的是，如果你定义了<code>get</code>与<code>set</code>方法，表示你要自行控制属性的存取，那么就不能再去定义<code>value</code>或<code>writable</code>的属性描述。</p><p>理解了ES5的对象属性描述符之后，往后我们在对对象的属性处理就可以更加灵活，像是VueJS也是通过Object.defineProperty的get与set来做到双向数据绑定的：</p><p><img src="/images/object2/3.jpg" srcset="/img/loading.gif" alt></p><p>每个组件实例都对应一个<strong>watcher</strong>实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 <code>setter</code> 触发时，会通知 <code>watcher</code>，从而使它关联的组件重新渲染。</p><p>图片来源：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue.js: 如何追踪变化</a></p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些好用的工具、网站</title>
    <link href="/2019/12/23/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99/"/>
    <url>/2019/12/23/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。   </p><h4 id="Evernote：一款神奇的笔记"><a href="#Evernote：一款神奇的笔记" class="headerlink" title="Evernote：一款神奇的笔记"></a>Evernote：一款神奇的笔记</h4><p>✔如果一款工具能满足你对笔记的所有需求的话，那就是Evernote了，写笔记，列清单，时间管理，录音，工作同步，手机和电脑端都可下载…   </p><p>✔如果你还没用过，推荐你现在关闭答案去应用市场下载一个，相信我你都会爱上它的。</p><p><img src="/images/tool/1.jpg" srcset="/img/loading.gif" alt></p><h4 id="免费人工智能PPT制作平台：beautiful-ai"><a href="#免费人工智能PPT制作平台：beautiful-ai" class="headerlink" title="免费人工智能PPT制作平台：beautiful.ai"></a>免费人工智能PPT制作平台：<a href="https://www.beautiful.ai/" target="_blank" rel="noopener">beautiful.ai</a></h4><p>✔这个国外的黑科技网站，网站提供很多超赞的板式，我们将文字放进去，AI智能帮助我们制作PPT。真的让我这个一做PPT就头疼的人，感到开心！   </p><p>✔没广告还免费！   </p><p><img src="/images/tool/2.jpg" srcset="/img/loading.gif" alt></p><h4 id="录制GIF工具-：GifCam"><a href="#录制GIF工具-：GifCam" class="headerlink" title="录制GIF工具 ：GifCam"></a>录制GIF工具 ：GifCam</h4><p>✔录制动图对许多人来说也算是必备的东西了。   </p><p>✔窗口化录屏，也可以直接设置全屏幕录制，录制完毕后直接保存为 GIF 图片，软件大小不超过 2M，简直太方便太良心了~    </p><p><img src="/images/tool/3.jpg" srcset="/img/loading.gif" alt></p><h4 id="截图-贴图神器：Snipaste"><a href="#截图-贴图神器：Snipaste" class="headerlink" title="截图/贴图神器：Snipaste"></a>截图/贴图神器：Snipaste</h4><p>✔它在我心中绝对可以堪称神器了！令人惊叹不仅仅是它的强大截图功能，而是它的贴图功能也实在是太好用了！   </p><p><img src="/images/tool/4.jpg" srcset="/img/loading.gif" alt></p><h4 id="设计网址导航网站：牛大拿"><a href="#设计网址导航网站：牛大拿" class="headerlink" title="设计网址导航网站：牛大拿"></a>设计网址导航网站：<a href="http://www.niudana.com/" target="_blank" rel="noopener">牛大拿</a></h4><p>✔精选国内外优秀的UI设计网站,设计参考文章与免费的UI设计素材与资源，每日更新Dribbble精选内容、Behance精选内容、站酷精选内容、UI中国…   </p><p>✔一定也有设计师不知道这个网站滴。   </p><p><img src="/images/tool/5.jpg" srcset="/img/loading.gif" alt></p><h4 id="国外设计师常用网站：Dribbble"><a href="#国外设计师常用网站：Dribbble" class="headerlink" title="国外设计师常用网站：Dribbble"></a>国外设计师常用网站：<a href="https://dribbble.com/" target="_blank" rel="noopener">Dribbble</a></h4><p>✔通过 Dribbble，你可以浏览许多创意设计，它们出自世界各地的个人设计师、设计团队以及设计公司。   </p><p>✔这些作品并不仅限于网页或手机 app 设计，还有图片设计、品牌设计、动画、插图、平面艺术等等。    </p><p><img src="/images/tool/6.jpg" srcset="/img/loading.gif" alt></p><h4 id="国内设计师常用网站：花瓣网"><a href="#国内设计师常用网站：花瓣网" class="headerlink" title="国内设计师常用网站：花瓣网"></a>国内设计师常用网站：花瓣网</h4><p>✔花瓣网算是一个国内比较好的素材采集网，平时想要找的各种类型的图片素材在花瓣都能采集到，比如平面、漫画、摄影、UI等等。    </p><p>✔而且花瓣的素材普遍都很有设计感和时尚感，很适合年轻一代做设计。   </p><p><img src="/images/tool/7.jpg" srcset="/img/loading.gif" alt> </p><h4 id="设计师和开发常用网站：iconfont-cn"><a href="#设计师和开发常用网站：iconfont-cn" class="headerlink" title="设计师和开发常用网站：iconfont.cn"></a>设计师和开发常用网站：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont.cn</a></h4><p>✔阿里巴巴旗下的免费icon百科网站，可免费下载矢量源文件，选择时可以打包所有你感兴趣的放在购物车，Download时还可以选择颜色和大小,很贴心有木有！同时支持下载开发用代码。   </p><p>✔比如搜索关键词“love”看到的结果：   </p><p><img src="/images/tool/8.jpg" srcset="/img/loading.gif" alt></p><h4 id="壁纸天堂：Wallhaven"><a href="#壁纸天堂：Wallhaven" class="headerlink" title="壁纸天堂：Wallhaven"></a>壁纸天堂：<a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">Wallhaven</a></h4><p>✔图片量大而且还高清，分类清晰(人物/风景/动画)。   </p><p>✔相比一些图库不全，广告遍地，收费下载的壁纸网站，免费下载的wallhaven简直就是业界良心。</p><p><img src="/images/tool/9.jpg" srcset="/img/loading.gif" alt></p><h4 id="在线制作流程图网站：ProcessOn"><a href="#在线制作流程图网站：ProcessOn" class="headerlink" title="在线制作流程图网站：ProcessOn"></a>在线制作流程图网站：<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a></h4><p>✔ProcessOn在线支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 </p><p>✔轻松绘制，基本上是0难度上手。</p><p><img src="/images/tool/10.jpg" srcset="/img/loading.gif" alt></p><h4 id="在线生成图片链接网站：SM-MS"><a href="#在线生成图片链接网站：SM-MS" class="headerlink" title="在线生成图片链接网站：SM.MS"></a>在线生成图片链接网站：<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a></h4><p>✔SM.MS图床网站只需上传一张本地的图片，点击生成链接即可，操作简单快捷。</p><p>✔永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式。   </p><p><img src="/images/tool/11.jpg" srcset="/img/loading.gif" alt></p><h4 id="Listary：电脑文件秒搜-路径直达"><a href="#Listary：电脑文件秒搜-路径直达" class="headerlink" title="Listary：电脑文件秒搜+路径直达"></a>Listary：电脑文件秒搜+路径直达</h4><p>✔软件体积非常小，全局本地搜索的便捷工具，设置热键后，能在任何环境下调出窗口搜索文件，如我设置的是’Win+F’，想要找某文件时按下Win+F调出小长条搜索框就能进行实时搜索，非常便捷。    </p><p>✔相信你用了后会觉得它很高效的。  </p><p><img src="/images/tool/12.jpg" srcset="/img/loading.gif" alt></p><h4 id="v9porn"><a href="#v9porn" class="headerlink" title="v9porn"></a><a href="https://github.com/techGay/v9porn" target="_blank" rel="noopener">v9porn</a></h4><p>✔看到上面的标题，想必大多数人都知道了吧嘿嘿嘿</p><p>✔那这个项目就不多介绍了，自行体会，体验好的话就默默点个赞哦   </p><p><img src="/images/tool/13.jpg" srcset="/img/loading.gif" alt>  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之立即执行函数IIFE</title>
    <link href="/2019/12/17/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0IIFE/"/>
    <url>/2019/12/17/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0IIFE/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们已经介绍了函数的参数，arguments对象以及回调函数，那么在今天的分享中，我们继续来看看函数在JavaScript的另外一种面貌——立即执行函数表达式（Immediately Invoked Functions Expressions，IIFE）。</p><p><strong>IIFE(Immediately Invoked Functions Expressions)</strong>其实可以就字面上直接来理解，Immediately就是立即的意思，invoked则是执行某个函数时「执行」的意思，function expression是一种用来创建函数的方法，<strong>总的来说，就是用函数表达式的方式建立函数后并立即执行它</strong>。</p><p>下面我们将做更进一步的介绍和说明。</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>JavaScript 中有两种常见的声明函数的方法，分别是通过<strong>function 命令</strong>或<strong>函数表达式声明</strong>，来看个简单的例子：</p><pre><code class="javascript">// function 命令 function  sayHi ( name )  {   console . log ( &#39;Hi&#39;  + name ) ; } sayHi( &#39;miqilin&#39; ) ;// 函数表达式var  sayHello  =  function ( name )  {   console . log ( &#39;Hello &#39;  + name ) ; } sayHello( &#39;miqilin&#39; ) ;</code></pre><h3 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h3><p>那么什么是<strong>IIFE</strong>呢？如同文章一开始所叙述的，<strong>IIFE指的就是通过函数表达式的方式来创建函数，并且立即执行它</strong>。那我们要怎么做呢？</p><p>首先我们可以用console.log的方式，先来看一下，我们刚刚创建的sayHello打印出来会长什么样子呢？</p><pre><code class="javascript">// 函数表达式var  sayHello  =  function ( name )  {   console . log ( &#39;Hello &#39;  + name ) ; } console.log(sayHello);</code></pre><p>结果会发现，直接把sayHello打印出来后，它会直接返回整个函数的代码内容，这是尚未”执行（Invoked）”代码前的结果。</p><p><img src="/images/IIFE/1.jpg" srcset="/img/loading.gif" alt></p><p>如果是IIFE就在这段代码的最后，加上一个执行的指令，也就是括号<code>( )</code>：</p><p><img src="/images/IIFE/2.jpg" srcset="/img/loading.gif" alt></p><p>上图就可以看出，在我们定义函数的同时，这段函数就会立即被执行了，当然最后的<code>( )</code>中可以加入参数：</p><p><img src="/images/IIFE/3.jpg" srcset="/img/loading.gif" alt></p><p>那如果我们把前面的声明变量去了呢，变成一个匿名函数：</p><pre><code class="javascript">//不可行的做法function ( name )  {   console.log( &#39;Hello &#39;  + name ) ; }</code></pre><p>但是这么做是不可行的，因为JavaScript引擎在解析代码的时候，你用<code>function</code>作为开头，引擎会认为你现在要输入<code>function</code> 命令去创建函数，<strong>可是你却没有给该function名称，于是它无法正确理解这段代码便抛出错误</strong>：</p><p><img src="/images/IIFE/4.jpg" srcset="/img/loading.gif" alt></p><p>所以，这时候我们要做的是告诉JavaScript 引擎说，这一整个并不是<code>function</code> 命令。要达到这样的目的，我们要让引擎在解析代码的时候，不是以读到<code>function</code> 作为开头。</p><p>为了要达到这样的目的，我们最常使用的做法就是用括号<code>()</code>将<code>function(){ ...}</code>包起来，像是这样：</p><pre><code class="javascript">(function ( name )  {   console.log( &#39;Hello &#39;  + name ) ; });</code></pre><p><strong>因为我们只会在括号内放入表达式，例如(3+2)，而不会放命令在括号内，所以JavaScript就会以表达式的方式来读取这段函数。</strong></p><p>在这种情况下，这个函数会被建立，但是不会被存在任何变量当中，也不会被执行。</p><p>结合刚刚上面IIFE的概念，我们可以在创建这个函数的同时，将这个函数加以执行，我们同样只需要在最后加上括号<code>()</code>就可以了：</p><p><img src="/images/IIFE/5.jpg" srcset="/img/loading.gif" alt></p><p>这样IIFE的型式，会在许多的JavaScript框架中都看得到，比如jQuery，jQuery用了这样的手法将<code>window</code>与<code>undefined</code>保留起来：</p><pre><code class="javascript">(function( window, undefined ) {  // 略...})( window );</code></pre><p>其中<code>undefined</code>是可以被修改的，虽然jQuery在IIFE定义了两个参数，但只传了一个<code>winodw</code>，就是为了保持<code>undefined</code>原本的样子。</p><p><strong>通过这样的方式，我们可以「直接执行某个函数」，一个很重要的一点是，这样做不仅避免了外界访问此 IIFE 内的变量，而且又不会污染全局作用域。</strong></p><h3 id="IIFE执行过程解析"><a href="#IIFE执行过程解析" class="headerlink" title="IIFE执行过程解析"></a>IIFE执行过程解析</h3><p>先看段IIFE实例代码：</p><pre><code class="javascript">//IIFE (function(name){  var greeting = &#39;Hello&#39;;  console.log(greeting+ &#39; &#39; +name);})(&quot;miqilin&quot;);</code></pre><p>让我们看看，当我们在执行这段代码的过程中，JavaScript引擎实际发生了什么事吧！</p><p>首先，当我执行这段代码时，会先建立全局执行上下文（Global Execution Context），但这时候这个执行上下文里面是没有任何内容的，因为我们并没有在全局这层建立任何变量（如果有的话，变量的名称会先提升在全局上下文中。）</p><p><img src="/images/IIFE/6.jpg" srcset="/img/loading.gif" alt></p><p>接着，JavaScript引擎会执行到我们所建立的这段IIFE，它会将这个匿名函数储存在全局执行上下文。</p><p><img src="/images/IIFE/7.jpg" srcset="/img/loading.gif" alt></p><p>由于我们在函数的最后有加上<code>( )</code>，所以这段函数会立即被执行，也因此，JavaScript会为这个匿名函数建立一个新的执行上下文。</p><p><img src="/images/IIFE/8.jpg" srcset="/img/loading.gif" alt></p><p>接着，它会去逐行执行我们这个函数中的代码内容，它发现到我们的代码中建立了一个变量，名称是”greeting”，因此，这个变量就被建立在函数的这个执行上下文中，而不是被建立在全局上下文中。</p><p><img src="/images/IIFE/9.jpg" srcset="/img/loading.gif" alt></p><p>因此，通过IIFE，我们可以发现，在IIFE中所建立的变量，都不会影响到全局执行上下文所建立的变量，这里再次提一下，通过IIFE，它避免了我们的变量间可能会互相干扰覆盖的情况。</p><h3 id="IIFE的实际应用"><a href="#IIFE的实际应用" class="headerlink" title="IIFE的实际应用"></a>IIFE的实际应用</h3><p>让我们先回到上面的代码，这时候我们在函数的外面，声明一个同样的变量名(greeting)。</p><pre><code class="javascript">//全局执行上下文var greeting = &#39;Hi&#39;;//IIFE(function(name){  var greeting = &#39;Hello&#39;;  console.log(greeting+ &#39; &#39; +name);})(&quot;miqilin&quot;);console.log(greeting);</code></pre><p>这时候的打印出的顺序为：</p><p><img src="/images/IIFE/10.jpg" srcset="/img/loading.gif" alt></p><p>你会发现，虽然同样都是调用greeting这个变量，但是一个是在函数执行上下文内的greeting，一个是在全局执行上下文的greeting，两者是不会互相影响的。</p><p>同样把它画成上面一样的图形，它们两个是不同的执行上下文被储存在不同的内存中，所以不会相互影响。</p><p><img src="/images/IIFE/11.jpg" srcset="/img/loading.gif" alt></p><p>如此，我们可以很直观地确定，放在IIFE里面的变量，并不会影响到其他外层的变量，也不会被外层的变量影响到。</p><h3 id="如果执意要影响外层变量呢？"><a href="#如果执意要影响外层变量呢？" class="headerlink" title="如果执意要影响外层变量呢？"></a>如果执意要影响外层变量呢？</h3><p>虽然我们使用IIFE的主要目的就是希望不同执行上下文之间的变量不要互相影响，但如果我们还是想让函数执行上下文这层的变量能够同时影响到全局执行上下文的变量时，我们可以怎么操作呢？</p><p>首先，我们得多一个参数，叫做global，在最后带入参数的地方，我们填入对象<code>window</code>，由于我们知道对象是引用类型的特性，因此我们可以直接针对<code>window</code>里面的对象去做改变，像这里，我就可以直接把<code>global</code>层次的对象改成<code>hola</code>（<code>global.greeting = &#39;Hola&#39;</code>）：</p><pre><code class="javascript">//全局执行上下文var greeting = &#39;Hi&#39;;//IIFE(function(global, name){  var greeting = &#39;Hello&#39;;  global.greeting = &#39;Hola&#39;;  console.log(greeting+ &#39; &#39; +name);})(window, &quot;miqilin&quot;);console.log(greeting);</code></pre><p>结果如下，原本在全局执行上下文的<code>Hi</code>，被变换为<code>Hola</code>了：</p><p><img src="/images/IIFE/12.jpg" srcset="/img/loading.gif" alt></p><p>这操作够骚吧！哈哈~</p><h3 id="一道IIFE经典面试题"><a href="#一道IIFE经典面试题" class="headerlink" title="一道IIFE经典面试题"></a>一道IIFE经典面试题</h3><p>题目是这样的：假设想通过循环+ setTimeout来做到，在五秒钟之内，每秒钟依序通过<code>console.log</code>打印出：<code>0 1 2 3 4</code></p><pre><code class="javascript">for( var i = 0; i &lt; 5; i++ ) {  window.setTimeout(function() {    console.log(i);  }, 1000);}</code></pre><p>真的是这样吗？我们来看看执行的结果：</p><pre><code>//过了接近一秒五个五同时打出55555</code></pre><p>为什么会这样呢？</p><p>我们知道， JavaScript是一个「异步」的语言，所以当我们执行这段代码时，<code>for</code>循环并不会等待<code>window.setTimeout</code>结束后才继续，而是在执行阶段就<strong>一口气跑完</strong>。</p><p>也就是说，当<code>window.setTimeout</code>内的回调函数执行时，拿到的<code>i</code>已经是跑完<code>for()</code>循环的<code>5</code>。</p><p><img src="/images/IIFE/13.jpg" srcset="/img/loading.gif" alt></p><p>那么要怎么解决这个问题呢？</p><p>我们可以把<code>window.setTimeout</code>包装成一个IIFE，这个问题就迎刃而解了：</p><pre><code class="javascript">for( var i = 0; i &lt; 5; i++ ) {  // 为了凸显差异，我们将传入后的参数改名为 x  // 当然由于作用域的不同，要继续在内部沿用 i 也是可以的。  (function(x){    window.setTimeout(function() {      console.log(x);    }, 1000);  })(i);}</code></pre><p>这时候你会发现，执行的结果就会是我们预期的<code>0 1 2 3 4</code>了，但还是有一个问题：就是<code>0 1 2 3 4</code>还是在一秒钟后同时出现啊？怎么解决？</p><p>嘿嘿，相信聪明的你已经发现，由于<code>for</code>循环在一瞬间就跑完，等于那一瞬间它向<code>window</code>依序注册了五次timer，每个timer都只等待一秒钟，当然同时出现喽。</p><p>所以我们稍微修改一下：</p><pre><code class="javascript">for( var i = 0; i &lt; 5; i++ ) {  (function(x){    // 将原来的 1000 改成 1000 * x    window.setTimeout(function() {      console.log(x);    }, 1000 * x);  })(i);}</code></pre><p>像这样，就可以依序打印出我们想要的结果喽！</p><p>[注] ES6以后新增了<code>let</code>与<code>const</code>，且改以<code>{ }</code>作为它的块级作用域。</p><p>换句话说，将上例中的<code>for</code>改为<code>let</code>就可以做到保留<code>i</code>在执行循环当下的「值」，打出一样的效果：</p><pre><code class="javascript">for( let i = 0; i &lt; 5; i++ ) {  window.setTimeout(function() {    console.log(i);  }, 1000*(i+1));}</code></pre><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再那么必要了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>IIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之回调函数</title>
    <link href="/2019/12/10/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/2019/12/10/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们已经介绍了函数的参数与arguments对象，那么今天的分享中，我们继续来看看函数在JavaScript的各种不同面貌——回调函数。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>你可能常听到人家在谈论回调函数（Callback function），但你真的知道回调函数是什么吗？其实回调函数跟一般的函数没什么不同，差别只在于被调用执行的时机。</p><p>先前介绍事件的时候有说过，「JavaScript 是一个事件驱动(Event-driven) 的编程语言」，而事件的概念就如同：</p><p><strong>办公室电话响了(事件被触发Event fired) -&gt; 接电话(处理事件Event Handler)</strong></p><p>而写成代码形式就类似：</p><pre><code class="javascript">// 注：这里只是比喻，并没有电话响这个事件Office.addEventListener( &#39;电话响&#39;, function 接电话(){ }, false);</code></pre><p>可以看到，<code>Office</code>通过<code>addEventListener</code>方法去注册了一个事件，当这个事件被触发时，它会去执行我们所指定的第二个参数，也就是某个「函数」(接电话)。</p><p>换句话说，这个函数只会在满足了某个条件才会被动地去执行，我们就可以说这是一个<strong>回调函数</strong>。</p><p>经历过各种「事件」的你，想必也发现了一件事，所谓的回调函数其实就是「<strong>把函数作为参数传递给另一个函数，然后通过另一个函数来调用它</strong>」。</p><p>不知大家有没有听懂？那我再讲一个简单案例吧：</p><pre><code class="javascript">window.setTimeout( function(){ ... }, 1000);</code></pre><p>如果我们希望隔某段时间之后，执行某件事，就可以通过<code>window.setTimeout</code>来帮助我们完成。</p><p>像是上面的范例中，<code>window.setTimeout</code>带有两个参数，第一个是要做的事情，用一个函数来代表，第二个则是时间(1/1000秒, milliseconds)。而第一个参数的函数也是回调函数的一种：「在经过了某段时间之后，才执行的函数」。</p><p>当然，上面两个范例中的回调函数我们也可以把它单独抽出来定义：</p><pre><code class="javascript">var handler = function 接电话() {};Office.addEventListener( &#39;电话响&#39;, handler, false);</code></pre><p>这样会使你的代码看起来更清楚。</p><p>除了事件以外，还有另一个会需要用到回调函数的场景，就是「<strong>控制多个函数间执行的顺序</strong>」。</p><p>啥意思呢？来看个简单的例子：</p><pre><code class="javascript">var funA = function(){  console.log(&#39;function A&#39;);};var funB = function(){  console.log(&#39;function B&#39;);};funA();funB();</code></pre><p>因为<code>funcA</code>与<code>funcB</code>都会立即执行，并且JavaScript 的单线程模型决定了同时只能执行一个任务，其他任务都必须在后面排队等待，所以执行结果必定为：</p><pre><code>function Afunction B</code></pre><p>但是，如果<code>funcA</code>是异步操作，<code>funcB</code>会立即执行，不会等到<code>funcA</code>结束再执行：</p><pre><code class="javascript">var funA = function(){  window.setTimeout(function(){    console.log(&#39;function A&#39;);  }, 1000);};var funB = function(){  console.log(&#39;function B&#39;);};funA();funB();</code></pre><p>像这种时候，为了确保先执行<code>funcA</code>，就可以通过回调函数的形式来进行处理：</p><pre><code class="javascript">// 为了确保先执行 funA 再执行 funB// 我们在 funA 加上 callback 参数var funA = function(callback){  window.setTimeout(function(){    console.log(&#39;function A&#39;);    // 如果 callback 是个函数就调用它    if( typeof callback === &#39;function&#39; ){      callback();    }  }, 1000);};var funB = function(){  console.log(&#39;function B&#39;);};// 将 funB 作为参数带入 funA()funA( funB );</code></pre><p>像这样，无论<code>funA</code>在执行的时候要等多久，<code>funB</code>都会等到<code>console.log(&#39;function A&#39;);</code>之后才执行。</p><p>不过需要注意的是，我们可以将不止一个的回调函数作为参数传递给一个函数，就像我们能够传递不止一个变量一样，过多的异步编程嵌套在一起产生的多重回调函数甚至叫回调地狱，维护起来真的如名字一样会很可怕！</p><p>多重回调函数就类似下面这样的形式：</p><pre><code class="javascript">function async(arg, callback) {  console.log(&#39;参数为 &#39; + arg +&#39; , 1秒后返回结果&#39;);  setTimeout(function () { callback(arg * 2); }, 1000);}function final(value) {  console.log(&#39;完成: &#39;, value);}async(1, function (value) {  async(2, function (value) {    async(3, function (value) {      async(4, function (value) {        async(5, function (value) {          async(6, final);        });      });    });  });});</code></pre><p>执行结果为：</p><pre><code>参数为 1 , 1秒后返回结果参数为 2 , 1秒后返回结果参数为 3 , 1秒后返回结果参数为 4 , 1秒后返回结果参数为 5 , 1秒后返回结果参数为 6 , 1秒后返回结果完成:  12</code></pre><p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p><p>如果真的不幸需要写到这么多层，这点后续我们介绍到<code>Promise</code>时会再说明如何摆脱这种困境。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Callback function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript事件三部曲之事件的兄弟姐妹们</title>
    <link href="/2019/12/03/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%84%E5%BC%9F%E5%A7%90%E5%A6%B9%E4%BB%AC/"/>
    <url>/2019/12/03/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%84%E5%BC%9F%E5%A7%90%E5%A6%B9%E4%BB%AC/</url>
    
    <content type="html"><![CDATA[<p>在前面的两篇文章中，已经介绍了事件的传达机制，以及如何阻止事件的冒泡与默认的行为。 那么，作为「事件三部曲」的最后一篇，我们就来大概介绍一下，DOM 规范之中究竟提供了哪些事件。</p><h3 id="事件的种类"><a href="#事件的种类" class="headerlink" title="事件的种类"></a>事件的种类</h3><p>浏览器可能发生的事件有很多种，了解这些事件的情境及效果，是 Web 开发不能忽略的基础，接下来介绍一下常见的几种事件：</p><h4 id="界面相关事件"><a href="#界面相关事件" class="headerlink" title="界面相关事件"></a>界面相关事件</h4><p>界面相关的事件不一定会与使用者对 DOM 的操作有关系，反而大多数与window对象比较有关系。</p><ul><li><code>load</code> 事件：</li></ul><p>注册在 <code>window</code> 对象上，指的是在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。</p><pre><code class="javascript">window.addEventListener(&#39;load&#39;, function(event) {  console.log(&#39;所有资源都加载完成&#39;);});</code></pre><ul><li><code>unload</code> 、 <code>beforeunload</code> 事件：</li></ul><p>与 <code>load</code> 事件相反，<code>unload</code> 与 <code>beforeunload</code> 事件分别会在离开页面或重新整理时触发，而 <code>beforeunload</code> 会跳出对话框询问使用者是否要离开当前页面。</p><p><img src="/images/event/7.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>error</code> 事件：</li></ul><p><code>error</code> 事件会在 <code>document</code> 或是图片载入错误时触发。由于考虑到维护性，大多事件的注册我会强烈建议使用「非侵入式 JavaScript」的写法，即JavaScript代码和标记的分离。只有 <code>error</code> 事件最适合以 <code>on-event</code> 的写法来处理：</p><pre><code class="html">&lt;img src=&quot;image.jpg&quot; onerror=&quot;this.src=&#39;default.jpg&#39;&quot;&gt;</code></pre><p>像这样，当<code>image.jpg</code>这张图片不存在的时候，马上就会触发<code>error</code>事件，就会通过<code>this.src</code>将<code>&lt;img&gt;</code>的 <code>src</code> 属性替换成指定的图片，是相当实用的技巧。</p><p>若是在网页 <code>load</code> 完成后才注册了<code>error</code>事件，你只会看到破图的结果，因为<code>error</code>事件不会再次被触发，后来挂上去的事件处理函数就等于没有一样。</p><ul><li><p><code>resize</code>事件：在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p></li><li><p><code>scroll</code>事件：在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p></li><li><p><code>DOMContentLoaded</code>事件：</p></li></ul><p>类似于<code>load</code>事件，但不同的是，<code>load</code>事件是在网页「所有」资源都已经载入完成后才会触发，而<code>DOMContentLoaded</code>事件是在 DOM 结构被完整的读取跟解析后就会被触发，不须等待外部资源读取完成，因此可以这么说，这两者所监听的阶段不同，可以用下面这张图来解释：</p><p><img src="/images/event/8.jpg" srcset="/img/loading.gif" alt></p><p>我们在<a href="https://zhuanlan.zhihu.com/p/66576306" target="_blank" rel="noopener">《通过DOM API 查找节点》</a>这篇文章中曾介绍过，<code>&lt;script&gt;</code>标签要是放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间，因为还没解析到网页本体会有选取不到 DOM 的问题对吧？</p><pre><code class="html">&lt;html&gt;&lt;head&gt;  &lt;script&gt;    // 因 Document 结构未载入，无效    document.getElementById(&#39;hello&#39;).textContent = &#39;Hello&#39;;  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;hello&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>那么，改成这样：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;  &lt;script&gt;    document.addEventListener(&quot;DOMContentLoaded&quot;, function() {      // 当 document 结构已解析完成才会执行      document.getElementById(&#39;hello&#39;).textContent = &#39;Hello&#39;;    }, false);  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;hello&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>就可以排除<code>&lt;script&gt;</code>标签放在<code>&lt;head&gt; ... &lt;/head&gt;</code>抓不到 DOM 的问题啦。</p><p>与大家所熟知的 <code>jQuery$( document ).ready( handler )</code>作用类似。</p><h4 id="鼠标相关事件"><a href="#鼠标相关事件" class="headerlink" title="鼠标相关事件"></a>鼠标相关事件</h4><ul><li><p><code>mousedown</code> / <code>mouseup</code> 事件: 这两个事件分别会在鼠标点击了某元素「按下」(mousedown) 按钮，以及「放开」(mouseup)按钮时触发。</p></li><li><p><code>click</code> 事件: 当鼠标「点击」了某元素时触发。</p></li><li><p><code>dblclick</code>事件: 当鼠标「连点两次」某元素时触发。</p></li><li><p><code>mouseenter</code> / <code>mousemove</code> / <code>mouseleave</code> 事件：这三个事件要放在一起看：</p></li></ul><ol><li>当鼠标光标移入了某元素时，会先触发 <code>mouseenter</code> 事件。</li><li>鼠标光标在这个元素內「移动」时，会连续触发 <code>mousemove</code> 事件。</li><li>直到鼠标光标离开了这个元素，才触发 <code>mouseleave</code> 事件。</li></ol><p><img src="/images/event/9.gif" srcset="/img/loading.gif" alt></p><p>这些鼠标相关的事件，都可以通过<code>event.pageX</code> 与 <code>event.pageY</code>属性去取得目前鼠标在网页对应的坐标。</p><h4 id="键盘相关事件"><a href="#键盘相关事件" class="headerlink" title="键盘相关事件"></a>键盘相关事件</h4><p>键盘常用相关事件有下列三种，在大多数情况下会将键盘事件注册在 <code>input</code> 的输入框上。</p><ul><li><p><code>keydown</code> 事件: 「压下」键盘按键时会触发 <code>keydown</code> 事件。</p></li><li><p><code>keypress</code> 事件: 除了 Shift, Fn, CapsLock 这三种按键外按住时会触发，若按着不放则会连续触发。</p></li><li><p><code>keyup</code> 事件: 「放开」键盘按键时会触发。</p></li></ul><p>如果我们针对同个元素同时绑定了这三个键盘事件，那么这三个事件执行的顺序会是：</p><pre><code>keydownkeypresskeyup</code></pre><p>若此时想要知道使用者按下的按键是哪个，则可以通过<code>event.keyCode</code>属性来查询。<code>keyCode</code>的对应表可以到<a href="https://gist.github.com/tylerbuchea/8011573" target="_blank" rel="noopener">这里</a>查看：</p><p>例如，今天你想要当使用者在<code>input</code>输入框按下 「enter」 时，发动<code>submit</code>，就可以这样做：</p><pre><code class="javascript">textBox.addEventListener(&#39;keydown&#39;, function(e){  // enter 的 keyCode 是 13  if( e.keyCode === 13 ){    formSubmit();  }}, false);</code></pre><p>像这样，通过<code>e.keyCode</code>就可以判断使用者目前按下的是哪个按钮。</p><h4 id="表单相关事件"><a href="#表单相关事件" class="headerlink" title="表单相关事件"></a>表单相关事件</h4><ul><li><p><code>input</code> 事件： 当 <code>input</code>、 <code>textarea</code> 以及带有 <code>contenteditable</code> 的元素內容被改变时，就会触发 <code>input</code> 事件。</p></li><li><p><code>change</code> 事件： 当 <code>input</code>、<code>select</code>、<code>textarea</code>、<code>radio</code>、<code>checkbox</code> 等表单元素被改变时触发。 但与 <code>input</code> 事件不同的是，<code>input</code> 事件会在输入框输入內容的当下触发，而 <code>change</code> 事件则是在目前焦点离开输入框后才触发。</p></li><li><p><code>submit</code> 事件：当表单被送出时触发，通常表单验证都会在这一步处理，若验证未通过则 <code>return false;</code>。</p></li><li><p><code>focus</code> 事件：当元素被聚焦时触发。</p></li><li><p><code>blur</code> 事件：当元素失去焦点时触发。</p></li></ul><h4 id="特殊事件"><a href="#特殊事件" class="headerlink" title="特殊事件"></a>特殊事件</h4><ul><li>Composition Event (组成事件):</li></ul><p><strong>Composition Event</strong> 其实指的是 <code>compositionstart</code> 、 <code>compositionend</code> ，以及 <code>compositionupdate</code> 这三个事件。</p><p>介绍 Composition Events 之前先来谈谈 DOM API 过去对输入框侦测变化的几个方式：</p><p>常见的表单输入框如: <code>&lt;input type=&quot;text&quot;&gt;</code> 如果要动态监听输入框的文字变化时， 大多会通过监听 <code>keydown</code>、<code>keypress</code>、<code>keyup</code> 等键盘事件来判断 <code>value</code> 是否变动，但如果是通过「<strong>复制粘贴</strong>」之类的操作，就无法通过键盘事件来判断。</p><p>而即使是 <code>change</code> 事件则是要在使用者改变內容，且<strong>焦点离开输入框</strong>的前一刻才会被触发。</p><p>所以后来有了 <code>input</code> 事件， <code>input</code> 事件会在输入框的<strong>內容被改变时即时触发</strong>，确实也解决了过去在 <code>onChange</code> 以及键盘相关事件功能不足所产生的问题。</p><p>但是，新的问题来了！</p><p>通常像这样的搜索框，我们会用类似 <code>autocomplete</code> (自动完成) 的方式给使用者搜索建议 (以 google 为例)：</p><p><img src="/images/event/10.jpg" srcset="/img/loading.gif" alt></p><p>如上图，在输入中文的时候，通常会需要通过注音之类的输入法来做拼字。</p><p>但是在大部分的情況下，针对「注音符号」或是「拼音文字」去给搜索建议是没有太大意义的。</p><p>这个时候就需要通过 <code>Composition Events</code> 来为输入框做增强。</p><p>通过 <code>Composition Events</code> 我们可以观察使用者在输入框內开启输入法 (Input Method Editor, IME) 时，组字或选字的状态。</p><p>Composition Events 提供三个事件给开发者监听：分別是 <code>compositionstart</code> 、 <code>compositionend</code> ，以及 <code>compositionupdate</code>。</p><ul><li><code>compositionstart</code>: 输入框內开启输入法，且正在拼字时触发。</li><li><code>compositionupdate</code>: 输入框內开启输入法，且正在拼字或选字时更改了內容时触发。</li><li><code>compositionend</code>: 输入框內开启输入法，拼字或选字完成，正要送出至输入框时触发。</li></ul><p>执行的时候像这样：</p><p><img src="/images/event/11.jpg" srcset="/img/loading.gif" alt></p><p>可以看到，如果要确认使用者输入完成并送出文字时，就可以通过<code>compositionend</code>来做最后确认。</p><h4 id="自订事件"><a href="#自订事件" class="headerlink" title="自订事件"></a>自订事件</h4><p>自订事件可以用<code>Event constructor</code>建立，同样通过<code>addEventListener</code>去监听，由<code>dispatchEvent</code>决定触发的时间。</p><pre><code class="javascript">var event = new Event(&#39;build&#39;);// 监听事件elem.addEventListener(&#39;build&#39;, function (e) { ... }, false);// 触发事件elem.dispatchEvent(event);</code></pre><p>若是想要在自订事件內增加更多资料，则可以改用<code>CustomEvent</code>：</p><pre><code class="javascript">var event = new CustomEvent(&#39;build&#39;, { &#39;detail&#39;: elem.dataset.time });</code></pre><p>那么在 Event 处理函数就可以通过<code>event</code>来接收：</p><pre><code class="javascript">function eventHandler(e) {  log(&#39;The time is: &#39; + e.detail);}</code></pre><p>当然，浏览器提供的事件相当多，今天分享的部分主要是比较常见的一些事件，以及工作上实际需要特別注意的部分。</p><p>其他的多数事件你都可以在 MDN 的 <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">Event reference</a> 找到。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>事件</tag>
      
      <tag>event</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript事件三部曲之隐藏在其中的&#39;秘密&#39;</title>
    <link href="/2019/11/28/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9A%90%E8%97%8F%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2019/11/28/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9A%90%E8%97%8F%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/73091706" target="_blank" rel="noopener">上篇文章</a>我们提到，注册事件的方法addEventListener()内有三个参数，分别是「事件名称」、「事件的处理程序」，以及「捕获」或「冒泡」的机制切换。</p><p>那么，今天我们要来看的第一个部分，就是隐藏在事件处理程序中的<code>event</code> 。</p><h3 id="隐藏在监听函数中的”event”"><a href="#隐藏在监听函数中的”event”" class="headerlink" title="隐藏在监听函数中的”event”"></a>隐藏在监听函数中的”event”</h3><p>当监听的事件发生时，浏览器会去执行我们通过<code>addEventListener()</code>注册的事件处理程序函数。</p><p>这个时候，EventListener 会去创建一个「事件对象」 (Event Object)，里面包含了所有与这个事件相关的属性，并且以「参数」的形式传给我们的处理程序函数：</p><pre><code class="javascript">&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;......var btn = document.getElementById(&#39;btn&#39;);// 参数 e 就是上面所说的事件对象 // 因为是参数，当然可以自己定名称btn.addEventListener(&#39;click&#39;, function(e){  console.log(e);}, false);</code></pre><p>当点击<code>&lt;button&gt;</code>后，可以从<code>console</code>看到<code>event</code>对象中提供了这么多东西：</p><p><img src="/images/event/5.jpg" srcset="/img/loading.gif" alt></p><p>像是</p><ul><li><code>type</code> : 表示事件的名称</li><li><code>target</code> : 表示触发事件的元素</li><li><code>bubbles</code>:表示这事件是否是在「冒泡」阶段触发( <code>true</code>/ <code>false</code>)</li><li><code>pageX</code>/ <code>pageY</code>:表示事件触发时，鼠标座标在网页的相对位置</li></ul><p>其余的属性这里就不一一介绍，不过要注意的是，每个「事件对象」所提供的属性都会根据触发的事件而稍微不同。</p><h3 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event. preventDefault()"></a>event. preventDefault()</h3><p>HTML中部分元素会有默认行为，像是<code>&lt;a&gt;</code>标签默认页面跳转或是锚点定位，或是表单的<code>submit</code>等等…</p><p>如果我们需要在这些元素上绑定事件，那么适当地<strong>取消它们的默认行为</strong>就是很重要的一件事。</p><p>比如，有一个通往baidu的链接<code>&lt;a&gt;</code>:</p><pre><code class="html">&lt;a id=&quot;link&quot; href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code></pre><p>假设今天点击这个link时，我希望浏览器执行<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;那么根据先前所说，我可以先注册<code>click</code>事件：</p><pre><code class="javascript">var link = document.querySelector(&#39;#link&#39;);link.addEventListener(&#39;click&#39;, function (e) {  console.log(&#39;米淇淋你好coll!&#39;);}, false);</code></pre><p>结果你却发现，即便我们在<code>&lt;a&gt;</code>中去注册了<code>click</code>事件，但是当我点击这个link的时候，浏览器开始会console.log出”米淇淋你好帅!”，但最后baidu的网页依旧会覆盖我想要的内容。</p><p>可是我希望执行的是<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;而不是直接把我带偏了去到baidu的网站，那么我们该怎么做，才能避免呢？</p><p>这时候如果<strong>调用<code>event.preventDefault()</code>方法，默认事件行为将不再触发</strong>：</p><pre><code class="javascript">var link = document.querySelector(&#39;#link&#39;);// 在 事件处理函数中 加上 e.preventDefault();link.addEventListener(&#39;click&#39;, function (e) {  e.preventDefault();  console.log(&#39;米淇淋你好帅!&#39;);}, false);</code></pre><p>这个时候，再试着点击link一次，你会发现浏览器默认的跳转页面的行为不见了，<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;也可顺利执行啦哈哈。</p><p>但要注意的是，<code>event.preventDefault()</code>并不会阻止事件向上传递(即事件冒泡) 。</p><p>另外，值得一提的是，下面这样设置也可以让a标签仅仅当做一个普通的按钮，点击实现一个功能，不想页面跳转，也不想锚点定位：</p><pre><code class="html">&lt;a href=&quot;javascript:;&quot;&gt;链接&lt;/a&gt;</code></pre><p>此外，在事件处理函数的<strong>最后</strong>加上<code>return false</code>;也会有<code>event.preventDefault()</code>的效果，但切记不可以加在前面，若是加在前面事件处理函数就直接gg了。</p><h3 id="event-stopPropagation-amp-event-stopImmediatePropagation"><a href="#event-stopPropagation-amp-event-stopImmediatePropagation" class="headerlink" title="event.stopPropagation() &amp; event.stopImmediatePropagation()"></a>event.stopPropagation() &amp; event.stopImmediatePropagation()</h3><p>1.<code>event.stopPropagation()</code> 方法阻止事件向上冒泡传递，阻止任何父事件处理程序被执行。</p><p>接下来我们看个例子：</p><pre><code class="javascript">&lt;div&gt;  &lt;div id=&quot;parent&quot;&gt;    父元素    &lt;div id=&quot;child&quot;&gt;子元素&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;......var parent = document.getElementById(&#39;parent&#39;);var child = document.getElementById(&#39;child&#39;);child.addEventListener(&#39;click&#39;, function () {  console.log(&#39;child bubbling&#39;);}, false);parent.addEventListener(&#39;click&#39;, function () {  console.log(&#39;parent bubbling&#39;);}, false);document.body.addEventListener(&#39;click&#39;, function () {  console.log(&#39;body bubbling&#39;);}, false);document.documentElement.addEventListener(&#39;click&#39;, function () {  console.log(&#39;html bubbling&#39;);}, false);document.addEventListener(&#39;click&#39;, function () {  console.log(&#39;document bubbling&#39;);}, false);window.addEventListener(&#39;click&#39;, function () {  console.log(&#39;window bubbling&#39;);}, false);</code></pre><p>当我点击的是「子元素」的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><pre><code>child bubblingparent bubblingbody bubblinghtml bubblingdocument bubblingwindow bubbling</code></pre><p>而如果在「子元素」中加入<code>event.stopPropagation()</code> 方法，其余保持原样的话：</p><pre><code class="javascript">child.addEventListener(&#39;click&#39;, function (e) {  console.log(&#39;child bubbling&#39;);  e.stopPropagation();}, false);</code></pre><p>再次点击「子元素」，则只出现：</p><pre><code>child bubbling</code></pre><p>其余父事件不会触发，即<code>event.stopPropagation()</code> 方法阻止了事件向上冒泡传递，阻止任何父事件处理程序被执行。</p><p>2.<code>stopImmediatePropagation()</code>方法 <strong>既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发</strong>。而 stopPropagation 只能实现前者的效果。</p><p>我们来看个例子：</p><pre><code class="javascript">&lt;body&gt;  &lt;button id=&quot;btn&quot;&gt;click me to stop propagation&lt;/button&gt;&lt;/body&gt;......var btn = document.querySelector(&#39;#btn&#39;);btn.addEventListener(&#39;click&#39;, function(e) {  console.log(&#39;btn click 1&#39;);  //e.stopImmediatePropagation();});btn.addEventListener(&#39;click&#39;, function() {  console.log(&#39;btn click 2&#39;);});document.body.addEventListener(&#39;click&#39;, function() {  console.log(&#39;body click&#39;);});document.documentElement.addEventListener(&#39;click&#39;, function() {  console.log(&#39;html click&#39;);});document.addEventListener(&#39;click&#39;, function() {  console.log(&#39;document click&#39;);});window.addEventListener(&#39;click&#39;, function() {  console.log(&#39;window click&#39;);});</code></pre><p>当我点击button的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><pre><code>btn click 1btn click 2body clickhtml clickdocument clickwindow click</code></pre><p>而如果在「btn的第一个监听函数」中加入<code>event.stopImmediatePropagation()</code> 方法，其余保持原样的话：</p><pre><code class="javascript">btn.addEventListener(&#39;click&#39;, function(e) {  console.log(&#39;btn click 1&#39;);  e.stopImmediatePropagation();});</code></pre><p>再次点击button，则只出现：</p><pre><code>btn click 1</code></pre><p>所以说，使用 <code>stopImmediatePropagation()</code> 方法后，点击按钮时，仅触发设置了<code>stopImmediatePropagation()</code> 方法的监听器，与此同时按钮的其余同类型点击事件不触发。</p><h3 id="event-target-amp-event-currentTarget"><a href="#event-target-amp-event-currentTarget" class="headerlink" title="event.target &amp; event.currentTarget"></a>event.target &amp; event.currentTarget</h3><p>老实说并不能好好用文字描述这两者的区别，我们直接看个例子：</p><pre><code class="javascript">&lt;style&gt;  #a{    width: 200px;    height: 200px;    background: yellow       ;  }  #b{    width: 150px;    height: 150px;    background: green;  }  #c{    width: 100px;    height: 100px;    background: grey;  }  #d{    width: 50px;    height: 50px;    background: black;  }&lt;/style&gt;......&lt;div id=&quot;a&quot;&gt;  &lt;div id=&quot;b&quot;&gt;    &lt;div id=&quot;c&quot;&gt;      &lt;div id=&quot;d&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;......document.getElementById(&#39;a&#39;).addEventListener(&#39;click&#39;, function(e) {    console.log(      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id    )})  document.getElementById(&#39;b&#39;).addEventListener(&#39;click&#39;, function(e) {    console.log(      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id    )})  document.getElementById(&#39;c&#39;).addEventListener(&#39;click&#39;, function(e) {    console.log(      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id    )})  document.getElementById(&#39;d&#39;).addEventListener(&#39;click&#39;, function(e) {    console.log(      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id    )})</code></pre><p><a href="https://jsbin.com/rubedoqepi/edit?html,js,output" target="_blank" rel="noopener">jsbin</a> 点这里。</p><p><img src="/images/event/6.gif" srcset="/img/loading.gif" alt></p><p>当我们点击最里层黑色区域的元素d的时候，会依次输出:</p><pre><code>target:d&amp;currentTarget:dtarget:d&amp;currentTarget:ctarget:d&amp;currentTarget:btarget:d&amp;currentTarget:a</code></pre><p>从输出中我们可以看到，<code>event.target</code>指向引起触发事件的元素，而<code>event.currentTarget</code>则是事件绑定的元素，只有被点击的那个目标元素的<code>event.target</code>才会等于<code>event.currentTarget</code>。<strong>也就是说，<code>event.currentTarget</code>始终是监听事件者，而<code>event.target</code>是事件的真正发出者</strong>。</p><p>另外，值得一提的是，function内部的<code>this</code>指的也就是<code>event.currentTarget</code>。</p><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件代理或叫事件委托（Event Delegation）。</p><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><ul><li>减少内存消耗，提高性能</li></ul><p>假设有一个列表，列表之中有大量的列表项，我们需要在点击每个列表项的时候响应一个事件：</p><pre><code class="html">&lt;ul id=&quot;myList&quot;&gt;  &lt;li&gt;Item 1&lt;/li&gt;  &lt;li&gt;Item 2&lt;/li&gt;  &lt;li&gt;Item 3&lt;/li&gt;  ......  &lt;li&gt;Item n&lt;/li&gt;&lt;/ul&gt;</code></pre><p>如果给每个列表项都绑定一个函数，假如此时列表项很多，那无疑对内存的消耗是非常大的，并且效率上需要消耗很多性能。借助事件代理，我们只需要给父容器 <code>ul</code> 绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。</p><ul><li>动态绑定事件</li></ul><p>在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。</p><h4 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h4><p>接下来我们来实现上例中父层元素 <code>#myList</code> 下的 <code>li</code> 元素的事件委托到它的父层元素上：</p><pre><code class="javascript">// 取得容器var myList = document.getElementById(&#39;myList&#39;);// 让父层 myList 来监听 click 事件myList.addEventListener(&#39;click&#39;, function(e){  // 判断目标元素若是 li 则执行 console.log  if( e.target.tagName.toLowerCase() === &#39;li&#39; ){    console.log(e.target.textContent);  }}, false);// 建立新的 &lt;li&gt; 元素var newList = document.createElement(&#39;li&#39;);// 建立 textNode 文字节点var textNode = document.createTextNode(&quot;Hello world!&quot;);// 通过 appendChild 将 textNode 加入至 newListnewList.appendChild(textNode);// 通过 appendChild 将 newList 加入至 myListmyList.appendChild(newList);</code></pre><p>我们把<code>click</code>事件改由父层的<code>myList</code>来监听，利用事件传递的原理，判断<code>e.target</code>是我们想要的目标节点时，才去执行后续的动作。</p><p>这样的好处是你的事件管理会非常轻松，而且后续加上的<code>newList</code>也会有<code>click</code>的效果，无需另外再去绑定<code>click</code>事件。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>事件</tag>
      
      <tag>event</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript事件三部曲之事件机制的原理</title>
    <link href="/2019/11/26/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2019/11/26/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 是一个事件驱动(Event-driven) 的语言，当浏览器载入网页开始读取后，虽然马上会读取JavaScript 事件相关的代码，但是必须要等到「事件」被触发(如使用者点击、按下键盘等)后，才会再进行对应代码段的执行。</p><p>啥意思呢？</p><p>就好比放了一部电话在家里，但是电话要是没响，我们不会主动去「接电话」 (没人打来当然也无法主动接) ，这里电话响了就好比事件被触发，接电话就好比去做对应的事情。</p><h3 id="电话响了-事件被触发-gt-接电话-去做对应的事"><a href="#电话响了-事件被触发-gt-接电话-去做对应的事" class="headerlink" title="电话响了(事件被触发) -&gt; 接电话(去做对应的事)"></a>电话响了(事件被触发) -&gt; 接电话(去做对应的事)</h3><p>换以我们很常见的网页对话框UI 来说，当使用者「按下了按钮」之后，才会启动对话框的显示。如果使用者没有按下按钮，就狂跳对话框，那使用者一定觉得这网站瓦特了吧。</p><p>以Bootstrap Modal 为例：</p><p><img src="/images/event/1.gif" srcset="/img/loading.gif" alt></p><p>在上面的例子中，当使用者点击了按钮，才会启动对话框的显示，那么「点击按钮」这件事，就被称作「<strong>事件</strong>」(Event)，而负责处理事件的代码段通常被称为「<strong>事件处理程序</strong>」(Event Handler)，也就是「启动对话框的显示」这个动作。</p><p>看完上面的例子，想必大家对事件有了一定的理解了吧，接下来就深入来探讨DOM事件。</p><h3 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h3><p>DOM有4次版本更新，与DOM版本变更，产生了3种不同的DOM事件：<strong>DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理</strong>。由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件。</p><h4 id="DOM-0级事件"><a href="#DOM-0级事件" class="headerlink" title="DOM 0级事件"></a>DOM 0级事件</h4><p>1.on-event (HTML 属性)：</p><pre><code class="html">&lt;input onclick=&quot;alert(&#39;xxx&#39;)&quot;/&gt;</code></pre><p>需要注意的是，基于代码的使用性与维护性考量，现在已经不建议用此方式来绑定事件。</p><p>on-event (非HTML 属性)：</p><p>像是<code>window</code>或<code>document</code>此类没有实体元素的情况：</p><pre><code class="javascript">window.onload = function(){  document.write(&quot;Hello world!&quot;);};</code></pre><p>若是实体元素：</p><pre><code class="html">// HTML&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;// JavaScriptvar btn = document.getElementById(&#39;btn&#39;); btn.onclick = function(){     alert(&#39;xxx&#39;); }</code></pre><p>若想解除事件的话，则重新指定<code>on-event</code>为<code>null</code>即可：</p><pre><code class="javascript"> btn.onclick = null</code></pre><p>2.同一个元素的同一种事件只能绑定一个函数，否则后面的函数会覆盖之前的函数</p><p>3.不存在兼容性问题</p><h4 id="DOM-2级事件"><a href="#DOM-2级事件" class="headerlink" title="DOM 2级事件"></a>DOM 2级事件</h4><p>1.Dom 2级事件是通过 <code>addEventListener</code> 绑定的事件</p><p>2.同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行</p><p>3.解绑Dom 2级事件时，使用 <code>removeEventListener</code></p><pre><code class="javascript">btn.removeEventListener( &quot;click&quot; ,a)</code></pre><p>Dom 2级事件有三个参数：第一个参数是事件名（如<code>click</code>）；第二个参数是事件处理程序函数；第三个参数如果是<code>true</code>的话表示在捕获阶段调用，为<code>false</code>的话表示在冒泡阶段调用。捕获阶段和冒泡阶段在下一节具体介绍。</p><p>还有注意<code>removeEventListener()</code>:不能移除匿名添加的函数。</p><h4 id="DOM-3级事件"><a href="#DOM-3级事件" class="headerlink" title="DOM 3级事件"></a>DOM 3级事件</h4><p>DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，增加的类型如下：</p><ul><li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li><li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</li><li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li><li>文本事件，当在文档中输入文本时触发，如：textInput</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li><li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li><li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</li><li>同时DOM3级事件也允许使用者自定义一些事件。</li></ul><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>事件流(Event Flow)指的就是「<strong>网页元素接收事件的顺序</strong>」。事件流可以分成两种机制：</p><ul><li>事件捕获(Event Capturing)</li><li>事件冒泡(Event Bubbling)</li></ul><p>当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段：</p><ol><li>捕获阶段：事件从<code>window</code>对象自上而下向目标节点传播的阶段；</li><li>目标阶段：真正的目标节点正在处理事件的阶段；</li><li>冒泡阶段：事件从目标节点自下而上向<code>window</code>对象传播的阶段。</li></ol><p>接着就来分别介绍事件捕获和事件冒泡这两种机制。</p><h4 id="事件捕获-Event-Capturing"><a href="#事件捕获-Event-Capturing" class="headerlink" title="事件捕获(Event Capturing)"></a>事件捕获(Event Capturing)</h4><p><img src="/images/event/2.jpg" srcset="/img/loading.gif" alt></p><p>事件捕获指的是「从启动事件的元素节点开始，逐层往下传递」，直到最下层节点，也就是<code>div</code>。</p><p>假设HTML 如下：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;  &lt;title&gt;米淇淋是个大帅哥&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div&gt;点我&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>假设我们点击(click)了<code>&lt;div&gt;点我&lt;/div&gt;</code>元素，那么在「事件捕获」的机制下，触发事件的顺序会是：</p><ol><li><code>document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;div&gt;点我&lt;/div&gt;</code></li></ol><p>像这样<code>click</code>事件由上往下依序被触发，就是「事件捕获」机制。</p><h4 id="事件冒泡-Event-Bubbling"><a href="#事件冒泡-Event-Bubbling" class="headerlink" title="事件冒泡(Event Bubbling)"></a>事件冒泡(Event Bubbling)</h4><p><img src="/images/event/3.jpg" srcset="/img/loading.gif" alt></p><p>刚刚说过「事件捕获」机制是由上往下来传递，那么「事件冒泡」(Event Bubbling) 机制则正好相反。</p><p>假设HTML 同样如下：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;  &lt;title&gt;米淇淋是个大帅哥&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div&gt;点我&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>假设我们点击(click)了<code>&lt;div&gt;点我&lt;/div&gt;</code>元素，那么在「事件冒泡」的机制下，触发事件的顺序会是：</p><ol><li><code>&lt;div&gt;点我&lt;/div&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;html&gt;</code></li><li><code>document</code></li></ol><p>像这样<code>click</code>事件逐层向上依序被触发，就是「事件冒泡」机制。</p><p>既然事件传递顺序有这两种机制，那<strong>我怎么知道事件是依据哪种机制</strong>执行的呢？</p><p>答案是：两种都会执行。</p><p><img src="/images/event/4.jpg" srcset="/img/loading.gif" alt></p><p>假设现在的事件是点击上图中蓝色的<code>&lt;td&gt;</code>。</p><p>那么当td的<code>click</code>事件发生时，会先走红色的「capture phase」：</p><ol><li><code>Document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;table&gt;</code></li><li><code>&lt;tbody&gt;</code></li><li><code>&lt;tr&gt;</code></li><li><code>&lt;td&gt;</code> (实际被点击的元素)</li></ol><p>由上而下依序触发它们的<code>click</code>事件。</p><p>然后到达「Target phase」后再继续执行绿色的「bubble phase」，反方向由<code>&lt;td&gt;</code>一路往上传至<code>Document</code>，整个事件流到此结束。</p><p>要检验事件流，我们可以通过<code>addEventListener()</code>方法来绑定<code>click</code>事件：</p><p>假设HTML 如下：</p><pre><code class="html">&lt;div&gt;  &lt;div id=&quot;parent&quot;&gt;    父元素    &lt;div id=&quot;child&quot;&gt;子元素&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>JavaScript 代码如下：</p><pre><code class="javascript">var parent = document.getElementById(&#39;parent&#39;);var child = document.getElementById(&#39;child&#39;);// 通过 addEventListener 指定事件的绑定// 第三个参数 true / false 分別代表 捕获/ 冒泡 机制parent.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Parent Capturing&#39;);}, true);parent.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Parent Bubbling&#39;);}, false);child.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Child Capturing&#39;);}, true);child.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Child Bubbling&#39;);}, false);</code></pre><p>当我点击的是「子元素」的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><pre><code class="javascript">&quot;Parent Capturing&quot;&quot;Child Capturing&quot;&quot;Child Bubbling&quot;&quot;Parent Bubbling&quot;</code></pre><p>而如果直接点击「父元素」，则出现：</p><pre><code class="javascript">&quot;Parent Capturing&quot;&quot;Parent Bubbling&quot;</code></pre><p>由此可知，点击子元素的时候，父层的<code>Capturing</code>会先被触发，然后再到子层内部的<code>Capturing</code>或<code>Bubbling</code>事件。最后才又回到父层的<code>Bubbling</code>结束。点击父元素的时候，不会经过子元素，子层的<code>Capturing</code>和<code>Bubbling</code>都不会触发。</p><p>那么，子层中的<code>Capturing</code>或<code>Bubbling</code>谁先谁后呢？要看你代码的顺序而定：</p><p>若是<code>Capturing</code>在<code>Bubbling</code>前面：</p><pre><code class="javascript">child.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Child Capturing&#39;);}, true);child.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Child Bubbling&#39;);}, false);</code></pre><p>则会得到：</p><pre><code class="javascript">&quot;Child Capturing&quot;&quot;Child Bubbling&quot;</code></pre><p>若是将两段代码段顺序反过来的话，就会是这样了：</p><pre><code class="javascript">child.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Child Bubbling&#39;);}, false);child.addEventListener(&#39;click&#39;, function () {  console.log(&#39;Child Capturing&#39;);}, true);</code></pre><p>则会得到：</p><pre><code class="javascript">&quot;Child Bubbling&quot;&quot;Child Capturing&quot;</code></pre><h3 id="事件监听-EventTarget-addEventListener"><a href="#事件监听-EventTarget-addEventListener" class="headerlink" title="事件监听 EventTarget.addEventListener()"></a>事件监听 EventTarget.addEventListener()</h3><p><code>addEventListener()</code>基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的<code>function</code>)，以及一个「Boolean」值，由这个Boolean决定事件是以「捕获」还是「冒泡」机制执行，若不指定则预设为「冒泡」。</p><pre><code class="html">// HTML&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;// JavaScriptvar btn = document.getElementById(&#39;btn&#39;);btn.addEventListener(&#39;click&#39;, function(){  console.log(&#39;HI&#39;);}, false);</code></pre><p>使用这种方式来注册事件的好处是：同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行。</p><pre><code class="javascript">var btn = document.getElementById(&#39;btn&#39;);btn.addEventListener(&#39;click&#39;, function(){  console.log(&#39;HI&#39;);}, false);btn.addEventListener(&#39;click&#39;, function(){  console.log(&#39;HELLO&#39;);}, false);</code></pre><p>点击后<code>console</code>出现：</p><pre><code class="javascript">&quot;HI&quot;&quot;HELLO&quot;</code></pre><p>若要解除事件的监听，则是通过<code>removeEventListener()</code>来取消。</p><p><code>removeEventListener()</code>的三个参数与<code>addEventListener()</code>一样，分别是「事件名称」、「事件的处理程序」以及代表「捕获」或「冒泡」机制的「Boolean」值。</p><p>但是需要注意的是，由于<code>addEventListener()</code>可以同时针对某个事件绑定多个函数，所以通过<code>removeEventListener()</code>解除事件的时候，第二个参数的函数必须要与先前在<code>addEventListener()</code>绑定的函数是同一个「实体」。</p><p>比如：</p><pre><code class="javascript">var btn = document.getElementById(&#39;btn&#39;);btn.addEventListener(&#39;click&#39;, function(){  console.log(&#39;HI&#39;);}, false);// 移除事件，但是没用btn.removeEventListener(&#39;click&#39;, function(){  console.log(&#39;HI&#39;);}, false);</code></pre><p>像上面这样，即使执行了<code>removeEventListener</code>来移除事件，但<code>click</code>时仍会出现’HI’。因为<code>addEventListener</code>与<code>removeEventListener</code>所移除的函数实际上是两个不同实体的function对象。</p><p>不知道为什么这两个function是两个不同实体的朋友请参考：<a href="https://zhuanlan.zhihu.com/p/63114665" target="_blank" rel="noopener">《JavaScript系列之内存空间》</a>。简单理解就是两个function指向不同的内存地址，代表来自于不同实体。</p><p>稍加改进后就能如愿移除了：</p><pre><code class="javascript">var btn = document.getElementById(&#39;btn&#39;);// 把 event 函数程序拉出來var clickHandler = function(){  console.log(&#39;HI&#39;);};btn.addEventListener(&#39;click&#39;, clickHandler, false);// 移除 clickHandler， ok!btn.removeEventListener(&#39;click&#39;, clickHandler, false);</code></pre><p>那么以上就是今天为各位介绍JavaScript事件机制原理的部分。</p><p>接下来的文章我会继续来介绍事件的种类，以及更多实际上处理「事件」时需要注意的事项。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>事件</tag>
      
      <tag>event</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之类数组对象arguments</title>
    <link href="/2019/11/19/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1arguments/"/>
    <url>/2019/11/19/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1arguments/</url>
    
    <content type="html"><![CDATA[<p>之前在<a href="https://zhuanlan.zhihu.com/p/71490991" target="_blank" rel="noopener">《JavaScript系列之this是什么》</a>这篇文章中，我们曾谈过”this”这个关键字，本章将会谈到另一个JavaScript中的关键字，叫做”arguments”。</p><p>那<code>arguments</code>到底是什么呢？下面就由我来简洁地介绍一下 <code>arguments</code>吧。</p><h3 id="什么是参数-parameters"><a href="#什么是参数-parameters" class="headerlink" title="什么是参数(parameters)"></a>什么是参数(parameters)</h3><p>在了解<code>arguments</code>之前，我们必须要先了解一下什么是参数(parameter)。参数其实就是我们会带入函数的变量，以下面例子来说，”house”、”car”、”money”，就是我们在执行函式的时候可以任意填入的参数。</p><pre><code class="javascript">function MyFavorite(house, car, money) {    console.log(house);    console.log(car);    console.log(money);}MyFavorite();</code></pre><p>首先，当我建立好这样的函数，我可以不带任何参数值就去执行这个函数，只要输入<code>MyFavorite()</code>这样就可以了！</p><p>一般如果有参数却又没有给它参数值，函数的执行上往往会有错误！但在JavaScript中不太一样的地方在于，即使你没有给它任何参数值就加以执行，也不会报错，而是会返回<code>undefined</code>。</p><p><img src="/images/arguments/1.jpg" srcset="/img/loading.gif" alt></p><p>为什么会得到”<code>undefined</code>“呢？</p><p>之所以会这样是因为当JavaScript在执行这个函数的时候，由于提升机制，它会先把我们的参数(<code>house</code>, <code>car</code>, <code>money</code>)存到内存中了，并且赋予它的值是<code>undefined</code>。</p><p>参数值会由左至右读取，如果我依序执行这样的代码就理解了：</p><pre><code class="javascript">MyFavorite();MyFavorite(&quot;别墅&quot;);MyFavorite(&quot;别墅&quot;, &quot;法拉利&quot;);MyFavorite(&quot;别墅&quot;, &quot;法拉利&quot;, &quot;一亿元&quot;);</code></pre><p>会分别读到以下的结果，表示JavaScript会由左至右来读取参数值，而且即使某些参数值有缺值的情况，JavaScript还是可以正常执行。</p><p><img src="/images/arguments/2.jpg" srcset="/img/loading.gif" alt></p><h3 id="设置函数中参数的默认值"><a href="#设置函数中参数的默认值" class="headerlink" title="设置函数中参数的默认值"></a>设置函数中参数的默认值</h3><p>由于目前的几款浏览器使用的JavaScript版本都尚不支持直接在参数的地方设置默认值（ES6的将可以），所以很多的框架都还不会用这种方式设置默认值。</p><p><strong>方法一：在ES6的JavaScript中，可以直接通过这种方式设置参数默认值：</strong></p><pre><code class="javascript">function MyFavorite(house, car, money = &#39;一亿元&#39;) {    console.log(house);    console.log(car);    console.log(money);    console.log(&quot;----------------&quot;);}</code></pre><p><strong>方法二：利用强制转换的概念设置默认值</strong></p><p>由于版本兼容的差异，现今多数的编程都是使用这种方式设置参数的默认值，利用简单的”=”和”||”就可以达到参数默认值的效果：</p><pre><code class="javascript">function MyFavorite(house, car, money) {    money = money || &#39;一亿元&#39;;    console.log(house);    console.log(car);    console.log(money);    console.log(&quot;----------------&quot;);}</code></pre><p>这时候即使在没有给值的情况下，<code>money</code>一样可以得到默认值为”一亿元”：</p><p><img src="/images/arguments/3.jpg" srcset="/img/loading.gif" alt></p><h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><p>了解了<code>parameters</code>的概念后，让我们回来谈谈<code>arguments</code>，MDN将它叫做类数组对象，那么什么是类数组对象呢？</p><p>所谓的类数组对象:</p><blockquote><p>就是拥有一个 <code>length</code> 属性和若干索引属性的对象</p></blockquote><p>举个例子：</p><pre><code class="javascript">var array = [&#39;house&#39;, &#39;car&#39;, &#39;money&#39;];var arrayLike = {    0: &#39;house&#39;,    1: &#39;car&#39;,    2: &#39;money&#39;,    length: 3}//读取console.log(array[0]); // houseconsole.log(arrayLike[0]); // housearray[0] = &#39;new house&#39;;arrayLike[0] = &#39;new house&#39;;//长度console.log(array.length); // 3console.log(arrayLike.length); // 3//遍历for(var i = 0, len = array.length; i &lt; len; i++) {   ……}for(var i = 0, len = arrayLike.length; i &lt; len; i++) {    ……}</code></pre><p>上面我们可以看得出来，类数组对象与数组在读取、获取长度、遍历三个方面一样，都能取到，那为什么还叫做类数组对象呢？</p><p>因为类数组对象不可以使用数组的方法，比如：</p><pre><code class="javascript">arrayLike.push(&#39;name&#39;);</code></pre><p>然而上述代码会报错: <code>arrayLike.push is not a function</code>，所以终归还是类数组呐……</p><h3 id="调用数组方法"><a href="#调用数组方法" class="headerlink" title="调用数组方法"></a>调用数组方法</h3><p>如果类数组想用数组的方法怎么办呢？</p><p>直接调用是不可取的，那我们可以通过 <code>Function.call</code> 的方法进行间接调用：</p><pre><code class="javascript">var arrayLike = {0: &#39;house&#39;, 1: &#39;car&#39;, 2: &#39;money&#39;, length: 3 }console.log(Array.prototype.join.call(arrayLike, &#39;&amp;&#39;)); // house&amp;car&amp;moneyconsole.log(Array.prototype.slice.call(arrayLike, 0)); // [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item){    return item.toUpperCase();}); // [&quot;HOUSE&quot;, &quot;CAR&quot;, &quot;MONEY&quot;]</code></pre><p>在上面已经提到了一种类数组转数组的方法，再补充三个：</p><pre><code class="javascript">var arrayLike = {0: &#39;house&#39;, 1: &#39;car&#39;, 2: &#39;money&#39;, length: 3 }// 1. sliceconsole.log(Array.prototype.slice.call(arrayLike)); // [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;] // 2. spliceconsole.log(Array.prototype.splice.call(arrayLike, 0)); // [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;] // 3. ES6 Array.fromconsole.log(Array.from(arrayLike)); // [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;] // 4. applyconsole.log(Array.prototype.concat.apply([], arrayLike));</code></pre><p>接下来重点讲讲 <code>Arguments</code> 这个类数组对象。</p><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p><code>arguments</code>比起<code>this</code>来说，要容易理解的多，<code>arguments</code>对象只定义在函数体中，包括了函数的参数和其他属性。</p><p>同样地通过上面的例子加以理解，我们直接在函数中去打印出”arguments”这个关键字：</p><pre><code class="javascript">function MyFavorite(house, car, money) {    money = money || &#39;一亿元&#39;;    console.log(arguments);    console.log(&quot;----------------&quot;);}MyFavorite();MyFavorite(&quot;别墅&quot;);MyFavorite(&quot;别墅&quot;, &quot;法拉利&quot;);MyFavorite(&quot;别墅&quot;, &quot;法拉利&quot;, &quot;一亿元&quot;);</code></pre><p>打印结果如下：</p><p><img src="/images/arguments/4.jpg" srcset="/img/loading.gif" alt></p><p>我们可以看到除了类数组的索引属性和<code>length</code>属性之外，还有一个<code>callee</code>属性，而且我们可以看到<code>arguments</code>对象的<code>__ proto __</code>是指向<code>object</code>的，这也说明了他是个类数组对象，而不是一个数组。下面我们进行一一介绍。</p><h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><p><code>arguments.length</code>为函数实参个数，举个例子：</p><pre><code class="javascript">function foo(house, car, money){    console.log(&quot;实参的长度为：&quot; + arguments.length)}console.log(&quot;形参的长度为：&quot; + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1</code></pre><h4 id="callee属性"><a href="#callee属性" class="headerlink" title="callee属性"></a>callee属性</h4><p>每个参数实例都有一个<code>callee</code>属性，通过它可以调用函数自身。 ES5的严格模式不允许访问<code>arguments.callee</code>。</p><p>讲个闭包经典面试题使用 <code>callee</code> 的解决方法：</p><pre><code class="javascript">var data = [];for (var i = 0; i &lt; 3; i++) {    (data[i] = function () {       console.log(arguments.callee.i)     }).i = i;}data[0]();data[1]();data[2]();// 0// 1// 2</code></pre><h3 id="最后来看看展开运算符spread-…"><a href="#最后来看看展开运算符spread-…" class="headerlink" title="最后来看看展开运算符spread(…)"></a>最后来看看展开运算符spread(…)</h3><p>除了<code>arguments</code>这个关键字，在新版ES6的JavaScript中另外提供了一个展开运算符(spread)，它就是「<code>...</code>」三个点，这个<code>...</code>有什么用呢？</p><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">MDN</a>对于展开运算符spread的描述如下：</p><blockquote><p>The spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) or multiple variables (for destructuring assignment) are expected.</p></blockquote><p>简单来说，就是它可以把函数中许多的参数(<code>arguments</code>)或数组中许多的元素(<code>elements</code>)形成一个新的变量。</p><p>举例来说：</p><p>在函数的部分，在参数的地方我们用”<code>...other</code>“，<code>other</code>是你想要储存成的数组变量名称，可以自己取。</p><p>在执行函数的地方，原本我们只有三个参数(<code>house</code>, <code>car</code>, <code>money</code>)，也只能填写三个参数；但使用了展开运算符”<code>...</code>“后，我们在执行函数的地方就可以带入不只三个参数（例如，我在最后面又加了”老婆”和”孩子”），这些多的参数值最后都会被放到<code>other</code>这个数组当中。</p><pre><code class="javascript">function MyFavorite(house, car, money, ...other){    console.log(other);    console.log(&#39;What my favorite are&#39; + house + &#39;,&#39; + car + &#39;,&#39; + money + &#39;,&#39; + other);}MyFavorite(&quot;别墅&quot;, &quot;法拉利&quot;, &quot;一亿&quot;);MyFavorite(&quot;别墅&quot;, &quot;法拉利&quot;, &quot;一亿&quot;, &quot;老婆&quot;, &quot;孩子&quot;);</code></pre><p>结果就会长的像这样子：</p><p><img src="/images/arguments/5.jpg" srcset="/img/loading.gif" alt></p><p>展开运算符还有其他的使用方式，像是把数组元素做连接等等，使用灵活的话相当方便，如果有需要的话，可以参考引1。</p><p>引1：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">Microsoft Developer Netword：展开运算符(…)</a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>1.利用arguments实现方法的重载</strong></p><p>下面我们利用<code>arguments</code>对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。</p><pre><code class="javascript">function add() {    var len = arguments.length,        sum = 0;    for(;len--;){        sum += arguments[len];    }    return sum;}console.log( add(1,2,3) );   //6console.log( add(1,3) );     //4console.log( add(1,2,3,5,6) );   //17</code></pre><p>由于JS是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用<code>arguments</code>，来判断传入的实参类型与数量进行不同的操作，然后返回不同的数值。</p><p><strong>2.利用arguments.callee实现递归</strong></p><p>先来看看平常我们是怎么实现递归的，这是一个结算阶乘的函数。</p><pre><code class="javascript">function foo(num) {     if(num&lt;=1) {         return 1;     }else {         return num * foo(num-1);     } } </code></pre><p>但是当这个函数变成了一个匿名函数时，我们就可以利用<code>callee</code>来递归这个函数。</p><pre><code class="javascript">function foo(num) {     if(num&lt;=1) {         return 1;     }else {         return num * arguments.callee(num-1);     } } </code></pre><p>这个方法虽然好用，但是有一点值得注意，ECMAScript4中为了限制JS的灵活度，让JS变得严格，新增了严格模式，在严格模式中我们被禁止不使用<code>var</code>来直接声明一个全局变量，当然这不是重点，重点是<code>arguments.callee</code>这个属性也被禁止了。不过这都不是事儿，ES6为我们新增了很多好用的变量声明方式和新的语法糖，作为一个时髦的前端，我们赶紧学习一些ES6的新语法吧。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>arguments</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flexbox 对你说爱不完</title>
    <link href="/2019/11/14/CSS%20Flexbox%20%E5%AF%B9%E4%BD%A0%E8%AF%B4%E7%88%B1%E4%B8%8D%E5%AE%8C/"/>
    <url>/2019/11/14/CSS%20Flexbox%20%E5%AF%B9%E4%BD%A0%E8%AF%B4%E7%88%B1%E4%B8%8D%E5%AE%8C/</url>
    
    <content type="html"><![CDATA[<p>Flexbox 意为弹性布局，是一种新的CSS 3 布局方式，与传统布局方式(基于盒模型，依赖display属性 +position属性 +float属性)相比，flex布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。</p><p>废话就不多说了，下面我将尽可能地用简洁明了的言语来描述 Flex 布局。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/images/flex/1.jpg" srcset="/img/loading.gif" alt> </p><p>使用了flex布局，则有flex容器（flex container），子元素为项目(flex item）。</p><p>在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，start和end表示对应轴的起始位置，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴。比如将Flexbox的方向设置为row，则主轴就是横轴，而交叉轴就是纵轴；反之设置成column，则主轴就是纵轴，而交叉轴就是横轴，这个下面会具体讲。</p><p>每个项目(flex item)占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。</p><p>这里还需要注意的是，不能直截了当地认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。</p><p>实际上，要实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。语法如下：</p><pre><code class="css">.container {    display: flex | inline-flex;       //可以有两种取值}</code></pre><p>给div这类块元素设置<code>display: flex</code>或者给span这类行内元素设<code>display: inline-flex</code>，flex布局即创建！</p><p>而Flex布局相关属性正好分为两拨，一拨作用在flex容器上，还有一拨作用在flex子项上。</p><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 的属性将会失效。</strong></p><h3 id="Flex容器上的属性"><a href="#Flex容器上的属性" class="headerlink" title="Flex容器上的属性"></a>Flex容器上的属性</h3><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><p><strong>1. flex-direction: 决定主轴的方向(即项目的排列方向)</strong></p><pre><code class="css">.container {    flex-direction: row | row-reverse | column | column-reverse;}</code></pre><ul><li><code>row</code>（默认）：主轴为水平方向，起点在左端</li></ul><p><img src="/images/flex/2.jpg" srcset="/img/loading.gif" alt> </p><ul><li><code>row-reverse</code>：主轴为水平方向，起点在右端</li></ul><p><img src="/images/flex/3.jpg" srcset="/img/loading.gif" alt> </p><ul><li><code>column</code>：主轴为垂直方向，起点在上沿</li></ul><p><img src="/images/flex/4.jpg" srcset="/img/loading.gif" alt> </p><ul><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿</li></ul><p><img src="/images/flex/5.jpg" srcset="/img/loading.gif" alt> </p><p><strong>2. flex-wrap: 决定容器内项目是否可换行</strong></p><p>默认情况下，项目都排在主轴线上，使用 <code>flex-wrap</code> 可实现项目的换行。</p><pre><code class="css">.container {    flex-wrap: nowrap | wrap | wrap-reverse;}</code></pre><ul><li><code>nowrap</code>（默认）：不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行</li></ul><p><img src="/images/flex/6.jpg" srcset="/img/loading.gif" alt> </p><ul><li><code>wrap</code>：项目主轴总尺寸超出容器时换行，第一行在上方</li></ul><p><img src="/images/flex/7.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>wrap-reverse</code>：换行并反向，第一行在下方</li></ul><p><img src="/images/flex/8.jpg" srcset="/img/loading.gif" alt></p><p><strong>3. flex-flow: flex-direction 和 flex-wrap 的复合简写形式</strong></p><pre><code class="css">.container {    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}</code></pre><p>默认值为: row nowrap，这个属性其实没多大卵用，不就是两个属性的缩写嘛。</p><p><strong>4. justify-content：定义项目在主轴的对齐方式</strong></p><pre><code class="css">.container {    justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>flex-start</code>（默认）：左对齐</li></ul><p><img src="/images/flex/9.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>flex-end</code>：右对齐</li></ul><p><img src="/images/flex/10.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>center</code>：居中</li></ul><p><img src="/images/flex/11.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>space-between</code>：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙</li></ul><p><img src="/images/flex/12.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>space-around</code>：每个项目两侧的间隔相等，所以项目之间的间隔是项目与边缘的间隔的两倍</li></ul><p><img src="/images/flex/13.jpg" srcset="/img/loading.gif" alt></p><p><strong>5. align-items: 定义项目在交叉轴上的对齐方式</strong></p><pre><code class="css">.container {    align-items: stretch | flex-start | flex-end | center | baseline;}</code></pre><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>stretch</code>（默认）：如果项目未设置高度或设为<code>auto</code>，将占满整个容器的高度</li></ul><p><img src="/images/flex/14.jpg" srcset="/img/loading.gif" alt></p><p>假设容器高度设置为 50px，而项目都没有设置高度或设为<code>auto</code>的情况下，则项目的高度也为 50px</p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li></ul><p><img src="/images/flex/15.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>flex-end</code>：交叉轴的终点对齐</li></ul><p><img src="/images/flex/16.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>center</code>：交叉轴的中点对齐</li></ul><p><img src="/images/flex/17.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>baseline</code>: 项目的第一行文字的基线对齐</li></ul><p><img src="/images/flex/18.jpg" srcset="/img/loading.gif" alt></p><p>以文字的底部为主</p><p><strong>6. align-content: 定义多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p><pre><code class="css">.container {    align-content: stretch | flex-start | flex-end | center | space-between | space-around;}</code></pre><p>什么叫项目只有一根轴线呢？其实可以这么理解：</p><p>当你 <code>flex-wrap</code> 设置为 <code>nowrap</code> 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p><p>当你 <code>flex-wrap</code> 设置为 <code>wrap</code> 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p><p>建立在主轴为水平方向时测试，即 <code>flex-direction: row</code>, <code>flex-wrap: wrap</code></p><ul><li><code>stretch</code>（默认）：轴线占满整个交叉轴</li></ul><p><img src="/images/flex/19.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>flex-start</code>：轴线全部与交叉轴上的起点对齐</li></ul><p><img src="/images/flex/20.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>flex-end</code>：轴线全部与交叉轴上的终点对齐</li></ul><p><img src="/images/flex/21.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>center</code>：轴线全部在交叉轴上的中间对齐</li></ul><p><img src="/images/flex/22.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>space-between</code>：轴线与交叉轴两端对齐，轴线之间的间隔平均分布</li></ul><p><img src="/images/flex/23.jpg" srcset="/img/loading.gif" alt></p><ul><li><code>space-around</code>：每个轴线两侧的间隔都相等，所以轴线之间的间隔是轴线与边缘的间隔的两倍</li></ul><p><img src="/images/flex/24.jpg" srcset="/img/loading.gif" alt></p><p>到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item（项目） 上的属性。</p><h3 id="Flex-项目上的属性"><a href="#Flex-项目上的属性" class="headerlink" title="Flex 项目上的属性"></a>Flex 项目上的属性</h3><p>item 项目上有六种属性可运用，它们分别是：</p><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><p><strong>1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p><pre><code class="css">.item {    order: &lt;integer&gt;;}</code></pre><p><img src="/images/flex/25.jpg" srcset="/img/loading.gif" alt></p><p><strong>2. flex-grow: 定义项目的放大比例</strong></p><pre><code class="css">.item {    flex-grow: &lt;number&gt;;}</code></pre><p>默认值为 0，即如果存在剩余空间，也不放大。</p><p>如果所有项目的 <code>flex-grow</code> 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code>flex-grow</code> 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p><strong>3. flex-shrink: 定义项目的缩小比例</strong></p><pre><code class="css">.item {    flex-shrink: &lt;number&gt;;}</code></pre><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><img src="/images/flex/26.jpg" srcset="/img/loading.gif" alt></p><p>如果所有项目的 <code>flex-shrink</code> 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code> 属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><p><strong>4. flex-basis: 定义了在分配容器剩余空间之前项目的默认大小。相当于对浏览器提前告知：浏览器兄弟，我要占据这么大的空间，提前帮我预留好</strong></p><pre><code class="css">.item {    flex-basis: &lt;length&gt; | auto;}</code></pre><p>默认值：<code>auto</code>，即项目本来的大小, 这时候 item 项目的宽高取决于 <code>width</code> 或 <code>height</code> 的值。</p><p>当主轴为水平方向的时候，同时设置 <code>width</code> 和 <code>flex-basis</code>，会忽略 <code>width</code>。flex顾名思义就是弹性的意思，因此，实际上不建议对flex项目使用 <code>width</code> 属性，因为不够弹性。</p><p>当容器剩余空间不足的时候，flex子项目的实际宽度通常不是设置的 <code>flex-basis</code> 尺寸，因为flex布局剩余空间不足的时候默认会收缩，如果有3个子项目，则默认按1:1:1收缩。</p><p><strong>5. flex: flex-grow, flex-shrink 和 flex-basis的复合缩写</strong></p><pre><code class="css">.item{    flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]} </code></pre><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值为<code>0 1 auto</code>。</p><p>有关快捷值：</p><pre><code class="css">flex: auto  //等同于flex:1 1 autoflex: none  //等同于flex:0 0 auto</code></pre><p><strong>6. align-self: 控制单独某一个项目的垂直对齐方式，与align-items属性语法区别不大</strong></p><pre><code class="css">.item {     align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre><p>唯一区别就是<code>align-self</code>多了个<code>auto</code>（默认值），表示继承自flex容器的<code>align-items</code>属性值，如果没有父元素，则等同于 <code>stretch</code>。</p><p>跟 <code>align-items</code> 其他属性值含义一样，只不过 <code>align-self</code> 是对单个项目生效的，而 <code>align-items</code> 则是对容器下的所有项目生效的。</p><h3 id="从垂直居中看出flex的强大"><a href="#从垂直居中看出flex的强大" class="headerlink" title="从垂直居中看出flex的强大"></a>从垂直居中看出flex的强大</h3><p>以往让元素垂直居中并不容易，直到CSS3的出现，使用绝对定位配合<code>translate</code>属性才让垂直居中变得简单，不过还有一个更爽的办法，那就是使用flex，让垂直居中变得异常简单</p><pre><code class="html">&lt;div class=“wrapper”&gt;    &lt;div class=“div”&gt;        flexbox 对你说爱不完    &lt;/div&gt;&lt;/div&gt;</code></pre><p>几行简单代码，即可让div垂直居中</p><pre><code class="css">.wrapper {    display: flex;    align-items: center;    justify-content: center;}</code></pre><p>这里最重要的就是包裹元素的三个关键属性:</p><ul><li><code>display: flex</code> 将容器指定为flex布局，任何一个元素都可以指定</li><li><code>align-items: center</code> 沿交叉轴对齐项目，这里指的是垂直方向</li><li><code>justify-content: center</code> 设置主轴内容对齐方式</li></ul><h3 id="其他Flex知识点"><a href="#其他Flex知识点" class="headerlink" title="其他Flex知识点"></a>其他Flex知识点</h3><ul><li>在Flex布局中，再强调一遍flex子元素中设置<code>float</code>，<code>clear</code>以及<code>vertical-align</code>属性都是没有用的。</li><li>Flexbox布局最适合应用程序的组件和小规模布局（一维布局），而Grid布局则适用于更大规模的布局（二维布局），有关Grid布局的文章后面会补充。</li><li>已经9102年了，Flex老语法不用在管了，果断放弃，然后私有前缀也不用再加了，看到就烦。</li><li>如果想更好地理解Flex的工作原理，可以在此页面上尝试<a href="http://www.csstutorial.org/flex-both.html" target="_blank" rel="noopener">flex 布局编辑器</a>。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之闭包</title>
    <link href="/2019/11/02/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/"/>
    <url>/2019/11/02/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/</url>
    
    <content type="html"><![CDATA[<p>相信很多初学者在学习JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。</p><p>在具体介绍闭包之前，为了更好的理解本文要介绍的内容，建议先去阅读前面的文章<a href="https://zhuanlan.zhihu.com/p/69142071" target="_blank" rel="noopener">《JavaScript系列之变量对象》</a>和<a href="https://zhuanlan.zhihu.com/p/69910449" target="_blank" rel="noopener">《JavaScript系列之作用域和作用域链》</a>，因为它们相互之间都是有关联的。</p><h3 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h3><p>首先，先来看看MDN 对闭包的定义：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是一个既不是函数的形参，也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>好，如果上面三行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 不过如果你是初学者的话，我想应该不会，如果仅用三言两语就把闭包讲通，那还能称为Javascript 语言的一个难点吗？</p><p>先来举个例子：</p><pre><code class="javascript">var n = 1;function f1() {    console.log(n);  // 1}f1() </code></pre><p><code>f1</code> 函数可以访问变量 <code>n</code>，但是 <code>n</code> 既不是 <code>f1</code> 函数的形参，也不是 <code>f1</code> 函数的局部变量，所以这种情况下的 <code>n</code> 就是自由变量。其实上面代码中就存在闭包了，即函数 <code>f1</code> + <code>f1</code> 函数访问的自由变量 <code>n</code> 就构成了一个<strong>闭包</strong>。</p><p>上面代码中，函数 <code>f1</code> 可以读取全局自由变量 <code>n</code>。但是，函数外部无法读取函数内部声明的变量：</p><pre><code class="javascript">function f1() {    var n = 1;}console.log(n)  // Uncaught ReferenceError: n is not defined</code></pre><p>如果有时需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过改变形式才能实现。那就是在函数的内部，再定义一个函数。</p><pre><code class="javascript">function f1() {  var n = 1;  function f2() {    console.log(n); // 1  }  return f2;}var a = f1();a();</code></pre><p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们就可以在<code>f1</code>外部读取它的内部变量了。</p><p>所以<strong>闭包是一个可以从另一个函数的作用域访问变量的函数。这是通过在函数内创建函数来实现的。当然，外部函数无法访问内部范围</strong>。</p><p>在我们深入研究闭包之前，有必要先从不使用闭包的情况切入，了解为什么要用闭包。</p><h3 id="不使用闭包的情况"><a href="#不使用闭包的情况" class="headerlink" title="不使用闭包的情况"></a>不使用闭包的情况</h3><p>在JavaScript 中，全局变量的错用可能会使得我们的代码出现不可预期的错误。</p><p>假设我们现在要做一个计数的函数，一开始我们想要先写一个给狗的计数函数：</p><pre><code class="javascript">// 狗的计数函数var count = 0function countDogs () {  count += 1  console.log(count + &#39; dog(s)&#39;)}countDogs()    // 1 dog(s)countDogs()    // 2 dog(s)countDogs()    // 3 dog(s)</code></pre><p>接着继续写代码的其他部分，当写到后面时，我发现我也需要写猫的计数函数，于是我又开始写了猫的计数函数：</p><pre><code class="javascript">// 狗的计数函数var count = 0function countDogs () {  count += 1  console.log(count + &#39; dog(s)&#39;)}// 中间的其它代码...// 猫的计数函数var count = 0function countCats () {  count += 1  console.log(count + &#39; cat(s)&#39;)}countCats()    // 1 cat(s)countCats()    // 2 cat(s)countCats()    // 3 cat(s)</code></pre><p>乍看之下好像没啥问题，当我执行<code>countDogs()</code>或<code>countCats()</code>，都会让<code>count</code>增加，然而问题在于当我在不注意的情况下把<code>count</code>这个变量建立在了全局作用域底下时，不论是执行<code>countDogs()</code>或是<code>countCats()</code>时，都是用到了全局的<code>count</code>变量，这使得当我执行下面的代码时，它没有办法分辨现在到底是在对狗计数还是对猫计数，进而导致把猫的数量和狗的数量交错计算的错误情况：</p><pre><code class="javascript">countCats()    // 1 cat(s)countCats()    // 2 cat(s)countCats()    // 3 cat(s)countDogs()    // 4 dog(s)，我希望是 1 dog(s)countDogs()    // 5 dog(s)，我希望是 2 dog(s)countCats()    // 6 cat(s)，我希望是 4 cat(s)</code></pre><h3 id="闭包让函数有私有变量"><a href="#闭包让函数有私有变量" class="headerlink" title="闭包让函数有私有变量"></a>闭包让函数有私有变量</h3><p>从上面的例子我们知道，如果错误的使用全局变量，很容易会出现一些莫名其妙的bug ，这时候我们就可以利用闭包（closure）的写法，让函数有自己私有变量，简单来说就是<code>countDogs</code>里面能有一个计算<code>dogs</code>的<code>count</code>变数；而<code>countCats</code>里面也能有一个计算<code>cats</code>的<code>count</code>变量，两者是不会互相干扰的。</p><p>为了达到这样的效果，我们就要利用闭包，让变量保留在该函数中而不会被外在环境干扰。</p><p>改成闭包的写法会像这样：</p><pre><code class="javascript">function dogHouse () {  var count = 0  function countDogs () {    count += 1    console.log(count + &#39; dogs&#39;)  }  return countDogs}const countDogs = dogHouse()countDogs()    // &quot;1 dogs&quot;countDogs()    // &quot;2 dogs&quot;countDogs()    // &quot;3 dogs&quot;</code></pre><p>这样我们就将专门计算狗的变量<code>count</code>闭包在<code>dogHouse</code>这个函数中，在<code>dogHouse</code>这个函数中里面的<code>countDogs()</code>才是我们真正执行计数的函数，而在<code>dogHouse</code>这个函数中存在<code>count</code>这个变量，由于JavaScript变量会被缩限在函数的执行上下文中，因此这个<code>count</code>的值只有在<code>dogHouse</code>里面才能被取用，在<code>dogHouse</code>函数外是取用不到这个值的。</p><p>接着因为我们要能够执行在<code>dogHouse</code>中真正核心<code>countDogs()</code>这个函数，因此我们会在最后把这个函数给return出来，好让我们可以在外面去调用到<code>dogHouse</code>里面的这个<code>countDogs()</code>函数。</p><p>最后当我们在使用闭包时，我们先把存在<code>dogHouse</code>里面的<code>countDogs</code>拿出来用，并一样命名为<code>countDogs</code>（这里变量名称可以自己取），因此当我执行全局中的<code>countDogs</code>时，实际上会执行的是<code>dogHouse</code>里面的<code>countDogs</code>函数。</p><p>上面这是闭包的基本写法：<strong>一个函数里面包了另一个函数，同时会 return 里面的函数让我们可以在外面使用到它</strong>。</p><p>我们可以把我们最一开始的代码都改成使用闭包的写法：</p><pre><code class="javascript">function dogHouse () {  var count = 0  function countDogs () {    count += 1    console.log(count + &#39; dogs&#39;)  }  return countDogs}function catHouse () {  var count = 0  function countCats () {    count += 1    console.log(count + &#39; cats&#39;)  }  return countCats}const countDogs = dogHouse()const countCats = catHouse()countDogs()    // &quot;1 dogs&quot;countDogs()    // &quot;2 dogs&quot;countDogs()    // &quot;3 dogs&quot;countCats()    // &quot;1 cats&quot;countCats()    // &quot;2 cats&quot;countDogs()    // &quot;4 dogs&quot;</code></pre><p>当我们正确地使用闭包时，虽然一样都是使用<code>count</code>来计数，但是是在不同执行环境内的<code>count</code>因此也不会相互干扰。</p><h3 id="进一步了解和使用闭包"><a href="#进一步了解和使用闭包" class="headerlink" title="进一步了解和使用闭包"></a>进一步了解和使用闭包</h3><p>另外，甚至在运用的是同一个<code>dogHouse</code> 时，变量间也都是独立的执行环境不会干扰，比如：</p><pre><code class="javascript">function dogHouse () {  var count = 0  function countDogs () {    count += 1    console.log(count + &#39; dogs&#39;)  }  return countDogs}// 虽然都是使用 dogHouse ，但是各是不同的执行环境// 因此彼此的变量不会互相干扰var countGolden = dogHouse()var countPug = dogHouse()var countPuppy = dogHouse()countGolden()     // 1 dogscountGolden()     // 2 dogscountPug()        // 1 dogscountPuppy()      // 1 dogscountGolden()     // 3 dogscountPug()        // 2 dogs</code></pre><h3 id="将参数代入闭包中"><a href="#将参数代入闭包中" class="headerlink" title="将参数代入闭包中"></a>将参数代入闭包中</h3><p>但是这么做的话你可能觉得还不够清楚，因为都是叫做<code>dogs</code>，这时候我们一样可以把外面的变量通过函数的参数代入闭包中，像是下面这样，返回的结果就清楚多了：</p><pre><code class="javascript">// 通过函数的参数将值代入闭包中function dogHouse (name) {  var count = 0  function countDogs () {    count += 1    console.log(count + &#39; &#39; + name)  }  return countDogs}// 同样是使用 dogHouse 但是使用不同的参数var countGolden = dogHouse(&#39;Golden&#39;)var countPug = dogHouse(&#39;Pug&#39;)var countPuppy = dogHouse(&#39;Puppy&#39;)// 结果看起来更清楚了countGolden()     // 1 GoldencountGolden()     // 2 GoldencountPug()        // 1 PugcountPuppy()      // 1 PuppycountGolden()     // 3 GoldencountPug()        // 2 Pug</code></pre><p>为了进一步简化代码，我们可以在闭包中直接return一个函数出来，我们就可以不必为里面的函数命名了，而是用匿名函数的方式直接把它返回出来。</p><p>因此写法可以简化成这样：</p><pre><code class="javascript">function dogHouse () {  var count = 0  // 把原本 countDogs 函数改成匿名函数直接放进来  return function () {    count += 1    console.log(count + &#39; dogs&#39;)  }}function catHouse () {  var count = 0  // 把原本 countCats 函数改成匿名函数直接放进来  return function () {    count += 1    console.log(count + &#39; cats&#39;)  }}</code></pre><p>然后我们刚刚有提到，可以透过函数参数的方式把值代入闭包当中，因此实际上我们只需要一个counter ，在不同的时间点给它参数区分就好。这样子不管你是要记录哪一种动物都很方便了，而且代码也相当简洁：</p><pre><code class="javascript">function createCounter (name) {  var count = 0  return function () {    count++    console.log(count + &#39; &#39; + name)  }}const dogCounter = createCounter(&#39;dogs&#39;)const catCounter = createCounter(&#39;cats&#39;)const pigCounter = createCounter(&#39;pigs&#39;)dogCounter()     // 1 dogsdogCounter()     // 2 dogscatCounter()     // 1 catscatCounter()     // 2 catspigCounter()     // 1 pigsdogCounter()     // 3 dogscatCounter()     // 3 cats</code></pre><h3 id="闭包的实际应用"><a href="#闭包的实际应用" class="headerlink" title="闭包的实际应用"></a>闭包的实际应用</h3><p>我们要实现这样的一个需求：点击某个按钮，提示点击的是”第n个”按钮，此处我们先不用事件代理:</p><pre><code class="javascript">.....&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;   var buttons = document.getElementsByTagName(&#39;button&#39;)    for (var i = 0; i &lt; buttons.length; i++) {      buttons[i].onclick = function () {        console.log(&#39;第&#39; + (i + 1) + &#39;个&#39;)      }    }&lt;/script&gt;  </code></pre><p>这时候可能会预期点选不同的按钮时，会根据每个button 点击顺序的不同而得到不同的结果。但是实际执行后，你会发现返回的结果都是“第四个”。这是因为<code>i</code>是全局变量，执行到点击事件时，此时<code>i</code>的值为3。</p><p>如果要强制返回预期的结果，那该如何修改呢？最简单的是用<code>let</code>声明<code>i</code>：</p><pre><code class="javascript">for (let i = 0; i &lt; buttons.length; i++) {    buttons[i].onclick = function () {        console.log(&#39;第&#39; + (i + 1) + &#39;个&#39;)    }}</code></pre><p>简单来说，通过<code>let</code>可以帮我们把所定义的变量缩限在块级作用域中，也就是变量的作用域只有在<code>{ }</code>内，来避免 <code>i</code> 这个变量跑到全局变量被重复覆盖。</p><p>另外我们可以通过闭包的方式来修改:</p><pre><code class="javascript">for (var i = 0; i &lt; buttons.length; i++) {    (function (j) {        buttons[j].onclick = function () {          console.log(&#39;第&#39; + (j + 1) + &#39;个&#39;)        }    })(i)}</code></pre><p>这其实也是「立即执行函数表达式 (Immediately Invoked Function Expression, IIFE)」的概念，后续会有专门的文章进行介绍。</p><p>希望看完这篇文章后，你能对于闭包有更清楚的认识。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之this是什么</title>
    <link href="/2019/10/24/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8Bthis%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2019/10/24/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8Bthis%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://zhuanlan.zhihu.com/p/69910449" target="_blank" rel="noopener">《JavaScript系列之作用域和作用域链》</a>中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。</p><p>再来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain-1.jpg" srcset="/img/loading.gif" alt></p><p>本章将专门介绍与执行上下文创建阶段直接相关的最后一个细节——<strong>this</strong>是什么？以及它的指向到底是什么。</p><h3 id="了解this"><a href="#了解this" class="headerlink" title="了解this"></a>了解this</h3><p>也许你在其他面向对象的编程语言曾经看过<code>this</code>，也知道它会指向某个构造器(constructor)所建立的对象。但事实上在JavaScript里面，<code>this</code>所代表的不仅仅是那个被建立的对象。</p><p>先来看看ECMAScript 标准规范对this 的定义：</p><blockquote><p>「The this keyword evaluates to the value of the ThisBinding of the current execution context.」<br>「this 这个关键字代表的值为当前执行上下文的ThisBinding。」</p></blockquote><p>然后再来看看MDN 对this 的定义：</p><blockquote><p>「In most cases, the value of this is determined by how a function is called.」<br>「在大多数的情况下，this 其值取决于函数的调用方式。」</p></blockquote><p>好，如果上面两行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 我想应该不会，至少我光看这两行还是不懂。</p><p>先来看个例子吧：</p><pre><code class="javascript">var getGender = function() {    return people1.gender;};var people1 = {    gender: &#39;female&#39;,    getGender: getGender};var people2 = {    gender: &#39;male&#39;,    getGender: getGender};console.log(people1.getGender());    // femaleconsole.log(people2.getGender());    // female</code></pre><p>what?怎么<code>people2</code>变性了呢，这不是我想要的结果啊，为什么呢？</p><p>因为<code>getGender()</code>返回(return)写死了<code>people1.gender</code>的关系，结果自然是’female’。</p><p>那么，如果我们把<code>getGender</code>稍改一下：</p><pre><code class="javascript">var getGender = function() {    return this.gender;};</code></pre><p>这个时候，你应该会分别得到<code>female</code>与<code>male</code>两种结果。</p><p>所以回到前面讲的重点，从这个例子可以看出，即便<code>people1</code>与<code>people2</code>的<code>getGender</code>方法参照的都是同一个<code>getGender function</code>，但由于调用的对象不同，所以执行的结果也会不同。</p><p>现在我们知道了第一个重点，<strong><code>this</code>实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数的调用方式</strong>。如何的区分<code>this</code>呢？</p><h3 id="this到底是谁"><a href="#this到底是谁" class="headerlink" title="this到底是谁"></a>this到底是谁</h3><p>看完上面的例子，还是有点似懂非懂吧？那接下来我们来看看不同的调用方式对 <code>this</code> 值的影响。</p><h4 id="情况一：全局对象-amp-调用普通函数"><a href="#情况一：全局对象-amp-调用普通函数" class="headerlink" title="情况一：全局对象&amp;调用普通函数"></a>情况一：全局对象&amp;调用普通函数</h4><p>在全局环境中，<code>this</code> 指向全局对象，在浏览器中，它就是 <code>window</code> 对象。下面的示例中，无论是否是在严格模式下，<code>this</code> 都是指向全局对象。</p><pre><code class="javascript">var x = 1console.log(this.x)               // 1console.log(this.x === x)         // trueconsole.log(this === window)      // true</code></pre><p>如果普通函数是在全局环境中被调用，在非严格模式下，普通函数中 <code>this</code> 也指向全局对象；如果是在严格模式下，<code>this</code> 将会是 <code>undefined</code>。ES5 为了使 JavaScript 运行在更有限制性的环境而添加了严格模式，严格模式为了消除安全隐患，禁止了 <code>this</code> 关键字指向全局对象。</p><pre><code class="javascript">var x = 1function fn() {    console.log(this);   // Window 全局对象    console.log(this.x);  // 1}fn();      </code></pre><p>使用严格模式后：</p><pre><code class="javascript">&quot;use strict&quot;     // 使用严格模式var x = 1function fn() {    console.log(this);   // undefined    console.log(this.x);  // 报错 &quot;Cannot read property &#39;x&#39; of undefined&quot;，因为此时 this 是 undefined}fn();  </code></pre><h4 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h4><p>我们知道，在对象里的值如果是原生值（primitive type；例如，字符串、数值、布尔值），我们会把这个新建立的东西称为「<strong>属性（property）</strong>」；如果对象里面的值是函数（function）的话，我们则会把这个新建立的东西称为「<strong>方法（method）</strong>」。</p><p>如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，<strong>函数中的<code>this</code>指向这个上一级对象</strong>。</p><pre><code class="javascript">var x = 1var obj = {    x: 2,    fn: function() {        console.log(this);            console.log(this.x);    }}obj.fn()     // obj.fn()结果打印出;// Object {x: 2, fn: function}// 2var a = obj.fna()   // a()结果打印出:   // Window 全局对象// 1</code></pre><p>在上面的例子中，直接运行 <code>obj.fn()</code> ，调用该函数的上一级对象是 <code>obj</code>，所以 <code>this</code> 指向 <code>obj</code>，得到 <code>this.x</code> 的值是 2；之后我们将 <code>fn</code> 方法首先赋值给变量 <code>a</code>，<code>a</code> 运行在全局环境中，所以此时 <code>this</code> 指向全局对象<code>Window</code>，得到 <code>this.x</code> 为 1。</p><p>我们再来看一个例子，如果函数被多个对象嵌套调用，this 会指向什么。</p><pre><code class="javascript">var x = 1var obj = {  x: 2,  y: {    x: 3,    fn: function() {      console.log(this);   // Object {x: 3, fn: function}      console.log(this.x);   // 3    }  }}obj.y.fn();    </code></pre><p>为什么结果不是 2 呢，因为在这种情况下记住一句话：<strong><code>this</code> 始终会指向直接调用函数的上一级对象</strong>，即 <code>y</code>，上面例子实际执行的是下面的代码。</p><pre><code class="javascript">var y = {  x: 3,  fn: function() {    console.log(this);   // Object {x: 3, fn: function}    console.log(this.x);   // 3  }}var x = 1var obj = {  x: 2,  y: y}obj.y.fn();  </code></pre><p>对象可以嵌套，函数也可以，如果函数嵌套，<code>this</code> 会有变化吗？我们通过下面代码来探讨一下。</p><pre><code class="javascript">var obj = {    y: function() {        console.log(this === obj);   // true        console.log(this);   // Object {y: function}        fn();        function fn() {            console.log(this === obj);   // false            console.log(this);   // Window 全局对象        }    }}obj.y();  </code></pre><p>在函数 <code>y</code> 中，<code>this</code> 指向了调用它的上一级对象 <code>obj</code>，这是没有问题的。但是在嵌套函数 <code>fn</code> 中，<code>this</code> 并不指向 <code>obj</code>。嵌套的函数不会从调用它的函数中继承 <code>this</code>，当嵌套函数作为函数调用时，其 <code>this</code> 值在非严格模式下指向全局对象，在严格模式是 <code>undefined</code>，所以上面例子实际执行的是下面的代码。</p><pre><code class="javascript">function fn() {    console.log(this === obj);   // false    console.log(this);   // Window 全局对象}var obj = {    y: function() {        console.log(this === obj);   // true        console.log(this);   // Object {y: function}        fn();    }}obj.y();  </code></pre><h4 id="情况三：作为构造函数调用"><a href="#情况三：作为构造函数调用" class="headerlink" title="情况三：作为构造函数调用"></a>情况三：作为构造函数调用</h4><p>我们可以使用 <code>new</code> 关键字，通过构造函数生成一个实例对象。此时，<strong><code>this</code> 便指向这个新对象</strong>。</p><pre><code class="javascript">var x = 1;function Fn() {　  this.x = 2;    console.log(this);  // Fn {x: 2}}var obj = new Fn();   // obj和Fn(..)调用中的this进行绑定console.log(obj.x)   // 2</code></pre><p>使用<code>new</code>来调用<code>Fn(..)</code>时，会构造一个新对象并把它（<code>obj</code>）绑定到<code>Fn(..)</code>调用中的<code>this</code>。还有值得一提的是，如果构造函数返回了非引用类型（<code>string</code>，<code>number</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>），<code>this</code> 仍然指向实例化的新对象。</p><pre><code class="javascript">var x = 1function Fn() {  this.x = 2  return {    x: 3  }}var a = new Fn()console.log(a.x)      // 3</code></pre><p>因为<code>Fn()</code>返回(return)的是一个对象（引用类型），<code>this</code> 会指向这个return的对象。如果return的是一个非引用类型的值呢？</p><pre><code class="javascript">var x = 1function Fn() {  this.x = 2  return 3}var a = new Fn()console.log(a.x)      // 2</code></pre><h4 id="情况四：call-和-apply-方法调用"><a href="#情况四：call-和-apply-方法调用" class="headerlink" title="情况四：call 和 apply 方法调用"></a>情况四：call 和 apply 方法调用</h4><p>如果你想改变 <code>this</code> 的指向，可以使用 <code>call</code> 或 <code>apply</code> 方法。<strong>它们的第一个参数都是指定函数运行时其中的<code>this</code>指向</strong>。如果第一个参数不传（参数为空）或者传 <code>null</code> 、<code>undefined</code>，默认 <code>this</code> 指向全局对象（非严格模式）或 <code>undefined</code>（严格模式）。</p><pre><code class="javascript">var x = 1;var obj = {  x: 2}function fn() {    console.log(this);    console.log(this.x);}fn.call(obj)// Object {x: 2}// 2fn.apply(obj)     // Object {x: 2}// 2fn.call()         // Window 全局对象// 1fn.apply(null)    // Window 全局对象// 1fn.call(undefined)    // Window 全局对象// 1</code></pre><p>使用 <code>call</code> 和 <code>apply</code> 时，如果给 <code>this</code> 传的不是对象，JavaScript 会使用相关构造函数将其转化为对象，比如传 <code>number</code> 类型，会进行<code>new Number()</code>操作，如传 <code>string</code> 类型，会进行<code>new String()</code>操作，如传 <code>boolean</code> 类型，会进行<code>new Boolean()</code>操作。</p><pre><code class="javascript">function fn() {  console.log(Object.prototype.toString.call(this))}fn.call(&#39;love&#39;)      // [object String]fn.apply(1)          // [object Number]fn.call(true)          // [object Boolean]</code></pre><p><code>call</code> 和 <code>apply</code> 的区别在于，<code>call</code> 的第二个及后续参数是一个参数列表，<code>apply</code> 的第二个参数是数组。参数列表和参数数组都将作为函数的参数进行执行。</p><pre><code class="javascript">var x = 1var obj = {  x: 2}function Sum(y, z) {  console.log(this.x + y + z)}Sum.call(obj, 3, 4)       // 9Sum.apply(obj, [3, 4])    // 9</code></pre><h4 id="情况五：bind-方法调用"><a href="#情况五：bind-方法调用" class="headerlink" title="情况五：bind 方法调用"></a>情况五：bind 方法调用</h4><p>调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，新函数的 <code>this</code> <strong>会永久的指向 <code>bind</code> 传入的第一个参数</strong>，无论这个函数是如何被调用的。</p><pre><code class="javascript">var x = 1var obj1 = {    x: 2};var obj2 = {    x: 3};function fn() {    console.log(this);    console.log(this.x);};var a = fn.bind(obj1);var b = a.bind(obj2);fn();// Window 全局对象// 1a();// Object {x: 2}// 2b();// Object {x: 2}// 2a.call(obj2);// Object {x: 2}// 2</code></pre><p>在上面的例子中，虽然我们尝试给函数 <code>a</code> 重新指定 <code>this</code> 的指向，但是它依旧指向第一次 <code>bind</code> 传入的对象，即使是使用 <code>call</code> 或 <code>apply</code> 方法也不能改变这一事实，即永久的指向 <code>bind</code> 传入的第一次参数。</p><h4 id="情况六：箭头函数中this指向"><a href="#情况六：箭头函数中this指向" class="headerlink" title="情况六：箭头函数中this指向"></a>情况六：箭头函数中this指向</h4><p>值得一提的是，从ES6 开始新增了箭头函数，先来看看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">MDN 上对箭头函数的说明</a>：</p><blockquote><p>An arrow function expression has a shorter syntax than a function expression and does notbind its own <code>this</code>,<code>arguments</code>,<code>super</code>, or <code>new.target</code>. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors.</p></blockquote><p>这里已经清楚了说明了，箭头函数没有自己的<code>this</code>绑定。<strong>箭头函数中使用的<code>this</code>，其实是直接包含它的那个函数或函数表达式中的<code>this</code></strong>。在前面情况二中函数嵌套函数的例子中，被嵌套的函数不会继承上层函数的 <code>this</code>，如果使用箭头函数，会发生什么变化呢？</p><pre><code class="javascript">var obj = {  y: function() {        console.log(this === obj);   // true        console.log(this);           // Object {y: function}      var fn = () =&gt; {          console.log(this === obj);   // true          console.log(this);           // Object {y: function}      }      fn();  }}obj.y() </code></pre><p>和普通函数不一样，箭头函数中的 <code>this</code> 指向了 <code>obj</code>，这是因为它从上一层的函数中继承了 <code>this</code>，你可以理解为箭头函数修正了 <code>this</code> 的指向。所以<strong>箭头函数的<code>this</code>不是调用的时候决定的，而是在定义的时候处在的对象就是它的<code>this</code></strong>。</p><p>换句话说，箭头函数的<code>this</code>看外层的是否有函数，如果有，外层函数的<code>this</code>就是内部箭头函数的<code>this</code>，如果没有，则<code>this</code>是<code>Window</code>。</p><pre><code class="javascript">var obj = {  y: () =&gt; {        console.log(this === obj);   // false        console.log(this);           // Window 全局对象       var fn = () =&gt; {          console.log(this === obj);   // false          console.log(this);           // Window 全局对象       }      fn();  }}obj.y() </code></pre><p>上例中，虽然存在两个箭头函数，其实<code>this</code>取决于最外层的箭头函数，由于<code>obj</code>是个对象而非函数，所以<code>this</code>指向为<code>Window</code>全局对象。</p><p>同 bind 一样，箭头函数也很“顽固”，我们无法通过 <code>call</code> 和 <code>apply</code> 来改变 <code>this</code> 的指向，即传入的第一个参数被忽略。</p><pre><code class="javascript">var x = 1var obj = {    x: 2}var a = () =&gt; {    console.log(this.x)    console.log(this)}a.call(obj)       // 1// Window 全局对象a.apply(obj)      // 1// Window 全局对象</code></pre><p>文字描述有点过多可能有点干涩，那么就看底下的这张流程图吧，我觉得这个图总结的很好（转自掘金小册-<a href="https://juejin.im/book/5bdc715fe51d454e755f75ef" target="_blank" rel="noopener">前端面试之道</a>），图中的流程只针对于单个规则。</p><p><img src="/images/this/1.png" srcset="/img/loading.gif" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇文章介绍了 <code>this</code> 指向的几种情况，不同的运行环境和调用方式都会对 <code>this</code> 产生影响。总的来说，函数 <code>this</code> 的指向取决于当前调用该函数的对象，也就是执行时的对象。在这一节中，你需要掌握：</p><ul><li><code>this</code> 指向全局对象的情况；</li><li>严格模式和非严格模式下 <code>this</code> 的区别；</li><li>函数作为对象的方法调用时 <code>this</code> 指向的几种情况；</li><li>作为构造函数时 <code>this</code> 的指向，以及是否 <code>return</code> 的区别；</li><li>使用 <code>call</code> 和 <code>apply</code> 改变调用函数的对象；</li><li><code>bind</code> 创建的函数中 <code>this</code> 的指向；</li><li>箭头函数中的 <code>this</code> 指向。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之作用域和作用域链</title>
    <link href="/2019/10/18/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2019/10/18/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://zhuanlan.zhihu.com/p/69142071" target="_blank" rel="noopener">《JavaScript系列之变量对象》</a>中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。</p><p>此外，我们也知道每次进入上下文时都会创建变量对象并填充初始值，并且值会在代码执行阶段进行更新，现在就对执行上下文做更深一步的了解。</p><p>先来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain/1.jpg" srcset="/img/loading.gif" alt></p><p>本章将专门介绍与执行上下文创建阶段直接相关的另一个细节——<strong>作用域链</strong>。</p><h3 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h3><p>在介绍作用域链前，有必要先来了解一下被称为作用域(Scope)的特性，那什么是作用域呢？</p><p>作用域就是在运行时代码中不同部分中函数和变量的可访问性。可能这句话并不太好理解，我们先来看段代码：</p><pre><code class="javascript">function fn() {    var inVariable = &quot;inner variable&quot;;    console.log(inVariable); // inner variable}fn(); console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined</code></pre><p>从上面的代码中我们可以很直观地体会作用域的概念，变量<code>inVariable</code>在全局作用域没有声明，所以在全局作用域下直接取值会报错。所以我们可以这样理解：<strong>作用域就像一个地头蛇，我的地盘我做主，让属于自己域内的变量不会轻易外泄出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong>。这几句话总比前面那句好理解多了吧。</p><p>关于JavaScript 中的作用域类型，<strong>ES6 之前 JavaScript 并没有块级作用域，只有全局作用域和函数作用域</strong>。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现：</p><ul><li>全局作用域 — 变量可以随处访问</li><li>函数作用域— 变量可以在定义它们的函数的边界内访问</li><li>块级作用域—变量可以在定义它们的块中访问，块由 { 和 } 分隔</li></ul><h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><pre><code class="javascript">const global = &#39;global scoped&#39;function fn() {    const global = &#39;function scoped&#39;;    console.log(global); // function scoped}fn();console.log(global); // global scoped</code></pre><p>从上面例子可以看出全局作用域和函数作用域的作用范围，即使全局变量在函数内部分配了不同的值，它也只保留在同一函数的边界内，互相并不影响，我们也不会因使用相同的变量名而出错。再来看个例子加深理解：</p><pre><code class="javascript">const global = &#39;global scoped&#39;const anotherGlobal = &#39;also global scoped&#39;function fn() {    const global = &#39;function scoped&#39;    console.log(global) // function scoped    const scoped = &#39;also function scoped&#39;    function inner() {        console.log(scoped); // also function scoped        console.log(anotherGlobal) // also global scoped    }    inner();}console.log(global); // global scopedconsole.log(anotherGlobal); // also global scopedfn();inner(); // Uncaught ReferenceError: inner is not defined</code></pre><p>在这里我们可以看到 <code>inner()</code> 函数可以访问在其父函数中声明的变量—<code>fn()</code>。每当我们需要函数内部的变量时，引擎将首先在当前函数作用域内查找它。如果它没有当前函数作用域内找到它，它将继续上升，向上一级查找，直到它找到全局作用域内的变量，如果找不到变量，我们将得到一个ReferenceError。格外注意<strong>函数内层作用域可以访问外层作用域的变量，反之则不行</strong>。</p><p>除了上面所讲的最外层函数外面定义的变量拥有全局作用域，全局作用域还有一种特殊的出现场合：就是<strong>所有末声明直接赋值的变量将自动声明为拥有全局作用域的变量</strong>：</p><pre><code class="javascript">function fn() {    variable = &quot;undeclared variable&quot;;    var inVariable = &quot;inner variable&quot;;}fn();console.log(variable); // undeclared variableconsole.log(inVariable); // Uncaught ReferenceError: inVariable is not defined</code></pre><p>全局作用域有个弊端：如果我们写了很多行 JavaScript 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中，这样就会污染全局命名空间，容易引起命名冲突。同时意外的全局变量还会引起内存泄漏，所以在编程时，尽量避免全局变量的使用，以便后期更快地调试。</p><p>还有值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 <code>if</code> 和 <code>switch</code> 条件语句或 <code>for</code> 和 <code>while</code> 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。比如：</p><pre><code class="javascript">if (true) {    // &#39;if&#39; 条件语句块不会创建一个新的作用域    var name = &#39;miqilin&#39;; // name 依然在全局作用域中}console.log(name); // miqilin</code></pre><p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致bug出现 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在ES6中，我们得到了两个新的变量声明关键字 - <code>let</code>和<code>const</code>。它们和<code>var</code>之间的主要区别在于，使用ES6关键字声明的变量是块作用域，这意味着它们仅在它们定义的代码块中可用。块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p><code>let</code> 声明的语法与 <code>var</code> 的语法一致。你基本上可以用 <code>let</code> 来代替 <code>var</code> 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li><strong>声明变量不会提升到代码块顶部</strong></li></ul><p><code>let</code>/<code>const</code>创建的变量不会像使用<code>var</code>声明的变量那样被提升到顶部，因此你需要手动将 <code>let</code>/<code>const</code> 声明放置到顶部，以便让变量在整个代码块内部可用。比如：</p><pre><code class="javascript">cosole.log(name); // Uncaught ReferenceError: cosole is not definedconst name = &quot;miqilin&quot;;</code></pre><p>所以确保代码没有引用错误的一种方法是确保只使用<code>let</code>和<code>const</code>进行变量声明。</p><ul><li><strong>禁止重复声明</strong></li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符再进行 <code>let</code> 声明就会抛出错误。比如：</p><pre><code class="javascript">var count = 10;let count = 20; // Uncaught SyntaxError: Identifier &#39;count&#39; has already been declared</code></pre><p>上面例子中<code>count</code> 变量被前后声明了两次：第一次使用 <code>var</code> ，另一次使用 <code>let</code> 。因为 <code>let</code> 不能在同一作用域内重复声明一个已有标识符，此处的 <code>let</code> 声明就会抛出错误。但如果在嵌套的作用域内使用 <code>let</code> 声明一个同名的新变量，则不会抛出错误：</p><pre><code class="javascript">var count = 10;// 不会抛出错误if (condition) {let count = 20;// 其他代码}</code></pre><ul><li><strong>循环中的绑定块作用域的妙用</strong></li></ul><p>开发者可能最希望实现<code>for</code>循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，比如：</p><pre><code class="javascript">for (let i = 0; i &lt; 10; i++) {  // ...}console.log(i);// ReferenceError: i is not defined</code></pre><p>上面代码中，因为用<code>let</code>声明计数器<code>i</code>，只在<code>for</code>循环体内有效，所以在循环体外引用就会报错。</p><pre><code class="javascript">var a = [];for (var i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 10</code></pre><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果换使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><pre><code class="javascript">var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6</code></pre><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><pre><code class="javascript">for (let i = 0; i &lt; 5; i++) {  let i = &#39;abc&#39;;  console.log(i);}// abc// abc// abc// abc// abc</code></pre><p>上面代码正确运行，输出了 5 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><h3 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h3><p>上面用一大篇幅来讲解作用域，其实在里面就有涉及到作用域链的知识了。简单的来说，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做<strong>作用域链</strong>。看下面一个例子：</p><pre><code class="javascript">function a() {    function b() {        console.log(myVar);    }    var myVar = 2;    b();}var myVar = 1;a(); // 2b(); // Uncaught ReferenceError: b is not defined</code></pre><p>最后加以执行<code>a()</code>和<code>b()</code>，这时候我们会发现两件事：</p><p>1.执行<code>a()</code>会得到2的结果：之所以会有这样的结果，是因为当我们执行<code>function a</code>里面的<code>function b</code>时，因为在<code>function b</code>里面它找不到<code>myVar</code>这个变量，因此它开始往它的外层去搜寻，而这时候它的父级作用域是<code>function a</code>，在<code>function a</code>里面它便找到了<code>myVar = 2</code>，因此它就不再往外部环境 (<code>myVar = 1</code>)去找了，直接返回了2这样的结果。</p><p>2.<code>b()</code>会得到<code>b is not defined</code>的结果：之所以<code>b</code>会是<code>not defined</code>（记得是<code>not defined</code>不是<code>undefined</code>哦！)，是因为这时候在最外层的全局上下文（<code>global execution context</code>）中，找不到<code>function b</code>。</p><p>而从<code>b() --&gt; a() --&gt; global execution context</code>这样的链，就称为<strong>作用域链（Scope Chain）</strong>：</p><p><img src="/images/scopechain/2.jpg" srcset="/img/loading.gif" alt></p><p>如果我们把<code>function a</code>里面对于<code>myVar</code>的声明拿掉的话，它才会继续往外层搜寻<code>myVar</code>，直到找到全局作用域中的声明<code>myVar = 1</code>，这时候才会返回1的结果。</p><pre><code class="javascript">function a() {    function b() {        console.log(myVar);    }    //var myVar = 2;    b();}var myVar = 1;a(); // 1</code></pre><p>如果我们更进一步的把全局作用域中，对于<code>myVar</code>的声明也拿掉，那么现在在全局作用域中也找不到<code>myVar</code>这个变量了，也就是说，在这整个作用域链中都找不到<code>myVar</code>，因此可想而知，最后的结果是<code>not defined</code>。</p><pre><code class="javascript">function a() {    function b() {        console.log(myVar);    }    //var myVar = 2;    b();}//var myVar = 1;a(); // Uncaught ReferenceError: myVar is not defined</code></pre><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Scope</tag>
      
      <tag>Scope Chain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之变量对象</title>
    <link href="/2019/10/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/10/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>JavaScript编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇<a href="https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/" target="_blank" rel="noopener">《JavaScript系列之执行上下文和执行栈》</a>，通过对变量对象(Variable Object)的介绍对执行上下文有一个更深一步的了解。</p><p>上一篇文章也提到了，一个执行上下文的生命周期可以分为三个阶段：</p><p><img src="/images/scopechain/1.jpg" srcset="/img/loading.gif" alt></p><p>详细了解执行上下文对于初学者来说极为重要，因为其中涉及到了变量对象，作用域链，this等很多JavaScript初学者没完全搞懂，且极为重要的概念，它关系到我们能不能真正理解JavaScript，真正理解也能更为轻松地胜任后续工作，在后面的文章中我们会一一详细介绍，这里我们先重点了解一下<strong>变量对象</strong>。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>变量对象（Variable Object）是一个与执行上下文相关的数据作用域，存储了在上下文中定义的<strong>变量</strong>和<strong>函数声明</strong>，先来看一段代码示例：</p><pre><code class="javascript">function foo(){    var a = 10;         function b(){}    (function c(){});    console.log(a);     // 10    console.log(b);   // function b(){}    console.log(c);   // Uncaught ReferenceError: c is not defined}foo();</code></pre><p>在上面的例子中，<code>foo（）</code>函数的变量对象包含<strong>变量<code>a</code></strong>和<strong>函数<code>b（）</code>的声明</strong>。这里要注意的一点是，函数表达式并不像函数声明一样包含在变量对象中，在示例中所看到的那样，访问c（）函数会导致引用错误。因为变量对象是抽象的和特殊的，它不能在代码中访问，但会由JavaScript引擎处理。</p><p>上面利用的是函数上下文下的变量对象来说明变量对象储存了什么，但变量对象还存在于全局上下文中，接下来就分别来聊聊全局上下文中和函数上下文中的变量对象吧。</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>以浏览器中为例，全局对象为<code>window</code>。 全局上下文有一个特殊的地方，它的变量对象，就是<code>window</code>全局对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p><pre><code class="javascript">// 以浏览器中为例，全局对象为window// 全局上下文创建阶段// VO 为变量对象（Variable Object）的缩写windowEC = {    VO: Window,    scopeChain: {},    this: Window}</code></pre><p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在上面已经提到了，变量对象存储了执行上下文中的变量和函数声明，但在函数上下文中，还多了一个<code>arguments(函数参数列表)</code>, 一个伪数组对象。</p><p>这时变量对象的<strong>创建阶段</strong>会包括：</p><ol><li><strong>创建<code>arguments</code>对象</strong>。检查当前上下文中的参数，建立该对象下的属性与属性值。</li><li><strong>检查当前上下文的函数声明，也就是使用function关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li><li><strong>检查当前上下文中的变量声明</strong>（<code>var</code> 声明的变量），默认为 <code>undefined</code>；如果变量名称跟已经声明的形式参数或函数相同，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过变量声明，原属性值不会被修改。</li></ol><p><img src="/images/variableobject/1.jpg" srcset="/img/loading.gif" alt></p><p>对于第3点中的“跳过”一词想必大家会有一丝疑问？底下例子中既然按照上面的规则，变量声明的<code>foo</code>遇到函数声明的<code>foo</code>会跳过，可是为什么最后<code>foo</code>的输出结果仍然是被覆盖了？</p><pre><code class="javascript">function foo() { console.log(&#39;I am function foo&#39;) }var foo = 10;console.log(foo); // 10</code></pre><p>理由其实很简单，因为上面的三条规则仅仅适用于变量对象的<strong>创建过程</strong>，也就是执行上下文的创建过程。而<code>foo = 10</code>是在执行上下文的<strong>执行过程</strong>中运行的，输出结果自然会是10。对比下例：</p><pre><code class="javascript">console.log(foo); // ƒ foo() { console.log(&#39;I am function foo&#39;) }function foo() { console.log(&#39;I am function foo&#39;) }var foo = 10;console.log(foo); // 10</code></pre><p>为啥又是不一样的结果呢？其实它的执行顺序为：</p><pre><code class="javascript">// 首先将所有函数声明放入变量对象中，函数声明变量提升function foo() { console.log(&#39;I am function foo&#39;) }// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过变量声明默认undefined的赋值// var foo = undefined;// 然后开始执行阶段代码的执行console.log(foo); // ƒ foo() { console.log(&#39;I am function foo&#39;) }// 在执行上下文的执行过程中运行foo = 10;console.log(foo); // 10</code></pre><p>根据上面的规则，理解变量提升就变得十分简单了，我们也可以看出，<strong><code>function</code>声明会比<code>var</code>声明优先级更高一点</strong>。为了帮助大家更好的理解变量对象，我们再结合一个简单的例子来进行探讨。</p><pre><code class="javascript">function test() {    console.log(a);    console.log(foo());    var a = 1;    function foo() {        return 2;    }}test();/* 结果为：undefined2*/</code></pre><p>根据上述的规则，理解变量提升后可以将执行顺序理解为：</p><pre><code class="javascript">function test() {    function foo() {        return 2;    }    var a;    console.log(a);    console.log(foo());    a = 1;}test();</code></pre><p>这样是不是一目了然了呢？</p><p>当然还需要注意的是，函数未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象（VO）转变为了活动对象（AO），然后开始进行执行阶段的操作。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>当前进入执行阶段，变量对象（VO）激活成活动对象（AO），里面的属性都能被访问了，函数会顺序执行代码，改变变量对象的属性值，此阶段的执行上下文代码会分成两个阶段进行处理：</p><ol><li>进入执行上下文</li><li>执行代码</li></ol><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当进入执行上下文时，这时候还没有执行代码。让我们看一个例子：</p><pre><code class="javascript">function foo(a, b) {  var c = 10;  function d() {}  var e = function _e() {};  (function x() {});}foo(10); </code></pre><p>当进入带有参数10的<code>foo</code>函数上下文时，AO表现为如下：</p><pre><code class="javascript">AO = {    arguments: {        0: 10,        1: undefined,        length: 1    }    a: 10,    b: undefined,    c: undefined,    d: &lt;function reference to d&gt;,    e: undefined,}</code></pre><p><code>x</code> 是函数表达式，所以不在变量对象当中，<code>e</code> 变量引用的值也是函数表达式，所以变量 <code>e</code> 本身是声明，所以在变量对象当中。</p><h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4><p>这个阶段会按顺序执行代码，修改变量对象的属性值，紧接上面的例子，执行完成后AO如下：</p><pre><code class="javascript">AO = {    arguments: {        0: 10,        1: undefined,        length: 1    }    a: 10,    b: undefined,    c: 10,    d: &lt;reference to function declaration d&gt;,    e: &lt;reference to Function expression to _e&gt;,}</code></pre><p>到这里变量对象的创建过程就介绍完了，让我们简短地总结一下：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 <code>Arguments</code> 对象</li><li>在进入执行上下文时会依次给变量对象<strong>添加形参</strong>、<strong>函数声明</strong>、<strong>变量声明</strong>等初始的属性值</li><li>函数未进入执行阶段之前，变量对象中的属性都不能访问</li><li>在执行代码阶段，会再次修改变量对象的属性值，并赋予该有的属性值</li></ol><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>变量对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之执行上下文和执行栈</title>
    <link href="/2019/10/04/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <url>/2019/10/04/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>如果你想成为一名优秀的JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。</p><p>执行上下文和执行栈是JavaScript的难点之一，所以本人尽量用通俗易懂的方式来阐述这些概念。</p><h3 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h3><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。执行上下文（可执行代码段）总共有三种类型：</p><ul><li><strong>全局执行上下文（全局代码）</strong>：不在任何函数中的代码都位于全局执行上下文中，只有一个，浏览器中的全局对象就是 <code>window</code> 对象，<code>this</code> 指向这个全局对象。</li><li><strong>函数执行上下文（函数体）</strong>：只有调用函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创-建，它都会按照特定的顺序执行一系列步骤。</li><li><strong><code>Eval</code> 函数执行上下文（eval代码）</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</li></ul><p>执行上下文又包括三个生命周期阶段：<strong>创建阶段→执行阶段→回收阶段</strong>，本文重点介绍创建阶段。</p><p><strong>1.创建阶段</strong></p><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li><strong>创建变量对象(Variable object，VO)</strong>：首先初始化函数的参数<code>arguments</code>，提升函数声明和变量声明。后文会详细说明。</li><li><strong>创建作用域链（Scope Chain）</strong>：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。后文会详细说明。</li><li><strong>确定this指向</strong>：包括多种情况，后文会详细说明。</li></ul><p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p><p>另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出<code>this</code> 、 <code>arguments</code>和函数的参数。</p><p><strong>2.执行阶段</strong></p><p>进入执行上下文、执行代码</p><p><strong>3.回收阶段</strong></p><p>执行完毕后执行上下文出栈并等待被垃圾回收</p><p><img src="/images/scopechain/1.jpg" srcset="/img/loading.gif" alt></p><h3 id="执行上下文栈（Execution-Context-Stack）"><a href="#执行上下文栈（Execution-Context-Stack）" class="headerlink" title="执行上下文栈（Execution Context Stack）"></a>执行上下文栈（Execution Context Stack）</h3><p>假如我们写的函数多了，每次调用函数时都创建一个新的执行上下文，如何管理创建的那么多执行上下文呢？</p><p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，具有 LIFO（后进先出）的栈结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个<strong>新的函数</strong>执行上下文并Push到当前执行栈的顶部，浏览器的JS执行引擎总是访问栈顶的执行上下文。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的<strong>下一个</strong>执行上下文，最终移回到<strong>全局</strong>执行上下文，全局上下文只有唯一的一个，它在浏览器关闭时Pop出。</p><p>看到目前为止，是否觉得这两个概念还是有点晦涩难懂呢？那…接下来通过几小段代码和图解来详细介绍并理解吧。</p><h3 id="执行上下文是如何执行的呢？"><a href="#执行上下文是如何执行的呢？" class="headerlink" title="执行上下文是如何执行的呢？"></a>执行上下文是如何执行的呢？</h3><p>让我们先来看一下这段简单代码：</p><pre><code class="javascript">function b(){}function a(){  b();}a();</code></pre><p>这段代码背后执行的逻辑是这样的：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，这时候会一并建立<code>this</code>、<code>global object</code> (<code>window</code>)，在函数开始执行的过程中，<code>function a</code>和<code>b</code>由于JS提升机制的缘故会先被建立在内存中，接着才会开始逐行执行函数。</p><p><img src="/images/context/1.jpg" srcset="/img/loading.gif" alt></p><p>接着，代码会执行到<code>a( )</code>这个部分，这时候，会建立<code>a</code>的执行上下文（execution context），并且被放置到执行栈（execution stack）中。在这个execution stack中，最上面的execution context会是正在被执行的<code>a( )</code>。如下图：</p><p><img src="/images/context/2.jpg" srcset="/img/loading.gif" alt></p><p><code>function a</code> 的execution context建立后，便会开始执行<code>function a</code>中的内容。由于在<code>function a( )</code> 里面有去执行<code>function b</code> ，因此，在这个execution stack中，接下来最上面会变成<code>function b</code> 的execution context。如下图：</p><p><img src="/images/context/3.jpg" srcset="/img/loading.gif" alt></p><p>当<code>function b</code> 执行完之后，会从execution stack中离开，继续逐行执行<code>function a</code>。当<code>function a</code> 执行完之后，一样会从execution stack中抽离，再回到Global Execution Context逐行执行。如下图：</p><p><img src="/images/context/4.jpg" srcset="/img/loading.gif" alt></p><h3 id="不同执行上下文中的变量是不同的"><a href="#不同执行上下文中的变量是不同的" class="headerlink" title="不同执行上下文中的变量是不同的"></a>不同执行上下文中的变量是不同的</h3><p>在了解了一般的函数其运作背后的逻辑后，让我们来看一下这段代码：</p><pre><code class="javascript">function b(){  var myVar;  console.log(myVar);}function a(){  var myVar = 2;  b();  console.log(myVar);}var myVar = 1;console.log(myVar);a();</code></pre><p>你可以想像，如果我们在不同的execution context中去把<code>myVar</code>这个变量打出来，会得到什么结果呢？结果如下：</p><p><img src="/images/context/5.jpg" srcset="/img/loading.gif" alt></p><p>我们分别得到了1、<code>undefined</code>和2。为什么会这样呢？</p><p>让我们来看看这段代码背后执行的逻辑：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，由于变量提升的缘故，<code>myVar</code>、<code>function a</code>和<code>b</code>都会被建立并储存在内存中，接着便开始逐行执行函数。一开始会碰到<code>var myVar = 1</code>所以，最外层的<code>myVar</code>便被给值为1，接着执行到了<code>console.log(myVar)</code>，这是在global execution context执行的，于是得到了第一个1的结果：</p><p><img src="/images/context/6.jpg" srcset="/img/loading.gif" alt></p><p>然后执行到了<code>a ( )</code>，于是建立了<code>a</code>的execution context，这时候由于逐行执行的关系，会先执行到<code>var myVar = 2</code>，但因为这是在function a的execution context中，所以并不会影响到global execution context的<code>myVar</code>：</p><p><img src="/images/context/7.jpg" srcset="/img/loading.gif" alt></p><p>在执行完<code>function a</code>中的<code>var myVar = 2</code>后，继续逐行执行，于是执行到了<code>b ( )</code>，这时候，<code>function b</code>的execution function便被建立，而且会先去执行<code>function b</code>里面的内容：</p><p><img src="/images/context/8.jpg" srcset="/img/loading.gif" alt></p><p><code>function b</code>的execution function建立后，会开始逐行执行<code>function b</code>里面的内容，于是读到了<code>var myVar</code>;，这时候在<code>function b</code>这个execution context中的<code>myVar</code>变量被建立，但是还没被赋值，所以会是<code>undefined</code>。和上面提到的一样，由于这个<code>myVar</code>是在<code>function b</code>中的execution context所建立，所以并不会影响到其他execution context的<code>myVar</code>，这时候执行到了<code>function b</code>的 execution context中的<code>console.log(myVar)</code>，于是得到了第二个看到的<code>undefined</code>：</p><p><img src="/images/context/9.jpg" srcset="/img/loading.gif" alt></p><p>最后，<code>function b</code>执行完之后，会从execution stack中离开，继续回到<code>function a</code>中的<code>b( )</code>后逐行执行，也就是<code>console.log(myVar)</code>，这时候是在function a的execution context加以执行的，因此也就得到了结果中看到的第三个2了。</p><p>最后由于<code>b ( )</code> 后面已经没有内容，<code>function a</code>执行完毕，这时候，<code>function a</code>也会从execution stack中抽离。</p><p><img src="/images/context/10.jpg" srcset="/img/loading.gif" alt></p><p>最后回到Global Execution Context，如果函数中的<code>a( )</code>后面还有内容的话，会继续进行逐行执行。</p><p>由上面的例子，我们可以知道，我们是在不同的execution context中分别去声明变量<code>myVar</code>的，<strong>因此在不同的execution context，变量彼此之间不会影响</strong>，所以虽然这三个变量都叫做<code>myVar</code>，但其实是三个不同的变量。</p><p>由于我们是在不同的execution context中去声明变量，所以这其实是位于三个不同execution context中的变量，所以即使我们是在执行完<code>a( )</code>后再去调用一次<code>myVar</code>，一样会得到” 1”的结果:</p><pre><code class="javascript">function b(){  var myVar;  console.log(myVar);}function a(){  var myVar = 2;  b();  console.log(myVar);}var myVar = 1;console.log(myVar);a();console.log(myVar);  // 一样会得到&quot;1&quot;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>最后需要注意的是，如果是在<code>function</code>里面直接使用<code>myVar</code>这个变量，而没有通过<code>var</code>重新声明它的话，就会得到不同的结果！因为在函数作用域内加 <code>var</code> 定义的变量是局部变量，不加 <code>var</code> 定义的就成了全局变量。在未声明新的变量的情况下，在该execution context中JavaScript 引擎找不到这个变量，它就会往它的外层去寻找，最后会得到，1 ,2 ,2 ,2 的结果:</p><pre><code class="javascript">function b(){  myVar;  console.log(myVar);}function a(){  myVar = 2;  b();  console.log(myVar);}var myVar = 1;console.log(myVar);a();console.log(myVar);/*打印出1222*/</code></pre><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Execution Context</tag>
      
      <tag>Execution Context Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈JavaScript中的函数构造式和prototype的建立</title>
    <link href="/2019/09/24/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <url>/2019/09/24/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/" target="_blank" rel="noopener">《谈谈JavaScript中的function constructor和new关键字》</a>这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。</p><p>在JavaScript中的函数也是一种对象，其中包含一些属性像是该函数的名称（<code>Name</code>）和该函数的内容（<code>Code</code>），但其实<code>function</code>这里面还有一个属性，这个属性就是<code>prototype</code>，这个属性会以空对象的型式呈现。</p><p>除非你是把<code>function</code>当做<code>function constructor</code>来使用，否则这个属性就没有特别的用途；但如果你是把它当做<code>function constructor</code>，通过<code>new</code>这个关键字来执行这个<code>function</code>的话，它就有特别的意义了。</p><p><img src="/images/constructor/1.jpg" srcset="/img/loading.gif" alt></p><p>要进入这个<code>function</code>的<code>prototype</code>属性只要直接通过 <code>.prototype</code> 就可以了。</p><p>然而，有一点很容易令人困惑的地方，我们会以为如果我使用 <code>.prototype</code> 时，就可以直接进入该函数的原型，但实际上并不是这样的！</p><p><strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个<code>function constructor</code>所建立出来的对象的<code>prototype</code></strong>，听起来有点混乱吧…没关系，让我们来看一些代码来帮助我们理解这一概念。</p><h3 id="说明函数中的prototype-属性"><a href="#说明函数中的prototype-属性" class="headerlink" title="说明函数中的prototype 属性"></a>说明函数中的prototype 属性</h3><p><strong>1.function 中的prototype 属性一开始是空对象</strong></p><p>我们先执行上篇文章最后所写的代码：</p><pre><code class="javascript">function  Person  ( firstName , lastName )  {   this . firstName = firstName ;   this . lastName = lastName ; }var person1 =  new  Person ( &#39;Jay&#39; ,  &#39;chou&#39; ) ; console . log ( person1 ) ; var person2 =  new  Person ( &#39;Jane&#39; ,  &#39;chou&#39; ) ; console . log ( person2 ) ;</code></pre><p>到Google Chrome的console视窗中，我们输入 <code>Person.prototype</code>得到的结果会得到一个空对象，如下图：</p><p><img src="/images/constructor/2.jpg" srcset="/img/loading.gif" alt></p><p><strong>2.通过function constructor 所建立的对象会继承该function 中prototype 的内容</strong></p><p>接着，让我们在<code>Person.prototype</code>里面增加一个<code>getFullName</code>的函数：</p><pre><code class="javascript">function  Person  ( firstName , lastName )  {   this . firstName = firstName ;   this . lastName = lastName ; }Person . prototype . getFullName  =  function ( )  {   return  this . firstName +  &#39; &#39;  +  this . lastName ; }var person1 =  new  Person ( &#39;Jay&#39; ,  &#39;chou&#39; ) ; console . log ( person1 ) ; var person2 =  new  Person ( &#39;Jane&#39; ,  &#39;chou&#39; ) ; console . log ( person2 ) ;</code></pre><p>在上面代码的第6 - 8行中，我们为<code>Person.prototype</code>添加了一个函数，所以当我们在Google Chrome的console视窗中调用<code>Person.prototype</code>时，会多了这个函数在内：</p><p><img src="/images/constructor/3.jpg" srcset="/img/loading.gif" alt></p><p>刚刚，我们有提到很重要的一句话，「<strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个function constructor所建立出来的对象的<code>prototype</code></strong>」。</p><p>这句话的意思其实是说<code>Person.prototype</code>并不是<code>Person.__proto__</code>，但是所有通过<code>Person</code>这个<code>function constructor</code>所建立的对象，在该实例对象的<code>__proto__</code>中，会包含有<code>Person.prototype</code>的内容。</p><p>也就是说，当我们使用<code>new</code>这个运算符来执行<code>function constructor</code>时，它会先建立一个空对象，同时将该构造函数中<code>prototype</code>这个属性的内容（<code>Person.prototype</code>），设置到该实例对象的<code>prototype</code>中，即 <code>person1.__proto__ === Person.prototype</code>的结果为<code>true</code>。</p><p>因此，当我们在Google Chrome的console中输入<code>person1.__proto__</code>时，我们就可以看到刚刚在<code>Person.prototype</code>所建立的函数<code>getFullName</code>已经继承在里面了：</p><p><img src="/images/constructor/4.jpg" srcset="/img/loading.gif" alt></p><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>由于<code>Person.prototype</code>中的方法已经被继承到由<code>Person</code>这个<code>function constructor</code>所建立的实例对象<code>person1</code>中，所以这时侯，我们就可以顺利的使用 <code>person1.getFullName</code> 这个方法：</p><pre><code class="javascript">function  Person  ( firstName , lastName )  {   this . firstName = firstName ;   this . lastName = lastName ; }Person . prototype . getFullName  =  function ( )  {   return  this . firstName +  &#39; &#39;  +  this . lastName ; }var person1 =  new  Person ( &#39;Jay&#39; ,  &#39;chou&#39; ) ; console . log ( person1 ) ; console . log ( person1.getFullName() ) ;</code></pre><p>可以正确的执行<code>getFullName</code>这个函数并得到如下的结果：</p><p><img src="/images/constructor/5.png" srcset="/img/loading.gif" alt></p><h3 id="通过function-constructor与Prototype-的实用处"><a href="#通过function-constructor与Prototype-的实用处" class="headerlink" title="通过function constructor与Prototype 的实用处"></a>通过function constructor与Prototype 的实用处</h3><p>通过这样的方法，我们可以让所有根据这个函数构造器（<code>function constructor</code>）所建立的对象都包含有某些我们想要使用的方法。如果我们有1000个对象是根据这个函数构造器所建立的，那么我们只需要使用 <code>.prototype</code>这样的方法，就可以让这1000个物件都可以使用到我们想要执行的某个<code>method</code>，这样减少了代码的复用。</p><p>有的人可能会好奇问，为什么我们不把<code>getFullName</code>这个方法直接写在函数构造式当中呢？</p><pre><code class="javascript">function  Person  ( firstName , lastName )  {   this . firstName = firstName ;   this . lastName = lastName ;   this . getFullName  =  function ( )  {     return  this . firstName +  &#39; &#39;  +  this . lastName ;   }}/*Person . prototype . getFullName  =  function ( )  {   return  this . firstName +  &#39; &#39;  +  this . lastName ; }*/</code></pre><blockquote><p>注意！我们不该把方法放在<code>function constructor</code> 中。</p></blockquote><p>把方法放在函数构造式中这么做虽然仍然可以正确执行并得到结果，但是这么做会有个问题，如果我们是把这个方法直接写在函数构造式中，那么每一个对象都会包含有这个方法，如果我们有1000 个对象根据这个函数构造式所建立，那么这1000 个对象都会包含这个方法在内，如此将会占据相当多的内存；但如果是建立在<code>prototype</code> 中，我们只会有一个这样的方法。</p><p>所以，为了性能上的考量，通常会把方法（<code>method</code>）放在构造函数的<code>prototype</code> 中，因为它们可以是通用的；把属性（<code>property</code>）放在构造函数当中，因为每一个对象可能都会有不同的属性内容，如此将能有效减少内存的问题。</p><p>最后，如果感觉当前缺少你要用的方法，可以自己通过这一方法去创建。</p><p>例如在json2.js源码中，为<code>Date</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code>方法添加一个<code>toJSON</code>的属性。</p><pre><code class="javascript">if (typeof Date.prototype.toJSON !== &#39;function&#39;) {  Date.prototype.toJSON = function (key) {    return isFinite(this.valueOf()) ?        this.getUTCFullYear() + &#39;-&#39; +      f(this.getUTCMonth() + 1) + &#39;-&#39; +      f(this.getUTCDate()) + &#39;T&#39; +      f(this.getUTCHours()) + &#39;:&#39; +      f(this.getUTCMinutes()) + &#39;:&#39; +      f(this.getUTCSeconds()) + &#39;Z&#39; : null;  };  String.prototype.toJSON =   Number.prototype.toJSON =   Boolean.prototype.toJSON = function (key) {    return this.valueOf();  };}</code></pre><p>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>constructor</tag>
      
      <tag>prototype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈JavaScript中的函数构造式和new关键字</title>
    <link href="/2019/09/17/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/09/17/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？</p><p>大多数 Javascript 的新开发者不太想要使用new关键字，因为这会让代码写的像是 Java 并且在使用上会造成一点混乱；在这篇文章我会尽量尝试着去理清这些东西，并解释它是如何运作的。</p><h3 id="谈谈function-constructor"><a href="#谈谈function-constructor" class="headerlink" title="谈谈function constructor"></a>谈谈function constructor</h3><p><code>constructor</code> 翻为构造器但为了让您之后更好地理解，会直接使用 <code>constructor</code>；在 Javascript 中任何一个函数(<code>function</code>)都可以被当作 <code>constructor</code>；Javascript 并没有明确的区分两者，也就是说 <code>function</code> 可以被当作 <code>constructor</code> 或者当作一般函数调用。</p><p>而 <code>constructor</code> 的用法就是 <code>function</code> 搭配<code>new</code>关键字：</p><pre><code class="javascript">function  Person  ( ) {   this . firstName =  &#39;Jay&#39; ;   this . lastName =  &#39;Chou&#39; ; }var person =  new  Person ( ) ; console . log ( person ) ;</code></pre><p>接着我们把<code>person</code>呼叫出来看，会得到如下的结果，<strong>通过<code>new</code>它会帮我们建立一个对象</strong>，然后里面有<code>Person</code>这个<code>function</code>里面的内容，并且变成了属性名称和属性值：</p><p><img src="/images/new/1.png" srcset="/img/loading.gif" alt></p><h3 id="进一步来看new-让这个过程发生了什么"><a href="#进一步来看new-让这个过程发生了什么" class="headerlink" title="进一步来看new 让这个过程发生了什么"></a>进一步来看new 让这个过程发生了什么</h3><p>当使用<code>new</code>命令时，它后面的函数依次执行下面的4个步骤：</p><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li><li>如果函数没有return其他对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ol><p>也就是说，当我们使用<code>new</code>这个关键字时，实际上会先有一个空的对象被建立。</p><p>接着<code>People</code>这个构造函数会被执行，这个空对象的原型，指向了<code>People.prototype</code>。</p><p>我们知道当函数执行的时候，在<code>execution context</code>中会有<code>this</code>被建立，而<strong>当我们使用<code>new</code>的时候，函数里面的<code>this</code>会被指定成刚刚所建立的那个空对象</strong>。</p><p>所以当执行<code>People</code>这个<code>function</code>，执行到<code>this.firstName</code>和<code>this.lastName</code>时，因为<code>this</code>现在指称的是那个空对象，所以实际上是在帮这个空对象赋予属性名称和属性值。</p><p>在这样的过程中，<strong>只要这个构造函数<code>People</code> 没有指定<code>return</code>为其他对象，它就会直接返回给我们这个新建立的对象</strong>。</p><p>接着让我们通过一段代码来更清楚的了解这个执行的过程：</p><pre><code class="javascript">function  Person  ( ) {   this . firstName =  &#39;Jay&#39; ;   this . lastName =  &#39;Chou&#39; ;   console . log ( &#39;这个函数有被执行&#39; ) ;}var person =  new  Person ( ) ; console . log ( person ) ;</code></pre><p>这时候在chrome 中呼叫出来的结果如下，说明了当我们使用<code>new</code> 在构造对象的时候<code>People</code> 这个<code>function</code> 确实有被执行：</p><p><img src="/images/new/2.png" srcset="/img/loading.gif" alt></p><h3 id="通过new-会帮我们建立一个空的对象"><a href="#通过new-会帮我们建立一个空的对象" class="headerlink" title="通过new 会帮我们建立一个空的对象"></a>通过new 会帮我们建立一个空的对象</h3><p>现在我把我们上面的代码改成这样：</p><pre><code class="javascript">function  Person ( ) {   console . log ( this ) ; }var person =  new  Person ( ) ; // console.log(person);</code></pre><p>这时候代码返回的结果如下，表示的确在执行这段代码的过程中帮我们建立了一个新的空对象：</p><p><img src="/images/new/3.jpg" srcset="/img/loading.gif" alt></p><h3 id="函数的最后若return其他对象，则原新对象内容会被覆盖"><a href="#函数的最后若return其他对象，则原新对象内容会被覆盖" class="headerlink" title="函数的最后若return其他对象，则原新对象内容会被覆盖"></a>函数的最后若return其他对象，则原新对象内容会被覆盖</h3><p>现在，让我们把原本的代码稍微做如下修改：</p><pre><code class="javascript">function  Person  ( ) {   this . firstName =  &#39;Jay&#39; ;   this . lastName =  &#39;Chou&#39; ;   return   { &quot;RETURN&quot; : &quot;原本this的内容就不会被返回&quot; } ; }var person =  new  Person ( ) ; console . log ( person ) ;</code></pre><p>构造函数的内部若<code>return</code>其他对象，<code>new</code>命令会返回<code>return</code>语句指定的对象，将原新对象内容覆盖掉；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。返回的结果如下：</p><p><img src="/images/new/4.png" srcset="/img/loading.gif" alt></p><h3 id="手写一个new实现"><a href="#手写一个new实现" class="headerlink" title="手写一个new实现"></a>手写一个new实现</h3><pre><code class="javascript">function create() {    // 创建一个空的对象    var obj = new Object(),    // 获得构造函数，arguments中去除第一个参数    Con = [].shift.call(arguments);    // 链接到原型，obj 可以访问到构造函数原型中的属性    obj.__proto__ = Con.prototype;    // 绑定 this 实现继承，obj 可以访问到构造函数中的属性    var ret = Con.apply(obj, arguments);    // 优先返回构造函数返回的对象    return ret instanceof Object ? ret : obj;};</code></pre><p>使用这个手写的new</p><pre><code class="javascript">function Person() {...}// 使用内置函数newvar person = new Person(...)// 使用手写的new，即createvar person = create(Person, ...)</code></pre><p>代码原理解析：</p><ol><li>用<code>new Object()</code> 的方式新建了一个对象<code>obj</code></li><li>取出第一个参数，就是我们要传入的构造函数。此外因为 <code>shift</code> 会修改原数组，所以 <code>arguments</code> 会被去除第一个参数</li><li>将 <code>obj</code> 的原型指向构造函数，这样<code>obj</code>就可以访问到构造函数原型中的属性</li><li>使用 <code>apply</code>，改变构造函数 <code>this</code> 的指向到新建的对象，这样 <code>obj</code> 就可以访问到构造函数中的属性</li><li>返回 <code>obj</code></li></ol><h3 id="function-constructor-的实际应用"><a href="#function-constructor-的实际应用" class="headerlink" title="function constructor 的实际应用"></a>function constructor 的实际应用</h3><p>由上面的方法，我们可以通过<code>function</code>的方式来建立一个新的对象，如果我们想要<strong>建立出同属性名称但不同属性值的对象内容，我们可以把对象的属性值变成参数</strong>，如此就能通过此<code>function constructor</code>建立出许多不同的对象：</p><pre><code class="javascript">function  Person  ( firstName , lastName )  {   this . firstName = firstName ;   this . lastName = lastName ; }var person1 =  new  Person ( &#39;Jay&#39; ,  &#39;chou&#39; ) ; console . log ( person1 ) ; var person2 =  new  Person ( &#39;Jane&#39; ,  &#39;chou&#39; ) ; console . log ( person2 ) ;</code></pre><p>如此，我们就可以通过同一个构造函数建立出很多不同的对象：</p><p><img src="/images/new/5.png" srcset="/img/loading.gif" alt></p><p>此外，我们会把根据<strong>构造器（<code>constructor</code>）所建立出来的对象称作是实例（<code>instance</code>）</strong>，这在之前的文章里也有提过。</p><h3 id="注意！如果我们忘了加上new关键字"><a href="#注意！如果我们忘了加上new关键字" class="headerlink" title="注意！如果我们忘了加上new关键字"></a>注意！如果我们忘了加上new关键字</h3><p>这里有一个地方我们需要非常留意，如果你在撰写代码的过程当中，忘记加上<code>new</code>这个关键字的话，比如：</p><pre><code class="javascript">function  Person  ( ) {   this . firstName =  &#39;Jay&#39; ;   this . lastName =  &#39;Chou&#39; ;  }var person =  Person ( ) ; console . log ( person ) ;</code></pre><p>如此，因为JavaScript不知道你是要执行这个函数，还是要根据这个<code>function</code>去建立<code>object</code>，因次最后会返回<code>undefined</code>的结果。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>其实构造函数（function constructor）就是普通的function，只是我们可以通过这个function 来建立对象。</li><li>通过在function 前面加上new 这个运算符，它会把函数中this 这个关键字建立成一个新的对象，然后如果你没有在该函数的内部指定返回出其它对象的话，它就会自动返回这个新的对象给你。</li></ul><p>那又是如何通过<code>function constructors</code> 来设定我们的原型（<code>prototype</code>）呢？让我们在下一篇文章来谈吧！</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>constructor</tag>
      
      <tag>new</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之对象的继承</title>
    <link href="/2019/09/11/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2019/09/11/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>这篇文章的重点讲的是关于JavaScript中对象的继承，这是面向对象编程很重要的一个方面。A 对象继承自B 对象，就能直接拥有 B 对象的所有属性和方法，作用是避免了代码的复用，节省代码量。</p><p>而大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。传统上，JavaScript 语言的继承不通过 class（ES6 引入了 class 语法，基于 class 的继承不在这里介绍），而是通过“原型对象”（<code>prototype</code>）实现，因此，这里把“继承”着重拿出来讲，就为了体现这个不同。</p><h3 id="复习原型-原型链"><a href="#复习原型-原型链" class="headerlink" title="复习原型/原型链"></a>复习原型/原型链</h3><p>JavaScript的继承得靠原型/原型链来实现，当然原型/原型链不是这篇文章的重点，之前的文章也已经介绍过了，所以这里我们来复习一下即可。</p><p>其实原型的概念很简单，我觉得用以下简短的几句话就能概括完全了：</p><ul><li>所有对象都有一个属性 <code>__proto__</code> 指向一个对象，也就是原型</li><li>每个对象的原型都可以通过 <code>constructor</code> 找到构造函数，构造函数也可以通过 <code>prototype</code> 找到原型</li><li>所有函数都可以通过 <code>__proto__</code> 找到 <code>Function</code> 对象</li><li>所有对象都可以通过 <code>__proto__</code> 找到 <code>Object</code> 对象</li><li>对象之间通过 <code>__proto__</code> 连接起来，这样称之为原型链。当前对象上不存在的属性可以通过原型链一层层往上查找，直到顶层 <code>Object</code> 对象，顶层 <code>Object</code> 对象最终指向<code>null</code></li></ul><p>我觉得原型中最重要的内容其实就这些了，没必要看太多关于原型的文章，到头来只是会越来越糊涂，如果硬要推荐原型参阅资料的话，《JavaScript高级程序设计》这本书，当之无愧！</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过上面的介绍，我们知道JavaScript中的继承是通过原型/原型链来体现的，先看几行代码：</p><pre><code class="javascript">function Foo() { }var f1 = new Foo();f1.a = 10;Foo.prototype.a = 100;Foo.prototype.b = 200;console.log(f1.a);  // 10console.log(f1.b);  // 200console.log(f1.c);  // undefined</code></pre><p>以上代码中，<code>f1</code>是<code>Foo</code>函数通过<code>new</code>构造出来的对象，<code>f1.a</code>是<code>f1</code>对象的基本属性，而<code>f1.b</code>是从<code>Foo.prototype</code>继承得到的，因为<code>f1.__proto__</code>指向的是<code>Foo.prototype</code>。</p><p>这里有一个重要的规则：<strong>当访问一个对象的属性时，首先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链往上找，看是否在链上，有的话就能继承这一属性，如果没有，就返回<code>undefined</code>，这就是原型链</strong>，又复习一遍咯。</p><p>看图直观一些，这里还是采用反复用的原型/原型链经典图：</p><p><img src="/images/inherit/1.jpg" srcset="/img/loading.gif" alt></p><p>上图中，访问<code>f1.a</code>时，<code>f1</code>的基本属性中有<code>a</code>，则不会继续沿着<code>__proto__</code>找，直接读出基本属性<code>a</code>的值；而访问<code>f1.b</code>时，<code>f1</code>的基本属性中没有<code>b</code>，于是沿着<code>__proto__</code>找到了<code>Foo.prototype.b</code>。</p><p>那我们如何在实际应用中区分一个属性到底是基本属性还是在原型链中的公有属性呢？这里可以好好利用一下这个属性——<code>hasOwnProperty</code>，一下就能测出谁是基本属性，当在<code>for…in…</code>循环中，需要额外注意。</p><p><img src="/images/inherit/2.jpg" srcset="/img/loading.gif" alt></p><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性，所以上图中，右边的只打印出<code>a</code>一个值，因为<code>b</code>是在<code>Foo.prototype</code>上的，不属于自身属性。</p><p>那<code>f1</code>的这个<code>hasOwnProperty()</code>方法，<code>f1</code>自身没有，<code>Foo.prototype</code>中也没有，又是从何而来呢？</p><p>还是引用那张原型/原型链经典图，从图上来看，<code>hasOwnProperty()</code>方法是从<code>Object.prototype</code>中继承来的：</p><p><img src="/images/inherit/3.jpg" srcset="/img/loading.gif" alt></p><p>所以对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，因为自身没有这一属性，就会沿着原型链一直查找到<code>Object.prototype</code>上有这一属性，如果没找到则返回<code>undefined</code>。</p><p>由于所有的对象的原型链都会最终找到<code>Object.prototype</code>，因此所有的对象都会有<code>Object.prototype</code>中的方法，比如<code>toString</code>、<code>valueOf</code>等这些公有属性，这就是所谓的“继承”。</p><p>当然这只是一个例子，你可以自定义函数和对象来实现自己的继承，这一点后续文章会有专门介绍。</p><p>这里再说一个函数的例子来加深理解吧。</p><p>我们都知道每个函数都有<code>apply</code>，<code>call</code>方法，都有<code>length</code>，<code>arguments</code>，<code>caller</code>等属性。为什么每个函数都有？这肯定是“继承”来的。在介绍<code>instanceof</code><a href="https://luozongmin.com/2019/06/05/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">这篇文章</a>中也提到，函数是由<code>Function</code>函数创建，都继承自<code>Function.prototype</code>中的方法。不信可以在Chrome中打印出：</p><p><img src="/images/inherit/4.jpg" srcset="/img/loading.gif" alt></p><p>直接可以看到了吧，有<code>call</code>、<code>length</code>等这些属性。</p><p>那怎么还有<code>hasOwnProperty</code>呢？上图中<code>hasOwnProperty</code>右边显示<code>Object</code>，代表<code>Function.prototype</code>继承自<code>Object.prototype</code>。有疑问可以再看看这张原型/原型链经典大图，<code>Function.prototype.__proto__</code>会指向<code>Object.prototype</code>。</p><p><img src="/images/inherit/5.jpg" srcset="/img/loading.gif" alt></p><p>最后还是那句话，当你完全搞懂上面这张图的时候，就是你掌握原型、原型链的时候了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>原型</tag>
      
      <tag>原型链</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从instanceof身上深入理解原型/原型链</title>
    <link href="/2019/09/05/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2019/09/05/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>今天将延续<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" target="_blank" rel="noopener">这篇文章</a>，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。</p><p>对于原始类型（primitive type）的值，即<code>string</code>/<code>number</code>/<code>boolean</code>，你可以通过<code>typeof</code>判断其类型，但是<code>typeof</code>在判断到合成类型（complex type）的值的时候，返回值只有<code>object</code>/<code>function</code>，你不知道它到底是一个<code>object</code>对象，还是数组，也不能判断出Object 下具体是什么细分的类型，比如 <code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code> 等。</p><p>官方对<code>instanceof</code>运算符的解释是返回一个布尔值，表示对象是否为某个构造函数的实例。比如：</p><pre><code class="javascript">function Foo() {}var f1 = new Foo();console.log(f1 instanceof Foo);  // trueconsole.log(f1 instanceof Object);  // true</code></pre><p>上面代码中，对象<code>f1</code>是构造函数<code>Foo</code>的实例，所以返回<code>true</code>，但是“f1 instanceof Object”为什么也是<code>true</code>呢？</p><p>至于为什么等会再解释，先把<code>instanceof</code>判断的规则告诉大家。根据以上代码看下图：</p><p><img src="/images/instanceof/1.jpg" srcset="/img/loading.gif" alt>  </p><p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数，左边变量暂称为A，右边变量暂称为B。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。</p><p>通俗一点来讲，<code>instanceof</code>的判断规则是：<strong><code>instanceof</code>会检查整个原型链，将沿着A的<code>__proto__</code>这条线来一直找，同时沿着B的<code>prototype</code>这条线来一直找，直到能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code></strong>。即上图中的 <code>f1</code>–&gt;<code>__proto__</code> 和 <code>Foo</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Foo)</code>为<code>true</code>。</p><p>按照以上规则，重新来看看“ f1 instanceof Object ”这句代码为什么是<code>true</code>？ 根据上图很容易就能看出来， f1–&gt;<code>__proto__</code>–&gt;<code>__proto__</code> 和<code>Object</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Object)</code>为<code>true</code>。</p><p>通过上面的规则，可以很好地解释一些比较怪异的现象，例如：</p><pre><code class="javascript">console.log(Object instanceof Function);   // trueconsole.log(Function instanceof Object);   // trueconsole.log(Function instanceof Function);   // trueconsole.log(Object instanceof Object);   // true</code></pre><p>这些就是<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" target="_blank" rel="noopener">这篇文章</a>所讲的看似很混乱的东西，现在知道为何了吧。</p><p>但还有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p><pre><code class="javascript">var obj = Object.create(null);typeof obj // &quot;object&quot;Object.create(null) instanceof Object // false</code></pre><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>后续会有专门文章介绍）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真。</p><p>说到这里，继续贴上这幅原型/原型链的经典图，是否现在看起来没那么复杂了呢。</p><p><img src="/images/inherit/5.jpg" srcset="/img/loading.gif" alt>  </p><p>如果<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" target="_blank" rel="noopener">这篇文章</a>你看的比较仔细，再结合刚才介绍的<code>instanceof</code>的概念规则，相信能看懂上面这张图的内容了。</p><p>那么问题又出来了。<code>instanceof</code>这样设计，到底有什么用？到底<code>instanceof</code>想表达什么呢？</p><p>这就要重点讲讲继承了，即<code>instanceof</code>表示的就是一种继承关系，或者原型链的结构，请看后续文章介绍。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>原型</tag>
      
      <tag>原型链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【译】12个编写干净且可扩展的JavaScript技巧</title>
    <link href="/2019/09/01/%E3%80%90%E8%AF%91%E3%80%9112%E4%B8%AA%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/"/>
    <url>/2019/09/01/%E3%80%90%E8%AF%91%E3%80%9112%E4%B8%AA%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。</p><p>现代Web应用程序严重依赖JavaScript，尤其是单页应用程序（SPA）。借助于React，AngularJS和Vue.js等新兴框架，Web应用程序主要使用JavaScript构建。</p><p>扩展这些应用程序有时候会比较棘手，通过简单的设置，您最终可能会遇到限制并迷失在混乱的海洋中。我想分享一些小技巧，这些技巧将帮助您以有效的方式编写干净的代码。</p><p>本文面向任何技能水平的JavaScript开发人员。 但是，至少具有JavaScript中级知识的开发人员将从这些技巧中获益最多。</p><blockquote><p>原文链接：<a href="https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/" target="_blank" rel="noopener">https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/</a></p></blockquote><h3 id="分隔您的代码"><a href="#分隔您的代码" class="headerlink" title="分隔您的代码"></a>分隔您的代码</h3><p>我建议保持代码库清洁和可读的最重要的事情是具有按主题分隔的特定逻辑块（通常是函数）。如果你编写一个函数，该函数应该默认只有一个目的，不应该一次做多个事情。</p><p>此外，您应避免引起副作用，这意味着在大多数情况下，您不应更改在函数外声明的任何内容。 您将数据接收到带参数的函数中；其他一切都不应该被访问。如果您希望从函数中获取某些内容，请返回新值。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当然，如果以类似的方式使用这些函数或执行类似的操作，您可以将多个函数分组到一个模块（and/or 的类中）。例如，如果要进行许多不同的计算，请将它们拆分为可以链接的独立步骤（函数）。但是，这些函数都可以在一个文件（模块）中声明。 以下是JavaScript中的示例：</p><pre><code class="javascript">function add(a, b) {    return a + b   }function subtract(a, b) {    return a - b   }module.exports = {    add,    subtract}const { add, subtract } = require(&#39;./calculations&#39;)console.log(subtract(5, add(3, 2))</code></pre><p>如果您正在编写前端JavaScript，请务必使用默认导出作为最重要的项目，并为次要项目命名导出。</p><h3 id="多个参数优先于单个对象参数"><a href="#多个参数优先于单个对象参数" class="headerlink" title="多个参数优先于单个对象参数"></a>多个参数优先于单个对象参数</h3><p>声明一个函数时，您应该总是喜欢多个参数而不是一个期望对象的参数：</p><pre><code class="javascript">// GOODfunction displayUser(firstName, lastName, age) {    console.log(`This is ${firstName} ${lastName}. She is ${age} years old.`)}// BADfunction displayUser(user) {    console.log(`This is ${user.firstName} ${user.lastName}. She is ${user.age} years old.`)}</code></pre><p>这背后的原因是，当您查看函数声明的第一行时，您能确切知道需要传递给函数的内容。</p><p>尽管函数应该受到限制 - 只做一项工作 - 但是它可能会变得更大。在函数体中扫描需要传递的变量（嵌套在对象中）将花费更多时间。有时，使用整个对象并将其传递给函数似乎更容易，但为了扩展应用程序，此设置肯定会有所帮助。</p><p>在某种程度上，声明特定参数没有意义。对我来说，它超过四个或五个功能参数。如果你的函数变大，你应该转向使用对象参数。</p><p>这里的主要原因是参数需要以特定顺序传递。 如果您有可选参数，则需要传递undefined或null。 使用对象参数，您可以简单地传递整个对象，其中顺序和未定义的值无关紧要。</p><h3 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h3><p>解构是ES6引入的一个很好的工具。它允许您从对象中获取特定字段并立即将其分配给变量。 您可以将它用于任何类型的对象或模块。</p><pre><code class="javascript">// EXAMPLE FOR MODULESconst { add, subtract } = require(&#39;./calculations&#39;)</code></pre><p>只导入您需要在文件中使用的函数而不是整个模块，然后从中访问特定的函数。 同样，当您确定您确实需要一个对象作为函数参数时，也可以使用destructuring。 这仍将为您提供函数内所需内容的概述：</p><pre><code class="javascript">function logCountry({name, code, language, currency, population, continent}) {    let msg = `The official language of ${name} `    if(code) msg += `(${code}) `    msg += `is ${language}. ${population} inhabitants pay in ${currency}.`    if(contintent) msg += ` The country is located in ${continent}`}logCountry({    name: &#39;Germany&#39;,    code: &#39;DE&#39;,    language &#39;german&#39;,    currency: &#39;Euro&#39;,    population: &#39;82 Million&#39;,})logCountry({    name: &#39;China&#39;,    language &#39;mandarin&#39;,    currency: &#39;Renminbi&#39;,    population: &#39;1.4 Billion&#39;,    continent: &#39;Asia&#39;,})</code></pre><p>正如你所看到的，我仍然知道我需要传递什么给函数 - 即使它被包装在一个对象中。要解决了解所需内容的问题，请参阅下一个提示！（顺便说一句，这也适用于React功能组件。）</p><h3 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h3><p>解构的默认值甚至基本函数参数都非常有用。首先，它们为您提供了一个可以传递给函数的值的示例。其次，您可以指出哪些值是必需的，哪些值不是。使用前面的示例，该函数的完整设置如下所示：</p><pre><code class="javascript">function logCountry({    name = &#39;United States&#39;,     code,     language = &#39;English&#39;,     currency = &#39;USD&#39;,     population = &#39;327 Million&#39;,     continent,}) {    let msg = `The official language of ${name} `    if(code) msg += `(${code}) `    msg += `is ${language}. ${population} inhabitants pay in ${currency}.`    if(contintent) msg += ` The country is located in ${continent}`}logCountry({    name: &#39;Germany&#39;,    code: &#39;DE&#39;,    language &#39;german&#39;,    currency: &#39;Euro&#39;,    population: &#39;82 Million&#39;,})logCountry({    name: &#39;China&#39;,    language &#39;mandarin&#39;,    currency: &#39;Renminbi&#39;,    population: &#39;1.4 Billion&#39;,    continent: &#39;Asia&#39;,})</code></pre><p>显然，有时您可能不想使用默认值，而是在未传递值时抛出错误。 然而，这通常是一个方便的技巧。</p><h3 id="数据稀缺性"><a href="#数据稀缺性" class="headerlink" title="数据稀缺性"></a>数据稀缺性</h3><p>前面的技巧引出了一个结论：最好不要传递您不需要的数据。同样，在设置函数时，这可能意味着更多的工作。但是，从长远来看，它肯定会为您提供更具可读性的代码库。确切地知道在特定位置使用哪些值是非常有价值的。</p><h3 id="行数和缩进限制"><a href="#行数和缩进限制" class="headerlink" title="行数和缩进限制"></a>行数和缩进限制</h3><p>我见过大文件 - 非常大的文件。实际上，超过3,000行代码。在这些文件中查找逻辑块是非常困难的。</p><p>因此，您应该将文件大小限制为一定数量的行。我倾向于将我的文件保存在100行代码之下。 有时候，很难分解文件，它们会增长到200-300行，在极少数情况下会增加到400行。</p><p>超过此临界值，意味着文件太杂乱，难以维护。随意创建新的模块和文件夹。您的项目应该看起来像一个森林，由树（模块部分）和分支（模块和模块文件组）组成。避免试图模仿阿尔卑斯山，在密闭区域堆积代码。</p><p>相比之下，你的实际文件应该看起来像Shire，这里和那里都有一些山丘（小水平的缩进），但一切都相对平坦。 尽量将压痕水平保持在四级以下。</p><p>也许为这些提示启用eslint规则是有帮助的！</p><h3 id="使用prettier"><a href="#使用prettier" class="headerlink" title="使用prettier"></a>使用prettier</h3><p>在团队中工作需要清晰的样式指南和格式。ESLint提供了一个巨大的规则集，您可以根据自己的需求进行自定义。还有 <code>eslint--fix</code>，它可以纠正一些错误，但不是全部。</p><p>相反，我建议使用<a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a>格式化代码。这样，开发人员不必担心代码格式化，而只需编写高质量的代码。 外观将一致并且格式自动化。</p><h3 id="使用有意义的变量名"><a href="#使用有意义的变量名" class="headerlink" title="使用有意义的变量名"></a>使用有意义的变量名</h3><p>理想情况下，应根据其内容命名变量。 以下是一些有助于您声明有意义的变量名称的指南。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数通常执行某种操作。为了解释这一点，人类使用动词 - 转换或显示，例如。在开头用动词命名函数是个好主意，例如<code>convertCurrency</code> 或 <code>displayUserName</code>。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>这些通常会包含一系列项目; 因此，将s附加到变量名称。 例如：</p><pre><code class="javascript">const students = [&#39;Eddie&#39;, &#39;Julia&#39;, &#39;Nathan&#39;, &#39;Theresa&#39;]</code></pre><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>简单地说就是尽量多接近于自然语言，这样好理解。你会问“这个人是教师吗？”→“是”或“否”。同样：</p><pre><code class="javascript">const isTeacher = true // OR false</code></pre><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><p><code>forEach</code>, <code>map</code>, <code>reduce</code>, <code>filter</code>等是很好的原生JavaScript函数，用于处理数组和执行某些操作。 我看到很多人只是将<code>el</code> 或 <code>element</code>作为参数传递给回调函数。 虽然这很简单快捷，但您还应根据其值来命名。 例如：</p><pre><code class="javascript">const cities = [&#39;Berlin&#39;, &#39;San Francisco&#39;, &#39;Tel Aviv&#39;, &#39;Seoul&#39;]cities.forEach(function(city) {...})</code></pre><h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>通常，您必须跟踪特定数据集和对象的ID。当嵌套id时，只需将其保留为id即可。在这里，我喜欢在将对象返回到前端之前将MongoDB <code>_id</code>映射到 <code>id</code>。从对象中提取<code>id</code>时，请预先添加对象的类型。例如：</p><pre><code class="javascript">const studentId = student.id// ORconst { id: studentId } = student // destructuring with renaming</code></pre><p>该规则的一个例外是模型中的MongoDB引用。 在这里，只需在引用的模型之后命名字段即可。 这将在填充参考文档时保持清晰：</p><pre><code class="javascript">const StudentSchema = new Schema({    teacher: {        type: Schema.Types.ObjectId,        ref: &#39;Teacher&#39;,        required: true,    },    name: String,    ...})</code></pre><h3 id="尽可能使用async-await"><a href="#尽可能使用async-await" class="headerlink" title="尽可能使用async / await"></a>尽可能使用async / await</h3><p>在可读性方面，回调是最糟糕的 - 特别是在嵌套时。Promises是一个很好的改进，但在我看来，async / await具有最好的可读性。即使对于初学者或来自其他语言的人来说，这也会有很大帮助。但是，请确保您了解其背后的概念，并且不要盲目地在任何地方使用它。</p><h3 id="模块导入顺序"><a href="#模块导入顺序" class="headerlink" title="模块导入顺序"></a>模块导入顺序</h3><p>正如我们在技巧1和2中看到的那样，将逻辑保持在正确的位置是可维护性的关键。 同样，导入不同模块的方式可以减少文件中的混淆。 我在导入不同模块时遵循一个简单的结构：</p><pre><code class="javascript">// 3rd party packagesimport React from &#39;react&#39;import styled from &#39;styled-components&#39;// Storesimport Store from &#39;~/Store// reusable componentsimport Button from &#39;~/components/Button&#39;// utility functionsimport { add, subtract } from &#39;~/utils/calculate&#39;// submodulesimport Intro from &#39;./Intro&#39;import Selector from &#39;./Selector&#39;</code></pre><p>我在这里使用了React组件作为示例，因为有更多类型的导入。 您应该能够根据您的具体用例进行调整。</p><h3 id="摆脱控制台"><a href="#摆脱控制台" class="headerlink" title="摆脱控制台"></a>摆脱控制台</h3><p><code>console.log</code> 是一种很好的调试方式 - 非常简单，快速，完成工作。显然，有更复杂的工具，但我认为每个开发人员仍然使用它。如果您忘记清理日志，您的控制台最终将陷入巨大的混乱。然后，您确实要在代码库中保留日志; 例如，警告和错误。</p><p>要解决此问题，您仍然可以使用<code>console.log</code> 进行调试，但对于持久日志，请使用<a href="https://www.npmjs.com/package/loglevel" target="_blank" rel="noopener">loglevel</a>或<a href="https://www.npmjs.com/package/winston" target="_blank" rel="noopener">winston</a>等库。此外，您可以使用ESLint警告控制台语句。这样你就可以轻松地全局查找<code>console...</code> 并删除这些语句。</p><p>遵循这些指导原则确实帮助我保持代码库的清洁和可扩展性。 你觉得还有什么提示特别有用的吗？请在评论中告诉我您在编码工作过程中值得推荐的内容，并请分享您用于帮助代码结构的任何其他提示！谢谢~</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由一段代码引发的关于Object和Function的鸡和蛋问题的思考</title>
    <link href="/2019/08/22/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2019/08/22/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。</p><h3 id="鸡和蛋问题的由来"><a href="#鸡和蛋问题的由来" class="headerlink" title="鸡和蛋问题的由来"></a>鸡和蛋问题的由来</h3><p>首先<code>Object</code>和<code>Function</code>都是构造函数，而所有的构造函数都是<code>Function</code>的实例对象。 因此<code>Object</code>是<code>Function</code>的实例对象；而<code>Function.prototype</code>是<code>Object</code>的实例对象。所以这里就引伸出了一个有意思的鸡和蛋的问题：</p><pre><code class="javascript">Object instanceof Function  // trueFunction instanceof Object  // trueObject.__proto__ === Function.prototype  // trueFunction.__proto__ === Function.prototype  // trueFunction.prototype.__proto__ === Object.prototype  // true</code></pre><p>那么<code>Object</code>和<code>Function</code>，谁是鸡谁是蛋呢？</p><p>接下来就来深入探究下上面这段代码所引起的鸡生蛋蛋生鸡问题，从下面这张原型/原型链经典图入手，在这个过程中深入了解 <code>Object.prototype</code>、<code>Function.prototype</code>、<code>function Object()</code> 、<code>function Function()</code> 之间的关系，这个过程可能有点烧脑，毕竟是JS的一大玄学嘛。</p><p><img src="/images/egg/1.jpg" srcset="/img/loading.gif" alt>  </p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>原型链的尽头就是<code>Object.prototype</code>（不考虑 <code>null</code> 的情况下）。<strong>所有对象均从</strong><code>Object.prototype</code><strong>继承toString() 等公共属性</strong>。</p><p><img src="/images/egg/2.jpg" srcset="/img/loading.gif" alt>   </p><p><code>Object.prototype</code> 表示 <code>Object</code> 的原型对象，实际上<code>Object.prototype</code> 并不是通过<code>Object</code>函数创建的，为什么呢？看如下代码：</p><pre><code class="javascript">function Dog() {  this.name = &#39;川普&#39;;}var dog = new Dog();dog.__proto__ === Dog.prototype;  // true</code></pre><p>实例对象的<code>__proto__</code>会指向构造函数的<code>prototype</code>，即<code>dog.__proto__</code>指向 <code>Dog.prototype</code>，但是<code>Object.prototype.__proto__</code>又是 <code>null</code>，所以 <code>Object.prototype</code> 并不是通过 <code>Object</code> 函数创建的，那它如何生成的？其实 <code>Object.prototype</code> 是浏览器底层根据 ECMAScript 规范创造的一个对象，所以在经典图里面只是看起来<code>Object.prototype</code> 是通过 <code>Object</code> 函数创建的，实际上并不是。</p><p><img src="/images/egg/3.jpg" srcset="/img/loading.gif" alt>  </p><h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p><code>Function.prototype</code>和<code>Function.__proto__</code>为<strong>同一对象</strong>。</p><p><img src="/images/egg/4.jpg" srcset="/img/loading.gif" alt>  </p><p>这也意味着：<strong><code>Object</code>/<code>Array</code>等等构造函数本质上和<code>Function</code>一样，均继承于<code>Function.prototype</code>，从经典图上来看都是通过<code>new Function</code>构造出来的</strong>。</p><p>当然，<code>Function.prototype</code> 对象是一个函数（对象），其<code>__proto__</code>属性指向 <code>Object.prototype</code>，即<code>Function.prototype</code>会直接继承root（<code>Object.prototype</code>）。</p><p><img src="/images/egg/5.jpg" srcset="/img/loading.gif" alt> </p><p>通过这点我们可以弄清<strong>继承的原型链</strong>：<code>Function|Object|Array...---&gt;Function.prototype---&gt;Object.prototype(root)</code>。如下图所示：</p><p><img src="/images/egg/6.jpg" srcset="/img/loading.gif" alt> </p><h3 id="function-Object"><a href="#function-Object" class="headerlink" title="function Object()"></a>function Object()</h3><p><code>Object</code> 作为构造函数时，其<code>__proto__</code>属性指向 <code>Function.prototype</code>，即:</p><pre><code class="javascript">Object.__proto__ === Function.prototype  // true</code></pre><p>从经典图来看：</p><p><img src="/images/egg/7.jpg" srcset="/img/loading.gif" alt>   </p><p>使用 <code>new Object()</code> 创建实例对象o1时，实例对象o1的 <code>__proto__</code>属性指向构造函数的 <code>prototype</code> 属性，对应上图就是 <code>Object.prototype</code>，即<code>o1.__proto__ === Object.prototype</code>结果为<code>true</code>。</p><p><code>Function.prototype</code>指向的对象，它的<code>__proto__</code>会指向<code>Object.prototype</code>，因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。</p><h3 id="function-Function"><a href="#function-Function" class="headerlink" title="function Function()"></a>function Function()</h3><p><code>Function</code>也是一个函数对象，也有<code>__proto__</code>属性，既然是函数，那么它一定是被<code>Function</code>创建，所以<code>Function</code>是被自身创建的，所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>：</p><pre><code class="javascript">Function.__proto__ === Function.prototype  // true</code></pre><p><img src="/images/egg/8.jpg" srcset="/img/loading.gif" alt>  </p><p>到这里就有点烧脑了吧，我们再看下鸡生蛋蛋生鸡问题。</p><h3 id="Function-amp-Object-鸡和蛋问题"><a href="#Function-amp-Object-鸡和蛋问题" class="headerlink" title="Function &amp; Object 鸡和蛋问题"></a>Function &amp; Object 鸡和蛋问题</h3><p>由上面可知，<code>Object</code>构造函数继承了<code>Function.prototype</code>，同时<code>Function</code>构造函数继承了<code>Object.prototype</code>，这里就产生了<strong>鸡和蛋</strong>的问题。为什么会出现这种问题呢？必须首先更深入一层去理解<code>Function.prototype</code>这个对象，因为它是导致<code>Function instanceof Object</code>和<code>Object instanceof Function</code>都为<code>true</code>的原因。</p><pre><code class="javascript">// Object instanceof Function     即Object.__proto__ === Function.prototype   // true// Function instanceof Object     即Function.__proto__.__proto__ === Object.prototype   // true// Object instanceof Object         即             Object.__proto__.__proto__ === Object.prototype   // true// Function instanceof Function 即    Function.__proto__ === Function.prototype   // true</code></pre><p>根据JS规范，<code>Function.prototype</code>又是个不同于一般函数（对象）的函数（对象），其中：</p><ol><li><code>Function.prototype</code>像普通函数一样可以调用，但总是返回<code>undefined</code>。</li><li>普通函数实际上是<code>Function</code>的实例，即普通函数继承于<code>Function.prototype</code>。即<code>func.__proto__ === Function.prototype</code>。</li><li><code>Function.prototype</code>继承于<code>Object.prototype</code>，并且没有<code>prototype</code>这个属性。</li><li>所以，<code>Function.prototype</code>其实是个另类的函数，可以独立于/先于<code>Function</code>产生。</li></ol><p>而<code>Object</code>本身是个（构造）函数，是<code>Function</code>的实例，即<code>Object.__proto__</code>就是<code>Function.prototype</code>。</p><p><strong>总结：先有<code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code>继承<code>Object.prototype</code>而产生，最后，<code>Function</code>和<code>Object</code>和其它构造函数继承<code>Function.prototype</code>而产生</strong>。</p><p>看到这里估计也都看烦了，是不是还是有点混乱呀？乱也很正常。那这篇文章就先让它乱着，下一篇我们将请另一个老朋友来帮忙，把它彻底理清楚，这位老朋友就是——<code>instanceof</code>，那就且听请下回分解咯。</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从原生JS实现jQuery的一个API中体会其设计思想</title>
    <link href="/2019/08/16/%E4%BB%8E%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84%E4%B8%80%E4%B8%AAAPI%E4%B8%AD%E4%BD%93%E4%BC%9A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2019/08/16/%E4%BB%8E%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84%E4%B8%80%E4%B8%AAAPI%E4%B8%AD%E4%BD%93%E4%BC%9A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？读源代码又太繁琐，所以这里利用原生JS来实现jQuery中的addClass这个API，通过实现此过程来体会jQuery的设计思想，力求简单易懂。</p><h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><pre><code class="javascript">function addClass(classes){} //可将所有输入的标签的class添加一个类</code></pre><h3 id="实现这个函数"><a href="#实现这个函数" class="headerlink" title="实现这个函数"></a>实现这个函数</h3><p>函数<code>addClass()</code>是输入一个类名，给选中的所有标签添加一个类，所以要用到<code>classList.add()</code>，具体实现如下:</p><pre><code class="javascript">function addClass(node, classes) {  var allTag = document.querySelectorAll(node)  for (let i = 0; i &lt; allTag.length; i++) {    allTag[i].classList.add(classes)  }}</code></pre><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在全局变量中创建一个对象，用来储存封装后的函数，这就是命名空间（名字前面统一加一个前缀）</p><pre><code class="javascript">window.jQuery = {}jQuery.addClass = addClassjQuery.addClass(&#39;div&#39;, &#39;red&#39;)</code></pre><p>整理之后</p><pre><code class="javascript">window.jQuery = {}jQuery.addClass = function(node, classes) {  var allTag = document.querySelectorAll(node)  for (let i = 0; i &lt; allTag.length; i++) {    allTag[i].classList.add(classes)  }}jQuery.addClass(&#39;div&#39;, &#39;red&#39;)</code></pre><h3 id="将node放到前面"><a href="#将node放到前面" class="headerlink" title="将node放到前面"></a>将node放到前面</h3><pre><code class="javascript">node.addClass(classes)</code></pre><p>方法一：扩展 Node 接口，直接在 <code>Node.prototype</code> 上加函数</p><pre><code class="javascript">Node.prototype.addClass = function(){   ...}</code></pre><p>方法二：新的接口 <code>BetterNode</code></p><pre><code class="javascript">window.jQuery = function(node) {  return {    element: node,    addClass: function(classes) {      var allTag = document.querySelectorAll(node)      for (let i = 0; i &lt; allTag.length; i++) {        allTag[i].classList.add(classes)      }    }  }}let node2 = jQuery(&#39;div&#39;)node2.addClass(&#39;red&#39;)</code></pre><p>第二种叫做「无侵入」。</p><h3 id="进一步完善"><a href="#进一步完善" class="headerlink" title="进一步完善"></a>进一步完善</h3><p>给个缩写并且使其可以是节点或者选择器</p><pre><code class="javascript">window.jQuery = function(nodeOrSelector){  let nodes = {}  if(typeof nodeOrSelector === &#39;string&#39;){    let temp = document.querySelectorAll(nodeOrSelector)    for(let i=0;i&lt;temp.length;i++){      nodes[i]=temp[i]    }    nodes.length = temp.length  }else if(nodeOrSelector instanceof Node){    nodes = {      0:nodeOrSelector,      length:1    }  }  nodes.addClass = function(classes){    for(let i=0;i&lt;nodes.length;i++){      nodes[i].classList.add(classes)    }  }  return nodes}window.$ = jQueryvar $div = $(&#39;div&#39;)$div.addClass(&#39;red&#39;) // 可将所有 div 的 class 添加一个 red</code></pre><h3 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h3><p>按照jQuery的设计思路封装一个ajax函数</p><pre><code class="javascript">window.jQuery.ajax = function(url, method, body, success, fail) {    let request = XMLHttpResquest()    request.open(method, url)    request.onreadystatechange = () =&gt; {        if (request.readyState === 4) {            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {                success.call(undefined, request.responseText)            } else if (request.status &gt;= 400) {                fail.call(undefined, request)            }        }    }    request.send(body)}</code></pre><p>升级改进一下满足promise规则</p><pre><code class="javascript">window.jQuery.ajax = function({    url,    method,    body,    headers}) {    return new Promise(function(resolve, reject) {        let request = XMLHttpResquest()        request.open(method, url)        for (let key in headers) {            let value = headers[key]            request.setRequestHeader(key, value)        }        request.onreadystatechange = () =&gt; {            if (request.readyState === 4) {                if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {                    success.call(undefined, request.responseText)                } else if (request.status &gt;= 400) {                    fail.call(undefined, request)                }            }        }        request.send(body)    })}</code></pre><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM Node 的建立、删除与修改</title>
    <link href="/2019/08/11/DOM%20Node%20%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9/"/>
    <url>/2019/08/11/DOM%20Node%20%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<p>在之前的介绍中，我们已经理解了DOM Node的类型、以及节点之间的查找与关系。那么在今天的介绍里我将继续来说明，如何通过DOM API来建立新的节点、修改以及删除节点。</p><h3 id="DOM-节点的新增"><a href="#DOM-节点的新增" class="headerlink" title="DOM 节点的新增"></a>DOM 节点的新增</h3><h4 id="document-createElement-tagName"><a href="#document-createElement-tagName" class="headerlink" title="document.createElement(tagName)"></a>document.createElement(tagName)</h4><p>通过<code>document.createElement()</code>可以建立一个新的元素：</p><pre><code class="javascript">var newDiv = document.createElement(&#39;div&#39;);</code></pre><p>在建立新的<code>div</code>元素<code>newDiv</code>后，这时候我们在浏览器上还看不到它，直到通过<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>等方法将新元素加入至指定的位置之后才会显示。</p><p>新建立的<code>newDiv</code>我们也可以同时对它指定属性，如：</p><pre><code class="javascript">newDiv.id = &quot;myNewDiv&quot;; newDiv.className = &quot;box&quot;;</code></pre><h4 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h4><p>之前曾介绍过，除了HTML元素节点外，还有文字节点，那么<code>document.createTextNode()</code>就是用来建立文字节点的方法。</p><p>用法很简单，直接在<code>document.createTextNode()</code>加入字符串即可。跟<code>createElement</code>一样的是，新增的TextNode在被加入至某个节点前，我们是看不到它的。  </p><pre><code class="javascript">var newDiv = document.createElement(&#39;div&#39;);// 建立 textNode 文字节点var textNode = document.createTextNode(&quot;Hello world!&quot;);// 通过 newDiv.appendChild 将 textNode 加入至 newDiv newDiv.appendChild(textNode);</code></pre><h4 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h4><p>在DOM规范的所有节点之中，<code>DocumentFragment</code>算是最特殊的一种，它是一种没有父层节点的<strong>最小化文件对象</strong>。可以把它看作是一个轻量化的<code>Document</code>，用如同标准文件一般的方式来保存片段的文件结构。</p><p>例如，一开始我们有一个HTML 的容器元素：</p><pre><code class="html">&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;</code></pre><p>接着我们通过<code>document.createDocumentFragment()</code>来建立<code>DocumentFragment</code>：</p><pre><code class="javascript">// 取得外层容器 myListvar ul = document.getElementById(&quot;myList&quot;);// 建立一个 DocumentFragment，可以把它看作一个虚拟的容器var fragment = document.createDocumentFragment();for (var i = 0; i &lt; 3; i++){  // 生成新的 li，加入文字后置入 fragment 中。  let li = document.createElement(&quot;li&quot;);  li.appendChild(document.createTextNode(&quot;Item &quot; + (i+1)));  fragment.appendChild(li);}// 最后将组合完成的 fragment 放进 ul 容器ul.appendChild(fragment);</code></pre><p>通过操作<code>DocumentFragment</code>与直接操作DOM最关键的区别在于<code>DocumentFragment</code>不是真实的DOM结构，所以说<code>DocumentFragment</code>的变动并不会影响目前的网页文件，也不会导致回流（reflow）或引起任何影响效果的情况发生。</p><h4 id="document-write"><a href="#document-write" class="headerlink" title="document.write()"></a>document.write()</h4><p><code>document</code>对象要将某内容写入网页也可以用<code>write()</code>方法，当浏览器读取页面，解析到<code>document.write()</code>的时候就会停下来，并且将内容输出，且不只是单纯的字符串，也可以是HTML的标签。</p><p>我们只要将对应的HTML 字符串传入：</p><pre><code class="javascript">document.write(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);</code></pre><p>甚至，如果要新增一个<code>&lt;script&gt;</code>标签，并指定外部js资源也是可以的，但要注意的是：</p><pre><code class="javascript">// 写成这样， &lt;/script&gt;会变成目前 script 块的结束，导致错误 document.write(&quot;&lt;script type=\&quot;text\javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; + &quot;&lt;/script&gt;&quot;);// 为了避免这种问题，要将结尾的标签这种写法 &lt;\/script&gt; 就 ok 了 document.write(&quot;&lt;script type=\&quot;text\javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; + &quot;&lt;\/script&gt;&quot;);</code></pre><p>另外，需要特别注意的是，当网页已经读取完成后才执行<code>document.write()</code>，则里面的内容会完全覆盖掉目前的网页：</p><pre><code class="javascript">window.onload = function(){     document.write(&quot;Hello world!&quot;); };</code></pre><p>上面例子的<code>window.onload</code>表示网页已载入完成，此时无论网页原本有什么内容，都会被<code>&quot;Hello world!&quot;</code>所覆盖。  </p><h3 id="DOM-节点的修改与删除"><a href="#DOM-节点的修改与删除" class="headerlink" title="DOM 节点的修改与删除"></a>DOM 节点的修改与删除</h3><p>上面介绍了很多建立DOM节点的方法，除了最后的<code>document.write</code>之外，其他都只是单纯建立节点，并未输出至网页上。</p><p>那么，接下来要介绍的几个方法，则说明要如何将刚刚建立好的DOM 节点，置入到我们所需要指定的位置上。</p><h4 id="NODE-appendChild-childNode"><a href="#NODE-appendChild-childNode" class="headerlink" title="NODE.appendChild(childNode)"></a>NODE.appendChild(childNode)</h4><p><img src="/images/domnode/1.jpg" srcset="/img/loading.gif" alt>  </p><p>通过<code>appendChild()</code>方法，可以将指定的<code>childNode</code>节点，加入到<code>Node</code>父容器节点的末端：</p><pre><code class="html">&lt;ul id=&quot;myList&quot;&gt;  &lt;li&gt;Item1&lt;/li&gt;  &lt;li&gt;Item2&lt;/li&gt;  &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  // 取得容器  var myList = document.getElementById(&#39;myList&#39;);  // 建立新的 &lt;li&gt; 元素  var newList = document.createElement(&#39;li&#39;);  // 建立 textNode 文字节点  var textNode = document.createTextNode(&quot;Hello world!&quot;);  // 通过 appendChild 将 textNode 加入至 newList  newList.appendChild(textNode);  // 通过 appendChild 将 newList 加入至 myList  myList.appendChild(newList);&lt;/script&gt;</code></pre><h4 id="NODE-insertBefore-newNode-refNode"><a href="#NODE-insertBefore-newNode-refNode" class="headerlink" title="NODE.insertBefore(newNode, refNode)"></a>NODE.insertBefore(newNode, refNode)</h4><p><img src="/images/domnode/2.jpg" srcset="/img/loading.gif" alt>  </p><p><code>insertBefore()</code>方法，则是将新节点<code>newNode</code>插入至指定的<code>refNode</code>节点的前面：</p><pre><code class="html">&lt;ul id=&quot;myList&quot;&gt;  &lt;li&gt;Item1&lt;/li&gt;  &lt;li&gt;Item2&lt;/li&gt;  &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  // 取得容器  var myList  = document.getElementById(&#39;myList&#39;);  // 取得 &quot;&lt;li&gt;Item2&lt;/li&gt;&quot; 的元素  var refNode = document.querySelectorAll(&#39;li&#39;)[1];  // 建立 li 元素节点  var newNode = document.createElement(&#39;li&#39;);  // 建立 textNode 文字节点  var textNode = document.createTextNode(&quot;Hello world!&quot;);  newNode.appendChild(textNode);  // 将新节点 newNode 插入 refNode 的前方  myList.insertBefore(newNode, refNode);&lt;/script&gt;</code></pre><h4 id="NODE-replaceChild-newChildNode-oldChildNode"><a href="#NODE-replaceChild-newChildNode-oldChildNode" class="headerlink" title="NODE.replaceChild(newChildNode, oldChildNode)"></a>NODE.replaceChild(newChildNode, oldChildNode)</h4><p><img src="/images/domnode/3.jpg" srcset="/img/loading.gif" alt>  </p><p><code>replaceChild()</code>方法，则是将原本的<code>oldNode</code>替换成指定的<code>newNode</code>。</p><pre><code class="html">&lt;ul id=&quot;myList&quot;&gt;  &lt;li&gt;Item1&lt;/li&gt;  &lt;li&gt;Item2&lt;/li&gt;  &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  // 取得容器  var myList  = document.getElementById(&#39;myList&#39;);  // 取得 &quot;&lt;li&gt;Item2&lt;/li&gt;&quot; 的元素  var oldNode = document.querySelectorAll(&#39;li&#39;)[1];  // 建立 li 元素节点  var newNode = document.createElement(&#39;li&#39;);  // 建立 textNode 文字节点  var textNode = document.createTextNode(&quot;Hello world!&quot;);  newNode.appendChild(textNode);  // 将原有的 oldNode 替换成新节点 newNode  myList.replaceChild(newNode, oldNode);&lt;script&gt;</code></pre><h4 id="NODE-removeChild-childNode"><a href="#NODE-removeChild-childNode" class="headerlink" title="NODE.removeChild(childNode)"></a>NODE.removeChild(childNode)</h4><p><img src="/images/domnode/4.jpg" srcset="/img/loading.gif" alt>  </p><p><code>removeChild()</code>方法，则是将指定的<code>childNode</code>子节点移除。</p><pre><code class="html">&lt;ul id=&quot;myList&quot;&gt;  &lt;li&gt;Item1&lt;/li&gt;  &lt;li&gt;Item2&lt;/li&gt;  &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  // 取得容器  var myList  = document.getElementById(&#39;myList&#39;);  // 取得 &quot;&lt;li&gt;Item2&lt;/li&gt;&quot; 的元素  var removeNode = document.querySelectorAll(&#39;li&#39;)[1];  // 将 myList 下的 removeNode 节点移除  myList.removeChild(removeNode);&lt;/script&gt;</code></pre><p>相信看完今天的分享，已经有能力可以通过DOM 提供的API 来进行节点的新增、修改以及删除了吧。</p><p>大家也许会发现，无论要对网页元素做出什么样的操作，我们都会基于某个节点出发对吧？</p><p>刚好呼应阿基米德的一句众所周知的名言：</p><blockquote><p>「给我一个支点，我就能撬动整个地球。」</p></blockquote><p>那么有了DOM API 的帮助后， JavaScript 也可以说：</p><blockquote><p>「给我一个节点，我就能建立整个网页世界。」</p></blockquote><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>DOM</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过DOM API 查找节点</title>
    <link href="/2019/08/08/%E9%80%9A%E8%BF%87DOM%20API%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9/"/>
    <url>/2019/08/08/%E9%80%9A%E8%BF%87DOM%20API%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>在上一篇的分享当中，我们简单介绍了BOM 与DOM，也了解到JavaScript 是怎么通过它们提供的方法来与浏览器进行沟通。</p><p>当一个网页被载入到浏览器时，浏览器会首先分析这个HTML 文档，然后会依照这份HTML 的内容解析成DOM (Document Object Model，即文件对象模型)。</p><p>而DOM 是W3C 制定的一个规范，它是独立于平台与语言的标准。换言之，只要遵守这样的规范，不管是什么平台或者是什么语言开发，都可以通过DOM 提供的API 来操作DOM 的内容、结构与样式。</p><p>所以说，DOM 是网页的根本，懂得<strong>控制DOM就可以控制整个网页，做出良好的互动体验</strong>。</p><p>那么在今天的分享中，我们就继续来介绍DOM API 查找节点的方法吧。</p><h3 id="前言-script标签放哪里有区别吗？"><a href="#前言-script标签放哪里有区别吗？" class="headerlink" title="前言:script标签放哪里有区别吗？"></a>前言:script标签放哪里有区别吗？</h3><p>针对<code>&lt;script&gt;</code>标签放哪里，这个题目其实没有标准答案，一般你会看到有两种版本：</p><ul><li>放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间</li><li>放在<code>&lt;/body&gt;</code>之前</li></ul><p>还有人会说为什么放在<code>&lt;head&gt; ... &lt;/head&gt;</code>里面的JavaScript没有作用？我觉得这说的有出入，这里我们简单来讲一下问题所在。</p><p>那么我们来试试上一篇介绍过的，先以<code>document.querySelector</code>取得<code>id=&quot;hello&quot;</code>的节点，然后通过<code>textContent</code>来修改内容。</p><p>先来试试把<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>之前。在jsbin里面马上执行看看，看起来似乎很ok呢！</p><p><img src="/images/domapi/1.jpg" srcset="/img/loading.gif" alt>    </p><p>接着，我们试着把<code>&lt;script&gt;</code>标签移到<code>&lt;head&gt; ... &lt;/head&gt;</code>之间：</p><p><img src="/images/domapi/2.jpg" srcset="/img/loading.gif" alt>    </p><p>咦？怎么什么都没有呢？而且也没有错误信息，JavaScript真的如大家说的一样，很垃圾吗？</p><p><img src="/images/domapi/3.jpg" srcset="/img/loading.gif" alt>   </p><p>冷静一下，容我解释一下。</p><p>前面说过，当一个网页被载入到浏览器时，浏览器会先分析这个HTML 文档，由上而下依序来读取解析：</p><p><img src="/images/domapi/4.jpg" srcset="/img/loading.gif" alt>   </p><p>所以上面jsbin例子中，当浏览器在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间遇到<code>&lt;script&gt;</code>标签时，就会暂停解析网页，并且<strong>立即</strong>执行<code>&lt;script&gt;</code>里的内容，直到script执行完毕后再继续解析网页。</p><p>当<code>&lt;head&gt; ... &lt;/head&gt;</code>里的<code>&lt;script&gt;</code>想要尝试去寻找<code>&lt;div id=&quot;hello&quot;&gt;</code>这个标签，但因为还没解析到网页本体，所以也无从取得。</p><p>不是浏览器坏掉，也不是JavaScript太渣，而是因为我们<strong>不理解浏览器执行的原理所造成的误会</strong>。</p><p>这里是浏览器加载一个有 <code>&lt;script&gt;</code> 标签的网站所发生的事情:</p><ol><li>拉取 HTML 页面</li><li>开始解析 HTML</li><li>解析到 <code>&lt;script&gt;</code> 标签之后准备获取 script 文件.</li><li>浏览器获取script文件。同时，html 解析中断并且<strong>阻断</strong>页面上其他html的解析。</li><li>一段时间后，script下载完成并且<strong>执行</strong>。</li><li>继续解析HTML文档的其他部分（解析script之后的html代码）</li></ol><p>第4步导致了很不好的用户体验，直到script文件全部下载完成之前HTML都不能得到解析。</p><p>那么，当我们把<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>结束之前，由于DOM已经解析完成，所以<code>document.querySelector</code>就可以顺利取得<code>id=&quot;hello&quot;</code>的节点，并且把<code>&#39;HELLO&#39;</code>的字串放在网页里啦！</p><p>这样说起来，<code>&lt;script&gt;</code>标签是不是就不适合放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间呢？</p><p>也不能这么说，这点认真要讲的话之后或许可以用一整篇来说明这个。</p><h3 id="DOM-节点的选取"><a href="#DOM-节点的选取" class="headerlink" title="DOM 节点的选取"></a>DOM 节点的选取</h3><p><img src="/images/domapi/5.jpg" srcset="/img/loading.gif" alt>  </p><p>上一篇文章说过，<code>document对象</code>是DOM tree的根节点，所以当我们要存取HTML时，都从<code>document</code>对象开始。而DOM的节点类型除了<strong>HTML元素节点</strong>(element nodes)外，还有<strong>文字节点</strong>(text nodes)、<strong>注释节点</strong>(comment nodes)等。</p><p>而常见的DOM 选取方法有下列这些：</p><pre><code class="javascript">// 根据传入的值，找到 DOM 中 id 为 &#39;xxx&#39; 的元素。document.getElementById(&#39;xxx&#39;);// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)document.getElementsByTagName(&#39;xxx&#39;);// 针对给定的 class 名称，返回所有符合条件的节点集合document.getElementsByClassName(&#39;xxx&#39;);// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的节点集合document.querySelector(&#39;xxx&#39;); document.querySelectorAll(&#39;xxx&#39;);</code></pre><h3 id="DOM-节点的类型"><a href="#DOM-节点的类型" class="headerlink" title="DOM 节点的类型"></a>DOM 节点的类型</h3><p>DOM 常用的节点类型有下面几种：</p><p><img src="/images/domapi/6.jpg" srcset="/img/loading.gif" alt>  </p><p>可以通过节点类型常数或是对应数值来判断：</p><pre><code class="javascript">document.nodeType === Node.DOCUMENT_NODE;   //truedocument.nodeType === 9;   //true</code></pre><p>其他不常用或是已经废弃的部分可以参考：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType" target="_blank" rel="noopener">MDN Node.nodeType</a>一节。</p><h3 id="DOM-节点间的查找遍历-Traversing"><a href="#DOM-节点间的查找遍历-Traversing" class="headerlink" title="DOM 节点间的查找遍历(Traversing)"></a>DOM 节点间的查找遍历(Traversing)</h3><p>由于DOM 节点有分层的概念，于是节点与节点之间的关系，我们大致上可以分成以下两种：</p><ul><li><strong>父子关系</strong>：除了<code>document</code>之外，每一个节点都会有个上层的节点，我们通常称之为「父节点」 (Parent node)，而相对地，从属于自己下层的节点，就会称为「子节点」 (Child node)。</li><li><strong>兄弟关系</strong>：有同一个「父节点」的节点，那么他们彼此之间就是「兄弟节点」(Siblings node)。</li></ul><p>而隔层的节点基本上没有直接关系。</p><p><img src="/images/domapi/7.jpg" srcset="/img/loading.gif" alt>  </p><p>上图中水平方向的邻层节点为父子关系，垂直方向的同层节点为兄弟关系。</p><p><strong>Node.childNodes</strong></p><p>所有的DOM节点对象都有<code>childNodes</code>属性，且此种属性无法修改。  </p><p>我们可以通过<code>Node.hasChildNodes()</code>来检查某个DOM节点是否有子节点。</p><pre><code class="javascript">var node = document.querySelector(&#39;#hello&#39;);// 如果 node 內有子元素if( node.hasChildNodes() ) {    // 可以通过 node.childNodes[n] (n 为数字索引) 取得对应的节点    // 注意，NodeList 对象內容为即时更新的集合    for (var i = 0; i &lt; node.childNodes[i].length; i++) {       // ...         }; }</code></pre><p><code>Node.childNodes</code>返回的可能会有这几种：</p><ul><li>HTML 元素节点(element nodes)</li><li>文字节点(text nodes)，包含空格</li><li>注释节点(comment nodes)</li></ul><p><strong>Node.firstChild</strong></p><p><code>Node.firstChild</code>可以取得<code>Node</code>节点的<strong>第一个</strong>子节点，如果没有子节点则返回<code>null</code>。</p><p>要注意的是，子节点包括空白节点，如下面例子：</p><pre><code class="html">&lt;p&gt;  &lt;span&gt;span 1&lt;/span&gt;  &lt;span&gt;span 2&lt;/span&gt;  &lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt;  var p = document.querySelector(&#39;p&#39;);      // tagName 属性可以取得 node 的标签名称  console.log(p.firstChild.tagName);      // undefined&lt;/script&gt;</code></pre><p>因为取得的是<code>&lt;p&gt;</code>与第一个<code>&lt;span&gt;</code>中间的换行字元，所以<code>p.firstChild.tagName</code>会得到<code>undefined</code>。所以改成这样：</p><pre><code class="html">&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt;  var p = document.querySelector(&#39;p&#39;);      // tagName 属性可以取得 node 的标签名称  console.log(p.firstChild.tagName);      // &quot;SPAN&quot;&lt;/script&gt;</code></pre><p>把中间的换行与空白移除，就会得到预期中的<code>&quot;SPAN&quot;</code>了。</p><p><strong>Node.lastChild</strong></p><p><code>Node.lastChild</code>可以取得<code>Node</code>节点的最后一个子节点，如果没有子节点则返回<code>null</code>。</p><p>与<code>Node.firstChild</code>一样的是，子节点也包括空白节点，所以像这样：</p><pre><code class="html">&lt;p&gt;  &lt;span&gt;span 1&lt;/span&gt;  &lt;span&gt;span 2&lt;/span&gt;  &lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt;  var p = document.querySelector(&#39;p&#39;);      // textContent 属性可以取得节点内的文字内容  console.log(p.lastChild.textContent);      // &quot;&quot; (换行字元)&lt;/script&gt;</code></pre><p>得到的会是一个换行字元的空字符串。</p><p>移除节点之间多余的空白后：</p><pre><code class="html">&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt;  var p = document.querySelector(&#39;p&#39;);      // textContent 属性可以取得节点内的文字内容  console.log(p.lastChild.textContent);      // &quot;span 3&quot;&lt;/script&gt;</code></pre><p>输出的就会是正确的”span 3” 啦。</p><p><strong>Node.parentNode</strong></p><p>那么相较于Child系列，<code>parentNode</code>就单纯一些。</p><p>通过<code>Node.parentNode</code>可以用来取得父元素，返回值可能会是一个元素节点(Element node)、根节点(Document node)或DocumentFragment节点。</p><pre><code class="html">&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt;  var el = document.querySelector(&#39;span&#39;);     console.log( el.parentNode.nodeName );    // &quot;P&quot;&lt;/script&gt;</code></pre><p><strong>Node.previousSibling</strong></p><p>看完了DOM父与子之后，接着来看看兄弟节点。</p><p>通过<code>Node.previousSibling</code>可以取得同层之间的前一个节点，如果node已经是第一个节点且前面无节点，则返回<code>null</code>。</p><pre><code class="html">&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt;  var el = document.querySelector(&#39;span&#39;);     console.log( el.previousSibling );    // null  // document.querySelectorAll 会取得所有符合条件的集合，  // 而 document.querySelectorAll(&#39;span&#39;)[2] 指的是「第三个」符合条件的元素。  var el2 = document.querySelectorAll(&#39;span&#39;)[2];     console.log( el2.previousSibling.textContent );    // &quot;span 2&quot;&lt;/script&gt;</code></pre><p><strong>Node.nextSibling</strong></p><p>与<code>Node.previousSibling</code>类似，通过<code>Node.nextSibling</code>可以取得同层之间的下一个节点，如果node已经是最后一个节点，则返回<code>null</code>。</p><pre><code class="html">&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt;  // document.querySelector 会取得第一个符合条件的元素  var el = document.querySelector(&#39;span&#39;);  console.log( el.nextSibling.textContent );    // &quot;span 2&quot;&lt;/script&gt;</code></pre><p><strong>document.getElementsBy*与document.querySelector/ document.querySelectorAll的差异</strong></p><p>今天分享了很多关于DOM的选取以及查找遍历的方式，其中，像是<code>document.getElementById</code>以及<code>document.querySelector</code>因为取得的一定只会有一个元素/节点，所以不会有<code>index</code>与<code>length</code>属性。</p><p>而<code>document.getElementsBy**</code>(注意，这里有个s)以及<code>document.querySelectorAll</code>则分别返回HTMLCollection与NodeList。</p><p>这两者其实是有点差别的，HTMLCollection只收集HTML element 节点，而NodeList除了HTML element 节点，也包含文字节点、属性节点等。当然两者也有类似的地方，虽然不能使用数组的method，但这两种都可以用数组索引的方式来存取内容，也就是伪数组。</p><p>另一个需要注意的地方是，HTMLCollection/NodeList在大部分情况下是<strong>即时更新</strong>的，但通过<code>document.querySelector</code>/<code>document.querySelectorAll</code>取得的NodeList是<strong>静态</strong>的。</p><p>啥意思呢？举个例子：</p><pre><code class="html">&lt;div id=&quot;outer&quot;&gt;  &lt;div id=&quot;inner&quot;&gt;inner&lt;/div&gt;&lt;/div&gt;&lt;script&gt;  // &lt;div id=&quot;outer&quot;&gt;  var outerDiv = document.getElementById(&#39;outer&#39;);      // 所有的 &lt;div&gt; 标签  var allDivs = document.getElementsByTagName(&#39;div&#39;);      console.log(allDivs.length);    // 2  // 清空 &lt;div id=&quot;outer&quot;&gt; 下的节点     outerDiv.innerHTML = &#39;&#39;;      // 因为清空了&lt;div id=&quot;outer&quot;&gt; 下的节点，所以只剩下 outer  console.log(allDivs.length);    // 1&lt;/script&gt;</code></pre><p>如果改成<code>document.querySelector</code>的写法：</p><pre><code class="html">&lt;div id=&quot;outer&quot;&gt;  &lt;div id=&quot;inner&quot;&gt;inner&lt;/div&gt;&lt;/div&gt;&lt;script&gt;  // &lt;div id=&quot;outer&quot;&gt;  var outerDiv = document.getElementById(&#39;outer&#39;);      // 所有的 &lt;div&gt; 标签  var allDivs = document.querySelectorAll(&#39;div&#39;);      console.log(allDivs.length);    // 2  // 清空 &lt;div id=&quot;outer&quot;&gt; 下的节点     outerDiv.innerHTML = &#39;&#39;;      // document.querySelector 返回的是静态的 NodeList，不受 outerDiv 更新影响  console.log(allDivs.length);    // 2&lt;/script&gt;</code></pre><p>那么以上就是今天所要介绍的内容啦。</p><p>在后续的文章会再继续说明DOM API新增/删除/修改节点的部分，欢迎持续关注。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>DOM</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈浏览器里的JavaScript</title>
    <link href="/2019/08/01/%E8%81%8A%E4%B8%80%E8%81%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%9A%84JavaScript/"/>
    <url>/2019/08/01/%E8%81%8A%E4%B8%80%E8%81%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%9A%84JavaScript/</url>
    
    <content type="html"><![CDATA[<p>在许多的网页前端教学或是文章书籍当中，你可能常常听到这样的说法：「HTML、CSS 与JavaScript 是网页前端三大要素」，其中： </p><ul><li>HTML 负责资料与结构</li><li>CSS 负责样式与呈现</li><li>JavaScript 负责行为与互动</li></ul><p><img src="/images/dom/1.jpg" srcset="/img/loading.gif" alt>   </p><p>那么，如果你跟我在学JavaScript的时候也有一样的疑问：<strong>变量、类型、对象、流程控制、函数</strong>…表面上看似基础都学会了，但…  </p><p><strong>我还是不知道怎么通过JavaScript在网页上输出”Hello World!”啊！</strong>   </p><p><img src="/images/dom/2.png" srcset="/img/loading.gif" alt>   </p><p>那么相信看完今天的分享，我保证你一定可以通过JavaScript 在网页上输出”Hello World!” (嘻嘻)  </p><h3 id="浏览器里的JavaScript"><a href="#浏览器里的JavaScript" class="headerlink" title="浏览器里的JavaScript"></a>浏览器里的JavaScript</h3><p>严格来说，JavaScript (或者说ECMAScript 标准) 并没有提供网页的操作方法。  </p><p>事实上，前端开发者在网页的操作方法都是由JavaScript的执行平台，也就是<strong>浏览器</strong>提供的。这些操作方法基本上会分别由这两种对象所拥有：BOM与DOM。  </p><p>所以广泛来说，在浏览器上的JavaScript 实际上包含了以下三部分：  </p><ul><li><strong>JavaScript核心</strong> (以ECMAScript标准为基础)</li><li><strong>BOM</strong> (Browser Object Model，浏览器对象模型)</li><li><strong>DOM</strong> (Document Object Model，文件对象模型)  </li></ul><p>由于BOM与DOM是由浏览器执行环境所提供；所以换句话说，在node环境下的JavaScript就不会有这两个部分。  </p><p>前端开发者就是可以通过JavaScript 去调用BOM 与DOM 提供的API，进一步通过它们去控制浏览器的行为与网页的内容。  </p><p>那么接下来就来具体介绍一下BOM与DOM吧。  </p><h3 id="BOM-是什么"><a href="#BOM-是什么" class="headerlink" title="BOM 是什么?"></a>BOM 是什么?</h3><p><strong>BOM</strong>(<strong>Browser Object Model</strong>，浏览器对象模型)，是浏览器所有功能的核心，与网页的内容无关。  </p><p>在早期没有制定标准规范的时候，各家浏览器厂商几乎在自家浏览器上都有各自的功能，非常混乱。直到后来W3C 把各家浏览器都有的部分，以及确定已经(或未来会) 加入的功能，统一集合起来纳入了HTML5 的标准中，这也就是我们现在看到的BOM API。  </p><p>BOM 有时也有人非正式地称它为Level 0 DOM。因为它在DOM level 1 标准前就已存在，而不是真的有文件去规范这些，所以Level 0 DOM与BOM两者实际上指的是同一个东西。</p><h3 id="BOM的核心window对象"><a href="#BOM的核心window对象" class="headerlink" title="BOM的核心window对象"></a>BOM的核心window对象</h3><p><img src="/images/dom/3.jpg" srcset="/img/loading.gif" alt>   </p><p>从上图可以看出BOM的核心是<code>window</code>对象。 </p><p>而<code>window</code>对象提供的属性主要为<code>document</code>、<code>location</code>、<code>navigator</code>、<code>screen</code>、<code>history</code>以及<code>frames</code>。  </p><p>在浏览器里的<code>window</code>对象会扮演着两种角色：  </p><ul><li>ECMAScript 标准里的<strong>全局对象</strong> (Global Object)</li><li>JavaScript 用来与浏览器沟通的窗口</li></ul><p>凡是<strong>在全局作用域内声明的变量、对象、函数等，都会自动变成全局对象的属性</strong>。通常这样的变量，我们会称它们叫做<strong>全局变量</strong>，可以通过window.xxx的方式取得它们。比如：  </p><pre><code class="javascript">var a = 10; console.log( window.a );    // 10</code></pre><p>除此之外，在全局作用域内声明的全局变量还有一个特性，就是无法使用<code>delete</code>关键字来移除： </p><pre><code class="javascript">var a = 10; console.log( window.a );    // 10console.log(delete window.a);     // falseconsole.log( window.a );    // 10</code></pre><p>但若是直接通过指定<code>window</code>对象的属性则可以：  </p><pre><code class="javascript">window.a = 10; console.log( window.a );    // 10console.log(delete window.a);        // trueconsole.log( window.a );    // undefined</code></pre><p>现在我们已经知道了全局对象是怎么回事了，那么<code>window</code>对象扮演的另一个角色，<strong>用来与浏览器沟通的窗口</strong>又是什么意思呢？  </p><h3 id="浏览器内建的对话框"><a href="#浏览器内建的对话框" class="headerlink" title="浏览器内建的对话框"></a>浏览器内建的对话框</h3><p>先来个最常见的例子：alert()警告对话框：  </p><p><img src="/images/dom/4.jpg" srcset="/img/loading.gif" alt>   </p><p>(alert on Chrome)</p><p>我想不管是不是刚接触JavaScript的朋友，对<code>alert</code>应该都不陌生，<code>alert</code>的完整语法其实是这样：  </p><pre><code class="javascript">window.alert(&quot;message&quot;);</code></pre><p>如同我们所熟知的全局变量一样，<code>window</code>对象下的成员，<code>window</code>是可以省略不打的。  </p><p>一行代码就可以生成一个对话框，很神奇吧？  </p><p>而这就是浏览器环境的BOM提供给JavaScript控制的功能之一。  </p><p>类似的对话框还有用来提供<strong>确定/取消</strong>的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm" target="_blank" rel="noopener">window.confirm()</a>，以及开放式问答的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt" target="_blank" rel="noopener">window.prompt()</a>对话框。  </p><p>当然BOM 提供的API 很多，包含开启/关闭视窗，改变视窗大小，计时器与取得网址等等。这些在之后的文章当中还会再细说。  </p><h3 id="DOM-是什么"><a href="#DOM-是什么" class="headerlink" title="DOM 是什么?"></a>DOM 是什么?</h3><p><strong>DOM</strong>(<strong>Document Object Model</strong>，文件对象模型)，是一个将HTML文件以树状的结构来表示的模型，而组合起来的树状图，我们称之为DOM Tree。 </p><p>简单来说，我们把HTML每个节点的关系连接起来倒着看，就好像是一棵树一样。假设我们有一个基本的HTML如下：</p><pre><code class="javascript">&lt;html&gt;    &lt;head&gt;        &lt;title&gt;米淇淋的个人博客&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;这是主题&lt;/h1&gt;        &lt;p&gt;这是一个&lt;i&gt;简单&lt;/i&gt;的段落&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/domapi-5.jpg" srcset="/img/loading.gif" alt>  </p><p>在最根部的地方，就是<code>document</code>，就是BOM图中<code>window</code>下面的那个。</p><p>往下可以延伸出一个个的HTML 标签，一个节点就是一个标签，往下又可以再延伸出文本节点与属性的节点。</p><p>而DOM API 就是定义了让JavaScript 可以存取、改变HTML 结构、样式和内容的方法，甚至是对节点绑定的事件。</p><p>JavaScript 就是通过DOM 提供的API 来对HTML 做存取与操作。 </p><h3 id="DOM-与-BOM-的区别"><a href="#DOM-与-BOM-的区别" class="headerlink" title="DOM 与 BOM 的区别"></a>DOM 与 BOM 的区别</h3><p>前面介绍BOM时，我们已经知道DOM的<code>document</code>其实也就是<code>window</code>对象的子对象之一。 </p><p>而 DOM 与 BOM 最大的区别在于：</p><ul><li>BOM: JavaScript 与<strong>浏览器</strong>沟通的窗口，不涉及网页内容。</li><li>DOM: JavaScript 用来控制<strong>网页</strong>的节点与内容的标准。</li></ul><p>BOM完全依赖于浏览器厂商实作本身无标准规范，而DOM有着W3C 所制定的标准来规范。</p><p>想要通过DOM API 取得节点，JavaScript 可以这样写： </p><pre><code class="javascript">// 根据传入的值，找到 DOM 中 id 为 &#39;xxx&#39; 的元素。document.getElementById(&#39;xxx&#39;);// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)document.getElementsByTagName(&#39;xxx&#39;);// 针对给定的 class 名称，返回所有符合条件的 NodeList 对象。document.getElementsByClassName(&#39;xxx&#39;);// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的 NodeList。document.querySelector(&#39;xxx&#39;); document.querySelectorAll(&#39;xxx&#39;);</code></pre><p>而透过DOM API选取出来的节点，我们可以通过操作<code>textContent</code>属性来变更它的文字。</p><p>假设有一个HTML 节点：</p><pre><code class="html">&lt;h1 id=&quot;greet&quot;&gt;&lt;/h1&gt;</code></pre><p>再来我们就可以先通过<code>document.querySelector()</code>方法来取得节点，然后修改<code>textContent</code>属性：</p><pre><code class="html">&lt;script&gt;    document.querySelector(&#39;#greet&#39;).textContent = &#39;Hello World!&#39;&lt;/script&gt;</code></pre><p><a href="http://jsbin.com/fuhurapivu/embed?html,js,output" target="_blank" rel="noopener">JS Bin on jsbin.com</a></p><p>看到这里，恭喜你已经可以通过JavaScript 在网页上输出”Hello World!” 啦！</p><p>在后续的内容中，我们会继续来介绍各种操作网页的DOM/BOM API。</p><p>毕竟对前端工程师来说，搞懂<strong>怎么与浏览器打交道、怎么操作网页内容</strong>，就是做好WebUI最重要的基础。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>DOM</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈数组常见遍历方法</title>
    <link href="/2019/07/23/%E6%B5%85%E8%B0%88%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <url>/2019/07/23/%E6%B5%85%E8%B0%88%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍数组常见的遍历方法：forEach、map、filter、find、every、some、reduce，它们都有个共同点：不会改变原始数组。 </p><p><img src="/images/array/1.png" srcset="/img/loading.gif" alt>   </p><p>接下来都是使用底下的基础数组来实现一些方法：  </p><ul><li>累加</li><li>比大小</li><li>分别运算</li><li>查找特定值等  </li></ul><pre><code class="javascript">let people = [  {    name: &#39;马云&#39;,    money: 2000  },  {    name: &#39;马化腾&#39;,    money: 1800  },  {    name: &#39;李彦宏&#39;,    money: 1500  },  {    name: &#39;我&#39;,    money: Infinity  }];</code></pre><h3 id="forEach：遍历数组"><a href="#forEach：遍历数组" class="headerlink" title="forEach：遍历数组"></a>forEach：遍历数组</h3><p>forEach与另外几种方法有些许不同，就是除了forEach以外的几个方法都会返回值，如果在等号的左方放一个变量，那么此变量返回值将会是<code>undefined</code>(没有返回任何值)。  </p><pre><code class="javascript">var forEachLoop = people.forEach( function ( item, index, array ) {    console .log(item, index, array); //（对象,索引,全部数组）});console .log(forEachLoop); // undefined</code></pre><p>其它的方法都会返回一个值或数组，以此来说就会传回原本的数组值。   </p><pre><code class="javascript">var mapLoop = people.map( function ( item, index, array ) {  return item});console .log(mapLoop); //与原本数组资料相同</code></pre><h3 id="map：一一映射另一个数组"><a href="#map：一一映射另一个数组" class="headerlink" title="map：一一映射另一个数组"></a>map：一一映射另一个数组</h3><p>map会return返回的对象、值，作用上是用来处理数组返回新值产生一个新数组，要特别注意返回的值数量与原始数组长度相同，所以如果不给return，默认返回<code>undefined</code>。</p><pre><code class="javascript">// 没有给return 也会产生undefinedvar mapEmpty = people.map( function ( item, index, array ) {});console .log(mapEmpty);     // [undefined, undefined, undefined, undefined]var everyoneAdd = people.map( function ( item, index, array ) {  item.money = item.money + 500 ; //每个money + 500  return item;              //返回对象});console .log(everyoneAdd);   // 返回每个处理后的数值，不过记得这是传参考特性，会影响到原始的对象// {name: &quot;马云&quot;, money: 2500}// {name: &quot;马化腾&quot;, money: 2300}// {name: &quot;李彦宏&quot;, money: 2000}// {name: &quot;我&quot;, money: Infinity}var mapMoneyThan1500 = people.map( function ( item, index, array ) { // 错误示范，长度不符合时 if (item.money &gt; 1500 ) { return item;               //取得大于1500  }});console .log(mapMoneyThan1500);// [{name: &quot;马云&quot;, money: 2000}, {name: &quot;马化腾&quot;, money: 1800}, undefined, {name: &quot;我&quot;, money: Infinity} ]</code></pre><h3 id="filter：过滤掉数组中符合条件的元素"><a href="#filter：过滤掉数组中符合条件的元素" class="headerlink" title="filter：过滤掉数组中符合条件的元素"></a>filter：过滤掉数组中符合条件的元素</h3><p>filter() 检测数值元素，并返回符合条件所有元素的数组。 filter() 不会改变原始数组。  </p><pre><code class="javascript">// filtervar filterEmpty = people.filter(function(item, index, array){});console.log(filterEmpty);    // 没有给条件，会是一个空数组var filterMoneyThan1500 = people.filter(function(item, index, array){  return item.money &gt; 1500;       // 取得大于1500});console.log(filterMoneyThan1500); // 马云，马化腾，我 这三个对象</code></pre><h3 id="find：返回符合条件的数组的第一个元素的值"><a href="#find：返回符合条件的数组的第一个元素的值" class="headerlink" title="find：返回符合条件的数组的第一个元素的值"></a>find：返回符合条件的数组的第一个元素的值</h3><p>find是用来查找数组中符合条件的对象，且<strong>仅能有一个</strong>，当返回的<code>true</code>数量超过两个以上时，那会以第一个为优先，通常会用来查找特定 id。如果没有符合条件的对象，则返回<code>undefined</code>。  </p><pre><code class="javascript">var findEmpty = people.find(function(item, index, array){});console.log(findEmpty);          // 没有条件，会是 undefinedvar findMoneyThan1500 = people.find(function(item, index, array){  return item.money &gt; 1500;      // 取得大于1500});console.log(findMoneyThan1500);  // 虽然满足条件的有3个，但只会返回 &#39;马云&#39; 这一个对象var findMe = people.find(function(item, index, array){  return item.name === &#39;我&#39;;    // 找到我});console.log(findMe);            // 我 这一对象</code></pre><h3 id="every：验证数组中是否每个元素都满足指定的条件"><a href="#every：验证数组中是否每个元素都满足指定的条件" class="headerlink" title="every：验证数组中是否每个元素都满足指定的条件"></a>every：验证数组中是否每个元素都满足指定的条件</h3><p>验证全部的结果，当全部的值都为 <code>true</code> 时，则最终会得到 <code>true</code>；只要其中之一为 <code>false</code>，则返回 <code>false</code>。  </p><pre><code class="javascript">var ans = people.every(function(item, index, array){  return item.money &gt; 1800;});console.log(ans); // false: 只要有部分不符合，则为 falsevar ans2 = people.every(function(item, index, array){  return item.money &gt; 500;});console.log(ans2); // true: 大家钱都超过 500</code></pre><h3 id="some：验证数组中是否有元素满足指定的条件"><a href="#some：验证数组中是否有元素满足指定的条件" class="headerlink" title="some：验证数组中是否有元素满足指定的条件"></a>some：验证数组中是否有元素满足指定的条件</h3><p>与前者类似，但只要部分为 <code>true</code>，则返回 <code>true</code>；全部为 <code>false</code> 时返回值才会为 <code>false</code>。  </p><pre><code class="javascript">var ans = people.some(function(item, index, array){  return item.money &gt; 1800;});console.log(ans); // true: 只要有部分符合，则为 truevar ans2 = people.some(function(item, index, array){  return item.money &lt; 500;});console.log(ans2); // false: 大家钱都不少于 500</code></pre><h3 id="reduce：将数组合成一个值"><a href="#reduce：将数组合成一个值" class="headerlink" title="reduce：将数组合成一个值"></a>reduce：将数组合成一个值</h3><p>reduce是其中最为特殊的，首先他返回的参数与之前的不同，它会接收到前一个返回的值供下一个对象使用，很适合用在累加与对比上，返回的可以是数字也可以是数组。</p><ul><li>accumulator: 前一个参数，如果是第一个数组的话，值是以另外传入或初始化的值</li><li>currentValue: 当前值</li><li>currentIndex: 当前索引</li><li>array: 全部数组</li></ul><pre><code class="javascript">var reduceEmpty = people.reduce(function(accumulator, currentValue, currentIndex, array){});console.log(reduceEmpty);                 // 沒有条件，会是 undefined</code></pre><p>可以通过与前一个相加的方式，累加数组中所有的值。</p><pre><code class="javascript">people.pop(); // 我的钱深不可测，先移除掉var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array){  // 分別是前一个返回值, 当前值, 当前索引值  console.log(accumulator, currentValue, currentIndex);  return accumulator + currentValue.money;  // 与前一个值相加}, 0);                                      // 传入初始化值为 0console.log(reducePlus);                    // 总和为 5300</code></pre><p>也可以相互对比，取出最高的值。</p><pre><code class="javascript">var reduceBestOne = people.reduce(function(accumulator, currentValue, currentIndex, array){  console.log(&#39;reduce&#39;, accumulator, currentValue, currentIndex)  return Math.max(accumulator, currentValue.money); // 与前一个值比较哪个更大}, 0);console.log(reduceBestOne);                  // 最大值为 2000</code></pre><p>reduce功能很强大，其余几种遍历方法可以用reduce方法来代替，这里只列出map被reduce代替的例子。</p><pre><code class="javascript">//map方法var mapMoneyDouble = people.map( function ( item, index, array ) { return item.money*2;               //钱翻倍});console .log(mapMoneyDouble); // 4000, 3600, 3000, Infinity//reduce方法实现同样的功能var reduceMoneyDouble = people.reduce( function ( accumulator, currentValue, currentIndex, array ) {             //钱翻倍  accumulator.push(currentValue.money*2);                //钱翻倍  return accumulator},[]);console .log(reduceMoneyDouble); // 4000, 3600, 3000, Infinity</code></pre><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【译】谈谈“typeof null为object”这一bug的由来</title>
    <link href="/2019/07/20/%E3%80%90%E8%AF%91%E3%80%91%E8%B0%88%E8%B0%88%E2%80%9Ctypeof%20null%E4%B8%BAobject%E2%80%9D%E8%BF%99%E4%B8%80bug%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <url>/2019/07/20/%E3%80%90%E8%AF%91%E3%80%91%E8%B0%88%E8%B0%88%E2%80%9Ctypeof%20null%E4%B8%BAobject%E2%80%9D%E8%BF%99%E4%B8%80bug%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<p>很多前端初级开发者也许并不深究typeof null为何为Object？想更深地了解这一bug的由来，可以参阅Dr. Axel Rauschmayer关于”typeof null”的历史这篇文章。 </p><blockquote><p>原文链接：<a href="http://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">http://www.2ality.com/2013/10/typeof-null.html</a></p></blockquote><p>我看了下C语言关于<code>typeof</code>的规范，它对于<code>typeof null</code>为何结果是’<code>object</code>’有更好的解释。  </p><p>在JavaScript中，<code>typeof null</code>的结果是’<code>Object</code>‘，它错误地暗示<code>null</code>是一个对象，实际上它是一个原始值。我在<a href="https://luozongmin.com/2019/05/09/JS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86/" target="_blank" rel="noopener">上一篇文章</a>也提到了这是JS的一大bug，不幸的是这并不能解决，因为这将破坏现有规范，接下来解释下这个bug的历史。  </p><p>“<code>typeof null</code>”的错误从JavaScripts第一个版本开始就已经存在了。在这个版本，值以32位为单位存储，由小型标签（1-3位）和值的实际数据组成。类型标签存储在单元的低位中。 其中有五种：   </p><ul><li>000: <code>object</code>. 数据是对象的引用。</li><li>1: <code>int</code>. 数据是31位有符号整数。</li><li>010: <code>double</code>. 数据是对双浮点数的引用。</li><li>100: <code>string</code>. 数据是对字符串的引用。</li><li>110: <code>boolean</code>. 数据是布尔值。</li></ul><p>也就是说，最低位是1，然后类型标签只有1位长，即<code>int</code>型。 或者最低位为0，那么类型标签的长度为3位，为其余4种类型提供了两个附加位。  </p><p>但有2个值是特殊的：  </p><ul><li><code>undefined</code>（JSVAL_VOID）是整数−2^30（整数范围之外的数字）。</li><li><code>null</code>(JSVAL_NULL) 为机器码NULL的空指针，或者说：为0的object类型标签。   </li></ul><p>现在应该明白为什么<code>typeof</code>认为<code>null</code>是一个对象：它检测一个他的类型标签并且返回”<code>object</code>”。 以下是<code>typeof</code>的引擎代码：  </p><pre><code class="c"> JS_PUBLIC_API(JSType)    JS_TypeOfValue(JSContext *cx, jsval v)    {        JSType type = JSTYPE_VOID;        JSObject *obj;        JSObjectOps *ops;        JSClass *clasp;        CHECK_REQUEST(cx);        if (JSVAL_IS_VOID(v)) {  // (1)            type = JSTYPE_VOID;        } else if (JSVAL_IS_OBJECT(v)) {  // (2)            obj = JSVAL_TO_OBJECT(v);            if (obj &amp;&amp;                (ops = obj-&gt;map-&gt;ops,                 ops == &amp;js_ObjectOps                 ? (clasp = OBJ_GET_CLASS(cx, obj),                    clasp-&gt;call || clasp == &amp;js_FunctionClass) // (3,4)                 : ops-&gt;call != 0)) {  // (3)                type = JSTYPE_FUNCTION;            } else {                type = JSTYPE_OBJECT;            }        } else if (JSVAL_IS_NUMBER(v)) {            type = JSTYPE_NUMBER;        } else if (JSVAL_IS_STRING(v)) {            type = JSTYPE_STRING;        } else if (JSVAL_IS_BOOLEAN(v)) {            type = JSTYPE_BOOLEAN;        }        return type;    }</code></pre><p>上述代码执行的步骤如下：  </p><ul><li>（1）引擎首先检测值是否是<code>undefined</code>(VOID)，它通过<code>==</code>做了这样的比较：  </li></ul><pre><code class="c">#define JSVAL_IS_VOID(v)  ((v) == JSVAL_VOID)</code></pre><ul><li><p>下一个（2）是检测该值是否具有<code>object type</code>。如果它可使用<code>call</code>被调用（3）或其存在内部属性<code>[[Class]]</code>标记为函数（4），则v是函数。 否则，它是一个对象。 这是由<code>typeof null</code>生成的结果。  </p></li><li><p>后续检查是针对<code>number</code>，<code>string</code>和<code>boolean</code>，甚至没有明确检查<code>null</code>。这可以由以下C语言宏执行。  </p></li></ul><pre><code class="c">#define JSVAL_IS_NULL(v)  ((v) == JSVAL_NULL)`  </code></pre><p>这看似是一个非常明显的bug，但不要忘记，第一个版本的JavaScript完成只用了极少的时间，具体可以看看<a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" target="_blank" rel="noopener">JavaScript的诞生</a>。   </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中一切都是对象吗？看这一篇就知道了</title>
    <link href="/2019/07/18/JS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86/"/>
    <url>/2019/07/18/JS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p>当你刚开始学习JavaScript时，你是否有遇到许多书籍，教程以及那些说“JavaScript中的所有内容都是对象”的人？这算是一个JavaScript中老生常谈的话题了，虽然它并不是100％正确（JavaScript中不是所有都是对象），但其实这种说法又有那么一点说得过去，这可能有点自相矛盾。</p><p><img src="/images/object/1.jpg" srcset="/img/loading.gif" alt>     </p><p>想必有点疑惑吧，那么造成这种现象的原因是什么呢？接下来就由我一一道来。  </p><h4 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h4><p>说起一切都是对象这种说法的由来，就要好好提一下历史因素了。  </p><p>1995年，JavaScript诞生之年，Netscape公司（JavaScript的设计者）与Sun公司（Java语言的发明者和所有者）合作开发一种可以嵌入网页的脚本语言，将JavaScript的数据结构借鉴Java而设计，包括将值分成原始值和对象两大类。   </p><p><strong>Java中一切皆对象，但基本类型却不是对象，为了解决这个问题，Java让每个基本类型都对应了一个包装器类型</strong>。包装器类型将基本类型包装起来，添加了属性和方法，包装器类型即为对象，所以可以这么说Java中的一切都可以充当对象，不会说的那么绝对。  </p><p>因此借鉴了Java数据结构的JavaScript也同样在基本类型中各对应了一个包装器类型，JavaScript中的一切都可以充当对象，接下来将详细进行介绍。  </p><h4 id="原始类型与对象"><a href="#原始类型与对象" class="headerlink" title="原始类型与对象"></a>原始类型与对象</h4><p>JavaScript中值可以分为两大类：原始类型和对象。  </p><p><strong>定义</strong>  </p><p>在JavaScript中，有六种原始数据类型：  </p><ul><li>Boolean - <code>true</code> 或 <code>false</code></li><li>null - 用 <code>type of</code> 检验 <code>null</code> 数据类型时为 <code>Object</code> ，但它不是对象，这是JS的一个bug</li><li>undefined</li><li>number - JavaScript中的所有数字都是浮点数，没有整数</li><li>string</li><li>symbol (ES6)</li></ul><p>除去上面的原始数据类型，所有其他值都是对象。对象可以进一步分为：  </p><ul><li>原始值的包装类型：<code>Boolean</code>,<code>Number</code>,<code>String</code>. - 很少直接使用。  </li><li>以下类型生成的对象也可以通过构造函数创建：</li></ul><ol><li>[] 类同于 new Array()</li><li>{} 类同于 new Object()</li><li>function() {} 类同于 new Function()</li><li>/\s<em>/ 类同于 new RegExp(“\s</em>“) </li></ol><ul><li>Dates: new Date(“2011-12-24”)  </li></ul><p><strong>不同点</strong>  </p><p>第一个不同点： </p><p>原始类型没有附加方法; 所以你永远不会看到<code>undefined.toString（）</code>。 也正因为如此，原始类型是不可变的，因为它们没有附加的方法可以改变它：  </p><pre><code class="javascript">var s = &quot;boy&quot;;s.bar = &quot;girl&quot;;console.log(s.bar); // undefined</code></pre><p>而默认情况下，对象是可变的，可以添加方法：</p><pre><code class="javascript">var obj = {};obj.foo = 123;  console.log(obj.foo); // 123  </code></pre><p>第二个不同点：</p><p>此外，与作为引用存储的对象不同，原始类型作为值本身存储。 这在执行相等性检查时会产生影响：  </p><pre><code class="javascript">&quot;dog&quot; === &quot;dog&quot;; // true14 === 14; // true{} === {}; // false[] === []; // false(function () {}) === (function () {}); // false</code></pre><p>原始类型按值存储，对象通过引用存储，存储地址也不同，原始类型直接存放在栈中，而对象是存放在堆里的，具体可以看之前写的关于<a href="https://luozongmin.com/2019/04/22/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" target="_blank" rel="noopener">内存空间</a>这篇文章。  </p><h4 id="原始值及其包装器"><a href="#原始值及其包装器" class="headerlink" title="原始值及其包装器"></a>原始值及其包装器</h4><p>三个基本类型<code>string</code>，<code>number</code>和<code>boolean</code>，它们有时被当做包装器类型，并且在原始值和包装类型之间进行转换很简单：  </p><ul><li>原始类型 to 包装类型: <code>new String(&quot;abc&quot;)</code></li><li>包装类型 to 原始类型: <code>new String(&quot;abc&quot;).valueOf()</code> </li></ul><p>比如字符串<code>“abc”</code>之类的原始值与<code>new String（“abc”）</code>之类的包装器实例有根本上的不同。 例如（用<code>typeof</code>和<code>instanceof</code>判断时）：  </p><pre><code class="javascript">typeof &quot;pet&quot;;  //&quot;string&quot;typeof new String(&quot;pet&quot;);  //&quot;object&quot;&quot;pet&quot; instanceof String;  // falsenew String(&quot;pet&quot;) instanceof String;  // true&quot;pet&quot; === new String(&quot;pet&quot;);  // false</code></pre><p>其实包装器实例就是一个对象，没办法在JavaScript中比较对象，甚至不能通过非严格相等 ==： </p><pre><code class="javascript">var a = new String(&quot;pet&quot;);var b = new String(&quot;pet&quot;);a == b;  // falsea == a;  // true</code></pre><p>因此JavaScript中的一切都可以充当对象，而JavaScript中的一切都是对象这种说法是欠妥的。</p><h4 id="临时包装（Auto-Boxing）"><a href="#临时包装（Auto-Boxing）" class="headerlink" title="临时包装（Auto-Boxing）"></a>临时包装（Auto-Boxing）</h4><p>有趣的是，原始字符串和对象的构造函数都是<code>String</code>函数。 更有趣的是你可以在原始字符串上调用<code>.constructor</code>这个方法，可是之前说过原始类型不能有方法，咋回事呢？先看下面的代码： </p><pre><code class="javascript">var pet = new String(&quot;dog&quot;)pet.constructor === String; // trueString(&quot;dog&quot;).constructor === String; // true</code></pre><p>上面代码所发生的事情是一个叫做Auto-Boxing的过程，我觉得翻译成中文是“临时包装”比较适宜。 当您尝试在某些基本类型上调用属性或方法时，JavaScript首先将其转换为临时包装器对象，并访问其上的属性/方法，而不会影响原始属性。  </p><pre><code class="javascript">var pet = &quot;dog&quot;;console.log(pet.length); // 3pet === &quot;dog&quot;; // true</code></pre><p>在上面的示例中，要访问属性<code>length</code>，JavaScript发生临时包装过程将<code>pet</code>转换为包装器对象，访问完包装器对象的<code>length</code>属性，然后将其丢弃。 这样做不会影响<code>pet</code>（<code>pet</code>仍然是一个原始字符串）。  </p><p>这也解释了为什么JavaScript在尝试将属性分配给基本类型时不会出问题，因为赋值是在该临时包装器对象上完成的，而不是基本类型本身，比如： </p><pre><code class="javascript">var foo = 42;foo.bar = &quot;lzm&quot;; // 是在临时包装器对象上完成的赋值foo.bar; // undefined</code></pre><p>但原始类型<code>undefined</code>和<code>null</code>，都是没有包装器对象的，当你尝试赋予属性时，它会报错。 </p><pre><code class="javascript">var foo = null;foo.bar = &quot;lzm&quot;; // Uncaught TypeError: Cannot set property &#39;bar&#39; of null</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1.并非JavaScript中的所有内容都是对象，应该说所有内容都可以充当对象。</p><p>2.JavaScript中有6种原始类型。</p><p>3.所有不是原始类型的值都是一个对象。</p><p>4.字符串，布尔值和数字可以表示为基本类型，但作为包装器类型时也可以表示为对象。</p><p>5.由于名为autoboxing的JavaScript特性，某些原始类型（字符串，数字，布尔值）似乎表现得有点像对象。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈JavaScript中创建对象(Object)</title>
    <link href="/2019/07/15/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%BB%BA%E7%AB%8B(Object)/"/>
    <url>/2019/07/15/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%BB%BA%E7%AB%8B(Object)/</url>
    
    <content type="html"><![CDATA[<p>在这篇文章中我将会着重说明如何创建和调用JavaScript里的对象（Object）。  </p><h4 id="对象（Object）是什么？"><a href="#对象（Object）是什么？" class="headerlink" title="对象（Object）是什么？"></a>对象（Object）是什么？</h4><p>在开始介绍如何创建对象前，我们要知道对象是什么。<strong>对象（<code>Object</code>）</strong>简单地来说，就是一堆「名称- 值」的配对（key - value pairs）。至于可以放入哪些值呢？  </p><p>第一种是原生的值（<code>primitive</code>），像是布尔值（<code>Boolean</code>）、数值（<code>Number</code>）或是字符串（<code>String</code>），而在对象当中，我们把这类的值称为属性（<code>Property</code>）。  </p><p>第二种可以放入的值是对象（<code>Object</code>），也就是在一个对象里面再嵌入一个对象，这种以对象为值的情况我们也把它称作属性（<code>Property</code>）。  </p><p>第三种放入的值可以是函数（<code>function</code>），在对象的情况下，我们会把这种函数称做方法（<code>method</code>）。在对象中的每一个<code>Property</code>或是<code>Method</code>都会占据电脑当中一个记忆体的位置，在需要使用到的时候，把它们调取出来。  </p><p>接下来我将介绍三种创建JavaScript里的对象及如何调用的方法：  </p><h4 id="方法一：使用"><a href="#方法一：使用" class="headerlink" title="方法一：使用 [ ]"></a>方法一：使用 [ ]</h4><p><strong>创建对象</strong>  </p><p>创建对象的第一个方法是使用<code>[ ]</code>，<code>[ ]</code>在JavaScript中被称做Computed Member Access：  </p><p><img src="/images/object/2.jpg" srcset="/img/loading.gif" alt>    </p><p>让我们看一下底下的例子：  </p><pre><code class="javascript">// 创建对象var person = new Object();person[&quot;firstname&quot;] = &quot;Jay&quot;;person[&quot;lastname&quot;] = &quot;Chou&quot;;</code></pre><p>这是利用<code>[ ]</code>创建对象的方法，首先我们创建一个对象，叫做<code>person</code>，接着开始给它「名称-值」配对，例如，<code>firstname</code>是属性的名称，<code>Jay</code>则是它的值；<code>lastname</code>也是属性名称，<code>Chou</code>则是它的值。通过这种方法，我们就可以创建对象里面的各种「名称-值」配对。  </p><p><strong>调用对象</strong>   </p><p>紧接上面的例子，我们也同样可以利用<code>[ ]</code>来调用已经建立好的对象，<code>[ ]</code>里面如果放的是字符串而不是变量，注意要记得加上引号’像是这样：  </p><pre><code class="javascript">// 调用对象console.log(person[&quot;firstname&quot;]);  // Jay</code></pre><p>另外，如果是通过<code>[ ]</code>来调用对象的话，还有一个特别的地方，就是<code>[ ]</code>内可以放变量，像是这样（当<code>[ ]</code>里面放的是变量时不用加引号<code>&quot;</code>），一样可以调用到对象的值，这个是用种方法二（<code>.</code>）做不到的：  </p><pre><code class="javascript">// 调用对象var id = &quot;lastname&quot;;console.log(person[id]);  // Chou</code></pre><h4 id="方法二：使用点符号"><a href="#方法二：使用点符号" class="headerlink" title="方法二：使用点符号 ."></a>方法二：使用点符号 .</h4><p><strong>创建对象</strong>  </p><p>第二种创建对象的方法是使用英文的句点 <code>.</code>，在JavaScript中被称做Member Access，创建的方法如下：我们在刚刚创建的<code>person</code>这个对象里面，再创建一个对象属性，名称为<code>address</code>。其实，我觉得可以把.翻译成中文的「的」，所以这里的意思就是，在<code>person</code>的里面创建一个名称为<code>address</code>的对象；在<code>person</code>的<code>address</code>的<code>country</code>，创建一个值为<code>&quot;China&quot;</code>，以此类推…。  </p><pre><code class="javascript">// 创建对象person.address = new Object();person.address.country = &quot;China&quot;;person.address.city = &quot;Hangzhou&quot;;person.address.location = &quot;Xihu&quot;;</code></pre><p><strong>调用对象</strong>  </p><p>同样的方法也可以用来调用出该对象的值：  </p><pre><code class="javascript">// 调用对象console.log(person.address);  //{country: &quot;China&quot;, city: &quot;Hangzhou&quot;, location: &quot;Xihu&quot;}console.log(person.address.country);  // Chinaconsole.log(person[&quot;address&quot;][&quot;location&quot;]);  // Xihu</code></pre><p>从上面可以看出，<code>.</code> 和<code>[ ]</code>是可以交替使用的。  </p><h4 id="方法三：使用"><a href="#方法三：使用" class="headerlink" title="方法三：使用{ }"></a>方法三：使用{ }</h4><p><strong>创建对象</strong>  </p><p>其实还有在创建对象上有更快的做法，我们可以直接使用<code>{ }</code>，我们可以把上面的代码，改成这样：  </p><pre><code class="javascript">// 创建对象var person = {    firstname: &quot;Jay&quot;,    lastname: &quot;Chou&quot;,    address: {        country: &quot;China&quot;,        city: &quot;Hangzhou&quot;,        location: &quot;Xihu&quot;    }}</code></pre><p>通过这种方式，可以得到与方法二一模一样的结果，调用方法也一致。  </p><p><strong>搭配函数使用对象</strong>  </p><p>在我们创建好对象后，我们可以搭配函数(<code>function</code>)来使用对象，例如，我先把刚刚创建的对象<code>person</code>，改成叫做<code>jaychou</code>。  </p><pre><code class="javascript">var jaychou = {    firstname: &quot;Jay&quot;,    lastname: &quot;Chou&quot;,    address: {        country: &quot;China&quot;,        city: &quot;Hangzhou&quot;,        location: &quot;Xihu&quot;    }}</code></pre><p>接着创建一个名称为<code>SayHI</code>的函数，并且带入我们的对象：  </p><pre><code class="javascript">function SayHI(people) {    console.log(&quot;HI&quot; + people.lastname);}SayHI(jaychou);  // HI Chou</code></pre><p><strong>直接在函数参数的地方创建对象</strong>  </p><p>我们也可以直接在调用函数的同时创建对象，像是这样子：  </p><pre><code class="javascript">SayHI({firstname: &quot;Jony&quot;, lastname: &quot;J&quot;});  // HI J</code></pre><p>一开始看到这样的写法可能会觉得很奇怪，但其实这种方式和我们直接在函数的参数里面输入字符串或数值是一样的意思，只是这里是创建一个对象。我们把这种直接在函数的参数中创建对象的方法称做”creating object on the fly”（即动态创建对象）。  </p><h4 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h4><p>其实使用<code>new Object</code>不是创建对象最好的方式，这点会在之后的文章再作说明。另外，虽然使用<code>[ ]</code>和<code>.</code>都可以拿来创建对象和调用对象，但还是建议尽量使用点符号.作为创建对象和调用对象的方法，这样比较干净简洁，在debug的时候也比较容易。  </p><p>还有不论你使用的是<code>new Object</code>、”<code>.</code>“、或者直接用”<code>{ }</code>“来创建对象，其实在JavaScript转译之后，本质上做的都是同样的事。它都会将这个对象建立在内存中，并创建该对象的属性（<code>property</code>）和方法（<code>method</code>）在内存中。   </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>对象</tag>
      
      <tag>Object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【译】分享7个好用的JavaScript技巧</title>
    <link href="/2019/07/12/%E5%88%86%E4%BA%AB7%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/"/>
    <url>/2019/07/12/%E5%88%86%E4%BA%AB7%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>就像所有其他编程语言一样，JavaScript也有许多技巧可以完成简单和困难的任务。 一些技巧广为人知，而其他技巧则足以让你大吃一惊。 让我们来看看你今天就可以开始使用的七个JavaScript技巧吧！</p><p><img src="/images/skill/1.jpg" srcset="/img/loading.gif" alt>    </p><p>原文链接：<a href="https://davidwalsh.name/javascript-tricks#comments" target="_blank" rel="noopener">https://davidwalsh.name/javascript-tricks#comments</a>   </p><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p>数组去重可能比您想象的更容易：  </p><pre><code class="javascript">var j = [...new Set([1, 2, 3, 4, 4])]&gt;&gt; [1, 2, 3, 4]</code></pre><p>很简单有木有！ </p><h4 id="过滤掉falsy值"><a href="#过滤掉falsy值" class="headerlink" title="过滤掉falsy值"></a>过滤掉falsy值</h4><p>是否需要从数组中过滤出falsy值（<code>0</code>，<code>undefined</code>，<code>null</code>，<code>false</code>等）？ 你可能不知道还有这个技巧：  </p><pre><code class="javascript">let res = [1,2,3,4,0,undefined,null,false,&#39;&#39;].filter(Boolean);&gt;&gt; 1,2,3,4</code></pre><h4 id="创建空对象"><a href="#创建空对象" class="headerlink" title="创建空对象"></a>创建空对象</h4><p>您可以使用<code>{ }</code>创建一个看似空的对象，但该对象仍然具有<code>__proto__</code>和通常的<code>hasOwnProperty</code>以及其他对象方法。 但是，有一种方法可以创建一个纯粹的“字典”对象：  </p><pre><code class="javascript">let dict = Object.create(null);// dict.__proto__ === &quot;undefined&quot;// No object properties exist until you add them</code></pre><p>这种方式创建的对象就很纯粹，没有任何属性和对象，非常干净。</p><h4 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h4><p>在JavaScript中合并多个对象的需求已经存在，尤其是当我们开始使用选项创建类和小部件时：  </p><pre><code class="javascript">const person = { name: &#39;David Walsh&#39;, gender: &#39;Male&#39; };const tools = { computer: &#39;Mac&#39;, editor: &#39;Atom&#39; };const attributes = { handsomeness: &#39;Extreme&#39;, hair: &#39;Brown&#39;, eyes: &#39;Blue&#39; };const summary = {...person, ...tools, ...attributes};/*Object {  &quot;computer&quot;: &quot;Mac&quot;,  &quot;editor&quot;: &quot;Atom&quot;,  &quot;eyes&quot;: &quot;Blue&quot;,  &quot;gender&quot;: &quot;Male&quot;,  &quot;hair&quot;: &quot;Brown&quot;,  &quot;handsomeness&quot;: &quot;Extreme&quot;,  &quot;name&quot;: &quot;David Walsh&quot;,}*/</code></pre><p>这三个点<code>(...)</code>使任务变得更加容易！   </p><h4 id="Require函数参数"><a href="#Require函数参数" class="headerlink" title="Require函数参数"></a>Require函数参数</h4><p>能够为函数参数设置默认值是JavaScript的一个很棒的补充，但是请查看这个技巧，要求为给定的参数传递值：  </p><pre><code class="javascript">const isRequired = () =&gt; { throw new Error(&#39;param is required&#39;); };const hello = (name = isRequired()) =&gt; { console.log(`hello ${name}`) };// This will throw an error because no name is providedhello();// This will also throw an errorhello(undefined);// These are good!hello(null);hello(&#39;David&#39;);</code></pre><h4 id="解构添加别名"><a href="#解构添加别名" class="headerlink" title="解构添加别名"></a>解构添加别名</h4><p>解构是JavaScript的一个非常受欢迎的补充，但有时我们更喜欢用其他名称来引用这些属性，所以我们可以利用别名：  </p><pre><code class="javascript">const obj = { x: 1 };// Grabs obj.x as { x }const { x } = obj;// Grabs obj.x as { otherName }const { x: otherName } = obj;</code></pre><p>有助于避免与现有变量的命名冲突！   </p><h4 id="获取查询字符串参数"><a href="#获取查询字符串参数" class="headerlink" title="获取查询字符串参数"></a>获取查询字符串参数</h4><p>获取url里面的参数值或者追加查询字符串，在这之前，我们一般通过正则表达式来获取查询字符串值，然而现在有一个新的api，具体详情可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams" target="_blank" rel="noopener">这里</a>，可以让我们以很简单的方式去处理url。  </p><p>比如现在我们有这样一个url，”?post=1234&amp;action=edit”，我们可以利用下面的技巧来处理这个url。</p><pre><code class="javascript">// Assuming &quot;?post=1234&amp;action=edit&quot;var urlParams = new URLSearchParams(window.location.search);console.log(urlParams.has(&#39;post&#39;)); // trueconsole.log(urlParams.get(&#39;action&#39;)); // &quot;edit&quot;console.log(urlParams.getAll(&#39;action&#39;)); // [&quot;edit&quot;]console.log(urlParams.toString()); // &quot;?post=1234&amp;action=edit&quot;console.log(urlParams.append(&#39;active&#39;, &#39;1&#39;)); // &quot;?post=1234&amp;action=edit&amp;active=1&quot;</code></pre><p>比我们过去用的容易多了！   </p><p>多年来JavaScript已经发生了很大的变化，但是我最喜欢的JavaScript部分是我们所看到的语言改进的速度。 尽管JavaScript的动态不断变化，我们仍然需要采用一些不错的技巧; 将这些技巧保存在工具箱中，以便在需要时使用！   </p><p>那你最喜欢的JavaScript技巧是什么？   </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中任何值的prototype到最后都是Object</title>
    <link href="/2019/07/09/JavaScript%E4%B8%AD%E4%BB%BB%E4%BD%95%E5%80%BC%E7%9A%84prototype%E5%88%B0%E6%9C%80%E5%90%8E%E9%83%BD%E6%98%AFObject/"/>
    <url>/2019/07/09/JavaScript%E4%B8%AD%E4%BB%BB%E4%BD%95%E5%80%BC%E7%9A%84prototype%E5%88%B0%E6%9C%80%E5%90%8E%E9%83%BD%E6%98%AFObject/</url>
    
    <content type="html"><![CDATA[<p>这篇笔记延伸上一篇所提到的<a href="https://luozongmin.com/2019/04/25/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">原型（prototype）</a>的概念，说明了在JavaScript当中，所有的类型（字符串、数值、Boolean值、函数、数组、对象）的prototype的最后都是object！    </p><p>什么意思呢？</p><p>假设我们现在分别建立对象、函数和数组，直接上代码：  </p><pre><code class="javascript">// Object var a =  {   name : &#39;miqilin&#39; }// function var  b  =  function ( ) {   console . log ( &#39;Hello&#39; ) ; }// Array var c =  [ &#39;A&#39; , &#39;r&#39; , &#39;r&#39; , &#39;a&#39; , &#39;y&#39;] ;// string var d =  &#39;This is string&#39; ;// number var e =  2 ;// boolean var f =  true ;</code></pre><p>接着，我们会在Google Chrome 的console 视窗来分别检验这些类型的<code>prototype</code>。  </p><h4 id="对象（object）"><a href="#对象（object）" class="headerlink" title="对象（object）"></a>对象（object）</h4><p>我们可以看到a这个对象本身的<code>prototype</code>也是一个对象，在下去就没了（<code>null</code>），也就是<strong>Object → Object → null的过程</strong>。 </p><p><img src="/images/object/3.jpg" srcset="/img/loading.gif" alt>    </p><p>而<code>a.__proto__</code>就是对象的原型，打开来看会发现里面有许多内置的方法。  </p><p><img src="/images/object/4.jpg" srcset="/img/loading.gif" alt>   </p><p>如果我在console中输入<code>a.</code>，则会出现对于对象而言内置的方法： </p><p><img src="/images/object/5.jpg" srcset="/img/loading.gif" alt>   </p><p>由于<code>a.__proto__</code>仍然是一个对象，所以如果我输入<code>a.__proto__.</code>的话，会得到除了<code>name</code>一样对于对象可以使用的方法：</p><p><img src="/images/object/6.jpg" srcset="/img/loading.gif" alt>   </p><h4 id="函数（function）"><a href="#函数（function）" class="headerlink" title="函数（function）"></a>函数（function）</h4><p>接着我们来看看函数，根据上面同样的方法得出是<strong>function → function → object → null</strong>的过程，所以最后还是结束在<code>object</code>。 </p><p><img src="/images/object/7.jpg" srcset="/img/loading.gif" alt>    </p><p>如果我们想要看函数有哪些内置的方法可以用，我们可以输入<code>b.</code>或<code>b.__proto__.</code>就可以看到了，这里我们就可以看到我们常用的<code>apply</code> , <code>bind</code> ,和<code>call</code>。  </p><p><img src="/images/object/8.jpg" srcset="/img/loading.gif" alt>   </p><h4 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h4><p>对于数组的话则是<strong>array → array → object → null</strong>的过程。  </p><p><img src="/images/object/9.jpg" srcset="/img/loading.gif" alt>   </p><p>如果我们要看数组有哪些方法可以用，一样可以透过<code>c.</code>或<code>c.__proto__.</code>来检视： </p><p><img src="/images/object/10.jpg" srcset="/img/loading.gif" alt>    </p><p>同样的方法也可以用来检视字符串、数字和Boolean值，有兴趣的通过chrome 来试试看吧！  </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之原型与原型链</title>
    <link href="/2019/07/03/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2019/07/03/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 也是一门面向对象的语言，ES6之前并没有引入类（class）的概念，像c++ 这种典型的面向对象语言都是通过类来创建实例对象，而JavaScript是直接通过构造函数来创建实例。   </p><p>所以理解两种继承模式的差异是需要一定时间的，今天我们就来了解一下原型和原型链，在介绍原型和原型链之前，我们有必要先了解一下构造函数的知识。   </p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。  </p><p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。另外就是调用方式的不同，普通函数是直接调用，<strong>而构造函数需要使用new关键字来调用</strong>。我们先使用构造函数创建一个对象：  </p><pre><code class="javascript">function Dog() {    this.name = &#39;阿黄&#39;}var dog = new Dog()console.log(dog.name)     // 阿黄</code></pre><p>上面例子中，Dog 就是一个构造函数，我们使用 new 创建了一个实例对象 dog。  </p><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p><strong>prototype</strong>  </p><p>JavaScript是一种<strong>基于原型的语言</strong>(prototype-based language)，每个对象拥有一个<strong>原型对象</strong>，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的<code>prototype</code>属性上，而非对象实例本身。看以下代码： </p><pre><code class="javascript">function Dog() {    this.name = &#39;阿黄&#39;}console.log(Dog.prototype)</code></pre><p>那这个构造函数的 <code>prototype</code> 属性指向的是什么呢？是这个函数的原型吗？  </p><p>打开 chrome 浏览器的开发者工具，在 console 栏输入上面的代码，你可以看到 <code>Dog.prototype</code> 的值： </p><p><img src="/images/prototype/1.jpg" srcset="/img/loading.gif" alt>    </p><p>其实，函数的 <code>prototype</code> 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的<strong>原型</strong>。   </p><p>那什么是<strong>原型</strong>呢？你可以这样理解：每一个JavaScript对象(<code>null</code>除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。  </p><p>让我们用一张图来表示构造函数和实例原型之间的关系：</p><p><img src="/images/prototype/2.jpg" srcset="/img/loading.gif" alt>     </p><p>那么我们该怎么表示实例与实例原型，也就是 <code>dog</code> 和 <code>Dog.prototype</code> 之间的关系呢，接下来就应该讲到第二个属性：  </p><p><strong><strong>proto</strong></strong>  </p><p>上面可以看到 Dog 原型（<code>Dog.prototype</code>）上有<code>__proto__</code>属性，这是一个访问器属性（即 getter 函数和 setter 函数），通过它可以访问到对象的内部<code>[[Prototype]]</code>(一个对象或<code>null</code>)。  </p><p>为了证明这一点,我们可以在chrome中输入：  </p><pre><code class="javascript">function Dog() {    this.name = &#39;阿黄&#39;}var dog = new Dog()console.log(Object.getPrototypeOf(dog) === dog.__proto__)  // trueconsole.log(dog.__proto__ === Dog.prototype)   // true</code></pre><p>这里用<code>dog.__proto__</code>获取对象的原型，<code>__proto__</code>是每个实例上都有的属性，<code>prototype</code>是构造函数的属性，这两个并不一样，但<code>dog.__proto__</code>和<code>Dog.prototype</code>指向同一个对象。于是我们更新下关系图： </p><p><img src="/images/prototype/3.png" srcset="/img/loading.gif" alt>    </p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？  </p><p><strong>constructor</strong>  </p><p>指向实例对象倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：<code>constructor</code>，每个原型都有一个 <code>constructor</code> 属性指向关联的构造函数。  </p><p>为了验证这一点，我们在chrome中输入：  </p><pre><code class="javascript">function Dog() {    this.name = &#39;阿黄&#39;}console.log(Dog.prototype.constructor === Dog)    // true</code></pre><p>所以再更新下关系图：  </p><p><img src="/images/prototype/4.png" srcset="/img/loading.gif" alt>     </p><p>综上我们已经得出：  </p><pre><code class="javascript">function Dog() {    this.name = &#39;阿黄&#39;}var dog = new Dog()console.log(dog.__proto__ == Dog.prototype) // trueconsole.log(Dog.prototype.constructor == Dog) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(dog) === Dog.prototype) // true</code></pre><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>在上文我们理解了原型，从字面意思看原型链肯定是与原型有关了，是一个个原型链接起来的么？我们先通过下面的图来观察一下。  </p><p><img src="/images/prototype/5.jpg" srcset="/img/loading.gif" alt>      </p><p>解析： </p><p><strong>obj.prop1</strong>：假设我们现在有一个对象，就称作<code>obj</code>，而这个对象包含一个属性<code>（property）</code>，我们称作<code>prop1</code>，现在我们可以使用<code>obj.prop1</code>来读取这个属性的值，就可以直接读取到<code>prop1</code>的属性值了。  </p><p><strong>obj.prop2</strong>：JavaScript中会有一些预设的属性和方法，所有的对象和函数都包含<code>prototype</code>这个属性，假设我们把<code>prototype</code>叫做<code>proto</code>，这时候如果我们使用<code>obj.prop2</code>的时候，JavaScript引擎会先在<code>obj</code>这个对象的属性里去寻找有没有叫作<code>prop2</code>的属性，<strong>如果它找不到，这时候它就会再进一步往该对象的<code>proto</code>里面去寻找</strong>。所以，虽然我们输入<code>obj.prop2</code>的时候会得到回传值，但实际上这不是<code>obj</code>里面直接的属性名称，而是在<code>obj</code>的<code>proto</code>里面找到的属性名称（即，<code>obj.proto.prop2</code>，但我们不需要这样打）。  </p><p><strong>obj.prop3</strong>：同样地，每一个对象里面都包含一个<code>prototype</code>，包括对象<code>proto</code>本身也不例外，所以，如果输入<code>obj.prop3</code>时，JavaScript会先在<code>obj</code>这个对象里去寻找有没有<code>prop3</code>这个属性名称，找不到时会再往<code>obj</code>的<code>proto</code>去寻找，<strong>如果还是找不到时，就再往<code>proto</code>这个对象里面的<code>proto</code>找下去</strong>，最后找到后回传属性值给我们（<code>obj.proto.proto.prop3</code>）。  </p><p>虽然乍看之下，<code>prop3</code>很像是在对象<code>obj</code>里面的属性，但实际上它是在<code>obj → prop → prop</code>的对象里面，而这样从对象本身往<code>proto</code>寻找下去的链我们就称作「原型链（prototype chain）」。这样一直往下找会找到什么时候呢？它会直到某个对象的原型为<code>null</code>为止（也就是不再有原型指向）。   </p><p>官方解释是：每个对象拥有一个原型对象，通过<code>__proto__</code>指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向<code>null</code>。这种关系被称为<strong>原型链 (prototype chain)</strong>，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p><h4 id="举个例子来帮助理解原型链"><a href="#举个例子来帮助理解原型链" class="headerlink" title="举个例子来帮助理解原型链"></a>举个例子来帮助理解原型链</h4><p>让我们实际来看个例子帮助我们了解prototype chain这个概念，这个例子只是单纯为了用来说明prototype chain的概念，实际上千万不要使用这样的方式编程！ </p><p>首先，我们先建立一个对象<code>person</code> 和一个对象<code>jay</code>：  </p><pre><code class="javascript">var person =  {   firstName :  &#39;Default&#39; ,   lastName :  &#39;Default&#39; ,   getFullName :  function ( )  {     return  this . firstName +  &#39; &#39;  +  this . lastName ;   } , } ;var jay =  {   firstName :  &#39;Jay&#39; ,   lastName :  &#39;Chou&#39; , } ;</code></pre><p>接着，我们知道<strong>所有的对象里面都会包含原型（prototype）这个对象，在JavaScript中这个对象的名称为<strong>proto</strong></strong>。如同上述原型链（prototype chain）的概念，如果在原本的对象中找不到指定的属性名称或方法时，就会进一步到<code>__proto__</code>这里面来找。  </p><p>为了示范，我们来对<code>__proto__</code>做一些事： </p><pre><code class="javascript">//千万不要照着下面这样做，这么做只是为了示范 jay . __proto__ = person ;</code></pre><p>如此，<code>jay</code>这个对象就继承了<code>person</code>对象。在这种情况下，如果我们想要呼叫某个属性或方法，但在原本<code>jay</code>这个对象中找不到这个属性名称或方法时，JavaScript引擎就会到<code>__proto__</code>里面去找，所以当接着执行如下的代码时，并不会报错： </p><pre><code class="javascript">console . log ( jay . getFullName ( ) )         // Jay Chou;</code></pre><p>我们可以得到”Jay Chou”的结果。原本在<code>jay</code>的这个对象中，是没有<code>getFullName()</code>这个方法的，但由于我让<code>__proto__</code>里面继承了<code>person</code>这个对象，所以当JavaScript引擎在<code>jay</code>对象里面找不到<code>getFullName()</code>这个方法时，它便会到<code>__proto__</code>里面去找，最后它找到了，于是它回传”Jay Chou”的结果。  </p><p>如果我是执行：  </p><pre><code class="javascript">console . log ( jay . firstName ) ;         // Jay</code></pre><p>我们会得到的是John而不是’Default’，因为JavaScript引擎在寻找<code>jay.firstName</code>这个属性时，在<code>jay</code>这个对象里就可以找到了，因此它不会在往<code>__proto__</code>里面找。<strong>这也就是刚刚在上面所的原型链（prototype chain）的概念，一旦它在上层的部分找到该属性或方法时，就不会在往下层的prototype去寻找</strong>。  </p><p>在了解了prototype chain这样的概念后，让我们接着看下面这段代码：  </p><pre><code class="javascript">var jane = {   firstName :  &#39;Jane&#39; }jane . __proto__ = person ; console . log ( jane . getFullName ( ) ) ;</code></pre><p>现在，你可以理解到会输出什么结果吗？</p><p>答案是”Jane Default” 。</p><p>因为在<code>jane</code>这个对象里只有<code>firstName</code>这个属性，所以当JavaScript引擎要寻找<code>getFullName()</code>这个方法和<code>lastName</code>这个属性时，它都会去找<code>__proto__</code>里面，而这里面找到的就是一开始建立的<code>person</code>这个对象的内容。</p><p>全代码如下：  </p><pre><code class="javascript">var person =  {   firstName : &#39;Default&#39; ,   lastName : &#39;Default&#39; ,   getFullName :  function ( ) {     return  this . firstName +  &#39; &#39;  +  this . lastName ;   } }var jay =  {   firstName : &#39;Jay&#39; ,   lastName : &#39;Chou&#39; }//千万不要照着下面这样做，这么做只是为了示范 jay . __proto__ = person ; console . log ( jay . getFullName ( ) ) ;     // Jay Chouconsole . log ( jay . firstName ) ;         // Jayvar jane = {   firstName :  &#39;Jane&#39; }jane . __proto__ = person ; console . log ( jane . getFullName ( ) ) ;</code></pre><p>以上就是目前能总结的全部了，肯定还是有缺陷的地方，后续还会修改完善的。最后再看底下这张图，是否有了更深入的理解呢？</p><p><img src="/images/prototype/6.png" srcset="/img/loading.gif" alt> </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>原型</tag>
      
      <tag>原型链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贵州黔东南之行</title>
    <link href="/2019/07/01/%E8%B4%B5%E5%B7%9E%E9%BB%94%E4%B8%9C%E5%8D%97%E4%B9%8B%E8%A1%8C/"/>
    <url>/2019/07/01/%E8%B4%B5%E5%B7%9E%E9%BB%94%E4%B8%9C%E5%8D%97%E4%B9%8B%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。</p><h4 id="镇远古镇"><a href="#镇远古镇" class="headerlink" title="镇远古镇"></a>镇远古镇</h4><p>第一站来到镇远古镇，路上听导游说这里还是一位皇帝的故乡呢！哈哈~当然不是古代的皇帝啦，其实是延禧攻略里面皇帝扮演者聂远的故乡啦😜。</p><p>我们到古城的时间也接近傍晚了，吃完晚饭散步在古城河边，天空中飘着乌云，真有一种“天青色等烟雨”的既视感了。</p><p><img src="/images/guizhou/1.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/2.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/3.jpg" srcset="/img/loading.gif" alt></p><p>河边坐落了许多充满文艺的小店和清吧。</p><p><img src="/images/guizhou/4.jpg" srcset="/img/loading.gif" alt></p><p>晚上的镇远古镇，虽说夜景和去过的其它几个古镇有些相似，但镇远独特之处在于宁静，有一种与世无争的感觉。</p><p><img src="/images/guizhou/5.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/6.jpg" srcset="/img/loading.gif" alt></p><p>在镇远古镇悠悠闲闲的一天里，给我最大的感受还是来自于它的静，很静，很舒服。</p><h4 id="西江千户苗寨"><a href="#西江千户苗寨" class="headerlink" title="西江千户苗寨"></a>西江千户苗寨</h4><p>第二站到达的西江千户苗寨，号称世界上最大的苗寨，一眼望去全是木质结构的屋子，层层叠叠错落有致。</p><p><img src="/images/guizhou/7.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/8.jpg" srcset="/img/loading.gif" alt></p><p>在苗寨里面瞎逛的途中遇到了当地苗族朋友的游行表演。</p><p><img src="/images/guizhou/9.jpg" srcset="/img/loading.gif" alt></p><p>来千户苗寨当然不能错过来自苗族朋友的热情，热情之一就是宴席上的“高山流水”，其实就是灌客人们喝甜甜的米酒，自知酒量不行，仪式开始之前就躲得远远的了哈哈，同桌几个男的就被灌了😄。</p><p><img src="/images/guizhou/10.jpg" srcset="/img/loading.gif" alt></p><p>因为苗寨难得遇到断电，“幸运地”被我们给遇上了，晚上只好回州府凯里住了，晚饭刚好感受了侗族形式的“高山流水”以及侗族的歌舞表演，表演倒是没啥好看的，不过有几个侗族小姐姐还是比较好看的~哈哈不知道她能不能看到，看到的话感觉会被打屎哦😥~</p><p><img src="/images/guizhou/11.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/12.jpg" srcset="/img/loading.gif" alt></p><h4 id="高要梯田"><a href="#高要梯田" class="headerlink" title="高要梯田"></a>高要梯田</h4><p>第三站抵达高要梯田，高要的梯田虽没有像广西龙胜、云南元阳被外界所熟知，但其美景完全不逊于前者，可惜不是金秋时节来，不然景色应该会更美。</p><p><img src="/images/guizhou/13.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/14.jpg" srcset="/img/loading.gif" alt></p><p>总体来说，此次贵州之行还是很轻松的，可惜的是没时间去到黄果树，希望下次再带她一起来哦~嘻嘻🤭。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贵州</tag>
      
      <tag>游记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之内存泄漏</title>
    <link href="/2019/06/30/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2019/06/30/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>在程序运行过程中不再用到的内存，没有及时释放，会出现内存泄漏（memory leak），会造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。   </p><p>而内存泄漏是每个开发人员最终必须面对的问题。 即使使用内存管理语言，比如C语言有着<code>malloc()</code> 和 <code>free()</code> 这种低级内存管理语言也有可能出现泄露内存的情况。  </p><p>这很麻烦，所以为了减轻编程中的负担，大多数语言提供了自动内存管理，这被称为”垃圾回收机制”（garbage collector）。   </p><h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p>现在各大浏览器通常采用的垃圾回收有两种方法：<strong>标记清除（mark and sweep）</strong>、<strong>引用计数(reference counting)</strong>。  </p><p><strong>1、标记清除</strong> </p><p>这是javascript中最常用的垃圾回收方式。  </p><p>工作原理：当变量进入执行环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。   </p><p>工作流程：  </p><ol><li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。</li><li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li><li>之后再被加上标记的变量将被视为准备删除的变量。</li><li>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。  </li></ol><p><strong>2、引用计数</strong>  </p><p>工作原理：跟踪记录每个值被引用的次数。   </p><p>工作流程：   </p><ol><li>将一个引用类型的值赋值给这个声明了的变量，这个引用类型值的引用次数就是1。</li><li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。</li><li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1</li><li>当引用次数变成0时，就表示这个值不再用到了。</li><li>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。   </li></ol><p>但如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，会导致内存泄漏。  </p><pre><code class="javascript">var arr = [1, 2, 3];console.log(&#39;hello miqilin&#39;);</code></pre><p>上面代码中，数组<code>[1, 2, 3]</code>会占用内存，赋值给了变量<code>arr</code>，因此引用次数为1。尽管后面的一段代码没有用到<code>arr</code>，它还是会持续占用内存。  </p><p>如果增加一行代码，解除arr对<code>[1, 2, 3]</code>引用，这块内存就可以被垃圾回收机制释放了。 </p><pre><code class="javascript">var arr = [1, 2, 3];console.log(&#39;hello miqilin&#39;);arr = null;</code></pre><p>上面代码中，<code>arr</code>重置为<code>null</code>，就解除了对<code>[1, 2, 3]</code>的引用，引用次数变成了0，内存就可以释放出来了。  </p><p>因此，并不是说有了垃圾回收机制，程序员就无事一身轻了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。  </p><p>接下来，我将介绍四种常见的JavaScript 内存泄漏及如何避免。目前水平有限，借鉴了国外大牛的文章了解这几种内存泄漏，原文链接：<a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="noopener">https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec</a>  </p><h4 id="四种常见的-JavaScript-内存泄漏"><a href="#四种常见的-JavaScript-内存泄漏" class="headerlink" title="四种常见的 JavaScript 内存泄漏"></a>四种常见的 JavaScript 内存泄漏</h4><p><strong>1.意外的全局变量</strong> </p><p>未定义的变量会在全局对象创建一个新变量，对于在浏览器的情况下，全局对象是<code>window</code>。 看以下代码：</p><pre><code class="javascript">function foo(arg) {     bar = &quot;this is a hidden global variable&quot;; }</code></pre><p>函数<code>foo</code>内部使用<code>var</code>声明，实际上JS会把<code>bar</code>挂载在全局对象上，意外创建一个全局变量。等同于：</p><pre><code class="javascript">function foo(arg) {     window.bar = &quot;this is an explicit global variable&quot;; }</code></pre><p>在上述情况下， 泄漏一个简单的字符串不会造成太大的伤害，但它肯定会更糟。 </p><p>另一种可以创建偶然全局变量的情况是<code>this</code>：  </p><pre><code class="javascript">function foo() {     this.variable = &quot;potential accidental global&quot;; }  // Foo called on its own, this points to the global object (window)// rather than being undefined. foo();</code></pre><p><strong>解决方法：</strong></p><p>在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，使用严格模式避免意外的全局变量，此时上例中的<code>this</code>指向<code>undefined</code>。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 <code>null</code> 或者重新定义。   </p><p><strong>2.被遗忘的计时器或回调函数</strong> </p><p>在JavaScript中使用<code>setInterval</code>非常常见。</p><pre><code class="javascript">var someResource = getData(); setInterval(function() {     var node = document.getElementById(&#39;Node&#39;);          if(node) {         // Do stuff with node and someResource.         node.innerHTML = JSON.stringify(someResource));     } }, 1000);</code></pre><p>上面的代码表明，在节点<code>node</code>或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当<code>node</code>节点被移除后，<code>interval</code> 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。   </p><pre><code class="javascript">var element = document.getElementById(&#39;button&#39;);  function onClick(event) {     element.innerHtml = &#39;text&#39;; }  element.addEventListener(&#39;click&#39;, onClick); // Do stuff element.removeEventListener(&#39;click&#39;, onClick); element.parentNode.removeChild(element); // Now when element goes out of scope,// both element and onClick will be collected even in old browsers that don&#39;t// handle cycles well.</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。其中IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 </p><p>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><p>诸如jQuery之类的框架和库在处理节点之前会删除侦听器（当使用它们的特定API时）。 这由库内部处理，并确保不会产生任何泄漏，即使在有问题的浏览器（如旧版Internet Explorer）下运行也是如此。  </p><p><strong>3.闭包</strong></p><p>JavaScript 开发的一个关键知识是闭包：这是一个内部函数，它可以访问外部（封闭）函数的变量。由于 JavaScript 运行时的实现细节，用下边这种方式可能会造成内存泄漏：  </p><pre><code class="javascript">var theThing = null; var replaceThing = function () {   var originalThing = theThing;      var unused = function () {     if (originalThing)       console.log(&quot;hi&quot;);   };      theThing = {     longStr: newArray(1000000).join(&#39;*&#39;),     someMethod: function () {       console.log(someMessage);     }   }; }; setInterval(replaceThing, 1000);</code></pre><p>每次调用<code>replaceThing</code>，<code>theThing</code>得到一个包含一个大数组和一个新闭包（<code>someMethod</code>）的新对象。同时，变量<code>unused</code>是一个引用<code>originalThing</code>的闭包（先前的<code>replaceThing</code>又调用了<code>theThing</code>）。<code>someMethod</code>可以通过<code>theThing</code>使用，<code>someMethod</code>与<code>unused</code>分享闭包作用域，尽管<code>unused</code>从未使用，它引用的<code>originalThing</code>迫使它保留在内存中（防止被回收）。需要记住的是<strong>一旦一个闭包作用域被同一个父作用域的闭包所创建，那么这个作用域是共享的</strong>。</p><p>所有这些都可能导致严重的内存泄漏。当上面的代码片段一次又一次地运行时，你可以看到内存使用量的急剧增加。当垃圾收集器运行时，也不会减少。一个链接列表闭包被创建（在这种情况下 <code>theThing</code> 变量是根源），每一个闭包作用域对打数组进行间接引用。  </p><p>解决方法：</p><p>在 <code>replaceThing</code> 的最后添加 <code>originalThing = null</code> 。将所有联系都切断。</p><p><strong>4.脱离 DOM 的引用</strong>  </p><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。如果在将来某个时候您决定删除这些行，则需要使两个引用都无法访问，都清除掉。   </p><pre><code class="javascript">var elements = {     button: document.getElementById(&#39;button&#39;),     image: document.getElementById(&#39;image&#39;),     text: document.getElementById(&#39;text&#39;) }; function doStuff() {     image.src = &#39;http://some.url/image&#39;;     button.click();     console.log(text.innerHTML);     // Much more logic} function removeButton() {     // The button is a direct child of body.     document.body.removeChild(document.getElementById(&#39;button&#39;));    // At this point, we still have a reference to #button in the global    // elements dictionary. In other words, the button element is still in    // memory and cannot be collected by the GC. }</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code>的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此<code>&lt;td&gt;</code>是表格的子节点，子元素与父元素是引用关系。由于<strong>代码保留了<code>&lt;td&gt;</code>的引用</strong>，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。  </p><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><p>在局部作用域中，等函数执行完毕，变量就没有存在的必要了，js垃圾回收机制很快做出判断并且回收，但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。  </p><p>我们在使用闭包的时候，就会造成严重的内存泄漏，因为闭包的原因，局部变量会一直保存在内存中，所以在使用闭包的时候，要多加小心。  </p><h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4><ul><li><a href="http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf" target="_blank" rel="noopener">http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf</a></li><li><a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156</a></li><li><a href="http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html" target="_blank" rel="noopener">http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html</a></li></ul><p>如果有别的关于内存泄漏好的资源，可以分享给我嘛谢谢了~   </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之内存空间</title>
    <link href="/2019/06/28/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"/>
    <url>/2019/06/28/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>对于很多没经验的前端开发来说，觉得JS反正有垃圾回收机制，很容易忽视内存空间的管理，这其实是一个大错误。</p><p>直到最近，看了阮一峰老师关于JS内存泄漏的文章，才发现自己以前写的代码，存在许多内存泄漏的问题，再者，因为忽略对内存空间的学习，导致后面很多进阶概念很模糊，比如闭包、作用域链，比如深拷贝与浅拷贝的区别等等。 </p><p><em>这里先介绍内存空间，后续还会通过别的文章来介绍深浅拷贝和内存泄漏。</em>  </p><h4 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h4><p>JavaScript的内存生命周期:  </p><pre><code>1. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还</code></pre><p>为了便于理解，我们使用一个简单的例子来解释这个周期。   </p><pre><code class="javascript">var a = 10;  // 在内存中给数值变量分配空间alert(a + 90);  // 使用分配到的内存a = null; // 使用完毕之后，释放内存空间</code></pre><p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，<strong>栈内存(stack)</strong>与<strong>堆内存(heap)</strong>。  </p><h4 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h4><p>栈(stack)是有序的，主要存放一些<strong>基本类型的变量和对象的地址</strong>，每个区块按照一定次序存放（后进先出），它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小也是确定的，并由系统自动分配和自动释放。   </p><p>因此，这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间，且寻址速度也更快。  </p><p><img src="/images/memory/1.jpg" srcset="/img/loading.gif" alt>    </p><p>堆(heap)是没有特别的顺序的，数据可以任意存放，多用于<strong>复杂数据类型（引用类型）</strong>分配空间，例如数组对象、object对象。   </p><p>其实这样说也不太准确，因为，引用类型数据的地址是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得想要访问对象的地址，然后，再通过地址指向找出堆中的所需数据。就好比书架上的书，虽然已经按顺序放好了，但我们只要知道书的名字，就可以对应的取下来。   </p><p><img src="/images/memory/2.jpg" srcset="/img/loading.gif" alt>     </p><h4 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h4><p>首先，我们来看一下代码：  </p><pre><code class="javascript">//原始类型都放在栈（stack）里//引用类型都放在堆（heap）里var a = 10;var b = &#39;lzm&#39;;var c = true;var d = { n: 22 }; //地址假设为0x0012ff7f，不代表实际地址var e = { n: 22 }; //重新开辟一段内存空间，地址假设为0x0012ff8cconsole.log(e==d); //falsevar obj = new Object(); //地址假设为0x0012ff9dvar arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]; //地址假设为0x0012ff6e</code></pre><p>为什么<code>console.log(e == d)</code>的结果为<code>false</code>？可以用下面的内存图解释：   </p><p><img src="/images/memory/3.jpg" srcset="/img/loading.gif" alt>    </p><p>变量a,b,c为基本数据类型，它们的值，直接存放在栈中，d,e,obj,arr为复合数据类型，他们的引用变量及地址存储在栈中，指向于存储在堆中的实际对象。我们是无法直接操纵堆中的数据的，也就是说我们无法直接操纵对象，我们只能通过栈中对对象的引用来操作对象，就像我们通过遥控机操作电视一样，区别在于这台电视本身并没有控制按钮。   </p><p>变量d,e虽然指向存在堆内存中对象内容的值是相等的，但是它们来自栈内存中变量地址不相同，导致<code>console.log(e == d)</code>的结果为<code>false</code>。   </p><p>这里就回到了最初的疑问，为什么原始类型值要放在栈中，而引用类型值要放在堆中，为什么要分开放置呢？单列一种内存岂不是更省事吗？那接下来，援引<a href="http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html" target="_blank" rel="noopener">这篇文章</a>里边的解释：   </p><p>记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题。堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。   </p><h4 id="比较抠细节的面试题"><a href="#比较抠细节的面试题" class="headerlink" title="比较抠细节的面试题"></a>比较抠细节的面试题</h4><p>下面的几道是关于内存空间的面试题，虽然不是特别的难，但比较扣细节你稍不注意就错了，我的建议还是老老实实画个内存图再自信的给出正确答案吧。   </p><p><strong>第一题：</strong></p><pre><code class="javascript">var a = 1 var b = a b = 2 请问 a 显示是几？ </code></pre><p><img src="/images/memory/4.jpg" srcset="/img/loading.gif" alt>     </p><p>上图中可以看出，答案为：1。在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值。<code>var b = a</code>执行之后，a与b虽然值都等于1，但是他们其实已经是相互独立互不影响的值了。 </p><p><strong>第二题：</strong> </p><pre><code class="javascript">var a = {name: &#39;a&#39;}var b = ab = {name: &#39;b&#39;}请问现在 a.name 是多少？ </code></pre><p><img src="/images/memory/5.jpg" srcset="/img/loading.gif" alt>     </p><p>上图中可以看出，答案为：”a”。因为<code>b ={name:&#39;b&#39;}</code>后相当于重新在堆内存中分配内存给对象<code>{name:&#39;b&#39;}</code>，同时栈内存中变量b的指向地址也随之变化，变量a不受影响。   </p><p><strong>第三题：</strong>  </p><pre><code class="javascript">var a = {name: &#39;a&#39;} var b = a b.name = &#39;b&#39; 请问现在 a.name 是多少？</code></pre><p><img src="/images/memory/6.jpg" srcset="/img/loading.gif" alt>    </p><p>上图中可以看出，答案为：”b”。我们通过<code>var b = a</code>执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在堆内存中访问到的具体对象实际上是同一个，因此<code>b.name =&#39;b&#39;</code>使堆内存中对象的value值变化，<code>a.name</code>的值也随之变化。  </p><p><strong>第四题：</strong> </p><pre><code class="javascript">var a = {name: &#39;a&#39;} var b = a b = null 请问现在 a 是什么？</code></pre><p><img src="/images/memory/7.jpg" srcset="/img/loading.gif" alt>    </p><p>上图中可以看出，答案为：{name: “a”}。因为<code>null</code>为基本类型，存在栈内存当中。因此栈内存中的变量b由之前指向对象的一个地址转变为<code>null</code>，变量a的地址还是指向原先的对象。  </p><p><strong>第五题：</strong> </p><pre><code class="javascript">var a = {n: 1};var b = a;a.x = a = {n: 2};a.x     // 这时 a.x 的值是多少b.x     // 这时 b.x 的值是多少</code></pre><p>答案是：<code>a.x</code> –&gt; <code>undefined</code>；<code>b.x</code> –&gt; <code>{n: 2}</code>。这道题的关键在于：</p><ol><li>优先级。<code>.</code>的优先级高于<code>=</code>，所以先执行<code>a.x</code>，堆内存中的<code>{n: 1}</code>就会变成<code>{n: 1, x: undefined}</code>，改变之后相应的<code>b.x</code>也变化了，因为指向的是同一个对象。</li><li>赋值操作是从右到左，所以先执行<code>a = {n: 2}</code>，<code>a</code>的引用就被改变了，然后这个返回值又赋值给了<code>a.x</code>，需要注意的是这时候<code>a.x</code>是第一步中的<code>{n: 1, x: undefined}</code>那个对象，其实就是<code>b.x</code>，相当于<code>b.x = {n: 2}</code></li></ol><p><img src="/images/memory/9.jpg" srcset="/img/loading.gif" alt></p><p>最后来个图总结一下：</p><p><img src="/images/memory/8.png" srcset="/img/loading.gif" alt>  </p><p>以上都是通过内存图来解释关于内存空间的知识，如有不合理的地方，希望指正一下~后续还会增加内存泄漏以及深浅拷贝的文章，敬请期待！</p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学会如何学习（三）</title>
    <link href="/2019/06/22/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2019/06/22/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第三周的学习因为拖延稍微拖了那么几天，而这周的主题又刚好是拖延症与记忆的关系。想要高效地学习，就得学会如何运用和提高自己的记忆能力，而这个过程中，必须先克服拖延症。所以上完这节课，我是该好好改改拖延的老毛病了嘻嘻~   </p><h4 id="拖延症的形成"><a href="#拖延症的形成" class="headerlink" title="拖延症的形成"></a>拖延症的形成</h4><p>我们常在那些让人不太舒服的事情上拖延，这点大家或多或少都会有，那事实结果是，拖延是一个极其重要、影响广泛的坏习惯，生活的方方面面都会受到拖延的影响。  </p><p><img src="/images/learn3/1.jpg" srcset="/img/loading.gif" alt>     </p><p>这里要强调一下，很多人觉得能靠自己的意志力去战胜拖延症，其实这是适得其反的。人每天的意志力是有限的，调用意志力去克服一件困难的事，会大量消耗能量。为什么拖延症这么容易就产生，是因为它变成了习惯，习惯是不需要意志力去执行的，它能减少大脑的消耗。所以改变习惯，是改变拖延症的正确方法。   </p><h4 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h4><p>习惯可以分为四个阶段：  </p><p><img src="/images/learn3/2.jpg" srcset="/img/loading.gif" alt>   </p><p>第一阶段是<strong>提示 (cue)</strong> ，是指引发你进行某种惯例的信息来源。比如朋友发来的一条微信信息，或是你看到了待办事项清单上的第一件事等等。   </p><p>第二个阶段就是<strong>惯例 (routine)</strong>，是指你对提示做出的惯性反应。比如看到微信信息就觉得要立马停下手头上的事情去回信息；看到待办的事情就想着当下去解决掉它。这里一个好的建议是，你可以通过关掉手机或者断网，或者远离其他占用碎片时间的消遣来隔离那些最具杀伤力的信号，就像你在进行番茄工作法那样。   </p><p>第三阶段是<strong>奖励 (reward)</strong>，是指你做完这个惯例之后得到的反馈，它会刺激你不断按照之前的惯例行事。任何一种习惯得以发展和延续都是因为它可以回报我们，它会立即给我们带来些许愉悦感。拖延是极易产生的习惯，因为你将关注点转向更令人愉悦的事情后，随之而来的奖励迅速而又简单。好习惯也是有奖励的，对于克服拖延症来说，想办法奖励好习惯非常重要，<strong>只有当大脑开始期待那个奖励，旧习惯才能得到重置，你才能养成新习惯</strong>。    </p><p>研究发现需要给奖励设定时间点。比如说，午休与朋友到快餐店吃饭，或是在下午5点结束主要的任务。这样小而实在的截止期限可以激励你很好地去工作。   </p><p>第四阶段是<strong>信念 (belief)</strong> 。改变拖延习惯最重要的一点就是“相信自己能够做到”的这个信念，就好比说必须要摒弃“自己不是学这块知识的料”这一习惯想法，而是要保持自己能够学好的信念并为之做出应有的努力。   </p><h4 id="应对生活和学习"><a href="#应对生活和学习" class="headerlink" title="应对生活和学习"></a>应对生活和学习</h4><p>要保持对学习目标的展望，一个很好的办法是每周写下本周关键任务列表，试着在前一晚写下第二日的任务，为什么要在前一晚呢？ 研究表明，这可以让你在潜意识下设法解决任务，从而找到完成方法。  </p><p>列下任务清单后，每天花一个或几个番茄钟的时间完成它们。如果可以短时间完成的任务，可以采用结果导向，如果不是则关注过程。你不必一定要设置25分钟的番茄钟，比如22分钟也是可行的。   </p><p>其实，<strong>当你能对一定时间内自己可以完成的工作量做出较准确的判断时，你将很快进步</strong>。计划好完成目标的时间是合理且最为重要的一点，计划你的休息时间和计划工作时间也同样重要，就是在努力学习之余保持健康休闲时间的人，其表现往往胜过那些一味努力学习的人，所以从现在开始，在努力工作学习之余试着挤出点休息时间吧！   </p><p>芭芭拉老师还建议在<strong>早晨尽量先开始最重要且最讨厌，最难的工作，至少做一个番茄时间，这证明了极其有效</strong>！有时会发生一些意料之外的事，我们当然需要对计划作出改变，但是请记住幸运法则——<strong>幸运女神会眷顾努力之人</strong>。良好的计划也是努力的一部分，关注学习目标，尽量避免因为偶发事件产生的不确定性。   </p><p><img src="/images/learn3/3.jpg" srcset="/img/loading.gif" alt>     </p><h4 id="提高记忆力"><a href="#提高记忆力" class="headerlink" title="提高记忆力"></a>提高记忆力</h4><p>改变了拖延症的坏习惯后，我们才能更好地利用记忆去学习。我们的大脑天生就擅长记忆不同的空间信息，如果你受邀参观一所陌生的房子 ，你会很快对这个房子有一个大致的概念。例如，整体的家具布局、房间位置、颜色的搭配。只需几分钟，你的大脑就能获取并存储数以千计的信息，甚至几周后，就算你面对是一堵白墙，也仍然能记起许多细节。这一系列空间信息，帮助你在脑中形成地图。如果能够<strong>充分发挥天生就很强大的视觉和空间记忆能力</strong>，你的记忆潜能就可以得到极大提高。   </p><p>评判一个人的记忆力好坏，主要看他的长期记忆的能力如何，每个人都可以通过集中注意力使某件事物进入你的临时工作记忆，但<strong>从工作记忆进入长期记忆则要满足两个条件。首先它要令人难忘，其次，信息需要复习和回顾</strong>。那如何让它难忘呢？比如记F=ma（力=质量x加速度）这个物理公式，老师把它想象成一只戴着飞行员眼镜的驴(a flying mule，英文首字母对应公式的简写)，躺在她老家厨房的水槽里，这样就完成了把抽象概念变成具体图像。这个比喻是不是很无厘头啊哈哈，所以说记忆大师们都是一些幻想家。   </p><p><img src="/images/learn3/4.jpg" srcset="/img/loading.gif" alt>     </p><p>记忆宫殿（Mind Palace / Memory Palace）就是这么一个虚拟的，让你储存信息的技巧工具。你可以把熟悉的场景，比如你的家，作为一个放置记忆碎片的地方，然后把要记的抽象的东西，通过联想，组团，转化成具体图像，放在那个场景中的某个地方。而且这个图像不需要阐述你要记住的东西的意义，甚至它越是不合常理，越稀奇古怪，效果就越好。因为大脑通常会滤过习以为常的事物，而对令人惊讶的非典型性事件记忆犹新。   </p><p>比如购物清单上要买的牛奶、面包、鸡蛋，使用这个技巧你可以想象在你的家中，有一大瓶牛奶在前门，面包掉到了沙发上，裂了的鸡蛋从咖啡桌边缘滴落。也就是说，你可以想象自己穿过一个熟悉的地方，伴随着一些与要记忆的物体相关的难忘画面，这种记忆方式往往记得很牢。   </p><p>题外话，爱看港剧的朋友，相信对TVB剧《读心神探》中的记忆宫殿印象深刻。第三集中有一段对记忆方法的特写，我们一起来细究一下吧！第三集刚开始的时候讲的就是记忆人名头像。那么记忆人名第一步就是观察人物的长相特征，这个特征可以看人物穿的衣服，戴的装饰品，五官的长相特点，发型，声音的特色等等，找出特点以后第二步就是对人物的名字进行联想。比如有个人叫袁泉，而正好她戴了一对圆圆的耳环，那么就很容易联想到“圆圈”（利用名字的谐音记忆）；又比如有人叫邓超，那么你可以联想到这个和你初识时，眼睛“邓”的超大的痴痴的望着你，只要你这么一想，那么这个人物名字肯定就在你脑海里留下了深刻的印象，虽然有点点毛骨悚然哈哈。   </p><p><img src="/images/learn3/5.jpg" srcset="/img/loading.gif" alt>    </p><p>看完上面举得例子也许会有人会问你那些名字和特征都是你事先设想好的，所以才容易发现名字与特征之间的联系，但其实这些都是临时想到的真实案例，<strong>其实我们能够观察到的特征是有限的，但是人的想象是无限的</strong>，只要你的想法足够好那肯定能找到一个人物的特征与名字之间的完美契合点，这也是记忆法的精髓。   </p><p>最后，在这一周的课外采访中，受采访者是一名美国记忆比赛的冠军，他是“记忆宫殿”这个技巧的专家。他给大家的学习建议是——保持孩童般的想象力与好奇心，通过新奇的想象来帮助你记忆，让学习变得有趣和容易。大家从现在开始不妨试一试~   </p><p>下一节课我们会学习复兴式学习与潜力的关系。</p>]]></content>
    
    
    <categories>
      
      <category>学习之道</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效学习</tag>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Undefined vs Null</title>
    <link href="/2019/06/17/Undefined%20vs%20Null/"/>
    <url>/2019/06/17/Undefined%20vs%20Null/</url>
    
    <content type="html"><![CDATA[<p>在JavaScript中，将一个变量赋值为undefined或null，感觉没啥区别，都表示“无”；但在实际应用中，远非如此，这两个之间区别的不明确可能会导致一些问题。</p><p><em>在<a href="https://luozongmin.com/2019/04/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">这篇文章</a>中，我已经简略介绍了<code>undefined</code>和<code>null</code>的特性了。</em></p><p>本文将探讨JavaScript中<code>undefined</code>和<code>null</code>之间的相似和差异之处。  </p><h4 id="相似性"><a href="#相似性" class="headerlink" title="相似性"></a>相似性</h4><p>（1）<code>undefined</code>和<code>null</code>在if语句中，都会被自动转为<code>false</code>，加!转换为<code>true</code>，相等运算符对于两者比较是相等的。  </p><pre><code class="javascript">if (!undefined)     console.log(&#39;undefined is false&#39;);// undefined is falseif (!null)     console.log(&#39;null is false&#39;);// null is falseundefined == null// true</code></pre><p>（2）在JavaScript中，只有六个falsy值，<code>null</code>和<code>undefined</code>都包含在六个falsy值中，当进行逻辑判断时所有的Falsy值均为false。   </p><ul><li>false</li><li>0</li><li>‘’ (空字符串，’’和””一样)</li><li><strong>null</strong></li><li><strong>undefined</strong></li><li>NaN</li></ul><p>除了这六个值，JavaScript中的任何其他值都被认为是truthy值，当进行逻辑判断时均为true。  </p><p>（3）同样在JavaScript中，有六个原始值，<code>null</code>和<code>undefined</code>都包含在这六个原始值中。  </p><ul><li>Boolean</li><li><strong>Null</strong></li><li><strong>Undefined</strong></li><li>Number</li><li>String</li><li>Symbol</li></ul><p>既然<code>undefined</code>和<code>null</code>的含义与用法都比较相似，那为什么还要无端增加另外一个值，这不是增加混淆吗？   </p><h4 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h4><p>最近，在阅读阮一峰老师的博客文章时，才从历史因素里得到答案！  </p><p>1995年JavaScript诞生之初，像Java一样，只设置了<code>null</code>作为表示”无”的值。  </p><p>根据C语言的传统，<code>null</code>被设计成可以自动转为0。  </p><pre><code class="javascript">Number(null)// 06 + null// 6</code></pre><p>但是，JavaScript的设计者Brendan Eich，觉得这样做达不到自己的预想，其中有两个原因。   </p><p>首先，<code>null</code>像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。  </p><p>其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果<code>null</code>自动转为0，很不容易发现错误。  </p><p>因此，Brendan Eich又设计增加了一个<code>undefined</code>。  </p><h4 id="差异性"><a href="#差异性" class="headerlink" title="差异性"></a>差异性</h4><p><strong>（1）数据类型区别</strong>  </p><p><code>undefined</code>类型只有一个值，undefined；<code>null</code>类型只有一个值，null。  </p><p>也就是说<code>undefined</code>值和<code>null</code>值分别属于不同的数据类型，并且这两个数据类型都只有一个值，使用“typeof”运算符判断类型。  </p><pre><code class="javascript">console.log(typeof undefined);  // undefinedconsole.log(typeof null);   // object </code></pre><p>第一行输出没毛病，正确打印出<code>undefined</code>类型；而第二行打印结果为<code>object</code>，难道<code>null</code>不是<code>null</code>类型？  </p><p>原因解释：这是JS一个设计失误，原本正确的结果应该是<code>null</code>，现在只能将错就错，或许以后哪个新版本会修正此问题。   </p><p><strong>（2）转为数值区别</strong>  </p><p>JavaScript的最初版本为了更好区分这两个值，是这样设定的：<code>null</code>是一个表示”无”的对象，转为数值时为0；<code>undefined</code>是一个表示”无”的<strong>原始值</strong>，转为数值时为<code>NaN</code>。  </p><pre><code class="javascript">var a1= 5 + null;console.log(a1)  // 5var a2= 5 + undefined;console.log(a2)  // NaN</code></pre><p><strong>（3）null !== undefined</strong>   </p><p>如上所见，<code>null</code>和<code>undefined</code>不同，但有一些相似之处， 因此，ECMAScript规范规定<code>null</code>不严格等于<code>undefined</code>。   </p><pre><code class="javascript">null !== undefined  // truenull === undefined  // false</code></pre><p>但是，上面也提到了，<code>null</code>松散相等于<code>undefined</code>（相比===的相等程度更低）。   </p><pre><code class="javascript">null == undefined  // true</code></pre><p>在JavaScript中，==适用松散相等，意味着我们在将它们转换为通用类型后比较两个值。   </p><p>只要记住<code>null==undefined</code>会返回<code>true</code>，因为它们是类似的值；但<code>null===undefined</code>会返回<code>false</code>，因为它们是不同类型的值。后续也会增加==与===区别的文章，敬请期待。  </p><h4 id="实际用法"><a href="#实际用法" class="headerlink" title="实际用法"></a>实际用法</h4><p>但是，上面的区分，在实践中都不常用。实际上，<code>null</code>和<code>undefined</code>被视为几乎同义的，只有一些细小的差别。  </p><p><strong>null表示一个变量被人为的设置为空对象，而不是原始状态，即该处不应该有值。</strong>一般会在以下 2 种场景中出现：</p><p>（1） 利用document.getElementById(‘XXX’) 寻找一个不存在的元素，将返回null。  </p><pre><code class="javascript">console.log(null == document.getElementById(&#39;notExistElement&#39;))  // true</code></pre><p>（2） 作为对象原型链的终点。  </p><pre><code class="javascript">Object.getPrototypeOf(Object.prototype)  // null</code></pre><p><strong>undefined表示一个变量自然的、最原始的状态值，就是此处应该有一个值，但是还没有定义。</strong>一般会在以下 4 种场景中出现：  </p><p>（1）声明了一个变量，但没有赋值，就等于<code>undefined</code>。  </p><pre><code class="javascript">var aconsole.log(a) // undefined</code></pre><p>（2) 函数定义了形参，但没有传递实参，该参数等于<code>undefined</code>。  </p><pre><code class="javascript">//函数定义了形参 a function f(a) {     console.log(a); // undefined }  f(); //未传递实参</code></pre><p>（3）访问对象上不存在的属性，该属性的值为<code>undefined</code>。  </p><pre><code class="javascript">var  a = new Object()a.p // undefined</code></pre><p>（4）函数没有返回值时，默认返回<code>undefined</code>。</p><pre><code class="javascript">var a = f()a // undefined</code></pre><p>所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 <code>undefined</code>，当需要<strong>释放一个对象</strong>时，直接赋值为 <code>null</code> 即可。 </p><p>最后引用玉伯大大对null和undefined的解释：  </p><p>值类型的“虚无”用<code>undefined</code>，引用类型的“虚无”，用<code>null</code>。   </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之类型转换</title>
    <link href="/2019/06/15/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2019/06/15/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 是一种<strong>弱类型</strong>或者说是一门<strong>动态</strong>语言，这意味着你不用提前声明变量的类型，而是在程序运行过程中，运算符会自动将值转换为正确的类型，但也有一些情况需要强制类型转换。</p><p>以下我将介绍将各种类型的值，分别转换成<strong>数字</strong>、<strong>字符串</strong>或者<strong>布尔值</strong>（基于ES5规范）。   </p><h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h4><p><strong>（1）Number()</strong>   </p><p>使用Number函数，可以将任意类型的值转化成数值。   </p><pre><code class="javascript">//数值Number(123)  // 123  转换后为原值//字符串Number(&#39;123&#39;)  // 123  转换为相应的数值，前提能被解析为数值//字符串Number(&#39;123abc&#39;)   // NaN  如果不能被解析为数值，则返回 NaN//布尔值Number(true)  // 1Number(false)  // 0//undefinedNumber(undefined)  // NaN//nullNumber(null)  // 0//对象Number({a: 1}) // NaNNumber([5]) // 5  //包含单个数值的数组将返回数字</code></pre><p><strong>（2）ParseInt()</strong>   </p><p><code>parseInt</code>函数可用于将字符串转为整数。   </p><pre><code class="javascript">parseInt(&#39;123&#39;)  // 123parseInt(&#39;   123&#39;)  // 123  如果字符串头部有空格，空格会被自动去除parseInt(1.23)  // 1  如果参数不是字符串，则会先转为字符串再转换parseInt(&#39;8a&#39;)  //  8  如果遇到不能转为数字的字符，就不再进行下去，返回可转的部分parseInt(&#39;abc&#39;)  // NaN  如果第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaNparseInt(&#39;+1&#39;) // 1parseInt(&#39;1000&#39;, 10) // 1000  第二个参数（2到36之间），表示被解析的值的进制</code></pre><p>如上，<code>Number()</code>函数会整体将目标字符串转为数值，只要有一个字符无法转成数值，目标就会被转为<code>NaN</code>，这点要比<code>parseInt()</code>函数严格很多。   </p><p>这里要注意一点，就是转换’011’时看起来01结构是8进制，实际上JS经过升级，后面加逗号8才是转为8进制或其他进制。   </p><pre><code class="javascript">parseInt(&#39;011&#39;)  // 11parseInt(&#39;011&#39; , 8)  // 9</code></pre><p><strong>（3）ParseFloat()</strong><br><code>parseFloat</code>函数用于将一个字符串转为浮点数。   </p><pre><code class="javascript">parseFloat(&#39;3.14&#39;)  //  3.14parseFloat(&#39;3.14more&#39;) // 3.14  如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分parseFloat([]) // NaNparseFloat(&#39;AAA&#39;) // NaNparseFloat(&#39;&#39;) // NaN  如果参数不是字符串或空，亦或字符串的第一个字符不能转化为浮点数，则返回NaN</code></pre><p>上面代码中，尤其注意的是，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。  </p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。  </p><pre><code class="javascript">Number(true) // 1parseFloat(true)  // NaNNumber(null) // 0parseFloat(null) // NaNNumber(&#39;&#39;) // 0parseFloat(&#39;&#39;) // NaNNumber(&#39;1.23A&#39;) // NaNparseFloat(&#39;1.23A&#39;) // 1.23</code></pre><p><strong>（4）字符串减0</strong>   </p><p>字符串数字后直接减一个0，可将字符串转为数值。  </p><pre><code class="javascript">&#39;1&#39; - 0  // 1&#39;123&#39; - 0  // 123&#39;1.23&#39; - 0  // 1.23&#39;12A&#39; - 0  // NaN  字符串里不是数字，则返回NaN&#39;null&#39; - 0  // NaN</code></pre><p>上面代码中，字符串减0操作既有<code>parseInt</code>、也有<code>parseFloat</code>的功能。   </p><p>还比较省代码数量，在实际应用中会比较常见。   </p><p><strong>（5）字符串前加+</strong>   </p><p>字符串数字前加一个+，可将字符串转为数字。   </p><pre><code class="javascript">+ &#39;1&#39; // 1+ &#39;1.23&#39; // 1.23+ &#39;.1&#39; // 0.1+ &#39;-1&#39; // -1+ &#39;12A&#39; // NaN</code></pre><p>上面代码中，字符串前加+操作也有<code>parseInt</code>和<code>parseFloat</code>的功能。  </p><h4 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h4><p><strong>（1）toString()</strong>   </p><pre><code class="javascript">// 数值var a = 123a.toString()  // &quot;123&quot;// 布尔值var a = truea.toString()  // &quot;true&quot;// undefinedvar a = undefineda.toString()  // 报错// nullvar a = nulla.toString()  // 报错// 对象var a = {}a.toString()  // &quot;[object Object]&quot;</code></pre><p>上面代码中，注意一点<code>null</code>、<code>undefined</code>用<code>toString()</code>转为字符串是不行的，而且<code>toString()</code>方法占的字节较多，那么有别的解决方法吗？   </p><p><strong>（2）加’’(双引号)</strong>   </p><p>当然有，更常用的转为字符串方法为：  </p><pre><code class="javascript">// 数值1 + &#39;&#39;  // &quot;1&quot; &#39;&#39; + 1  // &quot;1&quot; // 布尔值true + &#39;&#39; // &quot;true&quot;&#39;&#39; + true // &quot;true&quot;// undefinedundefined + &#39;&#39;  // &quot;undefined&quot;// nullnull + &#39;&#39;  // &quot;null&quot;// 对象var obj = {}obj + &#39;&#39;  // &quot;[object Object]&quot;[1, 2, 3] + &#39;&#39;  // &quot;1,2,3&quot;  数组，返回该数组的字符串形式</code></pre><p>相比<code>toString()</code>方法，这种方法更为常用，且和前后加’’的顺序无关。   </p><p><strong>（3）String()</strong>   </p><p><code>String</code>函数可以将任意类型的值转化成字符串。  </p><pre><code class="javascript">// 数值String(123) // &quot;123&quot;// 布尔值String(true) // &quot;true&quot;// undefinedString(undefined) // &quot;undefined&quot;// nullString(null) // &quot;null&quot;// 对象String({a: 1}) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot;  数组，返回该数组的字符串形式</code></pre><h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p><strong>（1）Boolean()</strong>  </p><p><code>Boolean</code>函数可以将任意类型的值转为布尔值。   </p><p>它的转换规则比较简单：除了以下五个<code>falsy</code>值的转换结果为<code>false</code>，其余的值全部为<code>true</code>。   </p><pre><code class="javascript">Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // false 包括+0、-0Boolean(NaN) // falseBoolean(&#39;&#39;) // false 和&quot;&quot;一样都为空字符串，这里当成同一种</code></pre><p>所以的话，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>。  </p><pre><code class="javascript">Boolean({}) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true</code></pre><p>这里需要注意的是，<code>Boolean()</code>操作对于’’和’ ‘（中间有空格）的结果是不一样的：  </p><pre><code class="javascript">Boolean(&#39;&#39;)  // falseBoolean(&#39;  &#39;)  // true 因为中间有空格，代表有空格键输入，不算真正意义上的无内容</code></pre><p><strong>（2）类型值前加！！</strong>   </p><p>任何数据类型值前面加两个！！，都可以将其转为布尔类型。   </p><pre><code class="javascript">!!undefined // false!!null // false!!0 // false !!NaN // false!!&#39;&#39; // false </code></pre><p>从<code>Boolean()</code>九个字符变为！！两个字符，省了代码量；转换规则也与<code>Boolean</code>函数一致，故老手多用此类方法。  </p><p>目前总结的就这么多啦，如有一些遗漏或有误的地方，欢迎大家指正~</p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之类型判断</title>
    <link href="/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <url>/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>类型判断在 web 开发中较为常见，简单的有判断数字还是字符串，判断是数组还是对象稍微复杂一些，再复杂一点的有判断日期、正则、错误类型，再再复杂一点还有比如判断 plainObject、空对象、Window 对象等等。  </p><p>通过本文，我将尝试概述Javascript中类型判断的几种方法（<strong>基于ES5的规范</strong>）。</p><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>typeof判断类型方法算是我们最最常用的了，直接上代码：   </p><pre><code class="javascript">typeof 3 // &quot;number&quot;typeof &quot;abc&quot; // &quot;string&quot;typeof {} // &quot;object&quot;typeof true // &quot;boolean&quot;typeof undefined // &quot;undefined&quot;typeof function(){} // &quot;function&quot;</code></pre><p>以上这些类型都比较正常，直到：   </p><pre><code class="javascript">typeof null // &quot;object&quot;</code></pre><p>这显然是一个错误。 这可能会在以后的ECMAScript哪个版本中修复，返回值将为“<code>null</code>”。   </p><p>除此之外 <code>Object</code> 下还有很多细分的类型，比如 <code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code> 等。如果用 <code>typeof</code> 去检测这些类型，举其中几个例子：   </p><pre><code class="javascript">var array1 = []var array2 = new Array();var date = new Date();var error = new Error();console.log(typeof array1); // objectconsole.log(typeof array2); // objectconsole.log(typeof date); // objectconsole.log(typeof error); // object</code></pre><p>因此，<code>typeof</code>非常善于区分不同类型的原始值，并区分它们和对象，但在区分不同类型的对象（包括数组和<code>null</code>）时完全没用，那这该怎么区分？有没有更好的解决方法呢？</p><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><p>JS作为一门愈加成熟的语言，解决方法当然有！嘿嘿~这就是<code>Object.prototype.toString</code>！  </p><p>那 <code>Object.protototype.toString</code>看起来是一长串字母，看起来比较复杂诶~为了讲清楚，在<strong>toString</strong>方法被调用时,是会执行下面的操作步骤的：  </p><ol><li>如果<code>this</code>的值为<code>undefined</code>,则返回”[<code>object Undefined</code>]”.</li><li>如果this的值为<code>null</code>,则返回”[<code>object Null</code>]”.</li><li>让O成为调用<code>ToObject(this)</code>的结果.</li><li>让class成为O的内部属性<code>[[Class]]</code>的值.</li><li>最后返回由 <code>&quot;[object &quot;</code>和 <code>class</code> 和 <code>&quot;]&quot;</code> 三个部分组成的字符串.    </li></ol><p>通过规范，我们至少了解了调用 <code>Object.prototype.toString</code> 最终会返回一个由 <code>&quot;[object &quot;</code> 和 <code>class</code> 和 <code>&quot;]&quot;</code> 组成的字符串，而 <code>class</code> 是要判断的对象的内部属性。</p><p>看这些规范还是一知半解的状态吧，直接上代码直观一点：   </p><pre><code class="javascript">console.log(Object.prototype.toString.call(3)) // [object Number]console.log(Object.prototype.toString.call([1, 2, 3])) // [object Array]console.log(Object.prototype.toString.call({})) // [object Object]console.log(Object.prototype.toString.call(null)) // [object Null]var date = new Date();console.log(Object.prototype.toString.call(date)) // [object Date]</code></pre><p>我们可以看到这个 class 值其实就是识别对象类型的关键！    </p><p>因此我们可以用 <code>Object.prototype.toString</code> 方法识别出更多类型！那到底能识别多少种类型呢？那还是看代码数个数吧~嘿嘿    </p><pre><code class="javascript">var number = 1;          // [object Number]var string = &#39;123&#39;;      // [object String]var bool = true;      // [object Boolean]var unde = undefined;     // [object Undefined]var nul = null;          // [object Null]var obj = {}         // [object Object]var array = [];   // [object Array]var date = new Date();   // [object Date]var error = new Error(); // [object Error]var reg = /a/g;          // [object RegExp]var func = function a(){}; // [object Function]function checkTypes() {    for (var i = 0; i &lt; arguments.length; i++) {        console.log(Object.prototype.toString.call(arguments[i]))    }}checkTypes(number, string, bool, unde, nul, obj, array, date, error, reg, func)//打印出[object Number][object String][object Boolean][object Undefined][object Null][object Object][object Array][object Date][object Error][object RegExp][object Function]</code></pre><p>除了以上 11 种之外，还有3种：   </p><pre><code class="javascript">console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]function a() {    console.log(Object.prototype.toString.call(arguments)); }a(); // [object Arguments]</code></pre><p>这里看我们至少可以识别14 种类型，而[[class]] 属性数量至少有 12 个。</p><h4 id="写个类库"><a href="#写个类库" class="headerlink" title="写个类库"></a>写个类库</h4><p>利用<code>Object.prototype.toString</code>判断类型的方法来写个类库吧，此类库来自(Axis.js)[//github.com/toddmotto/axis]:   </p><pre><code class="javascript">(function (root, factory) {  // 判断是否使用了模块  if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {    // 使用AMD模块    define(factory);  } else if (typeof exports === &#39;object&#39;) {    // 使用CMD模块    module.exports = factory;  } else {    // 没有使用模块，放在全局下    root.axis = factory();  }})(this, function () {  // 严格模式  &#39;use strict&#39;;  var exports = {};  // 将字符串转为数组  var types = &#39;Array Object String Date RegExp Function Boolean Number Null Undefined&#39;.split(&#39; &#39;);  // 判断类型  var type = function () {    return Object.prototype.toString.call(this).slice(8, -1);  };  // 遍历types，为exports对象添加isArray、isObject...等方法  for (var i = types.length; i--;) {    exports[&#39;is&#39; + types[i]] = (function (self) {      return function (elem) {        // type.call(elem)将type方法里的this指针指向elem        return type.call(elem) === self;      };    })(types[i]);  }  return exports;});</code></pre><p>使用方法也比较简单，直接上代码：  </p><pre><code class="javascript">axis.isArray([]); // trueaxis.isObject({}); // trueaxis.isString(&#39;&#39;); // trueaxis.isDate(new Date()); // trueaxis.isRegExp(/test/i); // trueaxis.isFunction(function () {}); // trueaxis.isBoolean(true); // trueaxis.isNumber(1); // trueaxis.isNull(null); // trueaxis.isUndefined(); // true</code></pre><p>考虑到实际情况下并不会检测 <code>Math</code> 和 <code>JSON</code>，而且上面这种方法也检测不了这两种类型，所以去掉这两个类型的检测。同时也不能识别自定义对象类型。</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>当 <code>typeof</code> 也有无解的时候，那么我们是否还有其他好的方法来判断一个变量是自定义对象类型呢？  </p><p>我们知道，javascript 的所有对象都有一个 <code>constructor</code> 属性，这个属性可以帮我们判断 object 数据类型，直接上代码：   </p><pre><code class="javascript">//alert(1.constructor); //报错 数字常量无 constructor 属性   var num = 1;   console.log(num.constructor == Number); //true   console.log(&quot;miqilin&quot;.constructor == String); //true   var str = &quot;miqilin&quot;;   console.log(str.constructor == String); //true   var obj= null;   console.log(obj.constructor); //报错，null 没有 constructor 属性   var none = undefined;   console.log(obj.constructor); //报错，undefined 没有 constructor 属性  </code></pre><p>可以看出，数字型常量，<code>null</code> 和 <code>undefined</code> 都没有 <code>constructor</code> 属性。  </p><p>之前以为到这就全部分析完了，看了多篇外文才知道原来还有可挖掘的东西，来看下面的代码：   </p><pre><code class="javascript">function Animal() {   }   function Cat() {   }   Cat.prototype = new Animal();   Cat.prototype.CatchMouse = function () {   //do some thing   }   var obj = new Cat();   console.log(obj.constructor == Cat); //false ？？因为 Cat.prototype不在obj的原型链上   console.log(obj.constructor == Animal); //true 理解 </code></pre><p>原来对于<strong>原型链继承</strong>的情况，<code>constuctor</code> 也不怎么好用了。那怎么办呢？  </p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>嘿嘿~原来还有一种方法可以解决这种困境，那就是 <code>instanceof</code>。<code>instanceof</code> 运算符会告诉您对象是否是某种类型的实例， 这里所谓的“类型”其实就是构造函数。直接上代码：  </p><pre><code class="javascript">function Animal() {   }   function Cat() {   }   Cat.prototype = new Animal();   Cat.prototype.CatchMouse = function () {   //do some thing   }   var obj = new Cat();   console.log(obj instanceof Cat); //true 毫无疑问   console.log(obj instanceof Animal); //true 可以理解</code></pre><p><code>instanceof</code> 适用于所有原生类型：</p><pre><code class="javascript">[1, 2, 3] instanceof Array // true/abc/ instanceof RegExp // true({}) instanceof Object // true(function(){}) instanceof Function // true</code></pre><p>但是 <code>instanceof</code> 不适用于原始类型：字符串，数字，布尔值：  </p><pre><code class="javascript">3 instanceof Number // falsetrue instanceof Boolean // false&#39;abc&#39; instanceof String // false</code></pre><p>所以这里<code>constructor</code>又有点优势了，可以适用于原始类型<code>number</code>，<code>string</code>和<code>boolean</code>的判断（<code>constructor</code>小节有例子）。    </p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>虽然检查任何一种特定类型真的不是那么难，但你可能不得不在此过程中做出很多选择，势必会引起一些混乱。因此，了解所有不同的选项会有所帮助，以下是对四种方法可识别类型的简单概括：</p><p><strong>typeof：</strong></p><ul><li>可以是标准类型（<code>Null</code> 除外）</li><li>不可识别具体的对象类型（<code>Function</code> 除外）</li></ul><p><strong>Object.prototype.toString：</strong></p><ul><li>可是识别标准类型及内置对象类型（例如，<code>Object</code>, <code>Date</code>, <code>Array</code>）</li><li>不能识别自定义对象类型</li></ul><p><strong>constructor：</strong></p><ul><li>可以识别标准类型（<code>Undefined</code>/<code>Null</code> 除外）</li><li>可识别内置对象类型</li><li>可识别自定义对象类型</li></ul><p><strong>instanceof：</strong></p><ul><li>不可判别原始类型</li><li>可判别内置对象类型</li><li>可判别自定义对象类型</li></ul><p>类型转换的<strong>图形化</strong>表示（其中红色单元格表示该判断方式不支持的类型）：  </p><p><img src="/images/judge/1.png" srcset="/img/loading.gif" alt>  </p><p>还有更复杂的判断比如 <code>plainObject</code>、空对象、<code>Window</code>对象、类数组对象等，还未涉及，后续也会增加。 敬请关注！  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列之数据类型</title>
    <link href="/2019/06/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/06/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>JavaScript提供了不同的数据类型来保存不同类型的值，主要有两种类型的数据类型：原始类型和引用类型。    </p><h4 id="原始类型（值类型）"><a href="#原始类型（值类型）" class="headerlink" title="原始类型（值类型）"></a>原始类型（值类型）</h4><ul><li>Undefined <code>undefined</code></li><li>Null <code>null</code></li><li>Boolean <code>true</code></li><li>String <code>&#39;hello&#39;</code></li><li>Number <code>123</code></li><li>Symbol(这里先不做介绍)  </li></ul><h4 id="引用类型（对象类型）"><a href="#引用类型（对象类型）" class="headerlink" title="引用类型（对象类型）"></a>引用类型（对象类型）</h4><ul><li>Object：由以上几种基本类型组成，而且对象里面还可以包含对象   </li></ul><pre><code class="JavaScript">var obj = {};&lt;!-- 原始类型变量的包装类型如下 --&gt;var bool = new Boolean(true);var str = new String(&quot;hello&quot;);var num = new Number(1);var obj0 = new Object();</code></pre><p>如<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">MDN</a>所讲，JavaScript 是一种<strong>弱类型</strong>或者说是一门<strong>动态</strong>语言。这意味着你不用提前声明变量的类型，而是在程序运行过程中，类型会被自动确定。  </p><p>当然，原始类型和引用类型会有一些<strong>区别</strong>：  </p><p>原始类型的值是直接储存在栈（Stack）内存中的，而引用类型的数据是把 Heap内存地址存在 Stack 里，所以对已引用类型的复制其实只是复制了相同的地址而非实际的变量值。   </p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>为整型直接量，浮点型直接量，十六进制直接量（0x-)，八进制直接量（0-）等 出现场合：  </p><ul><li><code>1024</code></li><li><code>3.14</code></li><li><code>1.2e5</code></li><li><code>0x10</code></li><li><code>0o377</code></li></ul><p>除以上常规数字外，还有所谓的“特殊数值”，它们也属于这种数据类型：<code>Infinity</code>，<code>-Infinity</code>和<code>NaN</code>。  </p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>JavaScript中的字符串必须用引号括起来，有3种类型的引号 出现场合：  </p><pre><code class="JavaScript">var str = &quot;Hello, world!&quot;;  //双引号var str = &#39;Hello, world!&#39;; //单引号var str = `Hello, world!`;  //反引号</code></pre><p>双引号和单引号是“简单”引号，它们在JavaScript中没有区别，但由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。   </p><p>反引号是“扩展功能”的引用，允许我们通过将变量和表达式包装在$ {…}中来将它们嵌入到字符串中，比如：  </p><pre><code class="JavaScript">var name = &quot;miqilin&quot;;// embed a variableconsole.log( `Hello, ${name}!` ); // Hello, miqilin!// embed an expressionconsole.log( `the result is ${1 + 2}` ); // the result is 3 </code></pre><p>加反引号后计算<code>$ {...}</code>内的表达式，结果会成为字符串的一部分。 我们可以在其中放置任何东西：像名称这样的变量或像1 + 2这样的算术表达式或更复杂的东西。   </p><p>但请注意，这只能在反引号中完成。 其他形式没有这种嵌入功能！  </p><pre><code class="JavaScript">console.log( &quot;the result is ${1 + 2}&quot; ); // the result is ${1 + 2} (双引号不生效)</code></pre><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>布尔类型只有两个值：<code>true</code> 和 <code>false</code> 出现场合：   </p><ul><li>条件语句导致的系统执行的隐式类型转换 <code>if(隐式转换){}</code></li><li>字面量或变量定义 <code>var bool = true;</code></li><li>也出现在比较的结果 ：</li></ul><pre><code class="JavaScript">var isGreater = 4 &gt; 1;console.log( isGreater ); // true (the comparison result is &quot;yes&quot;) </code></pre><h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>null 出现场合：</p><ul><li>获取不存在的对象 <code>document.getElementById(&#39;not-exist-element&#39;)</code>  </li></ul><p>在JavaScript中，<code>null</code>不是“对不存在的对象的引用”或者像其他语言中的“空指针”。它只是一个特殊值，代表“无”，“空”或“未知值”。</p><h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p>undefined的含义是“未赋值” 出现场合：</p><ul><li>变量声明了，但没赋值 <code>var obj;</code></li><li>获取对象不存在的属性 <code>var obj = {x: 0}; obj.y;</code></li><li>无返回值函数的执行结果 <code>function f(){}; var obj = f();</code></li><li>调用函数时，应该提供的参数没有提供 <code>function f(i){console.log(i)}; f();</code></li><li><code>void(expression)</code></li></ul><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，老实说，语法效果几乎没区别。</p><pre><code class="javascript">undefined == null  // true</code></pre><p>但也有一丝区别，区别是这样的：<code>null</code>是一个表示“空”的对象，转为数值时为0；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。   </p><pre><code class="javascript">Number(undefined) // NaN5 + undefined // NaN</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>属性集合 出现场合：</p><pre><code class="javascript">var obj = { name: &quot;miqilin&quot; };var obj = new Cat();var obj = new function() {    this.sound = &quot;wow&quot;;}</code></pre><p>但请注意，我们还没有提到过<code>Array</code>，<code>Date</code>，甚至是函数，因为正式地说，它们都是对象类型。</p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学会如何学习（二）</title>
    <link href="/2019/06/10/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2019/06/10/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。  </p><h3 id="Part1-组块"><a href="#Part1-组块" class="headerlink" title="Part1 组块"></a>Part1 组块</h3><h4 id="什么是组块"><a href="#什么是组块" class="headerlink" title="什么是组块"></a>什么是组块</h4><p>什么是组块 (chunk) ？对于绝大多数人来说这是一个全新的概念，看上去并没有什么意义，就像一堆乱糟糟的拼图。从神经科学的角度来看，<strong>组块就是通过应用或意义连接在一起的信息碎片</strong>。而在不加理解或不关注上下文的情况下，单纯的死记硬背并不能帮助你理解其内涵和你所学概念之间的关联，那么这个概念拼图就没有可以拼合的边缘，无法关联到其他的拼图碎片上。<br><img src="/images/learn2/1.jpg" srcset="/img/loading.gif" alt>      </p><p>当你全神贯注于某件事上，就好像你的脑子里有一只章鱼。这只注意力的章鱼会在必要时把它的触须穿过工作记忆的四个插槽，从而帮助你把分布于大脑不同区域里的信息联系起来。<br><img src="/images/learn2/2.jpg" srcset="/img/loading.gif" alt>      </p><p>这和发散模式下的随机连接不同，创建组块的过程中，它需要集中<strong>注意力</strong>将大脑的不同部分连接起来，专注模式下将不同的想法联系在一起。但在你很紧张时，你的注意力章鱼会失去一些连接能力，这也是为什么在你生气、紧张、害怕的时候，大脑似乎不能专注工作。    </p><p>在任何领域获得专业知识的第一步都是先创建出概念组块。这种根据意义将信息碎片拼接起来的思维跃进，可以运用于所有人类能够掌握的领域，如运动、音乐、舞蹈等。<strong>最重要的是专注的训练和重复可以建立强的记忆痕迹，从而帮助你创建组块</strong>。专业的培养都是一小步一小步的，这个过程中，小的组块可以形成更大的组块。随着你对学习材料的理解越来越深入，所有的专业知识都只是更有创造性的见解的铺路石。    </p><p>但仅仅通过练习和重复来创建组块，并不能使你得心应手并有创造力地运用它们。组块化可以让大脑工作得更有效，一旦你把某个想法、概念或动作组块化后，你就不再需要记住有关的全部细节，你只需要知道最主要的那个概念就行了，也就是只需要记住组块。这就像清晨起床穿衣服，你只需要一个简单的想法——“我要穿衣服”， 但细想你会发现这个简单想法的组块所包含的活动是非常复杂的。   </p><h4 id="怎样形成组块"><a href="#怎样形成组块" class="headerlink" title="怎样形成组块"></a>怎样形成组块</h4><p>如果你是吉他初学者，你想学习弹奏一首有难度的吉他曲，你脑中关于这首曲子的神经表征可被看作是一个巨大的组块。首先你会听这首曲子、看别人弹奏这首曲子，还要从持琴姿势学起。和大多数技能一样，你通常需要将曲子的每一小部分转化为一个小的神经组块，再将这些小组块组合起来形成大组块。经过一段时间的练习，当你掌握了很多乐段之后，你就能流利地弹奏一个乐段了。<br><img src="/images/learn2/3.jpg" srcset="/img/loading.gif" alt>  </p><p>对于数学和科学的相关学科来说，关上书本检测自己，能够帮你检验那些你以为已经明白了的问题，并且加快你的学习速度。<strong>当你能独自完成某件事时，你才是真正掌握了它</strong>。许多事情都是这个道理，就像你只是看别人画画，并不代表你也能画出来，仅仅听别人唱歌并不能使你拥有同样的唱功和洪亮的嗓音。某件事如果你只是在看，或者就算理解了如何去做，也不代表你能真正做到。只有在你自己实际操作和完全掌握的情况下才能建立起神经模型。  </p><p><strong>组块化的第一步：就是对你想要组块化的信息全神贯注</strong>。如果你正开着电视，或是每隔几分钟就检查、回复手机上的消息，这些都会增加你建立组块的难度，因为你的大脑并没有完全投入到新信息的组块化中去。   </p><p><strong>组块化的第二步：要求你对建立组块的对象有基本的了解</strong>。无论是理解概念性的知识，还是寻找故事中不同情节间的关联，通常我们都可以自然而然地领会所学内容的大意。  </p><p><strong>组块化的第三步：是获取背景知识</strong>。不断重复和练习解决相关的或不相关的问题，这样你不仅知道如何使用组块，还明白应该什么时候使用。这样做能帮你认识新建立的组块是如何融入整体知识框架的。   </p><p>最后<strong>第四步，练习能帮你拓宽组块连接的神经网络，并确保它们不仅牢固，还能通过不同途径访问</strong>。正如下图所示，学习由两部分组成，自上而下的认识以及由下至上的组块化。<br><img src="/images/learn2/4.jpg" srcset="/img/loading.gif" alt>    </p><p>在由下至上组块化的过程中，练习和重复能够帮助你建立和强化每一个组块，这样你就可以在需要它的时候使用它。当自上而下的方法能够让你清楚地看到你正在学习什么以及它适用于哪里。就完全掌握知识而言，这两个过程都非常重要。而背景认识就是这两个过程的交汇处，背景认识意味着学会在特定的时候使用正确的方法。   </p><p>通常在真正的阅读之前，快速浏览书中某一章的图片以及小标题，能够帮助你知晓大意。听那些有严谨层次结构的课程，可以帮你弄清楚应在哪里建立组块以及如何把不同组块联系起来。一旦完成了这些，再了解具体的信息，那么就算遗漏了一些让你疑惑的部分，你依然可以理解主要部分。   </p><p><img src="/images/learn2/5.jpg" srcset="/img/loading.gif" alt>   </p><p><strong>总的来说，最好在精神高度集中的时候建立组块，理解基本的含义后，通过练习来真正掌握知识，并对情境有个大致了解，是建立组块的基本步骤</strong>。快把“组块”融入到你正在使用的学习中去吧！  </p><h4 id="能力错觉"><a href="#能力错觉" class="headerlink" title="能力错觉"></a>能力错觉</h4><p>这一小节来介绍一些让学习走上正轨的基本理念。   </p><p><strong>1.回顾的重要性</strong>   </p><p>学习书本或资料时，最常见方法之一就是反复阅读。不过心理学家Jeffrey Karpicke证明，这种方法的成效远不及另一种简单技巧——回顾。也就是阅读材料后，移开视线，看看你能回忆起多少内容。<br><img src="/images/learn2/6.jpg" srcset="/img/loading.gif" alt>    </p><p>Karpicke发表在《科学》杂志上的研究提供了可靠证据。先让学生们学一篇科技文章，然后通过尽力回忆其中信息来巩固练习；接着，让他们重读并再次回想。结果相同时间内仅用回顾法练习的学生较使用其他学习方法的学生而言，对材料的掌握更为全面深入。其他学习方法包括反复阅读资料，或者绘制可以加强学习材料之间联系的思维导图。学生通过正式考试或非正式自测都证明了回顾法有助于学习。这给了我们一个重要提示，<strong>即在回顾知识时，我们并非机械地复述，而是在通过回顾这个过程加深理解</strong>。这也有助于我们形成知识组块，就好像回忆过程帮助我们在神经上嵌入了“钩子”，以便我们串联起前后知识。    </p><p>比起被动重复阅读，回顾——<strong>即在心里检索关键概念</strong>——可以使你的学习更加专注高效，只有隔上一定时间后再重读才会有效果，因为这样，重读就更像是间隔重复练习。    </p><p><strong>2.能力的错觉</strong>   </p><p>你该明白你才是要解决问题和掌握概念的人，如果你看到某个习题答案后告诉自己，“哦，我明白他们为什么这么做了！” 那么这个答案并不真正属于你，因为你没有真正把这些概念嵌入自己潜在的神经回路中去。这是一种学习中最为常见的自欺欺人式错觉。如果你想要很好地掌握材料以在考试中取得好成绩，并从中创新，就必须让这些知识在你脑海里生根发芽。    </p><p>另一个类似情况就是做笔记和注释。做笔记时高亮和下划线必须要谨慎，否则不仅没有效果还容易产生误导。在空白处写笔记总结关键概念也被证明是一种很更好的办法。<br><img src="/images/learn2/7.jpg" srcset="/img/loading.gif" alt>   </p><p>Karpicke的研究还发现，学生们喜欢重读笔记或课本的原因是，当他们面前打开着课本、笔记或谷歌时，会误以为这些知识同样在他们的脑海里，然而事实却并非如此。因为看书比回顾做起来简单，学生们会陷入一种自欺欺人的错觉。事实上，这种学习方式效率很低。    </p><p><strong>3.自测与犯错</strong>   </p><p>能力的错觉提醒我们，在学习资料上花太多时间并不能保证你真的懂了。而<strong>自测是一种极其有用的办法，来确保你是真的学会了，而不是自欺欺人的错觉</strong>。从某种意义上来说，这就是回忆在发挥作用。  </p><p>让你发现自己是否真的掌握一个概念，犯错实际上是件好事。因为你之后就会想要避免重复犯错，所以实际考试前，在自测中犯的错是很有价值的，因为它们能让你一点点弥补思维漏洞。<strong>犯错可以纠正思考方向，让你学得更好、做得更好</strong>。</p><p><strong>4.多场合回顾</strong>   </p><p>回顾是一种有效工具，而<strong>在常规学习场所以外回顾知识则会帮助你加深对知识的理解</strong>。通过在不同物理环境下回顾和思考知识，你会脱离对给定场所的依赖，这会帮助你避免由于考试与学习场所的不同而产生的问题。<br><img src="/images/learn2/8.jpg" srcset="/img/loading.gif" alt>   </p><h3 id="Part2-看到全局"><a href="#Part2-看到全局" class="headerlink" title="Part2 看到全局"></a>Part2 看到全局</h3><h4 id="是什么激励了你？"><a href="#是什么激励了你？" class="headerlink" title="是什么激励了你？"></a>是什么激励了你？</h4><p>你会发现当学的东西并非自己真正喜欢的东西时，学习是非常困难的；而学习自己真正感兴趣的东西的时候，一切都变得非常简单，那这是为什么呢?   </p><p>你的大脑有一套神经递质的广泛投射系统，它加载的不是经验本身的内容，而是信息的重要性以及对未来的价值。神经递质是可以影响神经元如何回应其他神经元的化学物质。今天我们将要谈谈它们其中的三种，<strong>乙酰胆碱、多巴胺和血清素</strong>。  </p><p><strong>乙酰胆碱影响专注学习和集中注意力</strong>。当你注意力高度集中的时候，这些乙酰胆碱神经元就会广泛地投射出来，并且激活环路来控制突触可塑性，从而形成新的长期记忆。   </p><p><strong>多巴胺信号与意料之外的奖励相关</strong>。当接受到一个毫无预期的奖励时，这些神经元将分泌出多巴胺，多巴胺的信号将广泛投射，这会对学习产生强有力的影响；同时也会影响决策，甚至是感官输入的价值所在，它控制着我们的动力。比如番茄工作法中的设置奖励就是给自己的多巴胺神经元加油。  </p><p><strong>血清素影响社会生活和冒险行为</strong>。它可以有力地影响你的社交生活。在猴子部落中的雄性首领有着最高的血清素分泌水平，而位列最末的公猴，其血清素水平则最低。血清素也与风险行为有着紧密的联系，在那些血清素低的猴子身上往往能观察到更多的冒险行为。服刑犯人中，因暴力犯罪而入狱的是社会中血清素分泌活动最低的群体之一。  </p><p><strong>情绪也可以强烈地影响你的学习</strong>。你自己应该深有体会，情绪曾一度被认为与认知互不影响，然而近期研究显示，情绪、感觉以及注意力互相交织，并与学习和记忆力互相影响。    </p><p>对于成功的学习来说，情绪及神经递质系统比感知和动作要反应迟缓，但却同等重要。   </p><h4 id="组块库的价值"><a href="#组块库的价值" class="headerlink" title="组块库的价值"></a>组块库的价值</h4><p>将新的组块和原有组块结合起来的能力，体现在很多历史的创新变革中。比如比尔·盖茨与其他工业领袖会留出长达一周的阅读周期，以便在一段时间内掌握多种不同想法，把新鲜想法留在头脑中，与未忘记的想法进行自我交流，可以形成<strong>创新性思维</strong>。</p><p>你的组块库越大，运用越熟练，无论学什么科目，你都将能够更轻易地解决问题。组块化并非创新灵活度所需要的全部，但是它是重要的一环。组块还可以帮助你理解新概念。这是因为当你理解一个组块时，你会发现这一组块能以令人惊讶的方式与相似的组块联系起来。不仅在同一领域中如此，在截然不同的领域中也是这样。这就是所谓的<strong>知识迁移</strong>(transfer)。<br><img src="/images/learn2/9.jpg" srcset="/img/loading.gif" alt>    </p><p>你建立每一个组块，它就为你补上知识拼图的一块，但如果你不训练变大的组块，它们就会保持模糊的状态，你要学习的东西拼到一起就会更为困难。<strong>建立组块库就是在训练你的大脑，不仅要认出一个特定的概念，还要识别概念的类别，以便你能够自如地知晓如何快速处理你遇到的问题</strong>。你将开始看到一些为你简化解决方法的模式，并很快发现不同的解决方法就潜藏在你的记忆边缘。   </p><p>有两种途径解决问题，一是顺序性地，一步步推理；二是通过整体性的直觉。顺序性思维涉及到专注模式；而直觉通常需要创造性的发散模式来联系不同的想法。大多数较难的问题和概念都是通过直觉来理解的，因为新的想法和你熟悉的领域相去甚远。发散模式是半随机地进行连接，这意味着它们带来的解决方法，应该由专注模式进行小心验证。直觉性的理解不是永远正确的，你大概会想无论你在学什么，仅在单一的部分或章节里就有那么多问题和概念，根本没法全学会。这时<strong>机遇定律</strong>就发挥作用了，幸运女神会眷顾努力之人。<strong>专注于你正在学习的单元，你会发现一旦你把第一个问题或概念放进组块库，不论那是什么，第二个概念的进入就会容易一些，然后第三个概念也就更容易，这并不都那么简单，但会越来越容易</strong>。<br><img src="/images/learn2/10.jpg" srcset="/img/loading.gif" alt>    </p><h4 id="过度学习、思维定势、交替学习"><a href="#过度学习、思维定势、交替学习" class="headerlink" title="过度学习、思维定势、交替学习"></a>过度学习、思维定势、交替学习</h4><p>当你在学习一个新单词、一种新概念或新的问题解法时，你需要在同一学习阶段内反复练习。一定的练习是必要且有用的，但在完全掌握此阶段的所有内容后继续学习训练，就是所谓的过度学习。过度学习在有些场合是有意义的，比如对网球发球、钢琴协奏曲演奏可能非常重要，它能在紧张的时候，帮助其行为自动化。但仍要警惕在单一学习阶段的重复性过度识记，研究表明，<strong>这可能会对宝贵的学习时间造成浪费</strong>。  </p><p>一旦你在某一阶段学会了一个基本概念，在这段时间不断地巩固它，并不能加强你所期许的长期记忆联系。<strong>学完一段时间之后再复习是更好更有用的，这可以加强并深化你的组块化神经模式</strong>。但请注意，重复你已经掌握的东西非常容易，而这可能会造成能力错觉，让你误以为自己已掌握了所有材料，但其实你只掌握了简单的部分。所以，<strong>你应该均衡学习，把精力集中在你认为困难的部分。专注于学习的困难部分称为刻意训练 (deliberate practice) ，这种刻意训练 (deliberate practice) 通常是好学生与优秀学生的差别所在</strong>。   </p><p>这些与<strong>思维定势</strong>(Einstellung) 的概念有关。一个已经形成并加强的神经模式可能阻碍你发现更棒的解决方案。思维定势在这张弹珠脑图里就表现为，你最初的想法向大脑上方移动，而解法的思维模式则位于下方。<br><img src="/images/learn2/11.jpg" srcset="/img/loading.gif" alt> </p><p>密集的专注模式以及先前构造的思维模式，会形成惯性，阻止你走向一个可能发现解决方法的新区域。你可以把思维定势想像为一个路障，而它是你最初的想法所造成的，这种错误的方式在运动和科学学科中就很容易发生。因为有时你最初”发生什么”或”该去做什么”的直觉是有误导性的，<strong>在学习新事物时，你必须摒弃错误的旧思想和方法</strong>。  </p><p>学生学习时会犯的一项重大失误是，在学会游泳前就跳入水中。换句话说，他们盲目地开始做作业，不看书、不上课、不看在线课程，或甚至不与熟识此方面的人交谈。这种学习方法只会失败。就像在放任思想在一个专注模式的弹珠器里跳来跳去，而完全不考虑解法到底在哪里。在学习和生活中，理解如何得到真正的解决方法很重要。掌握一门新学科不仅要学习基础组块，更要学会如何选择和应用不同的组块。<strong>最佳的学习方法是，在需要不同技术和策略的问题中来回切换、练习，这就是所谓的交替学习</strong>。  </p><p>交替学习非常重要，你需要让自己的大脑习惯这种思想，即仅仅知道如何使用特定的概念、方法或解题技巧是不够的，你也需要知道何时去使用 ，要贯彻交替学习的思想。这样你才能脱离只会练习和重复，而开始学会独立思考。当你在一个学科内交替学习，你就开始在这个学科内发展创造力了。当你在多个不同学科间交替学习，你就能更容易地在不同领域的组块间创造联系，这能进一步提高你的创造性。当然，在不同领域间发展固定知识组块需要时间，所以有时需要取舍。成为几个领域的专家，意味着你可以将一个领域的新思想引入另一个领域，但这也可能意味着，你在某个领域的专业知识 并不如专攻一个领域的人那么深厚。反过来，如果你只专研一个学科，你可能对它有很深刻的理解，但也变得只习惯某种思考方式，这种根深蒂固的思考模式，让你很难把握新思想。  </p><p>科学哲学家Thomas Kuhn发现，科学中大部分的方式转变都是由年轻人，或者之前学习其他学科的人所提出的。他们不那么容易陷于思维定势，不会被先前的专业训练阻碍思想。有句老话说道，科学会随着每个葬礼的进行而进步，因为葬礼意味着根深蒂固的旧思想的流逝。  </p><p>最后我转帖一个别人在元学习课程里用拼图的理念去学编程的文章，作为一个实例参考:  </p><p><a href="https://www.jianshu.com/p/385551d15a67" target="_blank" rel="noopener">元学习课心得和实践（一）——八小时搞定《JavaScript DOM》</a></p><p>下一节课我们会学习怎样应对拖延症，以及拖延症和记忆的关系。</p>]]></content>
    
    
    <categories>
      
      <category>学习之道</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效学习</tag>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建博客中遇到的一些&#39;事&#39;</title>
    <link href="/2019/06/08/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E2%80%9C%E4%BA%8B%E2%80%9D/"/>
    <url>/2019/06/08/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E2%80%9C%E4%BA%8B%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>我写的这篇<a href="https://luozongmin.com/2019/03/21/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">文章</a>已经详细讲解了怎样利用hexo搭建GitHub个人博客，自从入了hexo搭建博客的坑后，发现hexo真的是巨TM好用， 配置好以后对我最大的方便就是想改就改，想删就删，一条 $ hexo g -d 命令搞定了事，支持 Markdown ，还支持非备案域名绑定，开心！    </p><p>搭建过程中也并非一切顺利，稍微不注意就出现bug，接下来罗列了几条我搭建过程中所遇到的一些“事”及解决办法。</p><h4 id="仓库的名字"><a href="#仓库的名字" class="headerlink" title="仓库的名字"></a>仓库的名字</h4><p>仓库的名字的正确格式应该是<code>github用户名.github.io</code>，比如说，如果你的github用户名是test，那么你就应该新建<code>test.github.io</code>的仓库（必须是你的github用户名，这里再强调一遍，其它名称无效，之前因为没仔细看，随便起了个名字，果断报错）。    </p><h4 id="首页文章内容部分展示"><a href="#首页文章内容部分展示" class="headerlink" title="首页文章内容部分展示"></a>首页文章内容部分展示</h4><p>我用的是next主题，默认会把所有文章内容都展示出来，这可不简洁美观。所以查了一下，有一个小技巧，就是在你觉得要展示在首页的Mrakdown文件内容文字后面添加<code>&lt;!--more--&gt;</code>即可。例如：</p><pre><code>---title: HTML、CSS、JS中unicode字符的处理 ---# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等；</code></pre><p><img src="/images/hexobug/1.jpg" srcset="/img/loading.gif" alt>   </p><h4 id="GitHub-Pages绑定域名后每次hexo-d都会失效"><a href="#GitHub-Pages绑定域名后每次hexo-d都会失效" class="headerlink" title="GitHub Pages绑定域名后每次hexo d都会失效"></a>GitHub Pages绑定域名后每次hexo d都会失效</h4><p>在GitHub Pages绑定域名之后，发现每次<code>hexo d</code>后，域名网址都会报错404，又要重新部署，就有点太麻烦了。  </p><p><img src="/images/hexobug/2.jpg" srcset="/img/loading.gif" alt>   </p><p>搞了很久还是不行，后面在网上和群里问出，到这里域名绑定并没有结束，还差关键一步：    </p><p>具体就是在Hexo目录里的source文件下添加一个名为<code>CNAME</code>的文件，注意<strong>这个文件是没有后缀的，千万不要设置成.txt文本文件</strong>，文件的内容就是域名，格式如：   </p><pre><code>luozongmin.com</code></pre><p>添加后重新部署文件到github，这个时候再试，应该就成功了。   </p><h4 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h4><p>添加一个分类页面，并在菜单中显示页面链接。应先新建一个页面，命名为 categories ，命令如下：    </p><pre><code class="bash">$ hexo new page categories </code></pre><p><strong>注意！！！</strong>categories中千万别加””(双引号)，不然会导致部署完后网站中不显示具体分类：    </p><p><img src="/images/hexobug/3.jpg" srcset="/img/loading.gif" alt>      </p><p>之后在编辑刚新建的页面中，将页面的类型设置为<code>categories</code>； 最后编辑主题的<code>_config.yml</code>，将<code>menu</code>中的<code>categories: /categories</code>注释去掉即可。    </p><h4 id="Busuanzi-统计浏览量失效"><a href="#Busuanzi-统计浏览量失效" class="headerlink" title="Busuanzi 统计浏览量失效"></a>Busuanzi 统计浏览量失效</h4><p>由于busuanzi(不蒜子)的网址更新，导致了使用Hexo Next主题时统计浏览量时失效。   </p><p>解决方法:    </p><p>到hexo的themes文件夹下, 进入\themes\next\layout_third-party\analytics   </p><p>打开: busuanzi-counter.swig    </p><p>将src=“<a href="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”" target="_blank" rel="noopener">https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”</a>    </p><p>修改为src=“<a href="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”" target="_blank" rel="noopener">https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”</a>    </p><p>即可。    </p><p>不蒜子官网:<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a>  </p><h4 id="Hexo迁移错误-TypeError-Cannot-read-property-‘count’-of-undefined"><a href="#Hexo迁移错误-TypeError-Cannot-read-property-‘count’-of-undefined" class="headerlink" title="Hexo迁移错误 TypeError: Cannot read property ‘count’ of undefined"></a>Hexo迁移错误 TypeError: Cannot read property ‘count’ of undefined</h4><p>hexo搭建的博客，从旧电脑迁移到新电脑时，输入 $ hexo g 命令时，报出如下错误：</p><pre><code class="bash">$ hexo gINFO Start processingFATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTypeError: Cannot read property &#39;count&#39; of undefined at Hexo.module.exports (E:\github\hexo\node_modules\hexo-baidu-url-submit\lib\generator.js:4:40)at Hexo.tryCatcher (E:\github\hexo\node_modules\bluebird\js\release\util.js:16:23)at Hexo. (E:\github\hexo\node_modules\bluebird\js\release\method.js:15:34)at E:\github\hexo\node_modules\hexo\lib\hexo\index.js:337:24 at tryCatcher (E:\github\hexo\node_modules\bluebird\js\release\util.js:16:23)at MappingPromiseArray._promiseFulfilled (E:\github\hexo\node_modules\bluebird\js\release\map.js:61:38)at MappingPromiseArray.PromiseArray._iterate (E:\github\hexo\node_modules\bluebird\js\release\promise_array.js:113:31)</code></pre><p><strong>解决方案：</strong></p><pre><code class="bash">$ npm remove hexo-baidu-url-submit$ hexo clean$ hexo g</code></pre><p>删除百度自动提交就好了。</p><p><strong>未完待续……</strong></p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学会如何学习（一）</title>
    <link href="/2019/06/06/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/06/06/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？   </p><p>无意中在<a href="http://link.zhihu.com/?target=https%3A//www.coursera.org/learn/ruhe-xuexi" target="_blank" rel="noopener">Coursera</a>上发现了一门神奇适用的课程，叫做“Learning How to Learn”， 旨在利用科学知识以及授课者切身经验教会你学会如何学习，学习这门课我才开始恍然大悟，原来学习应该这样学习，算是初步悟到如何学习的真谛了。下面我将讨论我从第一周课堂中学到的经验教训。    </p><h4 id="利用专注与发散思维"><a href="#利用专注与发散思维" class="headerlink" title="利用专注与发散思维"></a>利用专注与发散思维</h4><p>研究发现，人有两种完全不同的思考模式，专注模式（focused mode）和发散模式（diffuse mode）。就目前神经学家所知，专注模式与发散模式只能单独存在，你不能同时使用两种模式。而发散思维是你试图了解新事物时应该采取的思维模式。</p><p>课程讲述萨尔瓦多·达利 (20世纪著名的超现实主义画家)有时会坐在椅子上，放空自己的大脑，并常常会漫无目的地思考一下之前的工作。这样他就能把脑海中那些在发散模式下得到的的联想和点子及时地收集起来，然后带着这些在发散模式下得到的新想法回到专注模式里去。<br><img src="/images/learn1/1.jpg" srcset="/img/loading.gif" alt>   </p><p>这个例子目的是告诉我们：当你处于长期专注的学习模式时，可以通过小睡或做一些运动，然后过渡到发散模式，有助于你的大脑建立必要的神经连接，在你的长时间记忆中建立持久的知识块。还要强调的是，当你学习一些新的东西，尤其是比较难的东西的时候，你的大脑需要有在两种学习模式之间来回转换的能力，这能帮助你更高效地学习。想要锻炼你的神经，你需要每天做一点练习，逐步建立起支撑你思考的神经骨架，这就是关键所在。</p><h4 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h4><p>每个人或多或少有拖延的毛病，只不过有些人比较严重。当你面对一件你极度不情愿做的事情时，就好像激活了大脑中与疼痛相关的区域。 </p><p>所以拖延的过程大概如下图：首先，某件事可能会让你产生轻微的不安；为了消除这种不适感，你会转而去做一些更让人愉悦的事情，这么做的结果就是你觉得更开心了，但这只是暂时的，后续文章会更深入地去了解拖延症。</p><p><img src="/images/learn1/2.jpg" srcset="/img/loading.gif" alt>    </p><h4 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h4><p>课程告诉我们一个小巧方便的意志力工具，这个小工具叫做番茄工作法 (Pomodoro)。这个小技巧所需的只有一个计时器（手机上搜索“番茄ToDo”APP，电脑端也有许多类似的软件，可以自行选择），具体的实行过程是这样的：    </p><ol><li>首先需要把计时器设定25分钟，屏蔽所有会打扰你的事物；</li><li>在25分钟内，集中精力专注你所要专注的事；</li><li>最后还有一件很重要的事情是，当你前两步之后要给自己一点小小的奖励。比如：上几分钟网、喝杯咖啡或者简单地做一下运动，来使你的大脑可以愉悦的放松一会儿。<br><img src="/images/learn1/3.jpg" srcset="/img/loading.gif" alt>   </li></ol><p>实行后你会发现番茄工作法的使用效果非常明显，这就像是你的大脑在健身房做完一次25分钟的高强度训练，然后进行休息放松一样。当你无法专注的时候不妨试一试！</p><h4 id="记忆与练习"><a href="#记忆与练习" class="headerlink" title="记忆与练习"></a>记忆与练习</h4><p>当我们回忆数学方程组时，我们使用的是长期记忆。当我们尝试结合脑海中的想法来帮助我们理解某一概念或解决某一问题时，我们使用的是工作记忆。工作记忆和长期记忆是两种主要的记忆系统，工作记忆是大脑在即时且有意识地处理信息时所涉及的那部分记忆。    </p><ul><li>长期记忆就像一个储存仓库，不同的长期记忆储存在大脑的不同区域。研究表明，当你首次尝试将一段短期记忆转入长期记忆中时，你需要多次回顾以增加需要时找到相关信息的几率。</li><li>当你遇到新事物时，你通常会运用工作记忆来处理它，如果你想将这个信息转移到长期记忆里，就需要间隔重复的练习来促进这一过程。</li><li>不断重复你尝试记忆的内容，但重复的过程必须间隔开来。如果你尝试在一个晚上重复记忆20次相同的内容，记忆效果还比不上在几天内重复同样的次数这种方法。    </li></ul><p>练习在数学和科学中学到的思想和概念是很重要的，通过反复实践练习可以帮助你提高和增强学习过程中生成的神经连接，越是抽象的东西越要注重练习。</p><ul><li>学习的时候如果一心一意地专注学习，时间一长学习效果反而不好，需要休息一下或者至少稍稍将注意力转移到其他地方。在这段看似放松的时间里，你大脑的发散模式就有机会在后台帮你完成对概念的理解。如果你不这么做，而是进行填鸭式学习，你的知识库看起来将会像杂乱不堪，基础不牢靠的泥堆。</li><li>如果你有拖延问题，就需要使用番茄工作法帮助你注意力集中一段时间，并适当休息。这会帮你行动起来，并开始建立你需要的神经模式，使你能更有成效地学习更具挑战性的内容！</li></ul><h4 id="睡眠的重要性"><a href="#睡眠的重要性" class="headerlink" title="睡眠的重要性"></a>睡眠的重要性</h4><p>你怎么也不会想到，当你绝对清醒时你的大脑会产生一些有毒的物质，那大脑如何除掉这些有毒物质呢？原来当人们睡觉时，大脑细胞会收缩，从而增加脑内细胞之间的距离。这就像疏通了一条溪流，液体会在细胞空隙间流过，冲走有毒的物质。所以，睡觉这件事有时候看起来像是浪费时间，实际上是大脑保持清洁和健康的一种方式。<br><img src="/images/learn1/4.jpg" srcset="/img/loading.gif" alt>    </p><p>睡眠不足意味着少量代谢毒素残留在你的大脑之中，而这些有毒物质会让你思维混乱，不仅会让你发挥失常，还会导致头疼、抑郁症、糖尿病、心脏类疾病，甚至寿命缩短，这绝不是在吓你，可以参考一下睡眠不足的危害。   </p><p>睡眠对人们解决困难问题和理解所学知识的能力有显著影响，大脑会将你学习和思考过的想法、概念进行整理，清除掉一些不太重要的部分；同时增强你需要或想要记住的区域的记忆。在睡梦中，大脑还会将你努力学习到的东西在神经中枢一遍遍排演以增强加深记忆力！</p><p>如果你在打盹或睡觉之前，复习一遍所学东西，那你将有更大可能性梦到它。如果你更进一步，告诉自己你想要梦到这些内容，你梦到它的几率也会大大提高。梦见你所学的知识，本质上能够增强你的理解能力，在一定程度上可以将你的记忆整合成更易被掌握的组块信息。   </p><p>现在是时候去打个盹儿了！   </p><h4 id="采访特伦斯·谢诺沃斯基-Terrence-Sejnowski-博士的学习方法"><a href="#采访特伦斯·谢诺沃斯基-Terrence-Sejnowski-博士的学习方法" class="headerlink" title="采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法"></a>采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法</h4><p>1、当你遇到完全陌生的事物时你是如何更容易学习的？    </p><p>答：单刀直入地实践，因为实践出真知，且大量的阅读作用甚微，同时最好有专家的指点。 </p><p>2、你是如何让自己在一场枯燥的讲座中保持专注的？</p><p>答：没有简单的方法是可以让你对不感兴趣的东西一直保持参与度的，但是有一个小技巧，就是用提问来“伏击”演讲者，这种打断通常会带出更有趣的讨论；比起被动的听，积极参与会让你学到更多。</p><p>3、你是如何进入发散思维模式，并从中获益的呢？</p><p>答：慢跑或户外锻炼是让思维跳出常规想法的绝佳方法，而且这时极其可能迸发灵感。奔跑中，事物从你身边略过，你会开始思考发生的一些事情，然后意识之外的想法涌上表面，接着通常就会出现有用的新想法。但是，这些转瞬即逝的点子过后很容易忘记，我会随身携带一本小本子及时记下来。</p><p>4、你会同时进行多项任务吗？</p><p>答：生活中有大量任务不断地“轰炸”，我们一刻也离不开多线程工作，如果做不到统筹兼顾，日子将会很难熬。但我们不能真正地同时做两件事，容易混淆且效率低下。同时处理多个任务实际是一种切换任务的能力。你可能要花很多时间才能完成这样的切换，切换任务并回到当时中断的地方开始工作，这是高效完成任务的方法之一。</p><p>5、神经科学方面的知识有运用到学习上的例子吗？</p><p>答：别把自己关在房间里，充足的空间、能激励你的人、很多可以积极参与的事件，以及运动和锻炼都大有助益，它们会增加新神经元的数量并促进神经元的生长。</p><p>6、你有关于高效地集中注意力、学习和创新的技巧吗？</p><p>答：处于富有创新氛围的环境中，是一种提升自身创造力的方法。当你和别人交流、阐述观点，你就会有更好的想法，这一过程通常有助于创新。</p><p>7、给大家的建议?</p><p>1） 聪明的人并不一定会成功，有很多聪明的人并不成功，而那些富有激情并且坚持努力的人容易达到，是因为人生中的成功多半来自于激情和努力，往往成功的人的身上都具有这样的品质。</p><p>2）每天我们周围都有值得发现去重新理解的东西，我们必须要用不同的视角来看待这些普通的东西，这很重要。</p>]]></content>
    
    
    <categories>
      
      <category>学习之道</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效学习</tag>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令拓展</title>
    <link href="/2019/05/30/Git%E5%91%BD%E4%BB%A4%E6%8B%93%E5%B1%95/"/>
    <url>/2019/05/30/Git%E5%91%BD%E4%BB%A4%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<p>本文的内容基本上是从廖雪峰及阮一峰老师的Git 教程中总结出来的，方便自己以后查阅相关命令。</p><p>一般来说，日常使用只需要记住下图6个命令即可。但是想往深度使用Git，恐怕还需要记住其余的几十个命令。</p><p><img src="/images/git/1.jpg" srcset="/img/loading.gif" alt></p><p>上图中几个专用名词的译名如下：    </p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：本地仓库</li><li>Remote：远程仓库</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code class="bash">$ git config --list    //显示当前的Git配置$ git config -e [--global]    //编辑Git配置文件$ git config --global user.name &quot;miqilin21&quot;$ git config --global user.email miqilin21@example.com   //设置你的仓库用户名及邮箱，用于标识提交者</code></pre><h4 id="新建Git代码库"><a href="#新建Git代码库" class="headerlink" title="新建Git代码库"></a>新建Git代码库</h4><pre><code class="bash">$ git init    //在当前目录新建一个Git代码库$ git init [project-name]   //新建一个目录，将其初始化为Git代码库$ git clone [url]    //下载一个项目和它的整个代码历史</code></pre><h4 id="添加-删除文件"><a href="#添加-删除文件" class="headerlink" title="添加/删除文件"></a>添加/删除文件</h4><pre><code class="bash">$ git add [file1] [file2] ...    //添加一个或多个文件到暂存区$ git add [dir]    //添加指定目录到暂存区，包括子目录$ git add    //添加当前目录的所有文件到暂存区$ git rm [file1] [file2] ..    //删除工作区文件，并放入暂存区$ git rm --cached [file]    //停止追踪指定文件，但该文件会保留在工作区</code></pre><h4 id="本地文件提交"><a href="#本地文件提交" class="headerlink" title="本地文件提交"></a>本地文件提交</h4><pre><code class="bash">$ git commit -m &quot;Commit message&quot;    //提交暂存区到仓库区$ git commit -a    //提交工作区自上次commit之后更改的所有文件，直接到仓库区$ git commit -v    //提交时显示所有diff信息$ git commit --amend -m &quot;Latest commit message&quot;    //使用一次新的commit，替代上一次提交；如果代码没有任何新变化，则用来改写上一次commit的提交信息</code></pre><h4 id="同步远程仓库"><a href="#同步远程仓库" class="headerlink" title="同步远程仓库"></a>同步远程仓库</h4><pre><code class="bash">$ git fetch [remote]    //下载远程仓库的所有变动$ git remote -v    //显示所有远程仓库$ git remote show [remote]    //显示某个远程仓库的信息$ git remote add [shortname] [url]    //增加一个新的远程仓库，并命名$ git pull [remote] [branch]    //同步远程仓库的变化，并与本地分支合并$ git push [remote] [branch]    //上传本地指定分支到远程仓库$ git push [remote] --force     //强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --all    //推送所有分支到远程仓库</code></pre><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><pre><code class="bash">$ git checkout [file]    //恢复暂存区的指定文件到工作区$ git checkout [commit] [file]    //恢复某个commit过的文件到暂存区和工作区$ git checkout    //恢复暂存区的所有文件到工作区$ git reset [file]    //重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset --hard    //重置暂存区与工作区，与上一次commit保持一致$ git reset --hard [commit]    //重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git revert [commit]    //新建一个commit，用来撤销指定commit；后者的所有变化都将被前者抵消，并且应用到当前分支$ git stash    //将工作区现场保存起来，等以后恢复后继续工作。通常用于处理更为着急的任务时，例如：bug$ git stash list    //查看保存的工作现场$ git stash apply    //恢复工作现场$ git stash drop    //删除stash内容$ git stash pop    //恢复的同时直接删除stash内容</code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code class="bash">$ git branch    //列出所有本地分支$ git branch -r    //列出所有远程分支$ git branch -a    //列出所有本地分支和远程分支$ git branch [branch-name]    //新建一个分支，但依然停留在当前分支$ git branch [branch] [commit]    //新建一个分支，指向指定commit$ git checkout -b [branch]    //新建一个分支，并切换到该分支$ git checkout [branch-name]    //切换到指定分支，并更新工作区$ git merge [branch]    //合并指定分支到当前分支$ git push origin [branch-name]    //将分支推送到远程仓库$ git push --all origin    //将所有分支推送到远程仓库$ git branch -d [branch-name]    //删除分支$ git push origin --delete [branch-name]$ git push origin :[branch-name]$ git branch -dr [remote/branch]     //删除远程分支</code></pre><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><pre><code class="bash">$ git tag    //列出所有tag$ git tag [tag]    //新建一个tag在当前commit$ git tag [tag] [commit]    //新建一个tag在指定commit$ git tag -d [tag]    //删除本地tag$ git push origin :refs/tags/[tagName]    //删除远程tag$ git show [tag]    //查看tag信息$ git push [remote] [tag]    //提交指定tag$ git push [remote] --tags$ git push --tags origin    //提交所有tag</code></pre><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><pre><code class="bash">$ git status    //显示有变更的文件$ git log    //显示当前分支的版本历史$ git log --stat    //显示commit历史，以及每次commit发生变更的文件$ git log -S [keyword]    //搜索提交历史，根据关键词$ git log --follow [file]$ git whatchanged [file]    //显示某个文件的版本历史，包括文件改名$ git log -p [file]    //显示指定文件相关的每一次diff$ git log -5 --pretty --oneline    //显示过去5次提交$ git shortlog -sn    //显示所有提交过的用户，按提交次数排序$ git blame [file]    //显示指定文件是什么人在什么时间修改过$ git diff    //显示暂存区和工作区的差异$ git diff --cached [file]    //显示暂存区和上一个commit的差异$ git diff HEAD    //显示工作区与当前分支最新commit之间的差异$ git diff [first-branch]...[second-branch]    //显示两次提交之间的差异$ git diff --shortstat &quot;@{0 day ago}&quot;    //显示今天你写了多少行代码$ git show [commit]    //显示某次提交的元数据和内容变化$ git show --name-only [commit]    //显示某次提交发生变化的文件$ git show [commit]:[filename]     //显示某次提交时，某个文件的内容$ git reflog    //显示当前分支的最近几次提交</code></pre>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo+GitHub搭建个人博客</title>
    <link href="/2019/05/27/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/05/27/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>hexo是一个快速、简洁且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多，所以就用它啦~     </p><p>下面一步一步地说怎么用hexo+github搭建一个个人博客。</p><p><strong><em>说明：本文只针对Windows平台下的搭建过程，其他平台的请自行上网查阅</em></strong></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在搭建博客之前，需要安装node.js和git，具体操作请参考<a href="https://www.jianshu.com/p/0356308834ad" target="_blank" rel="noopener">这篇文章</a>，并同时申请Github账号，使用的开发工具为VScode。</p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>1、首先新建一个文件夹如myBlog，用于存放整个博客源文件。右击鼠标点击文件夹，选中Git Bash Here在<strong>Git命令行中打开</strong>。  </p><p>2、执行以下命令安装Hexo及生成第一篇博客文章：</p><pre><code class="bash">$ npm install -g hexo-cli   //安装hexo$ hexo  init               //初始化hexo,这样myBlog就是整个博客的根目录，所有的页面都可以在里面进行增删改操作$ hexo generate            //生成静态页面$ hexo server              //启动本地服务器，进行博客文章预览</code></pre><p>Hexo会默认生成第一篇博客《Hello World》，在浏览器下打开localhost://4000你将会看到：<br><img src="/images/hexogit/1.png" srcset="/img/loading.gif" alt>    </p><p>myBlog源文件夹整体目录预览：<br><img src="/images/hexogit/2.jpg" srcset="/img/loading.gif" alt>     </p><p>其中_config.yml和package.json为项目的配置文件，themes存放了我们博客的主题，source-&gt;_post为我们的博客目录，public为执行hexo generate后生成的静态页面。</p><h4 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h4><p>1、在你的Github中建立新的 repo，repo 名称必须是「你的用户名.<a href="http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。" target="_blank" rel="noopener">http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。</a><br><img src="/images/hexogit/3.jpg" srcset="/img/loading.gif" alt> </p><p>2、将myBlog目录中的_config.yml文件在VScode中打开，编辑网站配置：</p><ul><li>把第 6 行的 title 改成你想要的名字</li><li>把第 10 行的 author 改成你想取大名</li><li>把最后一行的 type 改成 <code>type: git</code></li><li>在最后一行后面新增一行，左边与 type 平齐，加上一行 <code>repo: 仓库地址</code> （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址最好以 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>: 开头）<br><img src="/images/hexogit/4.jpg" srcset="/img/loading.gif" alt>     </li></ul><p><img src="/images/hexogit/5.png" srcset="/img/loading.gif" alt>     </p><p>3、修改完成配置后在myBlog目录下执行命令：</p><pre><code class="bash">$ npm install hexo-deployer-git --save    //安装 git 部署插件$ hexo deploy                             //将本地博客代码部署到Github上</code></pre><p>4、进入「你的用户名.<a href="http://github.io」对应的" target="_blank" rel="noopener">http://github.io」对应的</a> repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接；最后用浏览器访问「预览链接/index.html」就应该看到了你的博客啦！</p><h4 id="添加新文章"><a href="#添加新文章" class="headerlink" title="添加新文章"></a>添加新文章</h4><p>1、打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就相当于在本地添加了新文章</p><p>2、利用来VScode编辑新文章</p><p>3、<code>hexo generate</code></p><p>4、<code>hexo deploy</code></p><p>5、去看你的博客，应该能看到这篇新文章啦！</p><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>1、<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a> 上面有主题合集</p><p>2、随便找一个主题，进入主题的 GitHub 首页，比如我找的是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p>3、复制它的 SSH 地址或 HTTPS 地址，假设地址为 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:iissnan/hexo-theme-next.git</p><p>4、<code>cd themes</code></p><p>5、<code>git clone git@github.com:iissnan/hexo-theme-next.git</code></p><p>6、<code>cd ..</code></p><p>7、将 _config.yml 的第 75 行改为 <code>theme: hexo-theme-next</code>，保存</p><p>8、<code>hexo generate</code></p><p>9、<code>hexo deploy</code></p><p>10、等一分钟，然后刷新你的博客页面，你会看到一个新的外观，如果不喜欢这个主题，就回到第 1 步，重选一个主题。  </p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>1、最好进入一个安全的目录创建源文件夹，在根目录瞎搞；</p><p>2、_config.yml中的缩进和空格一定严格按照文件的默认格式来，不然会报错；</p><p>3、想要删除博客的话，直接删除source-&gt;_posts-&gt;对应的博客文章，然后再次执行hexo generate、hexo deploy即可；</p><p>4、在_config.yml中修改language为zh-CN，即可将博客中英文转换为中文；</p><p>5、常用命令：</p><pre><code class="bash">hexo new &quot;postName&quot;      //新建文章 hexo new page &quot;pageName&quot; //新建页面 hexo clean              //清除缓存文件db.json和已生成的静态文件 public,网站显示异常时可以执行这条命令试试。hexo generate           //生成静态文件 hexo deploy             //部署到Giihub hexo server             //启动本地服务器 hexo help               //查询帮助</code></pre><p>6、md文件需要用到<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown语法</a>。  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记—三栏布局</title>
    <link href="/2019/05/24/CSS%E5%B8%83%E5%B1%80%E2%80%94%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2019/05/24/CSS%E5%B8%83%E5%B1%80%E2%80%94%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>三栏布局的页面可分为左中右三部分，然后对中间那部分做自适应的一种布局方式。三栏布局在前端页面的开发中十分常见，那么怎么样的才算是三栏布局呢？比如苏宁易购的首页：<br><img src="/images/sanlang/1.jpg" srcset="/img/loading.gif" alt>    </p><p>上图的布局就是一个常见的三栏布局：即左边商品导航和右边导航为固定宽度，中间内容随浏览器宽度变化自适应。  </p><p>下面详细介绍了一些经典及新兴的三栏布局方式，且所有方式显示的效果如下图：<br><img src="/images/sanlang/2.jpg" srcset="/img/loading.gif" alt> </p><h4 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;    .container {        position: relative;    }    .left {        position: absolute;        width: 150px;        height: 200px;        left: 0;        top: 0;        background-color: red;    }        .middle {        height: 200px;        margin: 0 160px;        background-color: green;    }    .right {        position: absolute;        width: 150px;        height: 200px;            right: 0;        top: 0;            background-color: yellow;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>绝对定位布局是一个比较古老和容易想到的方式，其特点就是简单实用，而且也不容易出问题，缺点就是，容器脱离了文档流，后代元素也脱离了文档流，当高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。   </p><h4 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;    .left {        float: left;        height: 200px;        width: 150px;        background-color: red;    }        .middle {        margin: 0 160px;        height: 200px;        background-color: green;    }      .right {        float: right;            width: 150px;        height: 200px;        background-color: yellow;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>float布局也是一种较为简单且容易想到的方式，原理是左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应，缺点就是中间部分最后加载，内容较多时会影响体验。   </p><h4 id="BFC-三栏布局"><a href="#BFC-三栏布局" class="headerlink" title="BFC 三栏布局"></a>BFC 三栏布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;    .left {        float: left;        height: 200px;        width: 150px;        margin-right: 10px;        background-color: red;    }    .middle {        height: 200px;        overflow: hidden;        background-color: green;    }        .right {        float: right;            width: 150px;        height: 200px;        margin-left: 10px;        background-color: yellow;    }        &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>BFC有一特性：BFC的区域不会与外部浮动元素重叠，这里利用了这一特性，实现了两栏自适应布局。缺点和方法二类似，为了解决这个问题，引出下面要介绍的双飞翼布局。  </p><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;        .content {          float: left;          width: 100%;        }        .left {        float: left;        height: 200px;        width: 150px;        margin-left: -100%;        background-color: red;    }        .middle {          height: 200px;          margin-left: 160px;          margin-right: 160px;          background-color: green;        }    .right {        width: 150px;        height: 200px;        float: right;        margin-left: -200px;        background-color: yellow;    }        &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>双飞翼布局是在中间栏的 div 中再嵌套一个 div，内容写在嵌套的 div 里，然后对嵌套的 div 设置 margin-left 和 margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是 100% 宽度，只不过中间栏的内容通过 margin 的值显示在中间。    </p><p>中间内容可以优先加载，但其HTML 代码结构稍微复杂点。   </p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;    .container {        margin-left: 160px;        margin-right: 160px;    }    .middle {        float: left;        width: 100%;        height: 200px;        background-color: green;    }    .left {        float: left;        width: 150px;        height: 200px;        margin-left: -100%;        position: relative;        left: -160px;        background-color: red;    }    .right {        float: left;        width: 150px;        height: 200px;        margin-left: -210px;        position: relative;        right: -220px;        background-color: yellow;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>圣杯布局的核心是左、中、右三栏都通过float进行浮动，然后通过margin负值进行调整。跟双飞翼布局比较像，但还是有一些区别，相对于双飞翼布局来说，其HTML 结构相对简单，但是css语法就稍微复杂，也是优先加载中间内容。</p><p>还有注意一点是：中间内容要放在最上面，保证其先渲染。   </p><h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;    .container {            display: flex;    }    .middle {            flex-grow: 1;        height: 200px;        background-color: green;    }    .left {        order: -1;        flex: 0 1 150px;        margin-right: 10px;        height: 200px;        background-color: red;    }    .right {        flex: 0 1 150px;            margin-left: 10px;        height: 200px;        background-color: yellow;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Flex布局是由CSS3提供的一种较为新兴的、方便的三栏布局方式，简单实用，缺点是其兼容性差一点。    </p><h4 id="Table-布局"><a href="#Table-布局" class="headerlink" title="Table 布局"></a>Table 布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;      .container {        display: table;        width: 100%;      }      .left, .middle, .right {        display: table-cell;      }      .left {        width: 150px;        height: 200px;        background-color: red;      }      .middle {        background-color: green;      }      .right {        width: 150px;        height: 200px;        background-color: yellow;      }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>算是一种比较老的布局方式，较为简单，但其缺点是：无法设置栏间距，缺乏点灵活性，如下图：<br><img src="/images/sanlang/3.jpg" srcset="/img/loading.gif" alt> </p><h4 id="Grid-网格-布局"><a href="#Grid-网格-布局" class="headerlink" title="Grid(网格)布局"></a>Grid(网格)布局</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;      .container {        display: grid;        grid-template-columns: 160px auto 160px;            height: 200px;      }      .left {        background-color: red;            margin-right: 10px;            }      .middle {        background-color: green;      }      .right {        background-color: yellow;            margin-left: 10px;      }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>网格布局作为一种比较新潮的实现方式，仅仅几条样式命令就能完成三栏布局，可见其布局之强大，但其兼容性比较差。    </p><p><strong>以上就是我自己总结及结合文档所列出的8种css实现前端三栏布局的方式，如还有其他方式，欢迎大家告诉我哦。</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记—左右布局</title>
    <link href="/2019/05/22/CSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80/"/>
    <url>/2019/05/22/CSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>css左右布局是实现前端页面设计的基础，大部分的布局方式都能分割成左右布局，因此理解左右布局，能使我们在初学css的时候更快理解其他复杂的布局方式。</p><p>下面是我罗列的几种css实现前端左右布局的方式：   </p><h4 id="position-absolute实现"><a href="#position-absolute实现" class="headerlink" title="position: absolute实现"></a>position: absolute实现</h4><p>在父级元素内设置两个子元素，绝对定位它们，然后使用百分比将它们分成左右两部分。 这里的好处是，有两个可以容纳自己内容的独立容器。   </p><pre><code class="css">&lt;section&gt;  &lt;div class=&quot;left-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Left Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;  &lt;div class=&quot;right-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Right Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;&lt;/section&gt; /*以上为html代码*/section {  color: white;  text-align: center;}div {  height: 100%;}article {  position: absolute;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  width: 100%;  padding: 20px;}h1 {  font-size: 20px;}.left-half {  background-color: #ea68a2;  position: absolute;  left: 0px;  width: 50%;}.right-half {  background-color: pink;  position: absolute;  right: 0px;  width: 50%;}</code></pre><h4 id="table实现"><a href="#table实现" class="headerlink" title="table实现"></a>table实现</h4><p>table布局是页面布局中使用的最早的布局方式，随着前端技术的发展，table布局由于自身的局限性逐渐被div布局取代。    </p><pre><code class="css">&lt;section&gt;  &lt;div class=&quot;left-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Left Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;  &lt;div class=&quot;right-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Right Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;&lt;/section&gt;body {   color: white;  text-align: center;}h1 {  font-size: 20px;}div {  display: table-cell;  text-align: center;  vertical-align: middle;  width: 50%;  padding: 50px;}.left-half {  background: #ea68a2;}.right-half {  background: pink;}</code></pre><h4 id="float实现"><a href="#float实现" class="headerlink" title="float实现"></a>float实现</h4><p>float属性是css中关于布局的一个关键属性，可以产生脱离文档流的布局现象，其left属性值使该区域向父级标签区域的左侧边界放置，right属性值使该区域块向父级标签的右侧边界放置，利用该属性可以实现左右布局。    </p><pre><code class="css">&lt;section&gt;  &lt;div class=&quot;left-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Left Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;  &lt;div class=&quot;right-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Right Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;&lt;/section&gt;html, body, section, div {  height: 80%;}body {   color: white;  text-align: center;}section {  width: 100%;}article {  position: relative;  top: 50%;  left: 50%;  padding: 1rem;  transform: translate(-50%, -50%);}h1 {  font-size: 20px;}.left-half {  background-color: #ea68a2;  float: left;  width: 50%;}.right-half {  background-color: pink;  float: left;  width: 50%;}</code></pre><p>对于float对后面同级元素的影响，既可以采用margin进行影响的清除，还可以在受影响的元素上添加overflow：hidden来清除浮动对该区域块带来的影响。   </p><h4 id="Inline-Block实现"><a href="#Inline-Block实现" class="headerlink" title="Inline-Block实现"></a>Inline-Block实现</h4><p>display:inline-block属性是介于行内元素（display: inline）和块级元素（display: block）之间的属性，它既可以像行内元素一样水平布局，也可以像块级元素设置宽高属性，所以左右布局可以利用它这种属性。    </p><pre><code class="css">&lt;div class=&quot;left-half&quot;&gt;  &lt;article&gt;    &lt;h1&gt;Left Half&lt;/h1&gt;  &lt;/article&gt;&lt;/div&gt;&lt;div class=&quot;right-half&quot;&gt;&lt;article&gt;  &lt;h1&gt;Right Half&lt;/h1&gt;&lt;/article&gt;&lt;/div&gt;* {  box-sizing: border-box;}html, body, div {  height: 80%;}body {   color: white;  text-align: center;}article {  position: relative;  top: 50%;  left: 50%;  text-align: center;  transform: translate(-50%, -50%);}h1 {  font-size: 25px;}div {  display: inline-block;  vertical-align: top;  width: 50%;}.left-half {  background: #ea68a2;}.right-half {  background: pink;}</code></pre><h4 id="flexbox实现"><a href="#flexbox实现" class="headerlink" title="flexbox实现"></a>flexbox实现</h4><p>css3中出现了弹性盒子flexbox布局，使用这种方法，可以将父级容器变成一个灵活的盒子，子容器占用相等的份额， 无需再设置宽高。    </p><pre><code class="css">&lt;section class=&quot;container&quot;&gt;  &lt;div class=&quot;left-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Left Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;  &lt;div class=&quot;right-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Right Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;&lt;/section&gt;html, body, section {  height: 80%;}body {  color: white;  text-align: center;}div{  display: flex;  flex-direction: column;  justify-content: center;}h1 {  font-size: 25px;}.container {  display: flex;}.left-half {  background-color: #ea68a2;  flex: 1;}.right-half {  background-color: pink;  flex: 1;}</code></pre><h4 id="grid实现"><a href="#grid实现" class="headerlink" title="grid实现"></a>grid实现</h4><p>CSS Grid(网格) 布局技术就像是Flexbox和Table的混合体，你可以通过将 CSS 规则应用于父元素(成为 Grid Container 网格容器)和其子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid 布局。    </p><pre><code class="css">&lt;section class=&quot;container&quot;&gt;  &lt;div class=&quot;left-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Left Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;  &lt;div class=&quot;right-half&quot;&gt;    &lt;article&gt;      &lt;h1&gt;Right Half&lt;/h1&gt;    &lt;/article&gt;  &lt;/div&gt;&lt;/secion&gt;html, body, section, div {  height: 100%;}body {  color: white;}article {  position: relative;  top: 50%;  text-align: center;  transform: translate(0, -50%);}h1 {  font-size: 25px;}.container {  display: grid;}.left-half {  background: #ea68a2;  grid-column: 1;}.right-half {  background: pink;  grid-column: 2;}</code></pre><p>作为比较新兴的布局技术，相信在未来的前端发展中，Grid 布局技术会越来越受到广大开发者的青睐。    </p><p><strong>以上就是我自己总结及结合文档所列出的6种css实现前端左右布局的方式，如还有其他方式，欢迎大家告诉我。</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记—居中布局</title>
    <link href="/2019/05/21/CSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/"/>
    <url>/2019/05/21/CSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>我们在网页布局的时候，经常会碰到需要居中的情况，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。 </p><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="元素宽高未知"><a href="#元素宽高未知" class="headerlink" title="元素宽高未知"></a>元素宽高未知</h4><p>当元素的宽高都未知的时候，可以利用以下两种方法将元素水平居中：     </p><p>①CSS3 transform：</p><pre><code class="css">.parent {    position: relative;}.child {    position: absolute;    left: 50%;    transform: translateX(-50%);}</code></pre><p>②flexbox：</p><pre><code class="css">.parent {    display: flex;    justify-content: center;}</code></pre><h4 id="居中元素为内联元素"><a href="#居中元素为内联元素" class="headerlink" title="居中元素为内联元素"></a>居中元素为内联元素</h4><p>常见的内联元素有：span, a, img, input, label 等等。   </p><p>您可以在块级父元素内水平居中内联元素，只需css中加以下核心语法：    </p><pre><code class="css">.parent{   text-align: center;}</code></pre><p>这种方法适用于display 为 inline, inline-block, inline-table, inline-flex 类型的元素。    </p><h4 id="居中元素为块级元素"><a href="#居中元素为块级元素" class="headerlink" title="居中元素为块级元素"></a>居中元素为块级元素</h4><p>常见的块元素：div, h1~h6, table, p, ul, li 等等。     </p><p>①设置 margin：0 auto    </p><pre><code class="css">.parent {    width: 100%;}.child {    width: 800px;    height: 100px;    margin: 0 auto;    background: #999;}</code></pre><p>此方法只能进行水平的居中，对浮动元素或绝对定位元素是无效的。  </p><p>②转换为 inline-block 属性：</p><pre><code class="css">.parent {    text-align: center;}.child {    display: inline-block;}</code></pre><h4 id="居中元素为浮动元素"><a href="#居中元素为浮动元素" class="headerlink" title="居中元素为浮动元素"></a>居中元素为浮动元素</h4><p>加以下核心语法:</p><pre><code class="css">.child {    width: 100px;    float: left;    position: relative;    left: 50%;    margin-left: -50px;}</code></pre><h4 id="居中元素为绝对定位元素"><a href="#居中元素为绝对定位元素" class="headerlink" title="居中元素为绝对定位元素"></a>居中元素为绝对定位元素</h4><p>①</p><pre><code class="css">.parent {    position: relative;}.child {    position: absolute;    width: 100px;    left: 50%;    margin-left: -50px;}</code></pre><p>②</p><pre><code class="css">.parent {    position: relative;}.child {    position: absolute;    width: 100px;    left: 0;    right: 0;    margin: 0 auto;}</code></pre><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="元素宽高未知-1"><a href="#元素宽高未知-1" class="headerlink" title="元素宽高未知"></a>元素宽高未知</h4><p>当元素的宽高都未知的时候，也可以利用以下同样两种方法将元素垂直居中：  </p><p>①CSS3 transform：  </p><pre><code class="css">.parent {    position: relative;}.child {    position: absolute;    left: 50%;    transform: translateY(-50%);}</code></pre><p>②flexbox：</p><pre><code class="css">.parent {    display: flex;    flex-direction: column;    justify-content: center;}</code></pre><p>适用于子元素为浮动、绝对定位、内联元素，均可垂直居中。   </p><p>其中flexbox 是 CSS3 新增的属性，设计初衷就是为了解决像垂直居中这样的常见布局问题，相信未来flexbox布局会越来越多应用。     </p><h4 id="元素宽高已知"><a href="#元素宽高已知" class="headerlink" title="元素宽高已知"></a>元素宽高已知</h4><p>①</p><pre><code class="css">.parent {    position: relative;}.child{    position: absolute;    top: 50%;    height: 100px;    margin-top: -50px;}</code></pre><p>②</p><pre><code class="css">.parent {    position: relative;}.child{    position: absolute;    top: 0;    bottom: 0;    height: 100px;    margin: auto 0;}</code></pre><h4 id="居中元素为单行文本"><a href="#居中元素为单行文本" class="headerlink" title="居中元素为单行文本"></a>居中元素为单行文本</h4><p>①</p><pre><code class="css">.text {    line-height: 200px;    height: 200px;}</code></pre><p>将文本的 line-height 属性值设为和文字父容器一样的高度，但适用于只有一行文字的情况。   </p><p>②</p><pre><code class="css">.link {    padding-top:30px;    padding-bottom:30px;}</code></pre><p>有时内联/文本元素可以垂直居中显示，只是因为它们上部和下部都有相等的padding。    </p><h4 id="居中元素为多行文本"><a href="#居中元素为多行文本" class="headerlink" title="居中元素为多行文本"></a>居中元素为多行文本</h4><p>①table：</p><pre><code class="css">.parent {  display: table;}.child {  display: table-cell;  margin: 0;  vertical-align: middle;}</code></pre><p>②flexbox:</p><pre><code class="css">.parent {    display: flex;    justify-content: center;    flex-direction: column;    height:400px;}</code></pre><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="元素宽高已知-1"><a href="#元素宽高已知-1" class="headerlink" title="元素宽高已知"></a>元素宽高已知</h4><p>①负边距居中：</p><pre><code class="css">.parent {    position: relative;}.child {    width: 100px;    height: 100px;    position: absolute;    top: 50%;    left: 50%;    margin-left: -50px;    margin-top: -50px;}</code></pre><p>此方法灵活性差，不能自适应，且宽高不支持百分比尺寸和 min-/max- 属性。    </p><p>②绝对居中：</p><pre><code class="css">div {    width: 100px;    height: 100px;    margin: auto;    position: fixed;    //absolute is ok    top: 0;    right: 0;    bottom: 0;    left: 0;}</code></pre><p>元素的宽高支持百分比 % 属性值和 min-/max- 属性。     </p><p>③transform :</p><pre><code class="css">.parent {    position: relative;}.child {    width: 100px;    height: 100px;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);  }</code></pre><p>④table-cell:</p><pre><code class="css">.parent {    display: table-cell;    vertical-align: middle;    text-align: center;    width: 100px;    height: 100px;    border: 1px solid red;}.child {    width: 50px;    height: 50px;    display: inline-block;    background-color: #999;}</code></pre><p>这种方法适用于子元素 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，前提需要知道父元素的宽高，且父元素的宽高不能设为百分比数。     </p><p>⑤font-size 结合 vertical-align：</p><pre><code class="css">.parent {    font-size: 175.4px;    height: 200px;    text-align: center;}.child {    vertical-align: middle;    display: inline-block;    font-size: 12px;    width: 50px;    height: 50px;    background-color: #999;}</code></pre><p>该方法前提条件是需给父元素设一个合适的 font-size 值，该值一般为其父元素的高度除以 1.14 得到的值，并且子元素必须是一个 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，此外还需在子元素内加上 vertical-align: middle 属性。    </p><p>⑥文本内容：</p><pre><code class="css">text {    height: 100px;    line-height: 100px;    text-align: center;}</code></pre><h4 id="元素宽高未知-2"><a href="#元素宽高未知-2" class="headerlink" title="元素宽高未知"></a>元素宽高未知</h4><p>①transform :</p><pre><code class="css">.parent {    position: relative;}.child {    position: absolute;    top:50%;    left:50%;    transform:translate(-50%,-50%);}</code></pre><p>transform方法中元素既可以加宽高，也可不加，用于水平垂直居中布局。    </p><p>②flexbox :</p><pre><code class="css">.parent {    display: flex;    justify-content: center;    align-items: center;}</code></pre><p>③grid:</p><pre><code class="css">body, html {    height:100%;    display: grid;}span { /* thing to center */    margin: auto;}</code></pre><p>该方法适用于只有一个元素的时候，作为非常新的布局方式，其兼容性也比较差。        </p><p><strong>上面只是把所有方法的代码要点罗列了一下，能满足所有的居中布局方案，如你还有其他好方法，欢迎交流指正哦。</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何快速搭建静态资源服务器</title>
    <link href="/2019/05/18/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2019/05/18/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。以前的时候，都是使用php的本地环境，也算比较方便，但是自从学了nodejs，发现创建http-server更方便。<br><img src="/images/http-server/1.jpg" srcset="/img/loading.gif" alt>  </p><h3 id="本文的目的"><a href="#本文的目的" class="headerlink" title="本文的目的"></a>本文的目的</h3><p>在这篇文章中，我将向您展示如何使用NodeJS创建一个非常简单的HTTP服务器。您可以通过http访问目录中的静态资源，如HTML，Javascript，CSS等，比如：  </p><ul><li><a href="http://localhost:8080/hello.html" target="_blank" rel="noopener">http://localhost:8080/hello.html</a></li><li><a href="http://localhost:8080/abc.js" target="_blank" rel="noopener">http://localhost:8080/abc.js</a>   </li></ul><p>而不是通过默认的file:///来访问<br><img src="/images/http-server/2.jpg" srcset="/img/loading.gif" alt>    </p><p>那问题是为什么只有需要一个HTTP才能访问静态资源呢？ </p><p>是因为HTML文件含有Javascript文件时，如果通过默认的file://地址来访问此文件的话，浏览器会阻止本地Javascript文件的一些操作，此时就需要安装HTTP-Server来解决这个问题。<br><img src="/images/http-server/3.jpg" srcset="/img/loading.gif" alt>    </p><p>报错信息：  </p><ul><li>Failed to load file:///E:/webexamples/reactjs/hello-reactjs/person.jsx:</li><li>Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.   </li></ul><h3 id="创建HTTP-Server"><a href="#创建HTTP-Server" class="headerlink" title="创建HTTP-Server"></a>创建HTTP-Server</h3><p>首先，确保已在计算机上安装NodeJS和npm； 否则，请按照以下说明进行安装：  </p><ul><li>在Windows上安装NodeJS</li><li>打开 Git Bash或其他命令行工具，依次输入以下命令，按回车：<pre><code class="bash">npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress false</code></pre></li><li>npm 的配置被存储在 ~/.npmrc，你可以随时改。    </li></ul><p>①接下来第一步，先创建一个空目录：<br><img src="/images/http-server/4.jpg" srcset="/img/loading.gif" alt>     </p><p>②利用命令行工具进入这个目录，这里用的是Git Bash。右击鼠标，点击Git Bash here，即可用Git Bash打开这个目录：<br><img src="/images/http-server/5.jpg" srcset="/img/loading.gif" alt>    </p><p>③运行以下命令安装http-server：</p><pre><code class="bash">$ npm install http-server -g</code></pre><p>这将http-server全局安装，以便它可以从命令行运行。</p><p><img src="/images/http-server/6.jpg" srcset="/img/loading.gif" alt>    </p><p>④使用HTTP-Server，命令行进入当前文件夹，输入以下命令即可：</p><pre><code class="bash">$ http-server</code></pre><p>若要禁用缓存，请使用如下命令运行：</p><pre><code class="bash">http-server -c-1</code></pre><p><img src="/images/http-server/7.jpg" srcset="/img/loading.gif" alt>    </p><p>到此您的HTTP服务器就已经启动了，它正在端口8080上监听，您可以通过访问以下链接进行检查，3个地址在电脑端打开的是同一份东西：</p><ol><li><a href="http://192.168.1.116:8080/" target="_blank" rel="noopener">http://192.168.1.116:8080/</a> （只有这个地址能在手机中预览）</li><li><a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> （2和3性质是一样的）</li><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> （较为常用）   </li></ol><p>如果发现页面不存在，就在地址栏后面加 /index.html ，变成 <a href="http://127.0.0.1:xxxx/index.html" target="_blank" rel="noopener">http://127.0.0.1:xxxx/index.html</a></p><p>⑤在该目录中创建一个HTML文件，您可以通过此HTTP地址访问它：<br><img src="/images/http-server/8.jpg" srcset="/img/loading.gif" alt><br><img src="/images/http-server/9.jpg" srcset="/img/loading.gif" alt>    </p><p>⑥这里Windows 用户需要注意了，如果你发现你修改了源代码，页面却无法更新，说明 http-server 的缓存还未消除，那么可以这样做：  </p><ol><li>打开 Chrome 开发者工具</li><li>点击 Network</li><li>勾选 Disable Cache    </li></ol><p>这样缓存就不存在了~  </p><h3 id="其他命令安装HTTP-Server"><a href="#其他命令安装HTTP-Server" class="headerlink" title="其他命令安装HTTP-Server"></a>其他命令安装HTTP-Server</h3><p>这里就不仔细介绍步骤了，因为大部分操作和结果与第2步是一样的，直接上命令： </p><p><strong>第一种方法：</strong><br>安装：   </p><pre><code class="bash">$ npm i startserver -g</code></pre><p>快速开启：   </p><pre><code class="bash">$ startserver</code></pre><p>也可以简写：</p><pre><code class="bash">$ ss</code></pre><p><strong>第二种方法：</strong><br>安装：   </p><pre><code class="bash">$ npm install -g live-server</code></pre><p>快速开启：   </p><pre><code class="bash">$ live-server</code></pre><p>如果看到其他有意思的方法，后续还会增加的！   </p><p><strong>以上就是我在近期收集到的一些方法资料，不一定全面，如有错误欢迎指正哦。</strong>  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>前端相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>http-server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git/GitHub操作手册</title>
    <link href="/2019/05/15/Git%E5%8F%8AGithub%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <url>/2019/05/15/Git%E5%8F%8AGithub%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>Git 是目前最流行的版本管理工具，也是程序员的必备技能之一。这里主要介绍一下git/github远程仓库的使用及相关配置。 </p><h4 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h4><p>SSH Keys是什么呢？简单来说相当于一把钥匙（在机器中即电脑中进行配置），github相当于一把锁，每次发起请求是会去验证钥匙与锁是否配对。  </p><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置。     </p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那如何将我们这个本地仓库上传到 GitHub 呢？下图简单描述了Git常用的操作流程。<br><img src="/images/github/1.jpg" srcset="/img/loading.gif" alt>     </p><p>1、在本地新建文件夹，命名为blog，在本地的blog仓库的路径下运行命令行。    </p><pre><code class="bash">$ git init    // 在当前目录新建一个Git代码库</code></pre><p>这个操作在当前目录下生成一个.git文件，默认不显示，可在命令行中输入 ls -a,即可看到所有被隐藏文件，接下来进行如下操作：     </p><pre><code class="bash">$ echo &quot;# myblog&quot; &gt;&gt; README.md   //在当前目录下新建README.md,且文件内容为&#39;myBlog&#39;；如果目录下已经有文件，请省略这一步$ git add README.md                //将README.md文件提交到问题暂存区$ git commit -m &quot;first commit&quot;     //将暂存区文件提交到本地仓库，且本次提交记录为&#39;first commit&#39;$ git status -sb      //显示当前所有文件的状态</code></pre><p>这几步操作目的是将上传的文件提交到本地仓库，接下来就是介绍怎么样将本地仓库上传到远端库了。   </p><p>2、登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，名称随意，一般可以跟本地目录名一致。<br><img src="/images/github/2.jpg" srcset="/img/loading.gif" alt>     </p><p>在Repository name填入blog，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。    </p><p>3、点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图:<br><img src="/images/github/3.jpg" srcset="/img/loading.gif" alt>    </p><p>4、看上图，记得点击 SSH 按钮，如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用HTTPS 地址，因为使用HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但在某些只开放http端口的公司内部就无法使用SSH协议而只能用HTTPS 。    </p><p>5、目前，在GitHub上的这个blog仓库还是空的，GitHub告诉我们，可以在这个仓库创建一个新的本地仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。<br>现在，我们根据GitHub的提示，在本地的blog仓库下运行命令：    </p><pre><code class="bash">$ git remote add origin git@github.com:miqilin21/blog.git</code></pre><p>6、下一步，就可以把本地库的所有内容推送到远程库上：     </p><pre><code class="bash">$ git push -u origin master</code></pre><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。   </p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样:<br><img src="/images/github/4.jpg" srcset="/img/loading.gif" alt>    </p><p>7、如果你想查看变更历史，可以通过命令：<code>$ git log</code>    </p><p>8、从现在起，只要本地仓库作了修改，如果你想让改动保存到远程仓库里，你需要先<code>git add</code>文件或者也可以<code>git add</code>。注意，如果这个 文件以前被我们<code>add</code>过，所以此处的<code>git add</code>操作可以省略，但我建议你使用git的初期阶段，不要省略<code>git add</code>。换句话说，每一次改动，都要经过<code>git add</code>和<code>git commit</code>两个命令，才能被添加到 .git 本地仓库里。接下来就通过命令：    </p><pre><code class="bash">$ git push   //将本地仓库修改内容同步到远程仓库</code></pre><p>但是，如果远程库先有修改的话，要想本地仓库与其同步，还需通过命令：    </p><pre><code class="bash">$ git pull      //将远程库修改的内容下载到本地库</code></pre><p>最后把本地master分支的最新修改<code>$ git push</code>推送至GitHub，现在，你就拥有了真正的分布式版本库！    </p><h4 id="从远程库clone"><a href="#从远程库clone" class="headerlink" title="从远程库clone"></a>从远程库clone</h4><p>上面已经讲了     </p><ul><li>在本地创建仓库</li></ul><ul><li>将本地仓库上传到 GitHub    </li></ul><p>这里将介绍另外一种用法，那就是直接在 GitHub 创建一个仓库，然后克隆下载到本地。   </p><p>1、在GitHub 上新建一个仓库 git-demo，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下：<br><img src="/images/github/5.jpg" srcset="/img/loading.gif" alt>   </p><p>请按图中所示，一模一样的操作，然后点击创建按钮。    </p><p>2、这样一来，这个仓库就会自动生成三个文件：<br><img src="/images/github/6.jpg" srcset="/img/loading.gif" alt>    </p><p>3、现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库，点击页面中唯一的绿色按钮「clone or download」，会看到一个弹出层：<br><img src="/images/github/7.jpg" srcset="/img/loading.gif" alt>   </p><p>请确保弹出层里的地址是 SSH 地址，也就是 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> 开头的地址，如果不是，就点击 Use SSH 按钮，然后复制这个地址。    </p><p>4、打开 Git Bash，找一个安全目录，比如 ~/Desktop 桌面目录就很安全：cd ~/Desktop，然后运行：    </p><pre><code class="bash">$ git clone git@github.com:miqilin21/git-demo.git</code></pre><p>运行完了你就会发现，桌面上多出一个 git-demo-2 目录，里面的内容和远程库一模一样，至此从远程库克隆到本地就完成啦！    </p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>三种方式都说完了，它们分别是：    </p><p>1、在本地创建仓库    </p><p>2、将本地仓库上传到 GitHub </p><p>3、GitHub 上的仓库克隆下载到本地    </p><p>其实呢，还有很多种不同的方式，但是，你记住这几种就行了，已经够你用了。我们并不想要了解 git 的所有高级用法，我们的目的很明确：能通过 Git 命令使用 GitHub 就行。    </p><p>我们最后再回顾一遍已经学到的命令：    </p><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxxx，克隆下载远程仓库<br>git init，初始化本地仓库 .git<br>git status -sb，显示当前所有文件的状态<br>git add 文件路径，用来将变动加到暂存区<br>git commit -m “信息”，用来正式提交变动，并备注信息，提交至 .git 仓库<br>如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。<br>git log 查看变更历史</p></blockquote><h4 id="其他学习资源"><a href="#其他学习资源" class="headerlink" title="其他学习资源"></a>其他学习资源</h4><blockquote><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git命令清单</a><br><a href="http://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener">Git菜鸟教程</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000" target="_blank" rel="noopener">廖雪峰的Git教程</a>  </p></blockquote><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML常用标签</title>
    <link href="/2019/05/10/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2019/05/10/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p>HTML 是用来描述网页的一种语言，通过添加各种标签，达到在浏览器中展示期望的效果。    </p><ul><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)    </li></ul><ul><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)    </li></ul><ul><li>标记语言是一套标记标签 (markup tag)    </li></ul><ul><li>HTML 使用标记标签来描述网页    </li></ul><p>浏览器不会显示 HTML 标签(HTML tag)，而是使用标签来解释页面的内容：     </p><ul><li>HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code>  </li></ul><ul><li>HTML 标签通常是成对出现的，比如 <code>&lt;p&gt;</code> 和 <code>&lt;/p&gt;</code>  </li></ul><ul><li>标签对中的第一个标签是开始标签，第二个标签是结束标签     </li></ul><ul><li>开始和结束标签也被称为开放标签和闭合标签     </li></ul><p>⭐越多代表我觉得此标签越重要</p><h4 id="标题标签-⭐⭐⭐"><a href="#标题标签-⭐⭐⭐" class="headerlink" title="标题标签 ⭐⭐⭐"></a>标题标签 ⭐⭐⭐</h4><p>HTML提供了6个等级的标题(head)，即：h1、h2、h3、h4、h5和h6，h1是最高级的标题。其基本语法是：<code>&lt;hn&gt; 标题信息 &lt;/hn&gt;</code>     </p><p>注意：h1因为重要，尽量少用，一般都是给logo用，或者页面中最重要标题信息，其他5个级别标题在一个页面中都可以出现多次，h1只能出现一次。    </p><h4 id="段落标签-⭐⭐⭐"><a href="#段落标签-⭐⭐⭐" class="headerlink" title="段落标签 ⭐⭐⭐"></a>段落标签 ⭐⭐⭐</h4><p>在网页中要想把文字内容有条理地显示，离不开段落标签（paragraph）,它是网页中文章内容的基本组成部分。其基本语法是：<code>&lt;p&gt; 文本内容 &lt;/p&gt;</code>    </p><p>注意：段落标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 </p><h4 id="水平线标签-⭐⭐"><a href="#水平线标签-⭐⭐" class="headerlink" title="水平线标签 ⭐⭐"></a>水平线标签 ⭐⭐</h4><p>在网页中经常看到一些水平线将段落与段落间隔开，层次分明。这些水平线可以通过插入图片来实现，也可以简单地通过<code>&lt;hr/&gt;</code> 标签(horizontal)来完成。其基本语法是：<code>&lt;hr /&gt;是单标签</code>    </p><h4 id="换行标签-⭐⭐⭐"><a href="#换行标签-⭐⭐⭐" class="headerlink" title="换行标签 ⭐⭐⭐"></a>换行标签 ⭐⭐⭐</h4><p>在HTML中，一个段落的文字会从左往右按顺序排列，直到浏览器窗口的右端，然后会自动换行，如果希望某段文字强制进行换行，就需要使用换行标签(break)。其基本语法是：<code>&lt;br /&gt;</code>   </p><p>注意：除了少数应用（比如诗歌的分行），应该尽量避免使用这个标签，因为它并没有特别的语义含义，而且分行的视觉效果完全可以通过p标签、列表标签和CSS命令达到。   </p><h4 id="div-span标签-⭐⭐⭐⭐"><a href="#div-span标签-⭐⭐⭐⭐" class="headerlink" title="div span标签 ⭐⭐⭐⭐"></a>div span标签 ⭐⭐⭐⭐</h4><p>div 和 span是没有语义的，是现在网页布局用到的最主要的2个盒子，比如css+div的结合就可以基本上满足页面布局需要。其基本语法是：</p><pre><code class="html">&lt;div&gt; 这是头部 &lt;/div&gt;     &lt;span&gt; 今日行情 &lt;/span&gt;</code></pre><h4 id="文本格式化标签-⭐⭐"><a href="#文本格式化标签-⭐⭐" class="headerlink" title="文本格式化标签 ⭐⭐"></a>文本格式化标签 ⭐⭐</h4><p>在网页中，有时要为某些文字设置加粗、加斜或加下划线的效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。其基本语法是：<br><img src="/images/html/1.jpg" srcset="/img/loading.gif" alt>    </p><p>注意：b i s u 只有使用，没有强调的意思，strong em del ins的语义更强烈。    </p><h4 id="图像标签img-⭐⭐⭐⭐"><a href="#图像标签img-⭐⭐⭐⭐" class="headerlink" title="图像标签img ⭐⭐⭐⭐"></a>图像标签img ⭐⭐⭐⭐</h4><p>要想在网页中显示图像就需要使用图像标签，下图详细介绍了图像标签<code>&lt;img /&gt;</code> 以及与其相关的一些属性。其基本语法是：<br><img src="/images/html/2.jpg" srcset="/img/loading.gif" alt>    </p><ol><li>基本图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot;/&gt;</code></li><li>带有alt的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; alt=&quot;这是我吴彦祖的照片&quot;/&gt;</code></li><li>带有title的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot;/&gt;</code></li><li>带有宽度的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; /&gt;</code></li><li>带有边框的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; border=&quot;10&quot; /&gt;</code></li></ol><h4 id="链接标签-⭐⭐⭐⭐"><a href="#链接标签-⭐⭐⭐⭐" class="headerlink" title="链接标签 ⭐⭐⭐⭐"></a>链接标签 ⭐⭐⭐⭐</h4><p>在HTML中创建超链接比较简单，只需用链接标签(anchor)环绕需要被链接的对象即可。其基本语法是：<br><code>&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;</code>   </p><p>href：Hypertext Reference的缩写，意思是超文本引用，用于指定链接目标的url地址。    </p><p>target：用于指定链接页面的打开方式，其取值有self(新链接页面覆盖原页面，为默认值)、blank(在新窗口打开)、_parent(载入父级窗口，与iframe结合用得到)、_top(载入顶级窗口，与iframe结合用得到)，注意：     </p><ol><li>外部链接：需要添加 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>  </li><li>内部链接：直接链接内部页面名称即可，如<a href="index.html">首页</a>；还有可以通过创建锚点链接，能够快速定位到内部页面的目标内容：①.使用<a href="#id名">链接文本</a> ②.使用相应的id名标注跳转到目标的位置 </li><li>如果没有确定的链接目标时，通常将href属性定义为”#”(即href=”#”)，表示该链接暂时为一个空链接。</li><li>不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。   </li><li>当然也可以利用base标签来设置整体链接的打开状态，如网易这样设置让页面所有链接按新窗口打开：<br><img src="/images/html/3.jpg" srcset="/img/loading.gif" alt>     </li></ol><h4 id="特殊字符标签-⭐"><a href="#特殊字符标签-⭐" class="headerlink" title="特殊字符标签 ⭐"></a>特殊字符标签 ⭐</h4><p><img src="/images/html/4.jpg" srcset="/img/loading.gif" alt>    </p><h4 id="无序列表ul-⭐⭐⭐⭐"><a href="#无序列表ul-⭐⭐⭐⭐" class="headerlink" title="无序列表ul ⭐⭐⭐⭐"></a>无序列表ul ⭐⭐⭐⭐</h4><p>无序列表(unordered list)的各个列表项之间没有顺序级别之分，是并列的。其基本语法是：   </p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;列表项1&lt;/li&gt;  &lt;li&gt;列表项2&lt;/li&gt;  &lt;li&gt;列表项3&lt;/li&gt;  ......&lt;/ul&gt;</code></pre><p>注意：     </p><ul><li><code>&lt;ul&gt;&lt;/ul&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ul&gt;&lt;/ul&gt;</code>标签内输入其他标签或者文字的做法是不被允许的。  </li><li><code>&lt;li&gt;</code>与<code>&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。   </li><li>无序列表会自带样式属性，但还是让css来做！   </li></ul><h4 id="有序列表ol-⭐⭐"><a href="#有序列表ol-⭐⭐" class="headerlink" title="有序列表ol ⭐⭐"></a>有序列表ol ⭐⭐</h4><p>有序列表(ordered list)即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义。其基本语法是：   </p><pre><code class="html">&lt;ol&gt;   &lt;li&gt;列表项1&lt;/li&gt;   &lt;li&gt;列表项2&lt;/li&gt;   &lt;li&gt;列表项3&lt;/li&gt;   ...... &lt;/ol&gt;   </code></pre><p>所有特性基本和ul一致，且自带顺序。   </p><h4 id="定义列表-⭐"><a href="#定义列表-⭐" class="headerlink" title="定义列表 ⭐"></a>定义列表 ⭐</h4><p>定义列表(definition list)常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法是：    </p><pre><code class="html">&lt;dl&gt;  &lt;dt&gt;名词1&lt;/dt&gt;  &lt;dd&gt;名词1解释1&lt;/dd&gt;  &lt;dd&gt;名词1解释2&lt;/dd&gt;      ......    &lt;dt&gt;名词2&lt;/dt&gt;  &lt;dd&gt;名词2解释1&lt;/dd&gt;  &lt;dd&gt;名词2解释2&lt;/dd&gt;       ...... &lt;/dl&gt;</code></pre><h4 id="表格table-⭐⭐"><a href="#表格table-⭐⭐" class="headerlink" title="表格table ⭐⭐"></a>表格table ⭐⭐</h4><p>表格还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。其基本语法是：    </p><pre><code class="html">&lt;table&gt;  &lt;tr&gt;    &lt;td&gt;单元格内的文字&lt;/td&gt;    ...  &lt;/tr&gt;   ...&lt;/table&gt;</code></pre><p>上面的语法中包含三对HTML标签，分别为<code>&lt;table&gt;&lt;/table&gt;</code>、<code>&lt;tr&gt;&lt;/tr&gt;</code>、<code>&lt;td&gt;&lt;/td&gt;</code>，他们是创建表格的基本标签，缺一不可，下面对他们进行具体解释：    </p><ul><li>table用于定义一个表格。  </li><li>tr用于定义表格中的一行，必须嵌套在table标签中，且只能嵌套<code>&lt;td&gt;&lt;/td&gt;</code>，在table中包含几对tr，就有几行表格。   </li><li>td /td：用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中，一对<code>&lt;tr&gt;&lt;/tr&gt;</code>中包含几对<code>&lt;td&gt;&lt;/td&gt;</code>，就表示该行中有多少”列”（或多少个单元格），但表格只有行tr和单元格td，行里面装单元格，没有列的概念；<code>&lt;td&gt;&lt;/td&gt;</code>标签像一个容器，可以容纳所有的元素。   </li></ul><h4 id="表单标签-⭐⭐"><a href="#表单标签-⭐⭐" class="headerlink" title="表单标签 ⭐⭐"></a>表单标签 ⭐⭐</h4><p>表单的目的是为了收集用户信息，在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。<br><img src="/images/html/5.jpg" srcset="/img/loading.gif" alt>    </p><p>表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 </p><p>提示信息：一个表单中通常还需要包含一些说明性的文字，作用是提示用户进行填写和操作。    </p><p>表单域：相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过它定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。    </p><h4 id="input控件-⭐⭐⭐⭐"><a href="#input控件-⭐⭐⭐⭐" class="headerlink" title="input控件 ⭐⭐⭐⭐"></a>input控件 ⭐⭐⭐⭐</h4><p><code>&lt;input /&gt;</code>标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。其常见属性如下所示：<br><img src="/images/html/6.jpg" srcset="/img/loading.gif" alt>    </p><p>text语法:   </p><pre><code class="html">&lt;tr&gt;  &lt;td&gt;所在地区&lt;/td&gt;      &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;北京&quot; /&gt;&lt;/td&gt;    //value为默认值&lt;/tr&gt;</code></pre><p>password语法： </p><pre><code class="html">&lt;tr&gt;  &lt;td&gt;密码&lt;/td&gt;  &lt;td&gt;&lt;input type=&quot;password&quot; value=&quot;123456&quot; /&gt;&lt;/td&gt;    &lt;/tr&gt;</code></pre><p>radio单选按钮语法：   </p><pre><code class="html">&lt;tr&gt;  &lt;td&gt;性别&lt;/td&gt;  &lt;td&gt;     男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;     女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;     人妖&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;  &lt;/td&gt;    &lt;/tr&gt;</code></pre><h4 id="label标签-⭐⭐"><a href="#label标签-⭐⭐" class="headerlink" title="label标签 ⭐⭐"></a>label标签 ⭐⭐</h4><p>label标签为input元素定义标注，其中for属性规定了label与哪个表单元素绑定。其基本语法是：   </p><pre><code class="html">&lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; </code></pre><p>点击Male会直接跳到右边的文本框内，label通过for和id建立联系快速找到。当然也可以简化成这种形式：   </p><pre><code class="html">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;/label&gt;</code></pre><h4 id="textarea文件域-⭐⭐"><a href="#textarea文件域-⭐⭐" class="headerlink" title="textarea文件域 ⭐⭐"></a>textarea文件域 ⭐⭐</h4><p>text 文本框只能写一行文本，如果需要输入大量的信息，就需要用到textarea标签，可以轻松地创建多行文本输入框。其基本语法是：    </p><pre><code class="html">&lt;textarea cols=&quot;每行的字符数&quot; rows=&quot;显示的行数&quot;&gt;   文本内容   &lt;/textarea&gt;</code></pre><p>但是textarea的宽和高通常是通过css来控制的,cols和rows几乎不用。    </p><h4 id="下拉菜单-⭐⭐"><a href="#下拉菜单-⭐⭐" class="headerlink" title="下拉菜单 ⭐⭐"></a>下拉菜单 ⭐⭐</h4><p>使用select标签定义下拉菜单的基本语法如下：    </p><pre><code class="html">&lt;select&gt;  &lt;option&gt;选项1&lt;/option&gt;  &lt;option&gt;选项2&lt;/option&gt;  &lt;option&gt;选项3&lt;/option&gt;  ...&lt;/select&gt;</code></pre><p>注意：  </p><ul><li><code>&lt;select&gt;&lt;/select&gt;</code>中至少应包含一对<code>&lt;option&gt;&lt;/option&gt;</code>。</li><li>在option中定义selected=”selected”时，当前项即为默认选中项。    </li></ul><h4 id="表单域-⭐⭐"><a href="#表单域-⭐⭐" class="headerlink" title="表单域 ⭐⭐"></a>表单域 ⭐⭐</h4><p>在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。其基本语法是：    </p><pre><code class="html">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;        各种表单控件   &lt;/form&gt;</code></pre><p>常见属性：   </p><ul><li>Action：在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接受并处理表单数据的服务器程序的url地址。   </li><li>method：用于设置表单数据的提交方式，其取值为get或post。   </li><li>name：用于指定表单的名称，以区分同一个页面中的多个表单。<br>注意：每个表单都应该有自己的表单域。    </li></ul><h4 id="HTML5常用新标签-⭐⭐⭐"><a href="#HTML5常用新标签-⭐⭐⭐" class="headerlink" title="HTML5常用新标签 ⭐⭐⭐"></a>HTML5常用新标签 ⭐⭐⭐</h4><ul><li>header：定义文档的页眉</li></ul><ul><li>nav：定义导航链接的部分</li></ul><ul><li>footer：定义文档或节的页脚</li></ul><ul><li>article：标签规定独立的自包含内容</li></ul><ul><li>section：定义文档中的节（section、区段）</li></ul><ul><li>aside：定义其所处内容之外的内容（侧边）</li></ul><ul><li>datalist：标签定义选项列表，与input元素配合使用</li></ul><ul><li>fieldset：可将表单内的相关元素分组，打包，与legend搭配使用</li></ul><h4 id="HTML5新增的input-type属性"><a href="#HTML5新增的input-type属性" class="headerlink" title="HTML5新增的input type属性"></a>HTML5新增的input type属性</h4><p><img src="/images/html/7.jpg" srcset="/img/loading.gif" alt>     </p><h4 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h4><ul><li>embed：标签定义嵌入的内容</li></ul><ul><li>audio：播放音频</li></ul><ul><li>video：播放视频   </li></ul><h4 id="多媒体embed-⭐⭐"><a href="#多媒体embed-⭐⭐" class="headerlink" title="多媒体embed ⭐⭐"></a>多媒体embed ⭐⭐</h4><p>embed可以用来插入各种多媒体（较大的），格式可以是Wav、AIFF、AU、MP3等。其中url为音频或视频文件的路径，可以是相对路径或绝对路径。其基本语法是：  </p><pre><code class="html">&lt;embed src=&#39;http://player.youku.com/player.php/sid/XMzk4MDUzNTA1Mg==/v.swf&#39; allowFullScreen=&#39;true&#39; quality=&#39;high&#39; width=&#39;480&#39; height=&#39;400&#39; align=&#39;middle&#39; allowScriptAccess=&#39;always&#39; type=&#39;application/x-shockwave-flash&#39;&gt;&lt;/embed&gt;</code></pre><h4 id="多媒体audio-⭐⭐"><a href="#多媒体audio-⭐⭐" class="headerlink" title="多媒体audio ⭐⭐"></a>多媒体audio ⭐⭐</h4><p>HTML5通过<code>&lt;audio&gt;</code>标签来解决音频播放的问题。其基本语法是：  </p><pre><code class="html">&lt;audio src=&quot;./music/See You Again.mp3&quot;&gt;&lt;/audio&gt; //通过src指定音频文件路径即可</code></pre><p>并且可以通过添加属性来更友好控制音频的播放，如：   </p><ul><li>autoplay 自动播放  </li></ul><ul><li>controls 是否显示默认播放组件  </li></ul><ul><li>loop 循环播放 ，loop=2就是循环2次 ，loop或者loop=“-1”无限循环   </li></ul><h4 id="多媒体video-⭐⭐"><a href="#多媒体video-⭐⭐" class="headerlink" title="多媒体video ⭐⭐"></a>多媒体video ⭐⭐</h4><p>同音频播放一样，<code>&lt;video&gt;</code>（通常插入较小的视频）使用也相当简单。其基本语法是：   </p><pre><code class="html">&lt;video src=&quot;./video/movie.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; //通过src指定视频文件路径</code></pre><p>同样，通过附加属性可以更友好的控制视频的播放：  </p><ul><li>autoplay 自动播放</li></ul><ul><li>controls 是否显示默认播放组件</li></ul><ul><li>loop 循环播放 </li></ul><ul><li>width 设置播放窗口的宽度 </li></ul><ul><li>height 设置播放窗口的高度</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP入门笔记</title>
    <link href="/2019/05/05/HTTP%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/05/05/HTTP%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>HTTP 协议是互联网的基础协议，也是现在网页开发的必备知识，2015年出的最新版本 HTTP/2 更是成为互联网技术热点。   </p><p>本文介绍了 HTTP 协议的基础知识以及浏览器和web服务器之间请求和响应的详细信息。  </p><h4 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a><strong>什么是HTTP?</strong></h4><p>HTTP代表超文本传输协议。 这是互联网中数据通信的基础， 数据通信以客户端发送的请求开始，并以从Web服务器接收的响应结束，而HTTP的作用就是指导浏览器和服务器如何进行沟通。   </p><p>HTTP通信过程简图：<br><img src="/images/http/1.jpg" srcset="/img/loading.gif" alt>     </p><ul><li>客户端（通常为浏览器）负责发起请求</li></ul><ul><li>web服务器在 80 端口接收请求</li></ul><ul><li>web服务器之后负责响应请求的内容</li></ul><ul><li>浏览器负责下载响应内容   </li></ul><h4 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a><strong>curl命令</strong></h4><p>curl是一种命令行工具，作用是发出网络请求，然后得到响应和提取数据，显示在”标准输出”（stdout）上面。后面所说的请求，就是通过使用 curl 命令来实现的。比如输入：<code>curl -s -v -- &quot;www.sina.com&quot;</code><br>这一行命令，输出的请求内容为：  </p><pre><code class="bash">&gt; GET / HTTP/1.1&gt; Host: www.sina.com&gt; User-Agent: curl/7.55.0&gt; Accept: */*&gt;      响应内容为:    &lt; HTTP/1.1 200 OK&lt; Date: Sun, 03 Mar 2019 06:17:38 GMT&lt; Content-Type: text/html&lt; Content-Length: 23568&lt; Last-Modified: Sun, 03 Mar 2019 06:16:24 GMT&lt; Connection: keep-alive&lt; ETag: &quot;5c7b7138-5c10&quot;&lt; Expires: Sun, 03 Mar 2019 06:22:38 GMT&lt; Cache-Control: max-age=300&lt; Accept-Ranges: bytes&lt; Set-Cookie: TS0106d18b=0103cff18ca232a2464de8b94e660a71bf04913ec10acc3f4e7336f5c7620c43c          b93a3a1e3e5b394e3b5f0d8d9c8c835e649efa77c; Path=/&lt;</code></pre><p>想了解关于 curl 里的参数，推荐使用explainshell.com来查看解释，很快捷很详细哦。   </p><h4 id="请求的格式"><a href="#请求的格式" class="headerlink" title="请求的格式 "></a><strong>请求的格式 </strong></h4><p>来自计算机客户端的请求一般包含以下几个部分：    </p><blockquote><p>1 请求行：动词 路径 协议/版本 比如： GET /index.html HTTP/1.1<br>2 请求头：Key1: value1<br>2 Key2: value2<br>Key3: value3<br>Content-Type: application/x-www-form-urlencoded<br>Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>User-Agent: curl/7.54.0<br>回车：没有内容<br>4 消息体：要上传的数据    </p></blockquote><ul><li>请求最多包含四部分，最少包含三部分，最少三部分时消息体可以为空，且第三部分永远是一个回车（\n）</li></ul><ul><li>动词有 GET（从服务器获取资源，一项或多项） POST（在服务器新建一个资源） PUT（在服务器整体更新资源，客户端提供改变后的完整资源）PATCH（在服务器局部更新资源，客户端提供改变的属性） DELETE （从服务器删除资源） 等。如果想用POST，就输入：curl -X POST -d “1234567890” -s -v – “<a href="https://www.sina.com&quot;" target="_blank" rel="noopener">https://www.sina.com&quot;</a></li></ul><ul><li>这里的路径包括「查询参数」，但不包括「锚点」</li></ul><ul><li>如果你没有写路径，那么路径默认为 /</li></ul><ul><li>第 2 部分中的 Content-Type 标注了第 4 部分的格式     </li></ul><h4 id="响应的格式"><a href="#响应的格式" class="headerlink" title="响应的格式"></a><strong>响应的格式</strong></h4><p>来自服务器的响应一般包含以下几个部分：   </p><blockquote><p>1 状态行：协议/版本号 状态码 状态描述<br>响应头：Key1: value1<br>Key2: value2<br>Content-Length: 17931<br>Content-Type: text/html<br>回车：没有内容<br>消息体：要下载的内容    </p></blockquote><ul><li>响应都有4个部分，具体其实跟请求的格式差不多</li></ul><ul><li>常见的状态码：   <blockquote><p>200：请求成功<br>请求的资源被永久转移到其他地方（重定向）<br>404：请求的资源不存在<br>500：内部服务器错误   </p></blockquote></li></ul><ul><li>状态码分类      <blockquote><p>1开头：信息，服务器已经收到请求，需要请求者继续执行操作（不常用）<br>2开头：成功，操作被成功接收并处理<br>3开头：重定向，需要进一步操作来完成请求<br>4开头：客户端错误，请求包含语法错误或无法完成请求<br>5开头：服务器错误，服务器在处理请求时发成了错误    </p></blockquote></li></ul><ul><li>状态码列表<br><img src="/images/http/2.jpg" srcset="/img/loading.gif" alt><br><img src="/images/http/3.jpg" srcset="/img/loading.gif" alt>     </li></ul><h4 id="如何在Chrome上检查HTTP请求和响应？"><a href="#如何在Chrome上检查HTTP请求和响应？" class="headerlink" title="如何在Chrome上检查HTTP请求和响应？"></a><strong>如何在Chrome上检查HTTP请求和响应？</strong></h4><p>将Google Chrome视为常用浏览器，在其他浏览器中查看详细信息的过程仍然相同。   </p><ol><li>在Google Chrome中打开网页，然后转到”更多工具 &gt;开发者工具”菜单。</li><li>您也可以通过右键单击页面打开开发人员控制台，然后选择“检查”选项。</li><li>转到“Network”选项，然后重新加载页面。 现在，您将看到页面上每个组件的加载时间。</li><li>点击“Show Overview”图标以删除时间线，以便您可以清楚地查看其他详细信息。</li><li>单击左侧栏上的页面URL，然后转到“Response”选项。 （您还可以在“Preview”选项下查看相同的详细信息）。<br><img src="/images/http/4.jpg" srcset="/img/loading.gif" alt>    </li></ol><p>您可以在上面的部分中详细了解请求和响应的详细信息。 “Headers”选项将显示所选项目的请求和响应的HTTP标头信息的详细信息。    </p><h4 id="HTTP-标头检查工具"><a href="#HTTP-标头检查工具" class="headerlink" title="HTTP 标头检查工具"></a><strong>HTTP 标头检查工具</strong></h4><p>与Chrome类似，还有许多其他免费工具可用于检查HTTP标头中收到的响应代码。 例如，转到此HTTP标头检查工具，输入您要检查的任何URL，然后单击“提交”按钮。   </p><p>例如输入<a href="https://www.baidu.com，您将看到如下标头的详细信息：" target="_blank" rel="noopener">https://www.baidu.com，您将看到如下标头的详细信息：</a>   </p><blockquote><p>HTTP/1.1 200 OK<br>Accept-Ranges: bytes<br>Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform<br>Connection: Keep-Alive<br>Content-Length: 277<br>Content-Type: text/html<br>Date: Sun, 03 Mar 2019 07:27:41 GMT<br>Etag: “575e1f6f-115”<br>Last-Modified: Mon, 13 Jun 2016 02:50:23 GMT<br>Pragma: no-cache<br>Server: bfe/1.0.8.18  </p></blockquote><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
