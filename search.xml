<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript事件三部曲之隐藏在其中的秘密]]></title>
    <url>%2F2019%2F07%2F13%2FJavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9A%90%E8%97%8F%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[上篇文章我们提到，注册事件的方法addEventListener()内有三个参数，分别是「事件名称」、「事件的处理程序」，以及「捕获」或「冒泡」的机制切换。 那么，今天我们要来看的第一个部分，就是隐藏在事件处理程序中的event 。 隐藏在监听函数中的”event”当监听的事件发生时，浏览器会去执行我们通过addEventListener()注册的事件处理程序函数。 这个时候，EventListener 会去创建一个「事件对象」 (Event Object)，里面包含了所有与这个事件相关的属性，并且以「参数」的形式传给我们的处理程序函数： 123456789&lt;button id="btn"&gt;Click&lt;/button&gt;......var btn = document.getElementById('btn');// 参数 e 就是上面所说的事件对象 // 因为是参数，当然可以自己定名称btn.addEventListener('click', function(e)&#123; console.log(e);&#125;, false); 当点击&lt;button&gt;后，可以从console看到event对象中提供了这么多东西： 像是 type : 表示事件的名称 target : 表示触发事件的元素 bubbles:表示这事件是否是在「冒泡」阶段触发( true/ false) pageX/ pageY:表示事件触发时，鼠标座标在网页的相对位置 其余的属性这里就不一一介绍，不过要注意的是，每个「事件对象」所提供的属性都会根据触发的事件而稍微不同。 event. preventDefault()HTML中部分元素会有默认行为，像是&lt;a&gt;标签默认页面跳转或是锚点定位，或是表单的submit等等… 如果我们需要在这些元素上绑定事件，那么适当地取消它们的默认行为就是很重要的一件事。 比如，有一个通往baidu的链接&lt;a&gt;: 1&lt;a id="link" href="https://www.baidu.com"&gt;百度&lt;/a&gt; 假设今天点击这个link时，我希望浏览器执行console.log(&#39;米淇淋你好帅!&#39;);那么根据先前所说，我可以先注册click事件： 12345var link = document.querySelector('#link');link.addEventListener('click', function (e) &#123; console.log('米淇淋你好帅!');&#125;, false); 结果你却发现，即便我们在&lt;a&gt;中去注册了click事件，但是当我点击这个link的时候，浏览器开始会console.log出”米淇淋你好帅!”，但最后baidu的网页依旧会覆盖我想要的内容。 可是我希望执行的是console.log(&#39;米淇淋你好帅!&#39;);而不是直接把我带偏了去到baidu的网站，那么我们该怎么做，才能避免呢？ 这时候如果调用event.preventDefault()方法，默认事件行为将不再触发： 1234567var link = document.querySelector('#link');// 在 事件处理函数中 加上 e.preventDefault();link.addEventListener('click', function (e) &#123; e.preventDefault(); console.log('米淇淋你好帅!');&#125;, false); 这个时候，再试着点击link一次，你会发现浏览器默认的跳转页面的行为不见了，console.log(&#39;米淇淋你好帅!&#39;);也可顺利执行啦哈哈。 但要注意的是，event.preventDefault()并不会阻止事件向上传递(即事件冒泡) 。 另外，值得一提的是，下面这样设置也可以让a标签仅仅当做一个普通的按钮，点击实现一个功能，不想页面跳转，也不想锚点定位： 1&lt;a href="javascript:;"&gt;链接&lt;/a&gt; 此外，在事件处理函数的最后加上return false;也会有event.preventDefault()的效果，但切记不可以加在前面，若是加在前面事件处理函数就直接gg了。 event.stopPropagation() &amp; event.stopImmediatePropagation()1.event.stopPropagation() 方法阻止事件向上冒泡传递，阻止任何父事件处理程序被执行。 接下来我们看个例子： 123456789101112131415161718192021222324252627282930313233&lt;div&gt; &lt;div id="parent"&gt; 父元素 &lt;div id="child"&gt;子元素&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;......var parent = document.getElementById('parent');var child = document.getElementById('child');child.addEventListener('click', function () &#123; console.log('child bubbling');&#125;, false);parent.addEventListener('click', function () &#123; console.log('parent bubbling');&#125;, false);document.body.addEventListener('click', function () &#123; console.log('body bubbling');&#125;, false);document.documentElement.addEventListener('click', function () &#123; console.log('html bubbling');&#125;, false);document.addEventListener('click', function () &#123; console.log('document bubbling');&#125;, false);window.addEventListener('click', function () &#123; console.log('window bubbling');&#125;, false); 当我点击的是「子元素」的时候，通过console.log可以观察到事件触发的顺序为： 123456child bubblingparent bubblingbody bubblinghtml bubblingdocument bubblingwindow bubbling 而如果在「子元素」中加入event.stopPropagation() 方法，其余保持原样的话： 1234child.addEventListener('click', function (e) &#123; console.log('child bubbling'); e.stopPropagation();&#125;, false); 再次点击「子元素」，则只出现： 1child bubbling 其余父事件不会触发，即event.stopPropagation() 方法阻止了事件向上冒泡传递，阻止任何父事件处理程序被执行。 2.stopImmediatePropagation()方法 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发。而 stopPropagation 只能实现前者的效果。 我们来看个例子： 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;button id="btn"&gt;click me to stop propagation&lt;/button&gt;&lt;/body&gt;......var btn = document.querySelector('#btn');btn.addEventListener('click', function(e) &#123; console.log('btn click 1'); //e.stopImmediatePropagation();&#125;);btn.addEventListener('click', function() &#123; console.log('btn click 2');&#125;);document.body.addEventListener('click', function() &#123; console.log('body click');&#125;);document.documentElement.addEventListener('click', function() &#123; console.log('html click');&#125;);document.addEventListener('click', function() &#123; console.log('document click');&#125;);window.addEventListener('click', function() &#123; console.log('window click');&#125;); 当我点击button的时候，通过console.log可以观察到事件触发的顺序为： 123456btn click 1btn click 2body clickhtml clickdocument clickwindow click 而如果在「btn的第一个监听函数」中加入event.stopImmediatePropagation() 方法，其余保持原样的话： 1234btn.addEventListener('click', function(e) &#123; console.log('btn click 1'); e.stopImmediatePropagation();&#125;); 再次点击button，则只出现： 1btn click 1 所以说，使用 stopImmediatePropagation() 方法后，点击按钮时，仅触发设置了stopImmediatePropagation() 方法的监听器，与此同时按钮的其余同类型点击事件不触发。 event.target &amp; event.currentTarget老实说并不能好好用文字描述这两者的区别，我们直接看个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style&gt; #a&#123; width: 200px; height: 200px; background: yellow ; &#125; #b&#123; width: 150px; height: 150px; background: green; &#125; #c&#123; width: 100px; height: 100px; background: grey; &#125; #d&#123; width: 50px; height: 50px; background: black; &#125;&lt;/style&gt;......&lt;div id="a"&gt; &lt;div id="b"&gt; &lt;div id="c"&gt; &lt;div id="d"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;......document.getElementById('a').addEventListener('click', function(e) &#123; console.log( 'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id )&#125;) document.getElementById('b').addEventListener('click', function(e) &#123; console.log( 'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id )&#125;) document.getElementById('c').addEventListener('click', function(e) &#123; console.log( 'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id )&#125;) document.getElementById('d').addEventListener('click', function(e) &#123; console.log( 'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id )&#125;) jsbin 点这里。 当我们点击最里层黑色区域的元素d的时候，会依次输出: 1234target:d&amp;currentTarget:dtarget:d&amp;currentTarget:ctarget:d&amp;currentTarget:btarget:d&amp;currentTarget:a 从输出中我们可以看到，event.target指向引起触发事件的元素，而event.currentTarget则是事件绑定的元素，只有被点击的那个目标元素的event.target才会等于event.currentTarget。也就是说，event.currentTarget始终是监听事件者，而event.target是事件的真正发出者。 另外，值得一提的是，function内部的this指的也就是event.currentTarget。 事件代理由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件代理或叫事件委托（Event Delegation）。 1.优点 减少内存消耗，提高性能 假设有一个列表，列表之中有大量的列表项，我们需要在点击每个列表项的时候响应一个事件： 1234567&lt;ul id="myList"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; ...... &lt;li&gt;Item n&lt;/li&gt;&lt;/ul&gt; 如果给每个列表项都绑定一个函数，假如此时列表项很多，那无疑对内存的消耗是非常大的，并且效率上需要消耗很多性能。借助事件代理，我们只需要给父容器 ul 绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。 动态绑定事件 在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。 2.如何实现接下来我们来实现上例中父层元素 #myList 下的 li 元素的事件委托到它的父层元素上： 123456789101112131415161718192021222324// 取得容器var myList = document.getElementById('myList');// 让父层 myList 来监听 click 事件myList.addEventListener('click', function(e)&#123; // 判断目标元素若是 li 则执行 console.log if( e.target.tagName.toLowerCase() === 'li' )&#123; console.log(e.target.textContent); &#125;&#125;, false);// 建立新的 &lt;li&gt; 元素var newList = document.createElement('li');// 建立 textNode 文字节点var textNode = document.createTextNode("Hello world!");// 通过 appendChild 将 textNode 加入至 newListnewList.appendChild(textNode);// 通过 appendChild 将 newList 加入至 myListmyList.appendChild(newList); 我们把click事件改由父层的myList来监听，利用事件传递的原理，判断e.target是我们想要的目标节点时，才去执行后续的动作。 这样的好处是你的事件管理会非常轻松，而且后续加上的newList也会有click的效果，无需另外再去绑定click事件。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件三部曲之事件机制的原理]]></title>
    <url>%2F2019%2F07%2F11%2FJavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[JavaScript 是一个事件驱动(Event-driven) 的语言，当浏览器载入网页开始读取后，虽然马上会读取JavaScript 事件相关的代码，但是必须要等到「事件」被触发(如使用者点击、按下键盘等)后，才会再进行对应代码段的执行。 啥意思呢？ 就好比放了一部电话在家里，但是电话要是没响，我们不会主动去「接电话」 (没人打来当然也无法主动接) ，这里电话响了就好比事件被触发，接电话就好比去做对应的事情。 电话响了(事件被触发) -&gt; 接电话(去做对应的事)换以我们很常见的网页对话框UI 来说，当使用者「按下了按钮」之后，才会启动对话框的显示。如果使用者没有按下按钮，就狂跳对话框，那使用者一定觉得这网站瓦特了吧。 以Bootstrap Modal 为例： 在上面的例子中，当使用者点击了按钮，才会启动对话框的显示，那么「点击按钮」这件事，就被称作「事件」(Event)，而负责处理事件的代码段通常被称为「事件处理程序」(Event Handler)，也就是「启动对话框的显示」这个动作。 看完上面的例子，想必大家对事件有了一定的理解了吧，接下来就深入来探讨DOM事件。 DOM事件级别DOM有4次版本更新，与DOM版本变更，产生了3种不同的DOM事件：DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理。由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件。 DOM 0级事件1.on-event (HTML 属性)： 1&lt;input onclick="alert('xxx')"/&gt; 需要注意的是，基于代码的使用性与维护性考量，现在已经不建议用此方式来绑定事件。 on-event (非HTML 属性)： 像是window或document此类没有实体元素的情况： 123window.onload = function()&#123; document.write("Hello world!");&#125;; 若是实体元素： 12345678// HTML&lt;button id="btn"&gt;Click&lt;/button&gt;// JavaScriptvar btn = document.getElementById('btn'); btn.onclick = function()&#123; alert('xxx'); &#125; 若想解除事件的话，则重新指定on-event为null即可： 1btn.onclick = null 2.同一个元素的同一种事件只能绑定一个函数，否则后面的函数会覆盖之前的函数 3.不存在兼容性问题 DOM 2级事件1.Dom 2级事件是通过 addEventListener 绑定的事件 2.同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行 3.解绑Dom 2级事件时，使用 removeEventListener 1btn.removeEventListener( "click" ,a) Dom 2级事件有三个参数：第一个参数是事件名（如click）；第二个参数是事件处理程序函数；第三个参数如果是true的话表示在捕获阶段调用，为false的话表示在冒泡阶段调用。捕获阶段和冒泡阶段在下一节具体介绍。 还有注意removeEventListener():不能移除匿名添加的函数。 DOM 3级事件DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，增加的类型如下： UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified 同时DOM3级事件也允许使用者自定义一些事件。 DOM事件流事件流(Event Flow)指的就是「网页元素接收事件的顺序」。事件流可以分成两种机制： 事件捕获(Event Capturing) 事件冒泡(Event Bubbling) 当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段： 捕获阶段：事件从window对象自上而下向目标节点传播的阶段； 目标阶段：真正的目标节点正在处理事件的阶段； 冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。 接着就来分别介绍事件捕获和事件冒泡这两种机制。 事件捕获(Event Capturing) 事件捕获指的是「从启动事件的元素节点开始，逐层往下传递」，直到最下层节点，也就是div。 假设HTML 如下： 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;米淇淋是个大帅哥&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;点我&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 假设我们点击(click)了&lt;div&gt;点我&lt;/div&gt;元素，那么在「事件捕获」的机制下，触发事件的顺序会是： document &lt;html&gt; &lt;body&gt; &lt;div&gt;点我&lt;/div&gt; 像这样click事件由上往下依序被触发，就是「事件捕获」机制。 事件冒泡(Event Bubbling) 刚刚说过「事件捕获」机制是由上往下来传递，那么「事件冒泡」(Event Bubbling) 机制则正好相反。 假设HTML 同样如下： 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;米淇淋是个大帅哥&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;点我&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 假设我们点击(click)了&lt;div&gt;点我&lt;/div&gt;元素，那么在「事件冒泡」的机制下，触发事件的顺序会是： &lt;div&gt;点我&lt;/div&gt; &lt;body&gt; &lt;html&gt; document 像这样click事件逐层向上依序被触发，就是「事件冒泡」机制。 既然事件传递顺序有这两种机制，那我怎么知道事件是依据哪种机制执行的呢？ 答案是：两种都会执行。 假设现在的事件是点击上图中蓝色的&lt;td&gt;。 那么当td的click事件发生时，会先走红色的「capture phase」： Document &lt;html&gt; &lt;body&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; (实际被点击的元素) 由上而下依序触发它们的click事件。 然后到达「Target phase」后再继续执行绿色的「bubble phase」，反方向由&lt;td&gt;一路往上传至Document，整个事件流到此结束。 要检验事件流，我们可以通过addEventListener()方法来绑定click事件： 假设HTML 如下： 123456&lt;div&gt; &lt;div id="parent"&gt; 父元素 &lt;div id="child"&gt;子元素&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JavaScript 代码如下： 123456789101112131415161718192021var parent = document.getElementById('parent');var child = document.getElementById('child');// 通过 addEventListener 指定事件的绑定// 第三个参数 true / false 分別代表 捕获/ 冒泡 机制parent.addEventListener('click', function () &#123; console.log('Parent Capturing');&#125;, true);parent.addEventListener('click', function () &#123; console.log('Parent Bubbling');&#125;, false);child.addEventListener('click', function () &#123; console.log('Child Capturing');&#125;, true);child.addEventListener('click', function () &#123; console.log('Child Bubbling');&#125;, false); 当我点击的是「子元素」的时候，通过console.log可以观察到事件触发的顺序为： 1234"Parent Capturing""Child Capturing""Child Bubbling""Parent Bubbling" 而如果直接点击「父元素」，则出现： 12"Parent Capturing""Parent Bubbling" 由此可知，点击子元素的时候，父层的Capturing会先被触发，然后再到子层内部的Capturing或Bubbling事件。最后才又回到父层的Bubbling结束。点击父元素的时候，不会经过子元素，子层的Capturing和Bubbling都不会触发。 那么，子层中的Capturing或Bubbling谁先谁后呢？要看你代码的顺序而定： 若是Capturing在Bubbling前面： 1234567child.addEventListener('click', function () &#123; console.log('Child Capturing');&#125;, true);child.addEventListener('click', function () &#123; console.log('Child Bubbling');&#125;, false); 则会得到： 12"Child Capturing""Child Bubbling" 若是将两段代码段顺序反过来的话，就会是这样了： 1234567child.addEventListener('click', function () &#123; console.log('Child Bubbling');&#125;, false);child.addEventListener('click', function () &#123; console.log('Child Capturing');&#125;, true); 则会得到： 12"Child Bubbling""Child Capturing" 事件监听 EventTarget.addEventListener()addEventListener()基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的function)，以及一个「Boolean」值，由这个Boolean决定事件是以「捕获」还是「冒泡」机制执行，若不指定则预设为「冒泡」。 123456789// HTML&lt;button id="btn"&gt;Click&lt;/button&gt;// JavaScriptvar btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false); 使用这种方式来注册事件的好处是：同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行。 123456789var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false);btn.addEventListener('click', function()&#123; console.log('HELLO');&#125;, false); 点击后console出现： 12"HI""HELLO" 若要解除事件的监听，则是通过removeEventListener()来取消。 removeEventListener()的三个参数与addEventListener()一样，分别是「事件名称」、「事件的处理程序」以及代表「捕获」或「冒泡」机制的「Boolean」值。 但是需要注意的是，由于addEventListener()可以同时针对某个事件绑定多个函数，所以通过removeEventListener()解除事件的时候，第二个参数的函数必须要与先前在addEventListener()绑定的函数是同一个「实体」。 比如： 12345678910var btn = document.getElementById('btn');btn.addEventListener('click', function()&#123; console.log('HI');&#125;, false);// 移除事件，但是没用btn.removeEventListener('click', function()&#123; console.log('HI');&#125;, false); 像上面这样，即使执行了removeEventListener来移除事件，但click时仍会出现’HI’。因为addEventListener与removeEventListener所移除的函数实际上是两个不同实体的function对象。 不知道为什么这两个function是两个不同实体的朋友请参考：《JavaScript系列之内存空间》。简单理解就是两个function指向不同的内存地址，代表来自于不同实体。 稍加改进后就能如愿移除了： 1234567891011var btn = document.getElementById('btn');// 把 event 函数程序拉出來var clickHandler = function()&#123; console.log('HI');&#125;;btn.addEventListener('click', clickHandler, false);// 移除 clickHandler， ok!btn.removeEventListener('click', clickHandler, false); 那么以上就是今天为各位介绍JavaScript事件机制原理的部分。 接下来的文章我会继续来介绍事件的种类，以及更多实际上处理「事件」时需要注意的事项。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之类数组对象arguments]]></title>
    <url>%2F2019%2F07%2F06%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1arguments%2F</url>
    <content type="text"><![CDATA[之前在《JavaScript系列之this是什么》这篇文章中，我们曾谈过”this”这个关键字，本章将会谈到另一个JavaScript中的关键字，叫做”arguments”。 那arguments到底是什么呢？下面我将尽可能地用简洁明了的言语来描述 arguments。 什么是参数(parameters)在了解arguments之前，我们必须要先了解一下什么是参数(parameter)。参数其实就是我们会带入函数的变量，以下面例子来说，”house”、”car”、”money”，就是我们在执行函式的时候可以任意填入的参数。 1234567function MyFavorite(house, car, money) &#123; console.log(house); console.log(car); console.log(money);&#125;MyFavorite(); 首先，当我建立好这样的函数，我可以不带任何参数值就去执行这个函数，只要输入MyFavorite()这样就可以了！ 一般如果有参数却又没有给它参数值，函数的执行上往往会有错误！但在JavaScript中不太一样的地方在于，即使你没有给它任何参数值就加以执行，也不会报错，而是会返回undefined。 为什么会得到”undefined“呢？ 之所以会这样是因为当JavaScript在执行这个函数的时候，由于提升机制，它会先把我们的参数(house, car, money)存到内存中了，并且赋予它的值是undefined。 参数值会由左至右读取，如果我依序执行这样的代码就理解了： 1234MyFavorite();MyFavorite("别墅");MyFavorite("别墅", "法拉利");MyFavorite("别墅", "法拉利", "一亿元"); 会分别读到以下的结果，表示JavaScript会由左至右来读取参数值，而且即使某些参数值有缺值的情况，JavaScript还是可以正常执行。 设置函数中参数的预设值由于目前的几款浏览器使用的JavaScript版本都尚不支持直接在参数的地方设置预设值（ES6的将可以），所以很多的框架都还不会用这种方式设置预设值。 方法一：在ES6的JavaScript中，可以直接通过这种方式设置参数预设值： 123456function MyFavorite(house, car, money = '一亿元') &#123; console.log(house); console.log(car); console.log(money); console.log("----------------");&#125; 方法二：利用强制转换的概念设置预设值 由于版本兼容的差异，现今多数的编程都是使用这种方式设置参数的预设值，利用简单的”=”和”||”就可以达到参数预设值的效果： 12345678function MyFavorite(house, car, money) &#123; money = money || '一亿元'; console.log(house); console.log(car); console.log(money); console.log("----------------");&#125; 这时候即使在没有给值的情况下，money一样可以得到预设值为”一亿元”： 类数组对象了解了parameters的概念后，让我们回来谈谈arguments，MDN将它叫做类数组对象，那么什么是类数组对象呢？ 所谓的类数组对象: 就是拥有一个 length 属性和若干索引属性的对象 举个例子： 123456789101112131415161718192021222324252627var array = ['house', 'car', 'money'];var arrayLike = &#123; 0: 'house', 1: 'car', 2: 'money', length: 3&#125;//读取console.log(array[0]); // houseconsole.log(arrayLike[0]); // housearray[0] = 'new house';arrayLike[0] = 'new house';//长度console.log(array.length); // 3console.log(arrayLike.length); // 3//遍历for(var i = 0, len = array.length; i &lt; len; i++) &#123; ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; ……&#125; 上面我们可以看得出来，类数组对象与数组在读取、获取长度、遍历三个方面一样，都能取到，那为什么还叫做类数组对象呢？ 因为类数组对象不可以使用数组的方法，比如： 1arrayLike.push('name'); 然而上述代码会报错: arrayLike.push is not a function，所以终归还是类数组呐…… 调用数组方法如果类数组想用数组的方法怎么办呢？ 直接调用是不可取的，那我们可以通过 Function.call 的方法进行间接调用： 1234567891011var arrayLike = &#123;0: 'house', 1: 'car', 2: 'money', length: 3 &#125;console.log(Array.prototype.join.call(arrayLike, '&amp;')); // house&amp;car&amp;moneyconsole.log(Array.prototype.slice.call(arrayLike, 0)); // ["house", "car", "money"] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item)&#123; return item.toUpperCase();&#125;); // ["HOUSE", "CAR", "MONEY"] 在上面已经提到了一种类数组转数组的方法，再补充三个： 123456789var arrayLike = &#123;0: 'house', 1: 'car', 2: 'money', length: 3 &#125;// 1. sliceconsole.log(Array.prototype.slice.call(arrayLike)); // ["house", "car", "money"] // 2. spliceconsole.log(Array.prototype.splice.call(arrayLike, 0)); // ["house", "car", "money"] // 3. ES6 Array.fromconsole.log(Array.from(arrayLike)); // ["house", "car", "money"] // 4. applyconsole.log(Array.prototype.concat.apply([], arrayLike)); 接下来重点讲讲 Arguments 这个类数组对象。 arguments对象arguments比起this来说，要容易理解的多，arguments对象只定义在函数体中，包括了函数的参数和其他属性。 同样地通过上面的例子加以理解，我们直接在函数中去打印出”arguments”这个关键字： 123456789101112function MyFavorite(house, car, money) &#123; money = money || '一亿元'; console.log(arguments); console.log("----------------");&#125;MyFavorite();MyFavorite("别墅");MyFavorite("别墅", "法拉利");MyFavorite("别墅", "法拉利", "一亿元"); 打印结果如下： 我们可以看到除了类数组的索引属性和length属性之外，还有一个callee属性，而且我们可以看到arguments对象的__ proto __是指向object的，这也说明了他是个类数组对象，而不是一个数组。下面我们进行一一介绍。 length属性arguments.length为函数实参个数，举个例子： 12345678910function foo(house, car, money)&#123; console.log("实参的长度为：" + arguments.length)&#125;console.log("形参的长度为：" + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee属性每个参数实例都有一个callee属性，通过它可以调用函数自身。 ES5的严格模式不允许访问arguments.callee。 讲个闭包经典面试题使用 callee 的解决方法： 123456789101112131415var data = [];for (var i = 0; i &lt; 3; i++) &#123; (data[i] = function () &#123; console.log(arguments.callee.i) &#125;).i = i;&#125;data[0]();data[1]();data[2]();// 0// 1// 2 最后来看看展开运算符spread(…)除了arguments这个关键字，在新版ES6的JavaScript中另外提供了一个展开运算符(spread)，它就是「...」三个点，这个...有什么用呢？ 根据MDN对于展开运算符spread的描述如下： The spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) or multiple variables (for destructuring assignment) are expected. 简单来说，就是它可以把函数中许多的参数(arguments)或数组中许多的元素(elements)形成一个新的变量。 举例来说： 在函数的部分，在参数的地方我们用”...other“，other是你想要储存成的数组变量名称，可以自己取。 在执行函数的地方，原本我们只有三个参数(house, car, money)，也只能填写三个参数；但使用了展开运算符”...“后，我们在执行函数的地方就可以带入不只三个参数（例如，我在最后面又加了”老婆”和”孩子”），这些多的参数值最后都会被放到other这个数组当中。 123456789function MyFavorite(house, car, money, ...other)&#123; console.log(other); console.log('What my favorite are' + house + ',' + car + ',' + money + ',' + other);&#125;MyFavorite("别墅", "法拉利", "一亿");MyFavorite("别墅", "法拉利", "一亿", "老婆", "孩子"); 结果就会长的像这样子： 展开运算符还有其他的使用方式，像是把数组元素做连接等等，使用灵活的话相当方便，如果有需要的话，可以参考引1。 引1：Microsoft Developer Netword：展开运算符(…) 应用1.利用arguments实现方法的重载 下面我们利用arguments对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。 123456789101112function add() &#123; var len = arguments.length, sum = 0; for(;len--;)&#123; sum += arguments[len]; &#125; return sum;&#125;console.log( add(1,2,3) ); //6console.log( add(1,3) ); //4console.log( add(1,2,3,5,6) ); //17 由于JS是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用arguments，来判断传入的实参类型与数量进行不同的操作，然后返回不同的数值。 2.利用arguments.callee实现递归 先来看看平常我们是怎么实现递归的，这是一个结算阶乘的函数。 1234567function foo(num) &#123; if(num&lt;=1) &#123; return 1; &#125;else &#123; return num * foo(num-1); &#125; &#125; 但是当这个函数变成了一个匿名函数时，我们就可以利用callee来递归这个函数。 1234567function foo(num) &#123; if(num&lt;=1) &#123; return 1; &#125;else &#123; return num * arguments.callee(num-1); &#125; &#125; 这个方法虽然好用，但是有一点值得注意，ECMAScript4中为了限制JS的灵活度，让JS变得严格，新增了严格模式，在严格模式中我们被禁止不使用var来直接声明一个全局变量，当然这不是重点，重点是arguments.callee这个属性也被禁止了。不过这都不是事儿，ES6为我们新增了很多好用的变量声明方式和新的语法糖，作为一个时髦的前端，我们赶紧学习一些ES6的新语法吧。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>arguments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flexbox 对你说爱不完]]></title>
    <url>%2F2019%2F07%2F04%2FCSS%20Flexbox%20%E5%AF%B9%E4%BD%A0%E8%AF%B4%E7%88%B1%E4%B8%8D%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[Flexbox 意为弹性布局，是一种新的CSS 3 布局方式，与传统布局方式(基于盒模型，依赖display属性 +position属性 +float属性)相比，flex布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。 废话就不多说了，下面我将尽可能地用简洁明了的言语来描述 Flex 布局。 基本概念 使用了flex布局，则有flex容器（flex container），子元素为项目(flex item）。 在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，start和end表示对应轴的起始位置，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴。比如将Flexbox的方向设置为row，则主轴就是横轴，而交叉轴就是纵轴；反之设置成column，则主轴就是纵轴，而交叉轴就是横轴，这个下面会具体讲。 每个项目(flex item)占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。 这里还需要注意的是，不能直截了当地认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。 实际上，要实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。语法如下： 123.container &#123; display: flex | inline-flex; //可以有两种取值&#125; 给div这类块元素设置display: flex或者给span这类行内元素设display: inline-flex，flex布局即创建！ 而Flex布局相关属性正好分为两拨，一拨作用在flex容器上，还有一拨作用在flex子项上。 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex容器上的属性有下面六种属性可以设置在容器上，它们分别是： flex-direction flex-wrap flex-flow justify-content align-items align-content 1. flex-direction: 决定主轴的方向(即项目的排列方向) 123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 2. flex-wrap: 决定容器内项目是否可换行 默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）：不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行 wrap：项目主轴总尺寸超出容器时换行，第一行在上方 wrap-reverse：换行并反向，第一行在下方 3. flex-flow: flex-direction 和 flex-wrap 的复合简写形式 123.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 默认值为: row nowrap，这个属性其实没多大卵用，不就是两个属性的缩写嘛。 4. justify-content：定义项目在主轴的对齐方式 123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 建立在主轴为水平方向时的测试，即 flex-direction: row flex-start（默认）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙 space-around：每个项目两侧的间隔相等，所以项目之间的间隔是项目与边缘的间隔的两倍 5. align-items: 定义项目在交叉轴上的对齐方式 123.container &#123; align-items: stretch | flex-start | flex-end | center | baseline;&#125; 建立在主轴为水平方向时的测试，即 flex-direction: row stretch（默认）：如果项目未设置高度或设为auto，将占满整个容器的高度 假设容器高度设置为 50px，而项目都没有设置高度或设为auto的情况下，则项目的高度也为 50px flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 以文字的底部为主 6. align-content: 定义多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 123.container &#123; align-content: stretch | flex-start | flex-end | center | space-between | space-around;&#125; 什么叫项目只有一根轴线呢？其实可以这么理解： 当你 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。 当你 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。 建立在主轴为水平方向时测试，即 flex-direction: row, flex-wrap: wrap stretch（默认）：轴线占满整个交叉轴 flex-start：轴线全部与交叉轴上的起点对齐 flex-end：轴线全部与交叉轴上的终点对齐 center：轴线全部在交叉轴上的中间对齐 space-between：轴线与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每个轴线两侧的间隔都相等，所以轴线之间的间隔是轴线与边缘的间隔的两倍 到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item（项目） 上的属性。 Flex 项目上的属性item 项目上有六种属性可运用，它们分别是： order flex-grow flex-shrink flex-basis flex align-self 1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0 123.item &#123; order: &lt;integer&gt;;&#125; 2. flex-grow: 定义项目的放大比例 123.item &#123; flex-grow: &lt;number&gt;;&#125; 默认值为 0，即如果存在剩余空间，也不放大。 如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink: 定义项目的缩小比例 123.item &#123; flex-shrink: &lt;number&gt;;&#125; flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4. flex-basis: 定义了在分配容器剩余空间之前项目的默认大小。相当于对浏览器提前告知：浏览器兄弟，我要占据这么大的空间，提前帮我预留好 123.item &#123; flex-basis: &lt;length&gt; | auto;&#125; 默认值：auto，即项目本来的大小, 这时候 item 项目的宽高取决于 width 或 height 的值。 当主轴为水平方向的时候，同时设置 width 和 flex-basis，会忽略 width。flex顾名思义就是弹性的意思，因此，实际上不建议对flex项目使用 width 属性，因为不够弹性。 当容器剩余空间不足的时候，flex子项目的实际宽度通常不是设置的 flex-basis 尺寸，因为flex布局剩余空间不足的时候默认会收缩，如果有3个子项目，则默认按1:1:1收缩。 5. flex: flex-grow, flex-shrink 和 flex-basis的复合缩写 123.item&#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值为0 1 auto。 有关快捷值： 12flex: auto //等同于flex:1 1 autoflex: none //等同于flex:0 0 auto 6. align-self: 控制单独某一个项目的垂直对齐方式，与align-items属性语法区别不大 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 唯一区别就是align-self多了个auto（默认值），表示继承自flex容器的align-items属性值，如果没有父元素，则等同于 stretch。 跟 align-items 其他属性值含义一样，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。 从垂直居中看出flex的强大以往让元素垂直居中并不容易，直到CSS3的出现，使用绝对定位配合translate属性才让垂直居中变得简单，不过还有一个更爽的办法，那就是使用flex，让垂直居中变得异常简单 12345&lt;div class=“wrapper”&gt; &lt;div class=“div”&gt; flexbox 对你说爱不完 &lt;/div&gt;&lt;/div&gt; 几行简单代码，即可让div垂直居中 12345.wrapper &#123; display: flex; align-items: center; justify-content: center;&#125; 这里最重要的就是包裹元素的三个关键属性: display: flex 将容器指定为flex布局，任何一个元素都可以指定 align-items: center 沿交叉轴对齐项目，这里指的是垂直方向 justify-content: center 设置主轴内容对齐方式 其他Flex知识点 在Flex布局中，再强调一遍flex子元素中设置float，clear以及vertical-align属性都是没有用的。 Flexbox布局最适合应用程序的组件和小规模布局（一维布局），而Grid布局则适用于更大规模的布局（二维布局），有关Grid布局的文章后面会补充。 已经9102年了，Flex老语法不用在管了，果断放弃，然后私有前缀也不用再加了，看到就烦。 如果想更好地理解Flex的工作原理，可以在此页面上尝试flex 布局编辑器。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之闭包]]></title>
    <url>%2F2019%2F07%2F02%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)%2F</url>
    <content type="text"><![CDATA[相信很多初学者在学习JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。 在具体介绍闭包之前，为了更好的理解本文要介绍的内容，建议先去阅读前面的文章《JavaScript系列之变量对象》和《JavaScript系列之作用域和作用域链》，因为它们相互之间都是有关联的。 闭包是什么？首先，先来看看MDN 对闭包的定义： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是一个既不是函数的形参，也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 好，如果上面三行就看得懂的话那么就不用再往下看了，Congratulations！ …… 不过如果你是初学者的话，我想应该不会，如果仅用三言两语就把闭包讲通，那还能称为Javascript 语言的一个难点吗？ 先来举个例子： 1234567var n = 1;function f1() &#123; console.log(n); // 1&#125;f1() f1 函数可以访问变量 n，但是 n 既不是 f1 函数的形参，也不是 f1 函数的局部变量，所以这种情况下的 n 就是自由变量。其实上面代码中就存在闭包了，即函数 f1 + f1 函数访问的自由变量 n 就构成了一个闭包。 上面代码中，函数 f1 可以读取全局自由变量 n。但是，函数外部无法读取函数内部声明的变量： 12345function f1() &#123; var n = 1;&#125;console.log(n) // Uncaught ReferenceError: n is not defined 如果有时需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过改变形式才能实现。那就是在函数的内部，再定义一个函数。 12345678910function f1() &#123; var n = 1; function f2() &#123; console.log(n); // 1 &#125; return f2;&#125;var a = f1();a(); 上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量了。 所以闭包是一个可以从另一个函数的作用域访问变量的函数。这是通过在函数内创建函数来实现的。当然，外部函数无法访问内部范围。 在我们深入研究闭包之前，有必要先从不使用闭包的情况切入，了解为什么要用闭包。 不使用闭包的情况在JavaScript 中，全局变量的错用可能会使得我们的代码出现不可预期的错误。 假设我们现在要做一个计数的函数，一开始我们想要先写一个给狗的计数函数： 1234567891011// 狗的计数函数var count = 0function countDogs () &#123; count += 1 console.log(count + ' dog(s)')&#125;countDogs() // 1 dog(s)countDogs() // 2 dog(s)countDogs() // 3 dog(s) 接着继续写代码的其他部分，当写到后面时，我发现我也需要写猫的计数函数，于是我又开始写了猫的计数函数： 12345678910111213141516171819202122// 狗的计数函数var count = 0function countDogs () &#123; count += 1 console.log(count + ' dog(s)')&#125;// 中间的其它代码...// 猫的计数函数var count = 0function countCats () &#123; count += 1 console.log(count + ' cat(s)')&#125;countCats() // 1 cat(s)countCats() // 2 cat(s)countCats() // 3 cat(s) 乍看之下好像没啥问题，当我执行countDogs()或countCats()，都会让count增加，然而问题在于当我在不注意的情况下把count这个变量建立在了全局作用域底下时，不论是执行countDogs()或是countCats()时，都是用到了全局的count变量，这使得当我执行下面的代码时，它没有办法分辨现在到底是在对狗计数还是对猫计数，进而导致把猫的数量和狗的数量交错计算的错误情况： 12345678countCats() // 1 cat(s)countCats() // 2 cat(s)countCats() // 3 cat(s)countDogs() // 4 dog(s)，我希望是 1 dog(s)countDogs() // 5 dog(s)，我希望是 2 dog(s)countCats() // 6 cat(s)，我希望是 4 cat(s) 闭包让函数有私有变量从上面的例子我们知道，如果错误的使用全局变量，很容易会出现一些莫名其妙的bug ，这时候我们就可以利用闭包（closure）的写法，让函数有自己私有变量，简单来说就是countDogs里面能有一个计算dogs的count变数；而countCats里面也能有一个计算cats的count变量，两者是不会互相干扰的。 为了达到这样的效果，我们就要利用闭包，让变量保留在该函数中而不会被外在环境干扰。 改成闭包的写法会像这样： 12345678910111213function dogHouse () &#123; var count = 0 function countDogs () &#123; count += 1 console.log(count + ' dogs') &#125; return countDogs&#125;const countDogs = dogHouse()countDogs() // "1 dogs"countDogs() // "2 dogs"countDogs() // "3 dogs" 这样我们就将专门计算狗的变量count闭包在dogHouse这个函数中，在dogHouse这个函数中里面的countDogs()才是我们真正执行计数的函数，而在dogHouse这个函数中存在count这个变量，由于JavaScript变量会被缩限在函数的执行上下文中，因此这个count的值只有在dogHouse里面才能被取用，在dogHouse函数外是取用不到这个值的。 接着因为我们要能够执行在dogHouse中真正核心countDogs()这个函数，因此我们会在最后把这个函数给return出来，好让我们可以在外面去调用到dogHouse里面的这个countDogs()函数。 最后当我们在使用闭包时，我们先把存在dogHouse里面的countDogs拿出来用，并一样命名为countDogs（这里变量名称可以自己取），因此当我执行全局中的countDogs时，实际上会执行的是dogHouse里面的countDogs函数。 上面这是闭包的基本写法：一个函数里面包了另一个函数，同时会 return 里面的函数让我们可以在外面使用到它。 我们可以把我们最一开始的代码都改成使用闭包的写法： 1234567891011121314151617181920212223242526272829function dogHouse () &#123; var count = 0 function countDogs () &#123; count += 1 console.log(count + ' dogs') &#125; return countDogs&#125;function catHouse () &#123; var count = 0 function countCats () &#123; count += 1 console.log(count + ' cats') &#125; return countCats&#125;const countDogs = dogHouse()const countCats = catHouse()countDogs() // "1 dogs"countDogs() // "2 dogs"countDogs() // "3 dogs"countCats() // "1 cats"countCats() // "2 cats"countDogs() // "4 dogs" 当我们正确地使用闭包时，虽然一样都是使用count来计数，但是是在不同执行环境内的count因此也不会相互干扰。 进一步了解和使用闭包另外，甚至在运用的是同一个dogHouse 时，变量间也都是独立的执行环境不会干扰，比如： 123456789101112131415161718192021222324function dogHouse () &#123; var count = 0 function countDogs () &#123; count += 1 console.log(count + ' dogs') &#125; return countDogs&#125;// 虽然都是使用 dogHouse ，但是各是不同的执行环境// 因此彼此的变量不会互相干扰var countGolden = dogHouse()var countPug = dogHouse()var countPuppy = dogHouse()countGolden() // 1 dogscountGolden() // 2 dogscountPug() // 1 dogscountPuppy() // 1 dogscountGolden() // 3 dogscountPug() // 2 dogs 将参数代入闭包中但是这么做的话你可能觉得还不够清楚，因为都是叫做dogs，这时候我们一样可以把外面的变量通过函数的参数代入闭包中，像是下面这样，返回的结果就清楚多了： 123456789101112131415161718192021222324// 通过函数的参数将值代入闭包中function dogHouse (name) &#123; var count = 0 function countDogs () &#123; count += 1 console.log(count + ' ' + name) &#125; return countDogs&#125;// 同样是使用 dogHouse 但是使用不同的参数var countGolden = dogHouse('Golden')var countPug = dogHouse('Pug')var countPuppy = dogHouse('Puppy')// 结果看起来更清楚了countGolden() // 1 GoldencountGolden() // 2 GoldencountPug() // 1 PugcountPuppy() // 1 PuppycountGolden() // 3 GoldencountPug() // 2 Pug 为了进一步简化代码，我们可以在闭包中直接return一个函数出来，我们就可以不必为里面的函数命名了，而是用匿名函数的方式直接把它返回出来。 因此写法可以简化成这样： 1234567891011121314151617function dogHouse () &#123; var count = 0 // 把原本 countDogs 函数改成匿名函数直接放进来 return function () &#123; count += 1 console.log(count + ' dogs') &#125;&#125;function catHouse () &#123; var count = 0 // 把原本 countCats 函数改成匿名函数直接放进来 return function () &#123; count += 1 console.log(count + ' cats') &#125;&#125; 然后我们刚刚有提到，可以透过函数参数的方式把值代入闭包当中，因此实际上我们只需要一个counter ，在不同的时间点给它参数区分就好。这样子不管你是要记录哪一种动物都很方便了，而且代码也相当简洁： 12345678910111213141516171819function createCounter (name) &#123; var count = 0 return function () &#123; count++ console.log(count + ' ' + name) &#125;&#125;const dogCounter = createCounter('dogs')const catCounter = createCounter('cats')const pigCounter = createCounter('pigs')dogCounter() // 1 dogsdogCounter() // 2 dogscatCounter() // 1 catscatCounter() // 2 catspigCounter() // 1 pigsdogCounter() // 3 dogscatCounter() // 3 cats 闭包的实际应用我们要实现这样的一个需求：点击某个按钮，提示点击的是”第n个”按钮，此处我们先不用事件代理: 123456789101112.....&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;&lt;script type="text/javascript"&gt; var buttons = document.getElementsByTagName('button') for (var i = 0; i &lt; buttons.length; i++) &#123; buttons[i].onclick = function () &#123; console.log('第' + (i + 1) + '个') &#125; &#125;&lt;/script&gt; 这时候可能会预期点选不同的按钮时，会根据每个button 点击顺序的不同而得到不同的结果。但是实际执行后，你会发现返回的结果都是“第四个”。这是因为i是全局变量，执行到点击事件时，此时i的值为3。 如果要强制返回预期的结果，那该如何修改呢？最简单的是用let声明i： 12345for (let i = 0; i &lt; buttons.length; i++) &#123; buttons[i].onclick = function () &#123; console.log('第' + (i + 1) + '个') &#125;&#125; 简单来说，通过let可以帮我们把所定义的变量缩限在块级作用域中，也就是变量的作用域只有在{ }内，来避免 i 这个变量跑到全局变量被重复覆盖。 另外我们可以通过闭包的方式来修改: 1234567for (var i = 0; i &lt; buttons.length; i++) &#123; (function (j) &#123; buttons[j].onclick = function () &#123; console.log('第' + (j + 1) + '个') &#125; &#125;)(i)&#125; 希望看完这篇文章后，你能对于闭包有更清楚的认识。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之this是什么]]></title>
    <url>%2F2019%2F07%2F01%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8Bthis%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[上一篇《JavaScript系列之作用域和作用域链》中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。 再来回顾一下关于执行上下文的三个阶段生命周期： 本章将专门介绍与执行上下文创建阶段直接相关的最后一个细节——this是什么？以及它的指向到底是什么。 了解this也许你在其他面向对象的编程语言曾经看过this，也知道它会指向某个构造器(constructor)所建立的对象。但事实上在JavaScript里面，this所代表的不仅仅是那个被建立的对象。 先来看看ECMAScript 标准规范对this 的定义： 「The this keyword evaluates to the value of the ThisBinding of the current execution context.」「this 这个关键字代表的值为当前执行上下文的ThisBinding。」 然后再来看看MDN 对this 的定义： 「In most cases, the value of this is determined by how a function is called.」「在大多数的情况下，this 其值取决于函数的调用方式。」 好，如果上面两行就看得懂的话那么就不用再往下看了，Congratulations！ …… 我想应该不会，至少我光看这两行还是不懂。 先来看个例子吧： 12345678910111213141516var getGender = function() &#123; return people1.gender;&#125;;var people1 = &#123; gender: 'female', getGender: getGender&#125;;var people2 = &#123; gender: 'male', getGender: getGender&#125;;console.log(people1.getGender()); // femaleconsole.log(people2.getGender()); // female what?怎么people2变性了呢，这不是我想要的结果啊，为什么呢？ 因为getGender()返回(return)写死了people1.gender的关系，结果自然是’female’。 那么，如果我们把getGender稍改一下： 123var getGender = function() &#123; return this.gender;&#125;; 这个时候，你应该会分别得到female与male两种结果。 所以回到前面讲的重点，从这个例子可以看出，即便people1与people2的getGender方法参照的都是同一个getGender function，但由于调用的对象不同，所以执行的结果也会不同。 现在我们知道了第一个重点，this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数的调用方式。如何的区分this呢？ this到底是谁看完上面的例子，还是有点似懂非懂吧？那接下来我们来看看不同的调用方式对 this 值的影响。 情况一：全局对象&amp;调用普通函数在全局环境中，this 指向全局对象，在浏览器中，它就是 window 对象。下面的示例中，无论是否是在严格模式下，this 都是指向全局对象。 12345var x = 1console.log(this.x) // 1console.log(this.x === x) // trueconsole.log(this === window) // true 如果普通函数是在全局环境中被调用，在非严格模式下，普通函数中 this 也指向全局对象；如果是在严格模式下，this 将会是 undefined。ES5 为了使 JavaScript 运行在更有限制性的环境而添加了严格模式，严格模式为了消除安全隐患，禁止了 this 关键字指向全局对象。 12345678var x = 1function fn() &#123; console.log(this); // Window 全局对象 console.log(this.x); // 1&#125;fn(); 使用严格模式后： 123456789"use strict" // 使用严格模式var x = 1function fn() &#123; console.log(this); // undefined console.log(this.x); // 报错 "Cannot read property 'x' of undefined"，因为此时 this 是 undefined&#125;fn(); 情况二：作为对象方法的调用我们知道，在对象里的值如果是原生值（primitive type；例如，字符串、数值、布尔值），我们会把这个新建立的东西称为「属性（property）」；如果对象里面的值是函数（function）的话，我们则会把这个新建立的东西称为「方法（method）」。 如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，函数中的this指向这个上一级对象。 123456789101112131415161718192021var x = 1var obj = &#123; x: 2, fn: function() &#123; console.log(this); console.log(this.x); &#125;&#125;obj.fn() // obj.fn()结果打印出;// Object &#123;x: 2, fn: function&#125;// 2var a = obj.fna() // a()结果打印出: // Window 全局对象// 1 在上面的例子中，直接运行 obj.fn() ，调用该函数的上一级对象是 obj，所以 this 指向 obj，得到 this.x 的值是 2；之后我们将 fn 方法首先赋值给变量 a，a 运行在全局环境中，所以此时 this 指向全局对象Window，得到 this.x 为 1。 我们再来看一个例子，如果函数被多个对象嵌套调用，this 会指向什么。 12345678910111213var x = 1var obj = &#123; x: 2, y: &#123; x: 3, fn: function() &#123; console.log(this); // Object &#123;x: 3, fn: function&#125; console.log(this.x); // 3 &#125; &#125;&#125;obj.y.fn(); 为什么结果不是 2 呢，因为在这种情况下记住一句话：this 始终会指向直接调用函数的上一级对象，即 y，上面例子实际执行的是下面的代码。 123456789101112131415var y = &#123; x: 3, fn: function() &#123; console.log(this); // Object &#123;x: 3, fn: function&#125; console.log(this.x); // 3 &#125;&#125;var x = 1var obj = &#123; x: 2, y: y&#125;obj.y.fn(); 对象可以嵌套，函数也可以，如果函数嵌套，this 会有变化吗？我们通过下面代码来探讨一下。 1234567891011121314var obj = &#123; y: function() &#123; console.log(this === obj); // true console.log(this); // Object &#123;y: function&#125; fn(); function fn() &#123; console.log(this === obj); // false console.log(this); // Window 全局对象 &#125; &#125;&#125;obj.y(); 在函数 y 中，this 指向了调用它的上一级对象 obj，这是没有问题的。但是在嵌套函数 fn 中，this 并不指向 obj。嵌套的函数不会从调用它的函数中继承 this，当嵌套函数作为函数调用时，其 this 值在非严格模式下指向全局对象，在严格模式是 undefined，所以上面例子实际执行的是下面的代码。 1234567891011121314function fn() &#123; console.log(this === obj); // false console.log(this); // Window 全局对象&#125;var obj = &#123; y: function() &#123; console.log(this === obj); // true console.log(this); // Object &#123;y: function&#125; fn(); &#125;&#125;obj.y(); 情况三：作为构造函数调用我们可以使用 new 关键字，通过构造函数生成一个实例对象。此时，this 便指向这个新对象。 123456789var x = 1;function Fn() &#123; this.x = 2; console.log(this); // Fn &#123;x: 2&#125;&#125;var obj = new Fn(); // obj和Fn(..)调用中的this进行绑定console.log(obj.x) // 2 使用new来调用Fn(..)时，会构造一个新对象并把它（obj）绑定到Fn(..)调用中的this。还有值得一提的是，如果构造函数返回了非引用类型（string，number，boolean，null，undefined），this 仍然指向实例化的新对象。 12345678910111213var x = 1function Fn() &#123; this.x = 2 return &#123; x: 3 &#125;&#125;var a = new Fn()console.log(a.x) // 3 因为Fn()返回(return)的是一个对象（引用类型），this 会指向这个return的对象。如果return的是一个非引用类型的值呢？ 1234567891011var x = 1function Fn() &#123; this.x = 2 return 3&#125;var a = new Fn()console.log(a.x) // 2 情况四：call 和 apply 方法调用如果你想改变 this 的指向，可以使用 call 或 apply 方法。它们的第一个参数都是指定函数运行时其中的this指向。如果第一个参数不传（参数为空）或者传 null 、undefined，默认 this 指向全局对象（非严格模式）或 undefined（严格模式）。 123456789101112131415161718192021222324252627282930var x = 1;var obj = &#123; x: 2&#125;function fn() &#123; console.log(this); console.log(this.x);&#125;fn.call(obj)// Object &#123;x: 2&#125;// 2fn.apply(obj) // Object &#123;x: 2&#125;// 2fn.call() // Window 全局对象// 1fn.apply(null) // Window 全局对象// 1fn.call(undefined) // Window 全局对象// 1 使用 call 和 apply 时，如果给 this 传的不是对象，JavaScript 会使用相关构造函数将其转化为对象，比如传 number 类型，会进行new Number()操作，如传 string 类型，会进行new String()操作，如传 boolean 类型，会进行new Boolean()操作。 1234567function fn() &#123; console.log(Object.prototype.toString.call(this))&#125;fn.call('love') // [object String]fn.apply(1) // [object Number]fn.call(true) // [object Boolean] call 和 apply 的区别在于，call 的第二个及后续参数是一个参数列表，apply 的第二个参数是数组。参数列表和参数数组都将作为函数的参数进行执行。 123456789101112var x = 1var obj = &#123; x: 2&#125;function Sum(y, z) &#123; console.log(this.x + y + z)&#125;Sum.call(obj, 3, 4) // 9Sum.apply(obj, [3, 4]) // 9 情况五：bind 方法调用调用 f.bind(someObject) 会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，新函数的 this 会永久的指向 bind 传入的第一个参数，无论这个函数是如何被调用的。 1234567891011121314151617181920212223242526272829303132var x = 1var obj1 = &#123; x: 2&#125;;var obj2 = &#123; x: 3&#125;;function fn() &#123; console.log(this); console.log(this.x);&#125;;var a = fn.bind(obj1);var b = a.bind(obj2);fn();// Window 全局对象// 1a();// Object &#123;x: 2&#125;// 2b();// Object &#123;x: 2&#125;// 2a.call(obj2);// Object &#123;x: 2&#125;// 2 在上面的例子中，虽然我们尝试给函数 a 重新指定 this 的指向，但是它依旧指向第一次 bind 传入的对象，即使是使用 call 或 apply 方法也不能改变这一事实，即永久的指向 bind 传入的第一次参数。 情况六：箭头函数中this指向值得一提的是，从ES6 开始新增了箭头函数，先来看看MDN 上对箭头函数的说明： An arrow function expression has a shorter syntax than a function expression and does notbind its own this,arguments,super, or new.target. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 这里已经清楚了说明了，箭头函数没有自己的this绑定。箭头函数中使用的this，其实是直接包含它的那个函数或函数表达式中的this。在前面情况二中函数嵌套函数的例子中，被嵌套的函数不会继承上层函数的 this，如果使用箭头函数，会发生什么变化呢？ 1234567891011121314var obj = &#123; y: function() &#123; console.log(this === obj); // true console.log(this); // Object &#123;y: function&#125; var fn = () =&gt; &#123; console.log(this === obj); // true console.log(this); // Object &#123;y: function&#125; &#125; fn(); &#125;&#125;obj.y() 和普通函数不一样，箭头函数中的 this 指向了 obj，这是因为它从上一层的函数中继承了 this，你可以理解为箭头函数修正了 this 的指向。所以箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this。 换句话说，箭头函数的this看外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是Window。 1234567891011121314var obj = &#123; y: () =&gt; &#123; console.log(this === obj); // false console.log(this); // Window 全局对象 var fn = () =&gt; &#123; console.log(this === obj); // false console.log(this); // Window 全局对象 &#125; fn(); &#125;&#125;obj.y() 上例中，虽然存在两个箭头函数，其实this取决于最外层的箭头函数，由于obj是个对象而非函数，所以this指向为Window全局对象。 同 bind 一样，箭头函数也很“顽固”，我们无法通过 call 和 apply 来改变 this 的指向，即传入的第一个参数被忽略。 1234567891011121314151617var x = 1var obj = &#123; x: 2&#125;var a = () =&gt; &#123; console.log(this.x) console.log(this)&#125;a.call(obj) // 1// Window 全局对象a.apply(obj) // 1// Window 全局对象 小结本篇文章介绍了 this 指向的几种情况，不同的运行环境和调用方式都会对 this 产生影响。总的来说，函数 this 的指向取决于当前调用该函数的对象，也就是执行时的对象。在这一节中，你需要掌握： this 指向全局对象的情况； 严格模式和非严格模式下 this 的区别； 函数作为对象的方法调用时 this 指向的几种情况； 作为构造函数时 this 的指向，以及是否 return 的区别； 使用 call 和 apply 改变调用函数的对象； bind 创建的函数中 this 的指向； 箭头函数中的 this 指向。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贵州黔东南之行]]></title>
    <url>%2F2019%2F06%2F30%2F%E8%B4%B5%E5%B7%9E%E9%BB%94%E4%B8%9C%E5%8D%97%E4%B9%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。 镇远古镇第一站来到镇远古镇，路上听导游说这里还是一位皇帝的故乡呢！哈哈~当然不是古代的皇帝啦，其实是延禧攻略里面皇帝扮演者聂远的故乡啦😜。 我们到古城的时间也接近傍晚了，吃完晚饭散步在古城河边，天空中飘着乌云，真有一种“天青色等烟雨”的既视感了。 河边坐落了许多充满文艺的小店和清吧。 晚上的镇远古镇，虽说夜景和去过的其它几个古镇有些相似，但镇远独特之处在于宁静，有一种与世无争的感觉。 在镇远古镇悠悠闲闲的一天里，给我最大的感受还是来自于它的静，很静，很舒服。 西江千户苗寨第二站到达的西江千户苗寨，号称世界上最大的苗寨，一眼望去全是木质结构的屋子，层层叠叠错落有致。 在苗寨里面瞎逛的途中遇到了当地苗族朋友的游行表演。 来千户苗寨当然不能错过来自苗族朋友的热情，热情之一就是宴席上的“高山流水”，其实就是灌客人们喝甜甜的米酒，自知酒量不行，仪式开始之前就躲得远远的了哈哈，同桌几个男的就被灌了😄。 因为苗寨难得遇到断电，“幸运地”被我们给遇上了，晚上只好回州府凯里住了，晚饭刚好感受了侗族形式的“高山流水”以及侗族的歌舞表演，表演倒是没啥好看的，不过有几个侗族小姐姐还是比较好看的~哈哈不知道她能不能看到，看到的话感觉会被打屎哦😥~ 高要梯田第三站抵达高要梯田，高要的梯田虽没有像广西龙胜、云南元阳被外界所熟知，但其美景完全不逊于前者，可惜不是金秋时节来，不然景色应该会更美。 总体来说，此次贵州之行还是很轻松的，可惜的是没时间去到黄果树，希望下次再带她一起来哦~嘻嘻🤭。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>贵州</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之作用域和作用域链]]></title>
    <url>%2F2019%2F06%2F28%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在上一篇《JavaScript系列之变量对象》中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。 此外，我们也知道每次进入上下文时都会创建变量对象并填充初始值，并且值会在代码执行阶段进行更新，现在就对执行上下文做更深一步的了解。 先来回顾一下关于执行上下文的三个阶段生命周期： 本章将专门介绍与执行上下文创建阶段直接相关的另一个细节——作用域链。 作用域(Scope)在介绍作用域链前，有必要先来了解一下被称为作用域(Scope)的特性，那什么是作用域呢？ 作用域就是在运行时代码中不同部分中函数和变量的可访问性。可能这句话并不太好理解，我们先来看段代码： 1234567function fn() &#123; var inVariable = "inner variable"; console.log(inVariable); // inner variable&#125;fn(); console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined 从上面的代码中我们可以很直观地体会作用域的概念，变量inVariable在全局作用域没有声明，所以在全局作用域下直接取值会报错。所以我们可以这样理解：作用域就像一个地头蛇，我的地盘我做主，让属于自己域内的变量不会轻易外泄出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。这几句话总比前面那句好理解多了吧。 关于JavaScript 中的作用域类型，ES6 之前 JavaScript 并没有块级作用域，只有全局作用域和函数作用域。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现： 全局作用域 — 变量可以随处访问 函数作用域— 变量可以在定义它们的函数的边界内访问 块级作用域—变量可以在定义它们的块中访问，块由 { 和 } 分隔 全局作用域和函数作用域123456789const global = 'global scoped'function fn() &#123; const global = 'function scoped'; console.log(global); // function scoped&#125;fn();console.log(global); // global scoped 从上面例子可以看出全局作用域和函数作用域的作用范围，即使全局变量在函数内部分配了不同的值，它也只保留在同一函数的边界内，互相并不影响，我们也不会因使用相同的变量名而出错。再来看个例子加深理解： 123456789101112131415161718192021const global = 'global scoped'const anotherGlobal = 'also global scoped'function fn() &#123; const global = 'function scoped' console.log(global) // function scoped const scoped = 'also function scoped' function inner() &#123; console.log(scoped); // also function scoped console.log(anotherGlobal) // also global scoped &#125; inner();&#125;console.log(global); // global scopedconsole.log(anotherGlobal); // also global scopedfn();inner(); // Uncaught ReferenceError: inner is not defined 在这里我们可以看到 inner() 函数可以访问在其父函数中声明的变量—fn()。每当我们需要函数内部的变量时，引擎将首先在当前函数作用域内查找它。如果它没有当前函数作用域内找到它，它将继续上升，向上一级查找，直到它找到全局作用域内的变量，如果找不到变量，我们将得到一个ReferenceError。格外注意函数内层作用域可以访问外层作用域的变量，反之则不行。 除了上面所讲的最外层函数外面定义的变量拥有全局作用域，全局作用域还有一种特殊的出现场合：就是所有末声明直接赋值的变量将自动声明为拥有全局作用域的变量： 12345678function fn() &#123; variable = "undeclared variable"; var inVariable = "inner variable";&#125;fn();console.log(variable); // undeclared variableconsole.log(inVariable); // Uncaught ReferenceError: inVariable is not defined 全局作用域有个弊端：如果我们写了很多行 JavaScript 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中，这样就会污染全局命名空间，容易引起命名冲突。同时意外的全局变量还会引起内存泄漏，所以在编程时，尽量避免全局变量的使用，以便后期更快地调试。 还有值得注意的是：块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。比如： 123456if (true) &#123; // 'if' 条件语句块不会创建一个新的作用域 var name = 'miqilin'; // name 依然在全局作用域中&#125;console.log(name); // miqilin JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致bug出现 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。 块级作用域在ES6中，我们得到了两个新的变量声明关键字 - let和const。它们和var之间的主要区别在于，使用ES6关键字声明的变量是块作用域，这意味着它们仅在它们定义的代码块中可用。块级作用域在如下情况被创建： 在一个函数内部 在一个代码块（由一对花括号包裹）内部 let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点： 声明变量不会提升到代码块顶部 let/const创建的变量不会像使用var声明的变量那样被提升到顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。比如： 12cosole.log(name); // Uncaught ReferenceError: cosole is not definedconst name = "miqilin"; 所以确保代码没有引用错误的一种方法是确保只使用let和const进行变量声明。 禁止重复声明 如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符再进行 let 声明就会抛出错误。比如： 12var count = 10;let count = 20; // Uncaught SyntaxError: Identifier 'count' has already been declared 上面例子中count 变量被前后声明了两次：第一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误： 123456var count = 10;// 不会抛出错误if (condition) &#123;let count = 20;// 其他代码&#125; 循环中的绑定块作用域的妙用 开发者可能最希望实现for循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，比如： 12345for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，因为用let声明计数器i，只在for循环体内有效，所以在循环体外引用就会报错。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果换使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 123456789for (let i = 0; i &lt; 5; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc// abc// abc 上面代码正确运行，输出了 5 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 作用域链(Scope Chain)上面用一大篇幅来讲解作用域，其实在里面就有涉及到作用域链的知识了。简单的来说，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。看下面一个例子： 12345678910111213function a() &#123; function b() &#123; console.log(myVar); &#125; var myVar = 2; b();&#125;var myVar = 1;a(); // 2b(); // Uncaught ReferenceError: b is not defined 最后加以执行a()和b()，这时候我们会发现两件事： 1.执行a()会得到2的结果：之所以会有这样的结果，是因为当我们执行function a里面的function b时，因为在function b里面它找不到myVar这个变量，因此它开始往它的外层去搜寻，而这时候它的父级作用域是function a，在function a里面它便找到了myVar = 2，因此它就不再往外部环境 (myVar = 1)去找了，直接返回了2这样的结果。 2.b()会得到b is not defined的结果：之所以b会是not defined（记得是not defined不是undefined哦！)，是因为这时候在最外层的全局上下文（global execution context）中，找不到function b。 而从b() --&gt; a() --&gt; global execution context这样的链，就称为作用域链（Scope Chain）： 如果我们把function a里面对于myVar的声明拿掉的话，它才会继续往外层搜寻myVar，直到找到全局作用域中的声明myVar = 1，这时候才会返回1的结果。 123456789101112function a() &#123; function b() &#123; console.log(myVar); &#125; //var myVar = 2; b();&#125;var myVar = 1;a(); // 1 如果我们更进一步的把全局作用域中，对于myVar的声明也拿掉，那么现在在全局作用域中也找不到myVar这个变量了，也就是说，在这整个作用域链中都找不到myVar，因此可想而知，最后的结果是not defined。 123456789101112function a() &#123; function b() &#123; console.log(myVar); &#125; //var myVar = 2; b();&#125;//var myVar = 1;a(); // Uncaught ReferenceError: myVar is not defined 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
        <tag>Scope Chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之变量对象]]></title>
    <url>%2F2019%2F06%2F19%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JavaScript编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇《JavaScript系列之执行上下文和执行栈》，通过对变量对象(Variable Object)的介绍对执行上下文有一个更深一步的了解。 上一篇文章也提到了，一个执行上下文的生命周期可以分为三个阶段： 详细了解执行上下文对于初学者来说极为重要，因为其中涉及到了变量对象，作用域链，this等很多JavaScript初学者没完全搞懂，且极为重要的概念，它关系到我们能不能真正理解JavaScript，真正理解也能更为轻松地胜任后续工作，在后面的文章中我们会一一详细介绍，这里我们先重点了解一下变量对象。 变量对象变量对象（Variable Object）是一个与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明，先来看一段代码示例： 12345678910function foo()&#123; var a = 10; function b()&#123;&#125; (function c()&#123;&#125;); console.log(a); // 10 console.log(b); // function b()&#123;&#125; console.log(c); // Uncaught ReferenceError: c is not defined&#125;foo(); 在上面的例子中，foo（）函数的变量对象包含变量a和函数b（）的声明。这里要注意的一点是，函数表达式并不像函数声明一样包含在变量对象中，在示例中所看到的那样，访问c（）函数会导致引用错误。因为变量对象是抽象的和特殊的，它不能在代码中访问，但会由JavaScript引擎处理。 上面利用的是函数上下文下的变量对象来说明变量对象储存了什么，但变量对象还存在于全局上下文中，接下来就分别来聊聊全局上下文中和函数上下文中的变量对象吧。 全局上下文以浏览器中为例，全局对象为window。 全局上下文有一个特殊的地方，它的变量对象，就是window全局对象，而这个特殊，在this指向上也同样适用，this也是指向window。 12345678// 以浏览器中为例，全局对象为window// 全局上下文创建阶段// VO 为变量对象（Variable Object）的缩写windowEC = &#123; VO: Window, scopeChain: &#123;&#125;, this: Window&#125; 除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。 函数上下文在上面已经提到了，变量对象存储了执行上下文中的变量和函数声明，但在函数上下文中，还多了一个arguments(函数参数列表), 一个伪数组对象。 这时变量对象的创建阶段会包括： 创建arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果变量对象已经存在相同名称的属性，则完全替换这个属性。 检查当前上下文中的变量声明（var 声明的变量），默认为 undefined；如果变量名称跟已经声明的形式参数或函数相同，为了防止同名的函数被修改为undefined，则会直接跳过变量声明，原属性值不会被修改。 对于第3点中的“跳过”一词想必大家会有一丝疑问？底下例子中既然按照上面的规则，变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？ 1234function foo() &#123; console.log('I am function foo') &#125;var foo = 10;console.log(foo); // 10 理由其实很简单，因为上面的三条规则仅仅适用于变量对象的创建过程，也就是执行上下文的创建过程。而foo = 10是在执行上下文的执行过程中运行的，输出结果自然会是10。对比下例： 12345console.log(foo); // ƒ foo() &#123; console.log('I am function foo') &#125;function foo() &#123; console.log('I am function foo') &#125;var foo = 10;console.log(foo); // 10 为啥又是不一样的结果呢？其实它的执行顺序为： 123456789101112// 首先将所有函数声明放入变量对象中，函数声明变量提升function foo() &#123; console.log('I am function foo') &#125;// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过变量声明默认undefined的赋值// var foo = undefined;// 然后开始执行阶段代码的执行console.log(foo); // ƒ foo() &#123; console.log('I am function foo') &#125;// 在执行上下文的执行过程中运行foo = 10;console.log(foo); // 10 根据上面的规则，理解变量提升就变得十分简单了，我们也可以看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们再结合一个简单的例子来进行探讨。 12345678910111213141516function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test();/* 结果为：undefined2*/ 根据上述的规则，理解变量提升后可以将执行顺序理解为： 1234567891011function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 这样是不是一目了然了呢？ 当然还需要注意的是，函数未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象（VO）转变为了活动对象（AO），然后开始进行执行阶段的操作。 执行阶段当前进入执行阶段，变量对象（VO）激活成活动对象（AO），里面的属性都能被访问了，函数会顺序执行代码，改变变量对象的属性值，此阶段的执行上下文代码会分成两个阶段进行处理： 进入执行上下文 执行代码 进入执行上下文当进入执行上下文时，这时候还没有执行代码。让我们看一个例子： 12345678function foo(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125;; (function x() &#123;&#125;);&#125; foo(10); 当进入带有参数10的foo函数上下文时，AO表现为如下： 123456789101112AO = &#123; arguments: &#123; 0: 10, 1: undefined, length: 1 &#125; a: 10, b: undefined, c: undefined, d: &lt;function reference to d&gt;, e: undefined,&#125; x 是函数表达式，所以不在变量对象当中，e 变量引用的值也是函数表达式，所以变量 e 本身是声明，所以在变量对象当中。 执行代码这个阶段会按顺序执行代码，修改变量对象的属性值，紧接上面的例子，执行完成后AO如下： 123456789101112AO = &#123; arguments: &#123; 0: 10, 1: undefined, length: 1 &#125; a: 10, b: undefined, c: 10, d: &lt;reference to function declaration d&gt;, e: &lt;reference to Function expression to _e&gt;,&#125; 到这里变量对象的创建过程就介绍完了，让我们简短地总结一下： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会依次给变量对象添加形参、函数声明、变量声明等初始的属性值 函数未进入执行阶段之前，变量对象中的属性都不能访问 在执行代码阶段，会再次修改变量对象的属性值，并赋予该有的属性值 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>变量对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之执行上下文和执行栈]]></title>
    <url>%2F2019%2F06%2F13%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[如果你想成为一名优秀的JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。 执行上下文和执行栈是JavaScript的难点之一，所以本人尽量用通俗易懂的方式来阐述这些概念。 执行上下文（Execution Context）当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。执行上下文（可执行代码段）总共有三种类型： 全局执行上下文（全局代码）：不在任何函数中的代码都位于全局执行上下文中，只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 函数执行上下文（函数体）：只有调用函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创-建，它都会按照特定的顺序执行一系列步骤。 Eval 函数执行上下文（eval代码）： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。 执行上下文又包括三个生命周期阶段：创建阶段→执行阶段→回收阶段，本文重点介绍创建阶段。 1.创建阶段 当函数被调用，但未执行任何其内部代码之前，会做以下三件事： 创建变量对象(Variable object，VO)：首先初始化函数的参数arguments，提升函数声明和变量声明。后文会详细说明。 创建作用域链（Scope Chain）：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。后文会详细说明。 确定this指向：包括多种情况，后文会详细说明。 在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。 另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出this 、 arguments和函数的参数。 2.执行阶段 进入执行上下文、执行代码 3.回收阶段 执行完毕后执行上下文出栈并等待被垃圾回收 执行上下文栈（Execution Context Stack）假如我们写的函数多了，每次调用函数时都创建一个新的执行上下文，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，具有 LIFO（后进先出）的栈结构，用于存储在代码执行期间创建的所有执行上下文。 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的顶部，浏览器的JS执行引擎总是访问栈顶的执行上下文。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文，最终移回到全局执行上下文，全局上下文只有唯一的一个，它在浏览器关闭时Pop出。 看到目前为止，是否觉得这两个概念还是有点晦涩难懂呢？那…接下来通过几小段代码和图解来详细介绍并理解吧。 执行上下文是如何执行的呢？让我们先来看一下这段简单代码： 123456function b()&#123;&#125;function a()&#123; b();&#125;a(); 这段代码背后执行的逻辑是这样的： 首先，全局执行上下文（Global Execution Context）会被建立，这时候会一并建立this、global object (window)，在函数开始执行的过程中，function a和b由于JS提升机制的缘故会先被建立在内存中，接着才会开始逐行执行函数。 接着，代码会执行到a( )这个部分，这时候，会建立a的执行上下文（execution context），并且被放置到执行栈（execution stack）中。在这个execution stack中，最上面的execution context会是正在被执行的a( )。如下图： function a 的execution context建立后，便会开始执行function a中的内容。由于在function a( ) 里面有去执行function b ，因此，在这个execution stack中，接下来最上面会变成function b 的execution context。如下图： 当function b 执行完之后，会从execution stack中离开，继续逐行执行function a。当function a 执行完之后，一样会从execution stack中抽离，再回到Global Execution Context逐行执行。如下图： 不同执行上下文中的变量是不同的在了解了一般的函数其运作背后的逻辑后，让我们来看一下这段代码： 1234567891011121314function b()&#123; var myVar; console.log(myVar);&#125;function a()&#123; var myVar = 2; b(); console.log(myVar);&#125;var myVar = 1;console.log(myVar);a(); 你可以想像，如果我们在不同的execution context中去把myVar这个变量打出来，会得到什么结果呢？结果如下： 我们分别得到了1、undefined和2。为什么会这样呢？ 让我们来看看这段代码背后执行的逻辑： 首先，全局执行上下文（Global Execution Context）会被建立，由于变量提升的缘故，myVar、function a和b都会被建立并储存在内存中，接着便开始逐行执行函数。一开始会碰到var myVar = 1所以，最外层的myVar便被给值为1，接着执行到了console.log(myVar)，这是在global execution context执行的，于是得到了第一个1的结果： 然后执行到了a ( )，于是建立了a的execution context，这时候由于逐行执行的关系，会先执行到var myVar = 2，但因为这是在function a的execution context中，所以并不会影响到global execution context的myVar： 在执行完function a中的var myVar = 2后，继续逐行执行，于是执行到了b ( )，这时候，function b的execution function便被建立，而且会先去执行function b里面的内容： function b的execution function建立后，会开始逐行执行function b里面的内容，于是读到了var myVar;，这时候在function b这个execution context中的myVar变量被建立，但是还没被赋值，所以会是undefined。和上面提到的一样，由于这个myVar是在function b中的execution context所建立，所以并不会影响到其他execution context的myVar，这时候执行到了function b的 execution context中的console.log(myVar)，于是得到了第二个看到的undefined： 最后，function b执行完之后，会从execution stack中离开，继续回到function a中的b( )后逐行执行，也就是console.log(myVar)，这时候是在function a的execution context加以执行的，因此也就得到了结果中看到的第三个2了。 最后由于b ( ) 后面已经没有内容，function a执行完毕，这时候，function a也会从execution stack中抽离。 最后回到Global Execution Context，如果函数中的a( )后面还有内容的话，会继续进行逐行执行。 由上面的例子，我们可以知道，我们是在不同的execution context中分别去声明变量myVar的，因此在不同的execution context，变量彼此之间不会影响，所以虽然这三个变量都叫做myVar，但其实是三个不同的变量。 由于我们是在不同的execution context中去声明变量，所以这其实是位于三个不同execution context中的变量，所以即使我们是在执行完a( )后再去调用一次myVar，一样会得到” 1”的结果: 123456789101112131415function b()&#123; var myVar; console.log(myVar);&#125;function a()&#123; var myVar = 2; b(); console.log(myVar);&#125;var myVar = 1;console.log(myVar);a();console.log(myVar); // 一样会得到"1" 注意最后需要注意的是，如果是在function里面直接使用myVar这个变量，而没有通过var重新声明它的话，就会得到不同的结果！因为在函数作用域内加 var 定义的变量是局部变量，不加 var 定义的就成了全局变量。在未声明新的变量的情况下，在该execution context中JavaScript 引擎找不到这个变量，它就会往它的外层去寻找，最后会得到，1 ,2 ,2 ,2 的结果: 1234567891011121314151617181920212223function b()&#123; myVar; console.log(myVar);&#125;function a()&#123; myVar = 2; b(); console.log(myVar);&#125;var myVar = 1;console.log(myVar);a();console.log(myVar);/*打印出1222*/ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Execution Context</tag>
        <tag>Execution Context Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript中的function constructor和prototype的建立]]></title>
    <url>%2F2019%2F06%2F11%2F%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[在《谈谈JavaScript中的function constructor和new关键字》这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。 在JavaScript中的函数也是一种对象，其中包含一些属性像是该函数的名称（Name）和该函数的内容（Code），但其实function这里面还有一个属性，这个属性就是prototype，这个属性会以空对象的型式呈现。 除非你是把function当做function constructor来使用，否则这个属性就没有特别的用途；但如果你是把它当做function constructor，通过new这个关键字来执行这个function的话，它就有特别的意义了。 要进入这个function的prototype属性只要直接通过 .prototype 就可以了。 然而，有一点很容易令人困惑的地方，我们会以为如果我使用 .prototype 时，就可以直接进入该函数的原型，但实际上并不是这样的！ 函数当中prototype这个属性并不是这个函数的prototype，它指的是所有通过这个function constructor所建立出来的对象的prototype，听起来有点混乱吧…没关系，让我们来看一些代码来帮助我们理解这一概念。 说明函数中的prototype 属性1.function 中的prototype 属性一开始是空对象 我们先执行上篇文章最后所写的代码： 123456789function Person ( firstName , lastName ) &#123; this . firstName = firstName ; this . lastName = lastName ; &#125;var person1 = new Person ( 'Jay' , 'chou' ) ; console . log ( person1 ) ; var person2 = new Person ( 'Jane' , 'chou' ) ; console . log ( person2 ) ; 到Google Chrome的console视窗中，我们输入 Person.prototype得到的结果会得到一个空对象，如下图： 2.通过function constructor 所建立的对象会继承该function 中prototype 的内容 接着，让我们在Person.prototype里面增加一个getFullName的函数： 12345678910111213function Person ( firstName , lastName ) &#123; this . firstName = firstName ; this . lastName = lastName ; &#125;Person . prototype . getFullName = function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125;var person1 = new Person ( 'Jay' , 'chou' ) ; console . log ( person1 ) ; var person2 = new Person ( 'Jane' , 'chou' ) ; console . log ( person2 ) ; 在上面代码的第6 - 8行中，我们为Person.prototype添加了一个函数，所以当我们在Google Chrome的console视窗中调用Person.prototype时，会多了这个函数在内： 刚刚，我们有提到很重要的一句话，「函数当中prototype这个属性并不是这个函数的prototype，它指的是所有通过这个function constructor所建立出来的对象的prototype」。 这句话的意思其实是说Person.prototype并不是Person.__proto__，但是所有通过Person这个function constructor所建立的对象，在该实例对象的__proto__中，会包含有Person.prototype的内容。 也就是说，当我们使用new这个运算符来执行function constructor时，它会先建立一个空对象，同时将该构造函数中prototype这个属性的内容（Person.prototype），设置到该实例对象的prototype中，即 person1.__proto__ === Person.prototype的结果为true。 因此，当我们在Google Chrome的console中输入person1.__proto__时，我们就可以看到刚刚在Person.prototype所建立的函数getFullName已经继承在里面了： 实际运用由于Person.prototype中的方法已经被继承到由Person这个function constructor所建立的实例对象person1中，所以这时侯，我们就可以顺利的使用 person1.getFullName 这个方法： 123456789101112function Person ( firstName , lastName ) &#123; this . firstName = firstName ; this . lastName = lastName ; &#125;Person . prototype . getFullName = function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125;var person1 = new Person ( 'Jay' , 'chou' ) ; console . log ( person1 ) ; console . log ( person1.getFullName() ) ; 可以正确的执行getFullName这个函数并得到如下的结果： 通过function constructor与Prototype 的实用处通过这样的方法，我们可以让所有根据这个函数构造器（function constructor）所建立的对象都包含有某些我们想要使用的方法。如果我们有1000个对象是根据这个函数构造器所建立的，那么我们只需要使用 .prototype这样的方法，就可以让这1000个物件都可以使用到我们想要执行的某个method，这样减少了代码的复用。 有的人可能会好奇问，为什么我们不把getFullName这个方法直接写在函数构造式当中呢？ 12345678910111213function Person ( firstName , lastName ) &#123; this . firstName = firstName ; this . lastName = lastName ; this . getFullName = function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125;&#125;/*Person . prototype . getFullName = function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125;*/ 注意！我们不该把方法放在function constructor 中。 把方法放在函数构造式中这么做虽然仍然可以正确执行并得到结果，但是这么做会有个问题，如果我们是把这个方法直接写在函数构造式中，那么每一个对象都会包含有这个方法，如果我们有1000 个对象根据这个函数构造式所建立，那么这1000 个对象都会包含这个方法在内，如此将会占据相当多的内存；但如果是建立在prototype 中，我们只会有一个这样的方法。 所以，为了性能上的考量，通常会把方法（method）放在构造函数的prototype 中，因为它们可以是通用的；把属性（property）放在构造函数当中，因为每一个对象可能都会有不同的属性内容，如此将能有效减少内存的问题。 最后，如果感觉当前缺少你要用的方法，可以自己通过这一方法去创建。 例如在json2.js源码中，为Date、String、Number、Boolean方法添加一个toJSON的属性。 1234567891011121314151617if (typeof Date.prototype.toJSON !== 'function') &#123; Date.prototype.toJSON = function (key) &#123; return isFinite(this.valueOf()) ? this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z' : null; &#125;; String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function (key) &#123; return this.valueOf(); &#125;;&#125; 如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>constructor</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript中的function constructor和new关键字]]></title>
    <url>%2F2019%2F06%2F11%2F%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？ 大多数 Javascript 的新开发者不太想要使用new关键字，因为这会让代码写的像是 Java 并且在使用上会造成一点混乱；在这篇文章我会尽量尝试着去理清这些东西，并解释它是如何运作的。 谈谈function constructorconstructor 翻为构造器但为了让您之后更好地理解，会直接使用 constructor；在 Javascript 中任何一个函数(function)都可以被当作 constructor；Javascript 并没有明确的区分两者，也就是说 function 可以被当作 constructor 或者当作一般函数调用。 而 constructor 的用法就是 function 搭配new关键字： 1234567function Person ( ) &#123; this . firstName = 'Jay' ; this . lastName = 'Chou' ; &#125;var person = new Person ( ) ; console . log ( person ) ; 接着我们把person呼叫出来看，会得到如下的结果，通过new它会帮我们建立一个对象，然后里面有Person这个function里面的内容，并且变成了属性名称和属性值： 进一步来看new 让这个过程发生了什么当使用new命令时，它后面的函数依次执行下面的4个步骤： 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 如果函数没有return其他对象，那么new表达式中的函数调用会自动返回这个新对象。 也就是说，当我们使用new这个关键字时，实际上会先有一个空的对象被建立。 接着People这个构造函数会被执行，这个空对象的原型，指向了People.prototype。 我们知道当函数执行的时候，在execution context中会有this被建立，而当我们使用new的时候，函数里面的this会被指定成刚刚所建立的那个空对象。 所以当执行People这个function，执行到this.firstName和this.lastName时，因为this现在指称的是那个空对象，所以实际上是在帮这个空对象赋予属性名称和属性值。 在这样的过程中，只要这个构造函数People 没有指定return为其他对象，它就会直接返回给我们这个新建立的对象。 接着让我们通过一段代码来更清楚的了解这个执行的过程： 12345678function Person ( ) &#123; this . firstName = 'Jay' ; this . lastName = 'Chou' ; console . log ( '这个函数有被执行' ) ;&#125;var person = new Person ( ) ; console . log ( person ) ; 这时候在chrome 中呼叫出来的结果如下，说明了当我们使用new 在构造对象的时候People 这个function 确实有被执行： 通过new 会帮我们建立一个空的对象现在我把我们上面的代码改成这样： 123456function Person ( ) &#123; console . log ( this ) ; &#125;var person = new Person ( ) ; // console.log(person); 这时候代码返回的结果如下，表示的确在执行这段代码的过程中帮我们建立了一个新的空对象： 函数的最后若return其他对象，则原新对象内容会被覆盖现在，让我们把原本的代码稍微做如下修改： 12345678function Person ( ) &#123; this . firstName = 'Jay' ; this . lastName = 'Chou' ; return &#123; "RETURN" : "原本this的内容就不会被返回" &#125; ; &#125;var person = new Person ( ) ; console . log ( person ) ; 构造函数的内部若return其他对象，new命令会返回return语句指定的对象，将原新对象内容覆盖掉；否则，就会不管return语句，返回this对象。返回的结果如下： 手写一个new实现123456789101112function create() &#123; // 创建一个空的对象 var obj = new Object(), // 获得构造函数，arguments中去除第一个参数 Con = [].shift.call(arguments); // 链接到原型，obj 可以访问到构造函数原型中的属性 obj.__proto__ = Con.prototype; // 绑定 this 实现继承，obj 可以访问到构造函数中的属性 var ret = Con.apply(obj, arguments); // 优先返回构造函数返回的对象 return ret instanceof Object ? ret : obj;&#125;; 使用这个手写的new 1234567function Person() &#123;...&#125;// 使用内置函数newvar person = new Person(...) // 使用手写的new，即createvar person = create(Person, ...) 代码原理解析： 用new Object() 的方式新建了一个对象obj 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 将 obj 的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 返回 obj function constructor 的实际应用由上面的方法，我们可以通过function的方式来建立一个新的对象，如果我们想要建立出同属性名称但不同属性值的对象内容，我们可以把对象的属性值变成参数，如此就能通过此function constructor建立出许多不同的对象： 123456789function Person ( firstName , lastName ) &#123; this . firstName = firstName ; this . lastName = lastName ; &#125;var person1 = new Person ( 'Jay' , 'chou' ) ; console . log ( person1 ) ; var person2 = new Person ( 'Jane' , 'chou' ) ; console . log ( person2 ) ; 如此，我们就可以通过同一个构造函数建立出很多不同的对象： 此外，我们会把根据构造器（constructor）所建立出来的对象称作是实例（instance），这在之前的文章里也有提过。 注意！如果我们忘了加上new关键字这里有一个地方我们需要非常留意，如果你在撰写代码的过程当中，忘记加上new这个关键字的话，比如： 1234567function Person ( ) &#123; this . firstName = 'Jay' ; this . lastName = 'Chou' ; &#125;var person = Person ( ) ; console . log ( person ) ; 如此，因为JavaScript不知道你是要执行这个函数，还是要根据这个function去建立object，因次最后会返回undefined的结果。 小结 其实构造函数（function constructor）就是普通的function，只是我们可以通过这个function 来建立对象。 通过在function 前面加上new 这个运算符，它会把函数中this 这个关键字建立成一个新的对象，然后如果你没有在该函数的内部指定返回出其它对象的话，它就会自动返回这个新的对象给你。 那又是如何通过function constructors 来设定我们的原型（prototype）呢？让我们在下一篇文章来谈吧！ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>constructor</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之对象的继承]]></title>
    <url>%2F2019%2F06%2F10%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[这篇文章的重点讲的是关于JavaScript中对象的继承，这是面向对象编程很重要的一个方面。A 对象继承自B 对象，就能直接拥有 B 对象的所有属性和方法，作用是避免了代码的复用，节省代码量。 而大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。传统上，JavaScript 语言的继承不通过 class（ES6 引入了 class 语法，基于 class 的继承不在这里介绍），而是通过“原型对象”（prototype）实现，因此，这里把“继承”着重拿出来讲，就为了体现这个不同。 复习原型/原型链JavaScript的继承得靠原型/原型链来实现，当然原型/原型链不是这篇文章的重点，之前的文章也已经介绍过了，所以这里我们来复习一下即可。 其实原型的概念很简单，我觉得用以下简短的几句话就能概括完全了： 所有对象都有一个属性 __proto__ 指向一个对象，也就是原型 每个对象的原型都可以通过 constructor 找到构造函数，构造函数也可以通过 prototype 找到原型 所有函数都可以通过 __proto__ 找到 Function 对象 所有对象都可以通过 __proto__ 找到 Object 对象 对象之间通过 __proto__ 连接起来，这样称之为原型链。当前对象上不存在的属性可以通过原型链一层层往上查找，直到顶层 Object 对象，顶层 Object 对象最终指向null 我觉得原型中最重要的内容其实就这些了，没必要看太多关于原型的文章，到头来只是会越来越糊涂，如果硬要推荐原型参阅资料的话，《JavaScript高级程序设计》这本书，当之无愧！ 继承通过上面的介绍，我们知道JavaScript中的继承是通过原型/原型链来体现的，先看几行代码： 1234567891011function Foo() &#123; &#125;var f1 = new Foo();f1.a = 10;Foo.prototype.a = 100;Foo.prototype.b = 200;console.log(f1.a); // 10console.log(f1.b); // 200console.log(f1.c); // undefined 以上代码中，f1是Foo函数通过new构造出来的对象，f1.a是f1对象的基本属性，而f1.b是从Foo.prototype继承得到的，因为f1.__proto__指向的是Foo.prototype。 这里有一个重要的规则：当访问一个对象的属性时，首先在基本属性中查找，如果没有，再沿着__proto__这条链往上找，看是否在链上，有的话就能继承这一属性，如果没有，就返回undefined，这就是原型链，又复习一遍咯。 看图直观一些，这里还是采用反复用的原型/原型链经典图： 上图中，访问f1.a时，f1的基本属性中有a，则不会继续沿着__proto__找，直接读出基本属性a的值；而访问f1.b时，f1的基本属性中没有b，于是沿着__proto__找到了Foo.prototype.b。 那我们如何在实际应用中区分一个属性到底是基本属性还是在原型链中的公有属性呢？这里可以好好利用一下这个属性——hasOwnProperty，一下就能测出谁是基本属性，当在for…in…循环中，需要额外注意。 hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性，所以上图中，右边的只打印出a一个值，因为b是在Foo.prototype上的，不属于自身属性。 那f1的这个hasOwnProperty()方法，f1自身没有，Foo.prototype中也没有，又是从何而来呢？ 还是引用那张原型/原型链经典图，从图上来看，hasOwnProperty()方法是从Object.prototype中继承来的： 所以对象的原型链是沿着__proto__这条线走的，因此在查找f1.hasOwnProperty属性时，因为自身没有这一属性，就会沿着原型链一直查找到Object.prototype上有这一属性，如果没找到则返回undefined。 由于所有的对象的原型链都会最终找到Object.prototype，因此所有的对象都会有Object.prototype中的方法，比如toString、valueOf等这些公有属性，这就是所谓的“继承”。 当然这只是一个例子，你可以自定义函数和对象来实现自己的继承，这一点后续文章会有专门介绍。 这里再说一个函数的例子来加深理解吧。 我们都知道每个函数都有apply，call方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”来的。在介绍instanceof这篇文章中也提到，函数是由Function函数创建，都继承自Function.prototype中的方法。不信可以在Chrome中打印出： 直接可以看到了吧，有call、length等这些属性。 那怎么还有hasOwnProperty呢？上图中hasOwnProperty右边显示Object，代表Function.prototype继承自Object.prototype。有疑问可以再看看这张原型/原型链经典大图，Function.prototype.__proto__会指向Object.prototype。 最后还是那句话，当你完全搞懂上面这张图的时候，就是你掌握原型、原型链的时候了。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从instanceof身上深入理解原型/原型链]]></title>
    <url>%2F2019%2F06%2F05%2F%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[今天将延续这篇文章，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。 对于原始类型（primitive type）的值，即string/number/boolean，你可以通过typeof判断其类型，但是typeof在判断到合成类型（complex type）的值的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，也不能判断出Object 下具体是什么细分的类型，比如 Array、Date、RegExp、Error 等。 官方对instanceof运算符的解释是返回一个布尔值，表示对象是否为某个构造函数的实例。比如： 12345function Foo() &#123;&#125;var f1 = new Foo();console.log(f1 instanceof Foo); // trueconsole.log(f1 instanceof Object); // true 上面代码中，对象f1是构造函数Foo的实例，所以返回true，但是“f1 instanceof Object”为什么也是true呢？ 至于为什么等会再解释，先把instanceof判断的规则告诉大家。根据以上代码看下图： instanceof运算符的左边是实例对象，右边是构造函数，左边变量暂称为A，右边变量暂称为B。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。 通俗一点来讲，instanceof的判断规则是：instanceof会检查整个原型链，将沿着A的__proto__这条线来一直找，同时沿着B的prototype这条线来一直找，直到能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。即上图中的 f1–&gt;__proto__ 和 Foo–&gt;prototype 指向同一个对象，console.log(f1 instanceof Foo)为true。 按照以上规则，重新来看看“ f1 instanceof Object ”这句代码为什么是true？ 根据上图很容易就能看出来， f1–&gt;__proto__–&gt;__proto__ 和Object–&gt;prototype 指向同一个对象，console.log(f1 instanceof Object)为true。 通过上面的规则，可以很好地解释一些比较怪异的现象，例如： 1234console.log(Object instanceof Function); // trueconsole.log(Function instanceof Object); // trueconsole.log(Function instanceof Function); // trueconsole.log(Object instanceof Object); // true 这些就是这篇文章所讲的看似很混乱的东西，现在知道为何了吧。 但还有一种特殊情况，就是左边对象的原型链上，只有null对象。这时，instanceof判断会失真。 123var obj = Object.create(null);typeof obj // "object"Object.create(null) instanceof Object // false 上面代码中，Object.create(null)返回一个新对象obj，它的原型是null（Object.create后续会有专门文章介绍）。右边的构造函数Object的prototype属性，不在左边的原型链上，因此instanceof就认为obj不是Object的实例。但是，只要一个对象的原型不是null，instanceof运算符的判断就不会失真。 说到这里，继续贴上这幅原型/原型链的经典图，是否现在看起来没那么复杂了呢。 如果这篇文章你看的比较仔细，再结合刚才介绍的instanceof的概念规则，相信能看懂上面这张图的内容了。 那么问题又出来了。instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？ 这就要重点讲讲继承了，即instanceof表示的就是一种继承关系，或者原型链的结构，请看后续文章介绍。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】12个编写干净且可扩展的JavaScript技巧]]></title>
    <url>%2F2019%2F06%2F04%2F%E3%80%90%E8%AF%91%E3%80%9112%E4%B8%AA%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。 现代Web应用程序严重依赖JavaScript，尤其是单页应用程序（SPA）。借助于React，AngularJS和Vue.js等新兴框架，Web应用程序主要使用JavaScript构建。 扩展这些应用程序有时候会比较棘手，通过简单的设置，您最终可能会遇到限制并迷失在混乱的海洋中。我想分享一些小技巧，这些技巧将帮助您以有效的方式编写干净的代码。 本文面向任何技能水平的JavaScript开发人员。 但是，至少具有JavaScript中级知识的开发人员将从这些技巧中获益最多。 原文链接：https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/ 分隔您的代码我建议保持代码库清洁和可读的最重要的事情是具有按主题分隔的特定逻辑块（通常是函数）。如果你编写一个函数，该函数应该默认只有一个目的，不应该一次做多个事情。 此外，您应避免引起副作用，这意味着在大多数情况下，您不应更改在函数外声明的任何内容。 您将数据接收到带参数的函数中；其他一切都不应该被访问。如果您希望从函数中获取某些内容，请返回新值。 模块化当然，如果以类似的方式使用这些函数或执行类似的操作，您可以将多个函数分组到一个模块（and/or 的类中）。例如，如果要进行许多不同的计算，请将它们拆分为可以链接的独立步骤（函数）。但是，这些函数都可以在一个文件（模块）中声明。 以下是JavaScript中的示例： 12345678910111213141516function add(a, b) &#123; return a + b &#125;function subtract(a, b) &#123; return a - b &#125;module.exports = &#123; add, subtract&#125;const &#123; add, subtract &#125; = require('./calculations')console.log(subtract(5, add(3, 2)) 如果您正在编写前端JavaScript，请务必使用默认导出作为最重要的项目，并为次要项目命名导出。 多个参数优先于单个对象参数声明一个函数时，您应该总是喜欢多个参数而不是一个期望对象的参数： 123456789// GOODfunction displayUser(firstName, lastName, age) &#123; console.log(`This is $&#123;firstName&#125; $&#123;lastName&#125;. She is $&#123;age&#125; years old.`)&#125;// BADfunction displayUser(user) &#123; console.log(`This is $&#123;user.firstName&#125; $&#123;user.lastName&#125;. She is $&#123;user.age&#125; years old.`)&#125; 这背后的原因是，当您查看函数声明的第一行时，您能确切知道需要传递给函数的内容。 尽管函数应该受到限制 - 只做一项工作 - 但是它可能会变得更大。在函数体中扫描需要传递的变量（嵌套在对象中）将花费更多时间。有时，使用整个对象并将其传递给函数似乎更容易，但为了扩展应用程序，此设置肯定会有所帮助。 在某种程度上，声明特定参数没有意义。对我来说，它超过四个或五个功能参数。如果你的函数变大，你应该转向使用对象参数。 这里的主要原因是参数需要以特定顺序传递。 如果您有可选参数，则需要传递undefined或null。 使用对象参数，您可以简单地传递整个对象，其中顺序和未定义的值无关紧要。 解构（Destructuring）解构是ES6引入的一个很好的工具。它允许您从对象中获取特定字段并立即将其分配给变量。 您可以将它用于任何类型的对象或模块。 12// EXAMPLE FOR MODULESconst &#123; add, subtract &#125; = require('./calculations') 只导入您需要在文件中使用的函数而不是整个模块，然后从中访问特定的函数。 同样，当您确定您确实需要一个对象作为函数参数时，也可以使用destructuring。 这仍将为您提供函数内所需内容的概述： 12345678910111213141516171819202122function logCountry(&#123;name, code, language, currency, population, continent&#125;) &#123; let msg = `The official language of $&#123;name&#125; ` if(code) msg += `($&#123;code&#125;) ` msg += `is $&#123;language&#125;. $&#123;population&#125; inhabitants pay in $&#123;currency&#125;.` if(contintent) msg += ` The country is located in $&#123;continent&#125;`&#125;logCountry(&#123; name: 'Germany', code: 'DE', language 'german', currency: 'Euro', population: '82 Million',&#125;)logCountry(&#123; name: 'China', language 'mandarin', currency: 'Renminbi', population: '1.4 Billion', continent: 'Asia',&#125;) 正如你所看到的，我仍然知道我需要传递什么给函数 - 即使它被包装在一个对象中。要解决了解所需内容的问题，请参阅下一个提示！（顺便说一句，这也适用于React功能组件。） 使用默认值解构的默认值甚至基本函数参数都非常有用。首先，它们为您提供了一个可以传递给函数的值的示例。其次，您可以指出哪些值是必需的，哪些值不是。使用前面的示例，该函数的完整设置如下所示： 1234567891011121314151617181920212223242526272829function logCountry(&#123; name = 'United States', code, language = 'English', currency = 'USD', population = '327 Million', continent,&#125;) &#123; let msg = `The official language of $&#123;name&#125; ` if(code) msg += `($&#123;code&#125;) ` msg += `is $&#123;language&#125;. $&#123;population&#125; inhabitants pay in $&#123;currency&#125;.` if(contintent) msg += ` The country is located in $&#123;continent&#125;`&#125;logCountry(&#123; name: 'Germany', code: 'DE', language 'german', currency: 'Euro', population: '82 Million',&#125;)logCountry(&#123; name: 'China', language 'mandarin', currency: 'Renminbi', population: '1.4 Billion', continent: 'Asia',&#125;) 显然，有时您可能不想使用默认值，而是在未传递值时抛出错误。 然而，这通常是一个方便的技巧。 数据稀缺性前面的技巧引出了一个结论：最好不要传递您不需要的数据。同样，在设置函数时，这可能意味着更多的工作。但是，从长远来看，它肯定会为您提供更具可读性的代码库。确切地知道在特定位置使用哪些值是非常有价值的。 行数和缩进限制我见过大文件 - 非常大的文件。实际上，超过3,000行代码。在这些文件中查找逻辑块是非常困难的。 因此，您应该将文件大小限制为一定数量的行。我倾向于将我的文件保存在100行代码之下。 有时候，很难分解文件，它们会增长到200-300行，在极少数情况下会增加到400行。 超过此临界值，意味着文件太杂乱，难以维护。随意创建新的模块和文件夹。您的项目应该看起来像一个森林，由树（模块部分）和分支（模块和模块文件组）组成。避免试图模仿阿尔卑斯山，在密闭区域堆积代码。 相比之下，你的实际文件应该看起来像Shire，这里和那里都有一些山丘（小水平的缩进），但一切都相对平坦。 尽量将压痕水平保持在四级以下。 也许为这些提示启用eslint规则是有帮助的！ 使用prettier在团队中工作需要清晰的样式指南和格式。ESLint提供了一个巨大的规则集，您可以根据自己的需求进行自定义。还有 eslint--fix，它可以纠正一些错误，但不是全部。 相反，我建议使用Prettier格式化代码。这样，开发人员不必担心代码格式化，而只需编写高质量的代码。 外观将一致并且格式自动化。 使用有意义的变量名理想情况下，应根据其内容命名变量。 以下是一些有助于您声明有意义的变量名称的指南。 函数函数通常执行某种操作。为了解释这一点，人类使用动词 - 转换或显示，例如。在开头用动词命名函数是个好主意，例如convertCurrency 或 displayUserName。 数组这些通常会包含一系列项目; 因此，将s附加到变量名称。 例如： 1const students = ['Eddie', 'Julia', 'Nathan', 'Theresa'] 布尔简单地说就是尽量多接近于自然语言，这样好理解。你会问“这个人是教师吗？”→“是”或“否”。同样： 1const isTeacher = true // OR false 数组函数forEach, map, reduce, filter等是很好的原生JavaScript函数，用于处理数组和执行某些操作。 我看到很多人只是将el 或 element作为参数传递给回调函数。 虽然这很简单快捷，但您还应根据其值来命名。 例如： 1234const cities = ['Berlin', 'San Francisco', 'Tel Aviv', 'Seoul']cities.forEach(function(city) &#123;...&#125;) 标识通常，您必须跟踪特定数据集和对象的ID。当嵌套id时，只需将其保留为id即可。在这里，我喜欢在将对象返回到前端之前将MongoDB _id映射到 id。从对象中提取id时，请预先添加对象的类型。例如： 123const studentId = student.id// ORconst &#123; id: studentId &#125; = student // destructuring with renaming 该规则的一个例外是模型中的MongoDB引用。 在这里，只需在引用的模型之后命名字段即可。 这将在填充参考文档时保持清晰： 123456789const StudentSchema = new Schema(&#123; teacher: &#123; type: Schema.Types.ObjectId, ref: 'Teacher', required: true, &#125;, name: String, ...&#125;) 尽可能使用async / await在可读性方面，回调是最糟糕的 - 特别是在嵌套时。Promises是一个很好的改进，但在我看来，async / await具有最好的可读性。即使对于初学者或来自其他语言的人来说，这也会有很大帮助。但是，请确保您了解其背后的概念，并且不要盲目地在任何地方使用它。 模块导入顺序正如我们在技巧1和2中看到的那样，将逻辑保持在正确的位置是可维护性的关键。 同样，导入不同模块的方式可以减少文件中的混淆。 我在导入不同模块时遵循一个简单的结构： 12345678910111213141516// 3rd party packagesimport React from 'react'import styled from 'styled-components'// Storesimport Store from '~/Store// reusable componentsimport Button from '~/components/Button'// utility functionsimport &#123; add, subtract &#125; from '~/utils/calculate'// submodulesimport Intro from './Intro'import Selector from './Selector' 我在这里使用了React组件作为示例，因为有更多类型的导入。 您应该能够根据您的具体用例进行调整。 摆脱控制台console.log 是一种很好的调试方式 - 非常简单，快速，完成工作。显然，有更复杂的工具，但我认为每个开发人员仍然使用它。如果您忘记清理日志，您的控制台最终将陷入巨大的混乱。然后，您确实要在代码库中保留日志; 例如，警告和错误。 要解决此问题，您仍然可以使用console.log 进行调试，但对于持久日志，请使用loglevel或winston等库。此外，您可以使用ESLint警告控制台语句。这样你就可以轻松地全局查找console... 并删除这些语句。 遵循这些指导原则确实帮助我保持代码库的清洁和可扩展性。 你觉得还有什么提示特别有用的吗？请在评论中告诉我您在编码工作过程中值得推荐的内容，并请分享您用于帮助代码结构的任何其他提示！谢谢~ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>编程技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一段代码引发的关于Object和Function的鸡和蛋问题的思考]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。 鸡和蛋问题的由来首先Object和Function都是构造函数，而所有的构造函数都是Function的实例对象。 因此Object是Function的实例对象；而Function.prototype是Object的实例对象。所以这里就引伸出了一个有意思的鸡和蛋的问题： 123456Object instanceof Function // trueFunction instanceof Object // trueObject.__proto__ === Function.prototype // trueFunction.__proto__ === Function.prototype // trueFunction.prototype.__proto__ === Object.prototype // true 那么Object和Function，谁是鸡谁是蛋呢？ 接下来就来深入探究下上面这段代码所引起的鸡生蛋蛋生鸡问题，从下面这张原型/原型链经典图入手，在这个过程中深入了解 Object.prototype、Function.prototype、function Object() 、function Function() 之间的关系，这个过程可能有点烧脑，毕竟是JS的一大玄学嘛。 Object.prototype原型链的尽头就是Object.prototype（不考虑 null 的情况下）。所有对象均从Object.prototype继承toString() 等公共属性。 Object.prototype 表示 Object 的原型对象，实际上Object.prototype 并不是通过Object函数创建的，为什么呢？看如下代码： 12345function Dog() &#123; this.name = '川普';&#125;var dog = new Dog();dog.__proto__ === Dog.prototype; // true 实例对象的__proto__会指向构造函数的prototype，即dog.__proto__指向 Dog.prototype，但是Object.prototype.__proto__又是 null，所以 Object.prototype 并不是通过 Object 函数创建的，那它如何生成的？其实 Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象，所以在经典图里面只是看起来Object.prototype 是通过 Object 函数创建的，实际上并不是。 Function.prototypeFunction.prototype和Function.__proto__为同一对象。 这也意味着：Object/Array等等构造函数本质上和Function一样，均继承于Function.prototype，从经典图上来看都是通过new Function构造出来的。 当然，Function.prototype 对象是一个函数（对象），其__proto__属性指向 Object.prototype，即Function.prototype会直接继承root（Object.prototype）。 通过这点我们可以弄清继承的原型链：Function|Object|Array...---&gt;Function.prototype---&gt;Object.prototype(root)。如下图所示： function Object()Object 作为构造函数时，其__proto__属性指向 Function.prototype，即: 1Object.__proto__ === Function.prototype // true 从经典图来看： 使用 new Object() 创建实例对象o1时，实例对象o1的 __proto__属性指向构造函数的 prototype 属性，对应上图就是 Object.prototype，即o1.__proto__ === Object.prototype结果为true。 Function.prototype指向的对象，它的__proto__会指向Object.prototype，因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。 function Function()Function也是一个函数对象，也有__proto__属性，既然是函数，那么它一定是被Function创建，所以Function是被自身创建的，所以它的__proto__指向了自身的Prototype： 1Function.__proto__ === Function.prototype // true 到这里就有点烧脑了吧，我们再看下鸡生蛋蛋生鸡问题。 Function &amp; Object 鸡和蛋问题由上面可知，Object构造函数继承了Function.prototype，同时Function构造函数继承了Object.prototype，这里就产生了鸡和蛋的问题。为什么会出现这种问题呢？必须首先更深入一层去理解Function.prototype这个对象，因为它是导致Function instanceof Object和Object instanceof Function都为true的原因。 1234567891011// Object instanceof Function 即Object.__proto__ === Function.prototype // true// Function instanceof Object 即Function.__proto__.__proto__ === Object.prototype // true// Object instanceof Object 即 Object.__proto__.__proto__ === Object.prototype // true// Function instanceof Function 即 Function.__proto__ === Function.prototype // true 根据JS规范，Function.prototype又是个不同于一般函数（对象）的函数（对象），其中： Function.prototype像普通函数一样可以调用，但总是返回undefined。 普通函数实际上是Function的实例，即普通函数继承于Function.prototype。即func.__proto__ === Function.prototype。 Function.prototype继承于Object.prototype，并且没有prototype这个属性。 所以，Function.prototype其实是个另类的函数，可以独立于/先于Function产生。 而Object本身是个（构造）函数，是Function的实例，即Object.__proto__就是Function.prototype。 总结：先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生。 看到这里估计也都看烦了，是不是还是有点混乱呀？乱也很正常。那这篇文章就先让它乱着，下一篇我们将请另一个老朋友来帮忙，把它彻底理清楚，这位老朋友就是——instanceof，那就且听请下回分解咯。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从原生JS实现jQuery的一个API中体会其设计思想]]></title>
    <url>%2F2019%2F05%2F31%2F%E4%BB%8E%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84%E4%B8%80%E4%B8%AAAPI%E4%B8%AD%E4%BD%93%E4%BC%9A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？读源代码又太繁琐，所以这里利用原生JS来实现jQuery中的addClass这个API，通过实现此过程来体会jQuery的设计思想，力求简单易懂。 封装函数1function addClass(classes)&#123;&#125; //可将所有输入的标签的class添加一个类 实现这个函数函数addClass()是输入一个类名，给选中的所有标签添加一个类，所以要用到classList.add()，具体实现如下: 123456function addClass(node, classes) &#123; var allTag = document.querySelectorAll(node) for (let i = 0; i &lt; allTag.length; i++) &#123; allTag[i].classList.add(classes) &#125;&#125; 命名空间在全局变量中创建一个对象，用来储存封装后的函数，这就是命名空间（名字前面统一加一个前缀） 1234window.jQuery = &#123;&#125;jQuery.addClass = addClassjQuery.addClass('div', 'red') 整理之后 123456789window.jQuery = &#123;&#125;jQuery.addClass = function(node, classes) &#123; var allTag = document.querySelectorAll(node) for (let i = 0; i &lt; allTag.length; i++) &#123; allTag[i].classList.add(classes) &#125;&#125;jQuery.addClass('div', 'red') 将node放到前面1node.addClass(classes) 方法一：扩展 Node 接口，直接在 Node.prototype 上加函数 123Node.prototype.addClass = function()&#123; ...&#125; 方法二：新的接口 BetterNode 1234567891011121314window.jQuery = function(node) &#123; return &#123; element: node, addClass: function(classes) &#123; var allTag = document.querySelectorAll(node) for (let i = 0; i &lt; allTag.length; i++) &#123; allTag[i].classList.add(classes) &#125; &#125; &#125;&#125;let node2 = jQuery('div')node2.addClass('red') 第二种叫做「无侵入」。 进一步完善给个缩写并且使其可以是节点或者选择器 12345678910111213141516171819202122232425window.jQuery = function(nodeOrSelector)&#123; let nodes = &#123;&#125; if(typeof nodeOrSelector === 'string')&#123; let temp = document.querySelectorAll(nodeOrSelector) for(let i=0;i&lt;temp.length;i++)&#123; nodes[i]=temp[i] &#125; nodes.length = temp.length &#125;else if(nodeOrSelector instanceof Node)&#123; nodes = &#123; 0:nodeOrSelector, length:1 &#125; &#125; nodes.addClass = function(classes)&#123; for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].classList.add(classes) &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $('div')$div.addClass('red') // 可将所有 div 的 class 添加一个 red 封装ajax按照jQuery的设计思路封装一个ajax函数 1234567891011121314window.jQuery.ajax = function(url, method, body, success, fail) &#123; let request = XMLHttpResquest() request.open(method, url) request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123; success.call(undefined, request.responseText) &#125; else if (request.status &gt;= 400) &#123; fail.call(undefined, request) &#125; &#125; &#125; request.send(body)&#125; 升级改进一下满足promise规则 12345678910111213141516171819202122232425window.jQuery.ajax = function(&#123; url, method, body, headers&#125;) &#123; return new Promise(function(resolve, reject) &#123; let request = XMLHttpResquest() request.open(method, url) for (let key in headers) &#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123; success.call(undefined, request.responseText) &#125; else if (request.status &gt;= 400) &#123; fail.call(undefined, request) &#125; &#125; &#125; request.send(body) &#125;)&#125; 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM Node 的建立、删除与修改]]></title>
    <url>%2F2019%2F05%2F23%2FDOM%20Node%20%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[在之前的介绍中，我们已经理解了DOM Node的类型、以及节点之间的查找与关系。那么在今天的介绍里我将继续来说明，如何通过DOM API来建立新的节点、修改以及删除节点。 DOM 节点的新增document.createElement(tagName)通过document.createElement()可以建立一个新的元素： 1var newDiv = document.createElement('div'); 在建立新的div元素newDiv后，这时候我们在浏览器上还看不到它，直到通过appendChild()、insertBefore()或replaceChild()等方法将新元素加入至指定的位置之后才会显示。 新建立的newDiv我们也可以同时对它指定属性，如： 12newDiv.id = "myNewDiv"; newDiv.className = "box"; document.createTextNode()之前曾介绍过，除了HTML元素节点外，还有文字节点，那么document.createTextNode()就是用来建立文字节点的方法。 用法很简单，直接在document.createTextNode()加入字符串即可。跟createElement一样的是，新增的TextNode在被加入至某个节点前，我们是看不到它的。 1234567var newDiv = document.createElement('div');// 建立 textNode 文字节点var textNode = document.createTextNode("Hello world!");// 通过 newDiv.appendChild 将 textNode 加入至 newDiv newDiv.appendChild(textNode); document.createDocumentFragment()在DOM规范的所有节点之中，DocumentFragment算是最特殊的一种，它是一种没有父层节点的最小化文件对象。可以把它看作是一个轻量化的Document，用如同标准文件一般的方式来保存片段的文件结构。 例如，一开始我们有一个HTML 的容器元素： 1&lt;ul id="myList"&gt;&lt;/ul&gt; 接着我们通过document.createDocumentFragment()来建立DocumentFragment： 123456789101112131415// 取得外层容器 myListvar ul = document.getElementById("myList");// 建立一个 DocumentFragment，可以把它看作一个虚拟的容器var fragment = document.createDocumentFragment();for (var i = 0; i &lt; 3; i++)&#123; // 生成新的 li，加入文字后置入 fragment 中。 let li = document.createElement("li"); li.appendChild(document.createTextNode("Item " + (i+1))); fragment.appendChild(li);&#125;// 最后将组合完成的 fragment 放进 ul 容器ul.appendChild(fragment); 通过操作DocumentFragment与直接操作DOM最关键的区别在于DocumentFragment不是真实的DOM结构，所以说DocumentFragment的变动并不会影响目前的网页文件，也不会导致回流（reflow）或引起任何影响效果的情况发生。 document.write()document对象要将某内容写入网页也可以用write()方法，当浏览器读取页面，解析到document.write()的时候就会停下来，并且将内容输出，且不只是单纯的字符串，也可以是HTML的标签。 我们只要将对应的HTML 字符串传入： 1document.write("&lt;h1&gt;Hello World!&lt;/h1&gt;"); 甚至，如果要新增一个&lt;script&gt;标签，并指定外部js资源也是可以的，但要注意的是： 12345// 写成这样， &lt;/script&gt;会变成目前 script 块的结束，导致错误 document.write("&lt;script type=\"text\javascript\" src=\"file.js\"&gt;" + "&lt;/script&gt;");// 为了避免这种问题，要将结尾的标签这种写法 &lt;\/script&gt; 就 ok 了 document.write("&lt;script type=\"text\javascript\" src=\"file.js\"&gt;" + "&lt;\/script&gt;"); 另外，需要特别注意的是，当网页已经读取完成后才执行document.write()，则里面的内容会完全覆盖掉目前的网页： 123window.onload = function()&#123; document.write("Hello world!"); &#125;; 上面例子的window.onload表示网页已载入完成，此时无论网页原本有什么内容，都会被&quot;Hello world!&quot;所覆盖。 DOM 节点的修改与删除上面介绍了很多建立DOM节点的方法，除了最后的document.write之外，其他都只是单纯建立节点，并未输出至网页上。 那么，接下来要介绍的几个方法，则说明要如何将刚刚建立好的DOM 节点，置入到我们所需要指定的位置上。 NODE.appendChild(childNode) 通过appendChild()方法，可以将指定的childNode节点，加入到Node父容器节点的末端： 123456789101112131415161718192021&lt;ul id="myList"&gt; &lt;li&gt;Item1&lt;/li&gt; &lt;li&gt;Item2&lt;/li&gt; &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 取得容器 var myList = document.getElementById('myList'); // 建立新的 &lt;li&gt; 元素 var newList = document.createElement('li'); // 建立 textNode 文字节点 var textNode = document.createTextNode("Hello world!"); // 通过 appendChild 将 textNode 加入至 newList newList.appendChild(textNode); // 通过 appendChild 将 newList 加入至 myList myList.appendChild(newList);&lt;/script&gt; NODE.insertBefore(newNode, refNode) insertBefore()方法，则是将新节点newNode插入至指定的refNode节点的前面： 1234567891011121314151617181920212223&lt;ul id="myList"&gt; &lt;li&gt;Item1&lt;/li&gt; &lt;li&gt;Item2&lt;/li&gt; &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 取得容器 var myList = document.getElementById('myList'); // 取得 "&lt;li&gt;Item2&lt;/li&gt;" 的元素 var refNode = document.querySelectorAll('li')[1]; // 建立 li 元素节点 var newNode = document.createElement('li'); // 建立 textNode 文字节点 var textNode = document.createTextNode("Hello world!"); newNode.appendChild(textNode); // 将新节点 newNode 插入 refNode 的前方 myList.insertBefore(newNode, refNode);&lt;/script&gt; NODE.replaceChild(newChildNode, oldChildNode) replaceChild()方法，则是将原本的oldNode替换成指定的newNode。 1234567891011121314151617181920212223&lt;ul id="myList"&gt; &lt;li&gt;Item1&lt;/li&gt; &lt;li&gt;Item2&lt;/li&gt; &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 取得容器 var myList = document.getElementById('myList'); // 取得 "&lt;li&gt;Item2&lt;/li&gt;" 的元素 var oldNode = document.querySelectorAll('li')[1]; // 建立 li 元素节点 var newNode = document.createElement('li'); // 建立 textNode 文字节点 var textNode = document.createTextNode("Hello world!"); newNode.appendChild(textNode); // 将原有的 oldNode 替换成新节点 newNode myList.replaceChild(newNode, oldNode);&lt;script&gt; NODE.removeChild(childNode) removeChild()方法，则是将指定的childNode子节点移除。 12345678910111213141516&lt;ul id="myList"&gt; &lt;li&gt;Item1&lt;/li&gt; &lt;li&gt;Item2&lt;/li&gt; &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 取得容器 var myList = document.getElementById('myList'); // 取得 "&lt;li&gt;Item2&lt;/li&gt;" 的元素 var removeNode = document.querySelectorAll('li')[1]; // 将 myList 下的 removeNode 节点移除 myList.removeChild(removeNode);&lt;/script&gt; 相信看完今天的分享，已经有能力可以通过DOM 提供的API 来进行节点的新增、修改以及删除了吧。 大家也许会发现，无论要对网页元素做出什么样的操作，我们都会基于某个节点出发对吧？ 刚好呼应阿基米德的一句众所周知的名言： 「给我一个支点，我就能撬动整个地球。」 那么有了DOM API 的帮助后， JavaScript 也可以说： 「给我一个节点，我就能建立整个网页世界。」 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过DOM API 查找节点]]></title>
    <url>%2F2019%2F05%2F23%2F%E9%80%9A%E8%BF%87DOM%20API%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[在上一篇的分享当中，我们简单介绍了BOM 与DOM，也了解到JavaScript 是怎么通过它们提供的方法来与浏览器进行沟通。 当一个网页被载入到浏览器时，浏览器会首先分析这个HTML 文档，然后会依照这份HTML 的内容解析成DOM (Document Object Model，即文件对象模型)。 而DOM 是W3C 制定的一个规范，它是独立于平台与语言的标准。换言之，只要遵守这样的规范，不管是什么平台或者是什么语言开发，都可以通过DOM 提供的API 来操作DOM 的内容、结构与样式。 所以说，DOM 是网页的根本，懂得控制DOM就可以控制整个网页，做出良好的互动体验。 那么在今天的分享中，我们就继续来介绍DOM API 查找节点的方法吧。 前言:script标签放哪里有区别吗？针对&lt;script&gt;标签放哪里，这个题目其实没有标准答案，一般你会看到有两种版本： 放在&lt;head&gt; ... &lt;/head&gt;之间 放在&lt;/body&gt;之前 还有人会说为什么放在&lt;head&gt; ... &lt;/head&gt;里面的JavaScript没有作用？我觉得这说的有出入，这里我们简单来讲一下问题所在。 那么我们来试试上一篇介绍过的，先以document.querySelector取得id=&quot;hello&quot;的节点，然后通过textContent来修改内容。 先来试试把&lt;script&gt;标签放在&lt;/body&gt;之前。在jsbin里面马上执行看看，看起来似乎很ok呢！ 接着，我们试着把&lt;script&gt;标签移到&lt;head&gt; ... &lt;/head&gt;之间： 咦？怎么什么都没有呢？而且也没有错误信息，JavaScript真的如大家说的一样，很垃圾吗？ 冷静一下，容我解释一下。 前面说过，当一个网页被载入到浏览器时，浏览器会先分析这个HTML 文档，由上而下依序来读取解析： 所以上面jsbin例子中，当浏览器在&lt;head&gt; ... &lt;/head&gt;之间遇到&lt;script&gt;标签时，就会暂停解析网页，并且立即执行&lt;script&gt;里的内容，直到script执行完毕后再继续解析网页。 当&lt;head&gt; ... &lt;/head&gt;里的&lt;script&gt;想要尝试去寻找&lt;div id=&quot;hello&quot;&gt;这个标签，但因为还没解析到网页本体，所以也无从取得。 不是浏览器坏掉，也不是JavaScript太渣，而是因为我们不理解浏览器执行的原理所造成的误会。 这里是浏览器加载一个有 &lt;script&gt; 标签的网站所发生的事情: 拉取 HTML 页面 开始解析 HTML 解析到 &lt;script&gt; 标签之后准备获取 script 文件. 浏览器获取script文件。同时，html 解析中断并且阻断页面上其他html的解析。 一段时间后，script下载完成并且执行。 继续解析HTML文档的其他部分（解析script之后的html代码） 第4步导致了很不好的用户体验，直到script文件全部下载完成之前HTML都不能得到解析。 那么，当我们把&lt;script&gt;标签放在&lt;/body&gt;结束之前，由于DOM已经解析完成，所以document.querySelector就可以顺利取得id=&quot;hello&quot;的节点，并且把&#39;HELLO&#39;的字串放在网页里啦！ 这样说起来，&lt;script&gt;标签是不是就不适合放在&lt;head&gt; ... &lt;/head&gt;之间呢？ 也不能这么说，这点认真要讲的话之后或许可以用一整篇来说明这个。 DOM 节点的选取 上一篇文章说过，document对象是DOM tree的根节点，所以当我们要存取HTML时，都从document对象开始。而DOM的节点类型除了HTML元素节点(element nodes)外，还有文字节点(text nodes)、注释节点(comment nodes)等。 而常见的DOM 选取方法有下列这些： 123456789101112// 根据传入的值，找到 DOM 中 id 为 'xxx' 的元素。document.getElementById('xxx');// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)document.getElementsByTagName('xxx');// 针对给定的 class 名称，返回所有符合条件的节点集合document.getElementsByClassName('xxx');// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的节点集合document.querySelector('xxx'); document.querySelectorAll('xxx'); DOM 节点的类型DOM 常用的节点类型有下面几种： 可以通过节点类型常数或是对应数值来判断： 12document.nodeType === Node.DOCUMENT_NODE; //truedocument.nodeType === 9; //true 其他不常用或是已经废弃的部分可以参考：MDN Node.nodeType一节。 DOM 节点间的查找遍历(Traversing)由于DOM 节点有分层的概念，于是节点与节点之间的关系，我们大致上可以分成以下两种： 父子关系：除了document之外，每一个节点都会有个上层的节点，我们通常称之为「父节点」 (Parent node)，而相对地，从属于自己下层的节点，就会称为「子节点」 (Child node)。 兄弟关系：有同一个「父节点」的节点，那么他们彼此之间就是「兄弟节点」(Siblings node)。 而隔层的节点基本上没有直接关系。 上图中水平方向的邻层节点为父子关系，垂直方向的同层节点为兄弟关系。 Node.childNodes 所有的DOM节点对象都有childNodes属性，且此种属性无法修改。 我们可以通过Node.hasChildNodes()来检查某个DOM节点是否有子节点。 1234567891011var node = document.querySelector('#hello');// 如果 node 內有子元素if( node.hasChildNodes() ) &#123; // 可以通过 node.childNodes[n] (n 为数字索引) 取得对应的节点 // 注意，NodeList 对象內容为即时更新的集合 for (var i = 0; i &lt; node.childNodes[i].length; i++) &#123; // ... &#125;; &#125; Node.childNodes返回的可能会有这几种： HTML 元素节点(element nodes) 文字节点(text nodes)，包含空格 注释节点(comment nodes) Node.firstChild Node.firstChild可以取得Node节点的第一个子节点，如果没有子节点则返回null。 要注意的是，子节点包括空白节点，如下面例子： 123456789101112&lt;p&gt; &lt;span&gt;span 1&lt;/span&gt; &lt;span&gt;span 2&lt;/span&gt; &lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p = document.querySelector('p'); // tagName 属性可以取得 node 的标签名称 console.log(p.firstChild.tagName); // undefined&lt;/script&gt; 因为取得的是&lt;p&gt;与第一个&lt;span&gt;中间的换行字元，所以p.firstChild.tagName会得到undefined。所以改成这样： 12345678&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p = document.querySelector('p'); // tagName 属性可以取得 node 的标签名称 console.log(p.firstChild.tagName); // "SPAN"&lt;/script&gt; 把中间的换行与空白移除，就会得到预期中的&quot;SPAN&quot;了。 Node.lastChild Node.lastChild可以取得Node节点的最后一个子节点，如果没有子节点则返回null。 与Node.firstChild一样的是，子节点也包括空白节点，所以像这样： 123456789101112&lt;p&gt; &lt;span&gt;span 1&lt;/span&gt; &lt;span&gt;span 2&lt;/span&gt; &lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p = document.querySelector('p'); // textContent 属性可以取得节点内的文字内容 console.log(p.lastChild.textContent); // "" (换行字元)&lt;/script&gt; 得到的会是一个换行字元的空字符串。 移除节点之间多余的空白后： 1234567&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var p = document.querySelector('p'); // textContent 属性可以取得节点内的文字内容 console.log(p.lastChild.textContent); // "span 3"&lt;/script&gt; 输出的就会是正确的”span 3” 啦。 Node.parentNode 那么相较于Child系列，parentNode就单纯一些。 通过Node.parentNode可以用来取得父元素，返回值可能会是一个元素节点(Element node)、根节点(Document node)或DocumentFragment节点。 123456&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var el = document.querySelector('span'); console.log( el.parentNode.nodeName ); // "P"&lt;/script&gt; Node.previousSibling 看完了DOM父与子之后，接着来看看兄弟节点。 通过Node.previousSibling可以取得同层之间的前一个节点，如果node已经是第一个节点且前面无节点，则返回null。 1234567891011&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var el = document.querySelector('span'); console.log( el.previousSibling ); // null // document.querySelectorAll 会取得所有符合条件的集合， // 而 document.querySelectorAll('span')[2] 指的是「第三个」符合条件的元素。 var el2 = document.querySelectorAll('span')[2]; console.log( el2.previousSibling.textContent ); // "span 2"&lt;/script&gt; Node.nextSibling 与Node.previousSibling类似，通过Node.nextSibling可以取得同层之间的下一个节点，如果node已经是最后一个节点，则返回null。 123456789&lt;p&gt;&lt;span&gt;span 1&lt;/span&gt;&lt;span&gt;span 2&lt;/span&gt;&lt;span&gt;span 3&lt;/span&gt;&lt;/p&gt;&lt;script&gt; // document.querySelector 会取得第一个符合条件的元素 var el = document.querySelector('span'); console.log( el.nextSibling.textContent ); // "span 2"&lt;/script&gt; document.getElementsBy*与document.querySelector/ document.querySelectorAll的差异 今天分享了很多关于DOM的选取以及查找遍历的方式，其中，像是document.getElementById以及document.querySelector因为取得的一定只会有一个元素/节点，所以不会有index与length属性。 而document.getElementsBy**(注意，这里有个s)以及document.querySelectorAll则分别返回HTMLCollection与NodeList。 这两者其实是有点差别的，HTMLCollection只收集HTML element 节点，而NodeList除了HTML element 节点，也包含文字节点、属性节点等。当然两者也有类似的地方，虽然不能使用数组的method，但这两种都可以用数组索引的方式来存取内容，也就是伪数组。 另一个需要注意的地方是，HTMLCollection/NodeList在大部分情况下是即时更新的，但通过document.querySelector/document.querySelectorAll取得的NodeList是静态的。 啥意思呢？举个例子： 1234567891011121314151617181920&lt;div id="outer"&gt; &lt;div id="inner"&gt;inner&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // &lt;div id="outer"&gt; var outerDiv = document.getElementById('outer'); // 所有的 &lt;div&gt; 标签 var allDivs = document.getElementsByTagName('div'); console.log(allDivs.length); // 2 // 清空 &lt;div id="outer"&gt; 下的节点 outerDiv.innerHTML = ''; // 因为清空了&lt;div id="outer"&gt; 下的节点，所以只剩下 outer console.log(allDivs.length); // 1&lt;/script&gt; 如果改成document.querySelector的写法： 1234567891011121314151617181920&lt;div id="outer"&gt; &lt;div id="inner"&gt;inner&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // &lt;div id="outer"&gt; var outerDiv = document.getElementById('outer'); // 所有的 &lt;div&gt; 标签 var allDivs = document.querySelectorAll('div'); console.log(allDivs.length); // 2 // 清空 &lt;div id="outer"&gt; 下的节点 outerDiv.innerHTML = ''; // document.querySelector 返回的是静态的 NodeList，不受 outerDiv 更新影响 console.log(allDivs.length); // 2&lt;/script&gt; 那么以上就是今天所要介绍的内容啦。 在后续的文章会再继续说明DOM API新增/删除/修改节点的部分，欢迎持续关注。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈浏览器里的JavaScript]]></title>
    <url>%2F2019%2F05%2F21%2F%E8%81%8A%E4%B8%80%E8%81%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%9A%84JavaScript%2F</url>
    <content type="text"><![CDATA[在许多的网页前端教学或是文章书籍当中，你可能常常听到这样的说法：「HTML、CSS 与JavaScript 是网页前端三大要素」，其中： HTML 负责资料与结构 CSS 负责样式与呈现 JavaScript 负责行为与互动 那么，如果你跟我在学JavaScript的时候也有一样的疑问：变量、类型、对象、流程控制、函数…表面上看似基础都学会了，但… 我还是不知道怎么通过JavaScript在网页上输出”Hello World!”啊！ 那么相信看完今天的分享，我保证你一定可以通过JavaScript 在网页上输出”Hello World!” (嘻嘻) 浏览器里的JavaScript严格来说，JavaScript (或者说ECMAScript 标准) 并没有提供网页的操作方法。 事实上，前端开发者在网页的操作方法都是由JavaScript的执行平台，也就是浏览器提供的。这些操作方法基本上会分别由这两种对象所拥有：BOM与DOM。 所以广泛来说，在浏览器上的JavaScript 实际上包含了以下三部分： JavaScript核心 (以ECMAScript标准为基础) BOM (Browser Object Model，浏览器对象模型) DOM (Document Object Model，文件对象模型) 由于BOM与DOM是由浏览器执行环境所提供；所以换句话说，在node环境下的JavaScript就不会有这两个部分。 前端开发者就是可以通过JavaScript 去调用BOM 与DOM 提供的API，进一步通过它们去控制浏览器的行为与网页的内容。 那么接下来就来具体介绍一下BOM与DOM吧。 BOM 是什么?BOM(Browser Object Model，浏览器对象模型)，是浏览器所有功能的核心，与网页的内容无关。 在早期没有制定标准规范的时候，各家浏览器厂商几乎在自家浏览器上都有各自的功能，非常混乱。直到后来W3C 把各家浏览器都有的部分，以及确定已经(或未来会) 加入的功能，统一集合起来纳入了HTML5 的标准中，这也就是我们现在看到的BOM API。 BOM 有时也有人非正式地称它为Level 0 DOM。因为它在DOM level 1 标准前就已存在，而不是真的有文件去规范这些，所以Level 0 DOM与BOM两者实际上指的是同一个东西。 BOM的核心window对象 从上图可以看出BOM的核心是window对象。 而window对象提供的属性主要为document、location、navigator、screen、history以及frames。 在浏览器里的window对象会扮演着两种角色： ECMAScript 标准里的全局对象 (Global Object) JavaScript 用来与浏览器沟通的窗口 凡是在全局作用域内声明的变量、对象、函数等，都会自动变成全局对象的属性。通常这样的变量，我们会称它们叫做全局变量，可以通过window.xxx的方式取得它们。比如： 12var a = 10; console.log( window.a ); // 10 除此之外，在全局作用域内声明的全局变量还有一个特性，就是无法使用delete关键字来移除： 12345var a = 10; console.log( window.a ); // 10console.log(delete window.a); // falseconsole.log( window.a ); // 10 但若是直接通过指定window对象的属性则可以： 12345window.a = 10; console.log( window.a ); // 10console.log(delete window.a); // trueconsole.log( window.a ); // undefined 现在我们已经知道了全局对象是怎么回事了，那么window对象扮演的另一个角色，用来与浏览器沟通的窗口又是什么意思呢？ 浏览器内建的对话框先来个最常见的例子：alert()警告对话框： (alert on Chrome) 我想不管是不是刚接触JavaScript的朋友，对alert应该都不陌生，alert的完整语法其实是这样： 1window.alert("message"); 如同我们所熟知的全局变量一样，window对象下的成员，window是可以省略不打的。 一行代码就可以生成一个对话框，很神奇吧？ 而这就是浏览器环境的BOM提供给JavaScript控制的功能之一。 类似的对话框还有用来提供确定/取消的window.confirm()，以及开放式问答的window.prompt()对话框。 当然BOM 提供的API 很多，包含开启/关闭视窗，改变视窗大小，计时器与取得网址等等。这些在之后的文章当中还会再细说。 DOM 是什么?DOM(Document Object Model，文件对象模型)，是一个将HTML文件以树状的结构来表示的模型，而组合起来的树状图，我们称之为DOM Tree。 简单来说，我们把HTML每个节点的关系连接起来倒着看，就好像是一棵树一样。假设我们有一个基本的HTML如下： 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;米淇淋的个人博客&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是主题&lt;/h1&gt; &lt;p&gt;这是一个&lt;i&gt;简单&lt;/i&gt;的段落&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 在最根部的地方，就是document，就是BOM图中window下面的那个。 往下可以延伸出一个个的HTML 标签，一个节点就是一个标签，往下又可以再延伸出文本节点与属性的节点。 而DOM API 就是定义了让JavaScript 可以存取、改变HTML 结构、样式和内容的方法，甚至是对节点绑定的事件。 JavaScript 就是通过DOM 提供的API 来对HTML 做存取与操作。 DOM 与 BOM 的区别前面介绍BOM时，我们已经知道DOM的document其实也就是window对象的子对象之一。 而 DOM 与 BOM 最大的区别在于： BOM: JavaScript 与浏览器沟通的窗口，不涉及网页内容。 DOM: JavaScript 用来控制网页的节点与内容的标准。 BOM完全依赖于浏览器厂商实作本身无标准规范，而DOM有着W3C 所制定的标准来规范。 想要通过DOM API 取得节点，JavaScript 可以这样写： 123456789101112// 根据传入的值，找到 DOM 中 id 为 'xxx' 的元素。document.getElementById('xxx');// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)document.getElementsByTagName('xxx');// 针对给定的 class 名称，返回所有符合条件的 NodeList 对象。document.getElementsByClassName('xxx');// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的 NodeList。document.querySelector('xxx'); document.querySelectorAll('xxx'); 而透过DOM API选取出来的节点，我们可以通过操作textContent属性来变更它的文字。 假设有一个HTML 节点： 1&lt;h1 id="greet"&gt;&lt;/h1&gt; 再来我们就可以先通过document.querySelector()方法来取得节点，然后修改textContent属性： 123&lt;script&gt; document.querySelector('#greet').textContent = 'Hello World!'&lt;/script&gt; JS Bin on jsbin.com 看到这里，恭喜你已经可以通过JavaScript 在网页上输出”Hello World!” 啦！ 在后续的内容中，我们会继续来介绍各种操作网页的DOM/BOM API。 毕竟对前端工程师来说，搞懂怎么与浏览器打交道、怎么操作网页内容，就是做好WebUI最重要的基础。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈数组常见遍历方法]]></title>
    <url>%2F2019%2F05%2F14%2F%E6%B5%85%E8%B0%88%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文主要介绍数组常见的遍历方法：forEach、map、filter、find、every、some、reduce，它们都有个共同点：不会改变原始数组。 接下来都是使用底下的基础数组来实现一些方法： 累加 比大小 分别运算 查找特定值等 123456789101112131415161718let people = [ &#123; name: '马云', money: 2000 &#125;, &#123; name: '马化腾', money: 1800 &#125;, &#123; name: '李彦宏', money: 1500 &#125;, &#123; name: '我', money: Infinity &#125;]; forEach：遍历数组forEach与另外几种方法有些许不同，就是除了forEach以外的几个方法都会返回值，如果在等号的左方放一个变量，那么此变量返回值将会是undefined(没有返回任何值)。 1234var forEachLoop = people.forEach( function ( item, index, array ) &#123; console .log(item, index, array); //（对象,索引,全部数组）&#125;);console .log(forEachLoop); // undefined 其它的方法都会返回一个值或数组，以此来说就会传回原本的数组值。 1234var mapLoop = people.map( function ( item, index, array ) &#123; return item&#125;);console .log(mapLoop); //与原本数组资料相同 map：一一映射另一个数组map会return返回的对象、值，作用上是用来处理数组返回新值产生一个新数组，要特别注意返回的值数量与原始数组长度相同，所以如果不给return，默认返回undefined。 1234567891011121314151617181920212223// 没有给return 也会产生undefinedvar mapEmpty = people.map( function ( item, index, array ) &#123;&#125;);console .log(mapEmpty); // [undefined, undefined, undefined, undefined]var everyoneAdd = people.map( function ( item, index, array ) &#123; item.money = item.money + 500 ; //每个money + 500 return item; //返回对象&#125;);console .log(everyoneAdd); // 返回每个处理后的数值，不过记得这是传参考特性，会影响到原始的对象// &#123;name: "马云", money: 2500&#125;// &#123;name: "马化腾", money: 2300&#125;// &#123;name: "李彦宏", money: 2000&#125;// &#123;name: "我", money: Infinity&#125;var mapMoneyThan1500 = people.map( function ( item, index, array ) &#123; // 错误示范，长度不符合时 if (item.money &gt; 1500 ) &#123; return item; //取得大于1500 &#125;&#125;);console .log(mapMoneyThan1500);// [&#123;name: "马云", money: 2000&#125;, &#123;name: "马化腾", money: 1800&#125;, undefined, &#123;name: "我", money: Infinity&#125; ] filter：过滤掉数组中符合条件的元素filter() 检测数值元素，并返回符合条件所有元素的数组。 filter() 不会改变原始数组。 123456789// filtervar filterEmpty = people.filter(function(item, index, array)&#123;&#125;);console.log(filterEmpty); // 没有给条件，会是一个空数组var filterMoneyThan1500 = people.filter(function(item, index, array)&#123; return item.money &gt; 1500; // 取得大于1500&#125;);console.log(filterMoneyThan1500); // 马云，马化腾，我 这三个对象 find：返回符合条件的数组的第一个元素的值find是用来查找数组中符合条件的对象，且仅能有一个，当返回的true数量超过两个以上时，那会以第一个为优先，通常会用来查找特定 id。如果没有符合条件的对象，则返回undefined。 12345678910111213var findEmpty = people.find(function(item, index, array)&#123;&#125;);console.log(findEmpty); // 没有条件，会是 undefinedvar findMoneyThan1500 = people.find(function(item, index, array)&#123; return item.money &gt; 1500; // 取得大于1500&#125;);console.log(findMoneyThan1500); // 虽然满足条件的有3个，但只会返回 '马云' 这一个对象var findMe = people.find(function(item, index, array)&#123; return item.name === '我'; // 找到我&#125;);console.log(findMe); // 我 这一对象 every：验证数组中是否每个元素都满足指定的条件验证全部的结果，当全部的值都为 true 时，则最终会得到 true；只要其中之一为 false，则返回 false。 123456789var ans = people.every(function(item, index, array)&#123; return item.money &gt; 1800;&#125;);console.log(ans); // false: 只要有部分不符合，则为 falsevar ans2 = people.every(function(item, index, array)&#123; return item.money &gt; 500;&#125;);console.log(ans2); // true: 大家钱都超过 500 some：验证数组中是否有元素满足指定的条件与前者类似，但只要部分为 true，则返回 true；全部为 false 时返回值才会为 false。 123456789var ans = people.some(function(item, index, array)&#123; return item.money &gt; 1800;&#125;);console.log(ans); // true: 只要有部分符合，则为 truevar ans2 = people.some(function(item, index, array)&#123; return item.money &lt; 500;&#125;);console.log(ans2); // false: 大家钱都不少于 500 reduce：将数组合成一个值reduce是其中最为特殊的，首先他返回的参数与之前的不同，它会接收到前一个返回的值供下一个对象使用，很适合用在累加与对比上，返回的可以是数字也可以是数组。 accumulator: 前一个参数，如果是第一个数组的话，值是以另外传入或初始化的值 currentValue: 当前值 currentIndex: 当前索引 array: 全部数组 123var reduceEmpty = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123;&#125;);console.log(reduceEmpty); // 沒有条件，会是 undefined 可以通过与前一个相加的方式，累加数组中所有的值。 1234567people.pop(); // 我的钱深不可测，先移除掉var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; // 分別是前一个返回值, 当前值, 当前索引值 console.log(accumulator, currentValue, currentIndex); return accumulator + currentValue.money; // 与前一个值相加&#125;, 0); // 传入初始化值为 0console.log(reducePlus); // 总和为 5300 也可以相互对比，取出最高的值。 12345var reduceBestOne = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; console.log('reduce', accumulator, currentValue, currentIndex) return Math.max(accumulator, currentValue.money); // 与前一个值比较哪个更大&#125;, 0);console.log(reduceBestOne); // 最大值为 2000 reduce功能很强大，其余几种遍历方法可以用reduce方法来代替，这里只列出map被reduce代替的例子。 123456789101112//map方法var mapMoneyDouble = people.map( function ( item, index, array ) &#123; return item.money*2; //钱翻倍&#125;);console .log(mapMoneyDouble); // 4000, 3600, 3000, Infinity//reduce方法实现同样的功能var reduceMoneyDouble = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; //钱翻倍 accumulator.push(currentValue.money*2); //钱翻倍 return accumulator&#125;,[]);console .log(reduceMoneyDouble); // 4000, 3600, 3000, Infinity 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】谈谈“typeof null为object”这一bug的由来]]></title>
    <url>%2F2019%2F05%2F11%2F%E3%80%90%E8%AF%91%E3%80%91%E8%B0%88%E8%B0%88%E2%80%9Ctypeof%20null%E4%B8%BAobject%E2%80%9D%E8%BF%99%E4%B8%80bug%E7%9A%84%E7%94%B1%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[很多前端初级开发者也许并不深究typeof null为何为Object？想更深地了解这一bug的由来，可以参阅Dr. Axel Rauschmayer关于”typeof null”的历史这篇文章。 原文链接：http://www.2ality.com/2013/10/typeof-null.html 我看了下C语言关于typeof的规范，它对于typeof null为何结果是’object’有更好的解释。 在JavaScript中，typeof null的结果是’Object‘，它错误地暗示null是一个对象，实际上它是一个原始值。我在上一篇文章也提到了这是JS的一大bug，不幸的是这并不能解决，因为这将破坏现有规范，接下来解释下这个bug的历史。 “typeof null”的错误从JavaScripts第一个版本开始就已经存在了。在这个版本，值以32位为单位存储，由小型标签（1-3位）和值的实际数据组成。类型标签存储在单元的低位中。 其中有五种： 000: object. 数据是对象的引用。 1: int. 数据是31位有符号整数。 010: double. 数据是对双浮点数的引用。 100: string. 数据是对字符串的引用。 110: boolean. 数据是布尔值。 也就是说，最低位是1，然后类型标签只有1位长，即int型。 或者最低位为0，那么类型标签的长度为3位，为其余4种类型提供了两个附加位。 但有2个值是特殊的： undefined（JSVAL_VOID）是整数−2^30（整数范围之外的数字）。 null(JSVAL_NULL) 为机器码NULL的空指针，或者说：为0的object类型标签。 现在应该明白为什么typeof认为null是一个对象：它检测一个他的类型标签并且返回”object”。 以下是typeof的引擎代码： 1234567891011121314151617181920212223242526272829303132JS_PUBLIC_API(JSType) JS_TypeOfValue(JSContext *cx, jsval v) &#123; JSType type = JSTYPE_VOID; JSObject *obj; JSObjectOps *ops; JSClass *clasp; CHECK_REQUEST(cx); if (JSVAL_IS_VOID(v)) &#123; // (1) type = JSTYPE_VOID; &#125; else if (JSVAL_IS_OBJECT(v)) &#123; // (2) obj = JSVAL_TO_OBJECT(v); if (obj &amp;&amp; (ops = obj-&gt;map-&gt;ops, ops == &amp;js_ObjectOps ? (clasp = OBJ_GET_CLASS(cx, obj), clasp-&gt;call || clasp == &amp;js_FunctionClass) // (3,4) : ops-&gt;call != 0)) &#123; // (3) type = JSTYPE_FUNCTION; &#125; else &#123; type = JSTYPE_OBJECT; &#125; &#125; else if (JSVAL_IS_NUMBER(v)) &#123; type = JSTYPE_NUMBER; &#125; else if (JSVAL_IS_STRING(v)) &#123; type = JSTYPE_STRING; &#125; else if (JSVAL_IS_BOOLEAN(v)) &#123; type = JSTYPE_BOOLEAN; &#125; return type; &#125; 上述代码执行的步骤如下： （1）引擎首先检测值是否是undefined(VOID)，它通过==做了这样的比较： 1#define JSVAL_IS_VOID(v) ((v) == JSVAL_VOID) 下一个（2）是检测该值是否具有object type。如果它可使用call被调用（3）或其存在内部属性[[Class]]标记为函数（4），则v是函数。 否则，它是一个对象。 这是由typeof null生成的结果。 后续检查是针对number，string和boolean，甚至没有明确检查null。这可以由以下C语言宏执行。 1#define JSVAL_IS_NULL(v) ((v) == JSVAL_NULL)` 这看似是一个非常明显的bug，但不要忘记，第一个版本的JavaScript完成只用了极少的时间，具体可以看看JavaScript的诞生。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中一切都是对象吗？看这一篇就知道了]]></title>
    <url>%2F2019%2F05%2F09%2FJS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86%2F</url>
    <content type="text"><![CDATA[当你刚开始学习JavaScript时，你是否有遇到许多书籍，教程以及那些说“JavaScript中的所有内容都是对象”的人？这算是一个JavaScript中老生常谈的话题了，虽然它并不是100％正确（JavaScript中不是所有都是对象），但其实这种说法又有那么一点说得过去，这可能有点自相矛盾。 想必有点疑惑吧，那么造成这种现象的原因是什么呢？接下来就由我一一道来。 历史原因说起一切都是对象这种说法的由来，就要好好提一下历史因素了。 1995年，JavaScript诞生之年，Netscape公司（JavaScript的设计者）与Sun公司（Java语言的发明者和所有者）合作开发一种可以嵌入网页的脚本语言，将JavaScript的数据结构借鉴Java而设计，包括将值分成原始值和对象两大类。 Java中一切皆对象，但基本类型却不是对象，为了解决这个问题，Java让每个基本类型都对应了一个包装器类型。包装器类型将基本类型包装起来，添加了属性和方法，包装器类型即为对象，所以可以这么说Java中的一切都可以充当对象，不会说的那么绝对。 因此借鉴了Java数据结构的JavaScript也同样在基本类型中各对应了一个包装器类型，JavaScript中的一切都可以充当对象，接下来将详细进行介绍。 原始类型与对象JavaScript中值可以分为两大类：原始类型和对象。 定义 在JavaScript中，有六种原始数据类型： Boolean - true 或 false null - 用 type of 检验 null 数据类型时为 Object ，但它不是对象，这是JS的一个bug undefined number - JavaScript中的所有数字都是浮点数，没有整数 string symbol (ES6) 除去上面的原始数据类型，所有其他值都是对象。对象可以进一步分为： 原始值的包装类型：Boolean,Number,String. - 很少直接使用。 以下类型生成的对象也可以通过构造函数创建： [] 类同于 new Array() {} 类同于 new Object() function() {} 类同于 new Function() /\s/ 类同于 new RegExp(“\s“) Dates: new Date(“2011-12-24”) 不同点 第一个不同点： 原始类型没有附加方法; 所以你永远不会看到undefined.toString（）。 也正因为如此，原始类型是不可变的，因为它们没有附加的方法可以改变它： 123var s = "boy";s.bar = "girl";console.log(s.bar); // undefined 而默认情况下，对象是可变的，可以添加方法： 123var obj = &#123;&#125;;obj.foo = 123; console.log(obj.foo); // 123 第二个不同点： 此外，与作为引用存储的对象不同，原始类型作为值本身存储。 这在执行相等性检查时会产生影响： 123456"dog" === "dog"; // true14 === 14; // true&#123;&#125; === &#123;&#125;; // false[] === []; // false(function () &#123;&#125;) === (function () &#123;&#125;); // false 原始类型按值存储，对象通过引用存储，存储地址也不同，原始类型直接存放在栈中，而对象是存放在堆里的，具体可以看之前写的关于内存空间这篇文章。 原始值及其包装器三个基本类型string，number和boolean，它们有时被当做包装器类型，并且在原始值和包装类型之间进行转换很简单： 原始类型 to 包装类型: new String(&quot;abc&quot;) 包装类型 to 原始类型: new String(&quot;abc&quot;).valueOf() 比如字符串“abc”之类的原始值与new String（“abc”）之类的包装器实例有根本上的不同。 例如（用typeof和instanceof判断时）： 1234567typeof "pet"; //"string"typeof new String("pet"); //"object" "pet" instanceof String; // falsenew String("pet") instanceof String; // true "pet" === new String("pet"); // false 其实包装器实例就是一个对象，没办法在JavaScript中比较对象，甚至不能通过非严格相等 ==： 1234var a = new String("pet");var b = new String("pet");a == b; // falsea == a; // true 因此JavaScript中的一切都可以充当对象，而JavaScript中的一切都是对象这种说法是欠妥的。 临时包装（Auto-Boxing）有趣的是，原始字符串和对象的构造函数都是String函数。 更有趣的是你可以在原始字符串上调用.constructor这个方法，可是之前说过原始类型不能有方法，咋回事呢？先看下面的代码： 123var pet = new String("dog")pet.constructor === String; // trueString("dog").constructor === String; // true 上面代码所发生的事情是一个叫做Auto-Boxing的过程，我觉得翻译成中文是“临时包装”比较适宜。 当您尝试在某些基本类型上调用属性或方法时，JavaScript首先将其转换为临时包装器对象，并访问其上的属性/方法，而不会影响原始属性。 123var pet = "dog";console.log(pet.length); // 3pet === "dog"; // true 在上面的示例中，要访问属性length，JavaScript发生临时包装过程将pet转换为包装器对象，访问完包装器对象的length属性，然后将其丢弃。 这样做不会影响pet（pet仍然是一个原始字符串）。 这也解释了为什么JavaScript在尝试将属性分配给基本类型时不会出问题，因为赋值是在该临时包装器对象上完成的，而不是基本类型本身，比如： 123var foo = 42;foo.bar = "lzm"; // 是在临时包装器对象上完成的赋值foo.bar; // undefined 但原始类型undefined和null，都是没有包装器对象的，当你尝试赋予属性时，它会报错。 12var foo = null;foo.bar = "lzm"; // Uncaught TypeError: Cannot set property 'bar' of null 小结1.并非JavaScript中的所有内容都是对象，应该说所有内容都可以充当对象。 2.JavaScript中有6种原始类型。 3.所有不是原始类型的值都是一个对象。 4.字符串，布尔值和数字可以表示为基本类型，但作为包装器类型时也可以表示为对象。 5.由于名为autoboxing的JavaScript特性，某些原始类型（字符串，数字，布尔值）似乎表现得有点像对象。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript中创建对象(Object)]]></title>
    <url>%2F2019%2F05%2F07%2F%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%BB%BA%E7%AB%8B(Object)%2F</url>
    <content type="text"><![CDATA[在这篇文章中我将会着重说明如何创建和调用JavaScript里的对象（Object）。 对象（Object）是什么？在开始介绍如何创建对象前，我们要知道对象是什么。对象（Object）简单地来说，就是一堆「名称- 值」的配对（key - value pairs）。至于可以放入哪些值呢？ 第一种是原生的值（primitive），像是布尔值（Boolean）、数值（Number）或是字符串（String），而在对象当中，我们把这类的值称为属性（Property）。 第二种可以放入的值是对象（Object），也就是在一个对象里面再嵌入一个对象，这种以对象为值的情况我们也把它称作属性（Property）。 第三种放入的值可以是函数（function），在对象的情况下，我们会把这种函数称做方法（method）。在对象中的每一个Property或是Method都会占据电脑当中一个记忆体的位置，在需要使用到的时候，把它们调取出来。 接下来我将介绍三种创建JavaScript里的对象及如何调用的方法： 方法一：使用 [ ]创建对象 创建对象的第一个方法是使用[ ]，[ ]在JavaScript中被称做Computed Member Access： 让我们看一下底下的例子： 1234// 创建对象var person = new Object();person["firstname"] = "Jay";person["lastname"] = "Chou"; 这是利用[ ]创建对象的方法，首先我们创建一个对象，叫做person，接着开始给它「名称-值」配对，例如，firstname是属性的名称，Jay则是它的值；lastname也是属性名称，Chou则是它的值。通过这种方法，我们就可以创建对象里面的各种「名称-值」配对。 调用对象 紧接上面的例子，我们也同样可以利用[ ]来调用已经建立好的对象，[ ]里面如果放的是字符串而不是变量，注意要记得加上引号’像是这样： 12// 调用对象console.log(person["firstname"]); // Jay 另外，如果是通过[ ]来调用对象的话，还有一个特别的地方，就是[ ]内可以放变量，像是这样（当[ ]里面放的是变量时不用加引号&quot;），一样可以调用到对象的值，这个是用种方法二（.）做不到的： 123// 调用对象var id = "lastname";console.log(person[id]); // Chou 方法二：使用点符号 .创建对象 第二种创建对象的方法是使用英文的句点 .，在JavaScript中被称做Member Access，创建的方法如下：我们在刚刚创建的person这个对象里面，再创建一个对象属性，名称为address。其实，我觉得可以把.翻译成中文的「的」，所以这里的意思就是，在person的里面创建一个名称为address的对象；在person的address的country，创建一个值为&quot;China&quot;，以此类推…。 12345// 创建对象person.address = new Object();person.address.country = "China";person.address.city = "Hangzhou";person.address.location = "Xihu"; 调用对象 同样的方法也可以用来调用出该对象的值： 1234// 调用对象console.log(person.address); //&#123;country: "China", city: "Hangzhou", location: "Xihu"&#125;console.log(person.address.country); // Chinaconsole.log(person["address"]["location"]); // Xihu 从上面可以看出，. 和[ ]是可以交替使用的。 方法三：使用{ }创建对象 其实还有在创建对象上有更快的做法，我们可以直接使用{ }，我们可以把上面的代码，改成这样： 12345678910// 创建对象var person = &#123; firstname: "Jay", lastname: "Chou", address: &#123; country: "China", city: "Hangzhou", location: "Xihu" &#125;&#125; 通过这种方式，可以得到与方法二一模一样的结果，调用方法也一致。 搭配函数使用对象 在我们创建好对象后，我们可以搭配函数(function)来使用对象，例如，我先把刚刚创建的对象person，改成叫做jaychou。 123456789var jaychou = &#123; firstname: "Jay", lastname: "Chou", address: &#123; country: "China", city: "Hangzhou", location: "Xihu" &#125;&#125; 接着创建一个名称为SayHI的函数，并且带入我们的对象： 12345function SayHI(people) &#123; console.log("HI" + people.lastname);&#125;SayHI(jaychou); // HI Chou 直接在函数参数的地方创建对象 我们也可以直接在调用函数的同时创建对象，像是这样子： 1SayHI(&#123;firstname: "Jony", lastname: "J"&#125;); // HI J 一开始看到这样的写法可能会觉得很奇怪，但其实这种方式和我们直接在函数的参数里面输入字符串或数值是一样的意思，只是这里是创建一个对象。我们把这种直接在函数的参数中创建对象的方法称做”creating object on the fly”（即动态创建对象）。 其他说明其实使用new Object不是创建对象最好的方式，这点会在之后的文章再作说明。另外，虽然使用[ ]和.都可以拿来创建对象和调用对象，但还是建议尽量使用点符号.作为创建对象和调用对象的方法，这样比较干净简洁，在debug的时候也比较容易。 还有不论你使用的是new Object、”.“、或者直接用”{ }“来创建对象，其实在JavaScript转译之后，本质上做的都是同样的事。它都会将这个对象建立在内存中，并创建该对象的属性（property）和方法（method）在内存中。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】分享7个好用的JavaScript技巧]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%88%86%E4%BA%AB7%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[就像所有其他编程语言一样，JavaScript也有许多技巧可以完成简单和困难的任务。 一些技巧广为人知，而其他技巧则足以让你大吃一惊。 让我们来看看你今天就可以开始使用的七个JavaScript技巧吧！ 原文链接：https://davidwalsh.name/javascript-tricks#comments 数组去重数组去重可能比您想象的更容易： 12var j = [...new Set([1, 2, 3, 4, 4])]&gt;&gt; [1, 2, 3, 4] 很简单有木有！ 过滤掉falsy值是否需要从数组中过滤出falsy值（0，undefined，null，false等）？ 你可能不知道还有这个技巧： 12let res = [1,2,3,4,0,undefined,null,false,''].filter(Boolean);&gt;&gt; 1,2,3,4 创建空对象您可以使用{ }创建一个看似空的对象，但该对象仍然具有__proto__和通常的hasOwnProperty以及其他对象方法。 但是，有一种方法可以创建一个纯粹的“字典”对象： 1234let dict = Object.create(null);// dict.__proto__ === "undefined"// No object properties exist until you add them 这种方式创建的对象就很纯粹，没有任何属性和对象，非常干净。 合并对象在JavaScript中合并多个对象的需求已经存在，尤其是当我们开始使用选项创建类和小部件时： 12345678910111213141516const person = &#123; name: 'David Walsh', gender: 'Male' &#125;;const tools = &#123; computer: 'Mac', editor: 'Atom' &#125;;const attributes = &#123; handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' &#125;;const summary = &#123;...person, ...tools, ...attributes&#125;;/*Object &#123; "computer": "Mac", "editor": "Atom", "eyes": "Blue", "gender": "Male", "hair": "Brown", "handsomeness": "Extreme", "name": "David Walsh",&#125;*/ 这三个点(...)使任务变得更加容易！ Require函数参数能够为函数参数设置默认值是JavaScript的一个很棒的补充，但是请查看这个技巧，要求为给定的参数传递值： 12345678910111213const isRequired = () =&gt; &#123; throw new Error('param is required'); &#125;;const hello = (name = isRequired()) =&gt; &#123; console.log(`hello $&#123;name&#125;`) &#125;;// This will throw an error because no name is providedhello();// This will also throw an errorhello(undefined);// These are good!hello(null);hello('David'); 解构添加别名解构是JavaScript的一个非常受欢迎的补充，但有时我们更喜欢用其他名称来引用这些属性，所以我们可以利用别名： 1234567const obj = &#123; x: 1 &#125;;// Grabs obj.x as &#123; x &#125;const &#123; x &#125; = obj;// Grabs obj.x as &#123; otherName &#125;const &#123; x: otherName &#125; = obj; 有助于避免与现有变量的命名冲突！ 获取查询字符串参数获取url里面的参数值或者追加查询字符串，在这之前，我们一般通过正则表达式来获取查询字符串值，然而现在有一个新的api，具体详情可以查看这里，可以让我们以很简单的方式去处理url。 比如现在我们有这样一个url，”?post=1234&amp;action=edit”，我们可以利用下面的技巧来处理这个url。 123456789// Assuming "?post=1234&amp;action=edit"var urlParams = new URLSearchParams(window.location.search);console.log(urlParams.has('post')); // trueconsole.log(urlParams.get('action')); // "edit"console.log(urlParams.getAll('action')); // ["edit"]console.log(urlParams.toString()); // "?post=1234&amp;action=edit"console.log(urlParams.append('active', '1')); // "?post=1234&amp;action=edit&amp;active=1" 比我们过去用的容易多了！ 多年来JavaScript已经发生了很大的变化，但是我最喜欢的JavaScript部分是我们所看到的语言改进的速度。 尽管JavaScript的动态不断变化，我们仍然需要采用一些不错的技巧; 将这些技巧保存在工具箱中，以便在需要时使用！ 那你最喜欢的JavaScript技巧是什么？ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>编程技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中任何值的prototype到最后都是Object]]></title>
    <url>%2F2019%2F04%2F27%2FJavaScript%E4%B8%AD%E4%BB%BB%E4%BD%95%E5%80%BC%E7%9A%84prototype%E5%88%B0%E6%9C%80%E5%90%8E%E9%83%BD%E6%98%AFObject%2F</url>
    <content type="text"><![CDATA[这篇笔记延伸上一篇所提到的原型（prototype）的概念，说明了在JavaScript当中，所有的类型（字符串、数值、Boolean值、函数、数组、对象）的prototype的最后都是object！ 什么意思呢？ 假设我们现在分别建立对象、函数和数组，直接上代码： 123456789101112131415161718192021// Object var a = &#123; name : 'miqilin' &#125;// function var b = function ( ) &#123; console . log ( 'Hello' ) ; &#125;// Array var c = [ 'A' , 'r' , 'r' , 'a' , 'y'] ;// string var d = 'This is string' ;// number var e = 2 ;// boolean var f = true ; 接着，我们会在Google Chrome 的console 视窗来分别检验这些类型的prototype。 对象（object）我们可以看到a这个对象本身的prototype也是一个对象，在下去就没了（null），也就是Object → Object → null的过程。 而a.__proto__就是对象的原型，打开来看会发现里面有许多内置的方法。 如果我在console中输入a.，则会出现对于对象而言内置的方法： 由于a.__proto__仍然是一个对象，所以如果我输入a.__proto__.的话，会得到除了name一样对于对象可以使用的方法： 函数（function）接着我们来看看函数，根据上面同样的方法得出是function → function → object → null的过程，所以最后还是结束在object。 如果我们想要看函数有哪些内置的方法可以用，我们可以输入b.或b.__proto__.就可以看到了，这里我们就可以看到我们常用的apply , bind ,和call。 数组（Array）对于数组的话则是array → array → object → null的过程。 如果我们要看数组有哪些方法可以用，一样可以透过c.或c.__proto__.来检视： 同样的方法也可以用来检视字符串、数字和Boolean值，有兴趣的通过chrome 来试试看吧！ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之原型与原型链]]></title>
    <url>%2F2019%2F04%2F25%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[JavaScript 也是一门面向对象的语言，ES6之前并没有引入类（class）的概念，像c++ 这种典型的面向对象语言都是通过类来创建实例对象，而JavaScript是直接通过构造函数来创建实例。 所以理解两种继承模式的差异是需要一定时间的，今天我们就来了解一下原型和原型链，在介绍原型和原型链之前，我们有必要先了解一下构造函数的知识。 构造函数构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。 构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。我们先使用构造函数创建一个对象： 123456function Dog() &#123; this.name = '阿黄'&#125;var dog = new Dog()console.log(dog.name) // 阿黄 上面例子中，Dog 就是一个构造函数，我们使用 new 创建了一个实例对象 dog。 原型prototype JavaScript是一种基于原型的语言(prototype-based language)，每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的prototype属性上，而非对象实例本身。看以下代码： 12345function Dog() &#123; this.name = '阿黄'&#125;console.log(Dog.prototype) 那这个构造函数的 prototype 属性指向的是什么呢？是这个函数的原型吗？ 打开 chrome 浏览器的开发者工具，在 console 栏输入上面的代码，你可以看到 Dog.prototype 的值： 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图来表示构造函数和实例原型之间的关系： 那么我们该怎么表示实例与实例原型，也就是 dog 和 Dog.prototype 之间的关系呢，接下来就应该讲到第二个属性： proto 上面可以看到 Dog 原型（Dog.prototype）上有__proto__属性，这是一个访问器属性（即 getter 函数和 setter 函数），通过它可以访问到对象的内部[[Prototype]](一个对象或null)。 为了证明这一点,我们可以在chrome中输入： 12345678function Dog() &#123; this.name = '阿黄'&#125;var dog = new Dog()console.log(Object.getPrototypeOf(dog) === dog.__proto__) // trueconsole.log(dog.__proto__ === Dog.prototype) // true 这里用dog.__proto__获取对象的原型，__proto__是每个实例上都有的属性，prototype是构造函数的属性，这两个并不一样，但dog.__proto__和Dog.prototype指向同一个对象。于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor 指向实例对象倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们在chrome中输入： 12345function Dog() &#123; this.name = '阿黄'&#125;console.log(Dog.prototype.constructor === Dog) // true 所以再更新下关系图： 综上我们已经得出： 12345678910function Dog() &#123; this.name = '阿黄'&#125;var dog = new Dog()console.log(dog.__proto__ == Dog.prototype) // trueconsole.log(Dog.prototype.constructor == Dog) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(dog) === Dog.prototype) // true 原型链在上文我们理解了原型，从字面意思看原型链肯定是与原型有关了，是一个个原型链接起来的么？我们先通过下面的图来观察一下。 解析： obj.prop1：假设我们现在有一个对象，就称作obj，而这个对象包含一个属性（property），我们称作prop1，现在我们可以使用obj.prop1来读取这个属性的值，就可以直接读取到prop1的属性值了。 obj.prop2：JavaScript中会有一些预设的属性和方法，所有的对象和函数都包含prototype这个属性，假设我们把prototype叫做proto，这时候如果我们使用obj.prop2的时候，JavaScript引擎会先在obj这个对象的属性里去寻找有没有叫作prop2的属性，如果它找不到，这时候它就会再进一步往该对象的proto里面去寻找。所以，虽然我们输入obj.prop2的时候会得到回传值，但实际上这不是obj里面直接的属性名称，而是在obj的proto里面找到的属性名称（即，obj.proto.prop2，但我们不需要这样打）。 obj.prop3：同样地，每一个对象里面都包含一个prototype，包括对象proto本身也不例外，所以，如果输入obj.prop3时，JavaScript会先在obj这个对象里去寻找有没有prop3这个属性名称，找不到时会再往obj的proto去寻找，如果还是找不到时，就再往proto这个对象里面的proto找下去，最后找到后回传属性值给我们（obj.proto.proto.prop3）。 虽然乍看之下，prop3很像是在对象obj里面的属性，但实际上它是在obj → prop → prop的对象里面，而这样从对象本身往proto寻找下去的链我们就称作「原型链（prototype chain）」。这样一直往下找会找到什么时候呢？它会直到某个对象的原型为null为止（也就是不再有原型指向）。 官方解释是：每个对象拥有一个原型对象，通过__proto__指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。 举个例子来帮助理解原型链让我们实际来看个例子帮助我们了解prototype chain这个概念，这个例子只是单纯为了用来说明prototype chain的概念，实际上千万不要使用这样的方式编程！ 首先，我们先建立一个对象person 和一个对象jay： 123456789101112var person = &#123; firstName : 'Default' , lastName : 'Default' , getFullName : function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125; , &#125; ;var jay = &#123; firstName : 'Jay' , lastName : 'Chou' , &#125; ; 接着，我们知道所有的对象里面都会包含原型（prototype）这个对象，在JavaScript中这个对象的名称为proto。如同上述原型链（prototype chain）的概念，如果在原本的对象中找不到指定的属性名称或方法时，就会进一步到__proto__这里面来找。 为了示范，我们来对__proto__做一些事： 12//千万不要照着下面这样做，这么做只是为了示范 jay . __proto__ = person ; 如此，jay这个对象就继承了person对象。在这种情况下，如果我们想要呼叫某个属性或方法，但在原本jay这个对象中找不到这个属性名称或方法时，JavaScript引擎就会到__proto__里面去找，所以当接着执行如下的代码时，并不会报错： 1console . log ( jay . getFullName ( ) ) // Jay Chou; 我们可以得到”Jay Chou”的结果。原本在jay的这个对象中，是没有getFullName()这个方法的，但由于我让__proto__里面继承了person这个对象，所以当JavaScript引擎在jay对象里面找不到getFullName()这个方法时，它便会到__proto__里面去找，最后它找到了，于是它回传”Jay Chou”的结果。 如果我是执行： 1console . log ( jay . firstName ) ; // Jay 我们会得到的是John而不是’Default’，因为JavaScript引擎在寻找jay.firstName这个属性时，在jay这个对象里就可以找到了，因此它不会在往__proto__里面找。这也就是刚刚在上面所的原型链（prototype chain）的概念，一旦它在上层的部分找到该属性或方法时，就不会在往下层的prototype去寻找。 在了解了prototype chain这样的概念后，让我们接着看下面这段代码： 123456var jane = &#123; firstName : 'Jane' &#125;jane . __proto__ = person ; console . log ( jane . getFullName ( ) ) ; 现在，你可以理解到会输出什么结果吗？ 答案是”Jane Default” 。 因为在jane这个对象里只有firstName这个属性，所以当JavaScript引擎要寻找getFullName()这个方法和lastName这个属性时，它都会去找__proto__里面，而这里面找到的就是一开始建立的person这个对象的内容。 全代码如下： 12345678910111213141516171819202122232425var person = &#123; firstName : 'Default' , lastName : 'Default' , getFullName : function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125; &#125;var jay = &#123; firstName : 'Jay' , lastName : 'Chou' &#125;//千万不要照着下面这样做，这么做只是为了示范 jay . __proto__ = person ; console . log ( jay . getFullName ( ) ) ; // Jay Chouconsole . log ( jay . firstName ) ; // Jayvar jane = &#123; firstName : 'Jane' &#125;jane . __proto__ = person ; console . log ( jane . getFullName ( ) ) ; 以上就是目前能总结的全部了，肯定还是有缺陷的地方，后续还会修改完善的。最后再看底下这张图，是否有了更深入的理解呢？ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之内存泄漏]]></title>
    <url>%2F2019%2F04%2F22%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[在程序运行过程中不再用到的内存，没有及时释放，会出现内存泄漏（memory leak），会造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 而内存泄漏是每个开发人员最终必须面对的问题。 即使使用内存管理语言，比如C语言有着malloc() 和 free() 这种低级内存管理语言也有可能出现泄露内存的情况。 这很麻烦，所以为了减轻编程中的负担，大多数语言提供了自动内存管理，这被称为”垃圾回收机制”（garbage collector）。 垃圾回收机制现在各大浏览器通常采用的垃圾回收有两种方法：标记清除（mark and sweep）、引用计数(reference counting)。 1、标记清除 这是javascript中最常用的垃圾回收方式。 工作原理：当变量进入执行环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 之后再被加上标记的变量将被视为准备删除的变量。 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 2、引用计数 工作原理：跟踪记录每个值被引用的次数。 工作流程： 将一个引用类型的值赋值给这个声明了的变量，这个引用类型值的引用次数就是1。 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1 当引用次数变成0时，就表示这个值不再用到了。 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 但如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，会导致内存泄漏。 12var arr = [1, 2, 3];console.log('hello miqilin'); 上面代码中，数组[1, 2, 3]会占用内存，赋值给了变量arr，因此引用次数为1。尽管后面的一段代码没有用到arr，它还是会持续占用内存。 如果增加一行代码，解除arr对[1, 2, 3]引用，这块内存就可以被垃圾回收机制释放了。 123var arr = [1, 2, 3];console.log('hello miqilin');arr = null; 上面代码中，arr重置为null，就解除了对[1, 2, 3]的引用，引用次数变成了0，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就无事一身轻了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 接下来，我将介绍四种常见的JavaScript 内存泄漏及如何避免。目前水平有限，借鉴了国外大牛的文章了解这几种内存泄漏，原文链接：https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec 四种常见的 JavaScript 内存泄漏1.意外的全局变量 未定义的变量会在全局对象创建一个新变量，对于在浏览器的情况下，全局对象是window。 看以下代码： 123function foo(arg) &#123; bar = "this is a hidden global variable"; &#125; 函数foo内部使用var声明，实际上JS会把bar挂载在全局对象上，意外创建一个全局变量。等同于： 123function foo(arg) &#123; window.bar = "this is an explicit global variable"; &#125; 在上述情况下， 泄漏一个简单的字符串不会造成太大的伤害，但它肯定会更糟。 另一种可以创建偶然全局变量的情况是this： 123456function foo() &#123; this.variable = "potential accidental global"; &#125; // Foo called on its own, this points to the global object (window)// rather than being undefined. foo(); 解决方法： 在 JavaScript 文件头部加上 &#39;use strict&#39;，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。 2.被遗忘的计时器或回调函数 在JavaScript中使用setInterval非常常见。 1234567var someResource = getData(); setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // Do stuff with node and someResource. node.innerHTML = JSON.stringify(someResource)); &#125; &#125;, 1000); 上面的代码表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。 12345678910111213var element = document.getElementById('button'); function onClick(event) &#123; element.innerHtml = 'text'; &#125; element.addEventListener('click', onClick); // Do stuff element.removeEventListener('click', onClick); element.parentNode.removeChild(element); // Now when element goes out of scope,// both element and onClick will be collected even in old browsers that don't// handle cycles well. 对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。其中IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用removeEventListener了。 诸如jQuery之类的框架和库在处理节点之前会删除侦听器（当使用它们的特定API时）。 这由库内部处理，并确保不会产生任何泄漏，即使在有问题的浏览器（如旧版Internet Explorer）下运行也是如此。 3.闭包 JavaScript 开发的一个关键知识是闭包：这是一个内部函数，它可以访问外部（封闭）函数的变量。由于 JavaScript 运行时的实现细节，用下边这种方式可能会造成内存泄漏： 123456789101112131415var theThing = null; var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log("hi"); &#125;; theThing = &#123; longStr: newArray(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;; &#125;; setInterval(replaceThing, 1000); 每次调用replaceThing，theThing得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量unused是一个引用originalThing的闭包（先前的replaceThing又调用了theThing）。someMethod可以通过theThing使用，someMethod与unused分享闭包作用域，尽管unused从未使用，它引用的originalThing迫使它保留在内存中（防止被回收）。需要记住的是一旦一个闭包作用域被同一个父作用域的闭包所创建，那么这个作用域是共享的。 所有这些都可能导致严重的内存泄漏。当上面的代码片段一次又一次地运行时，你可以看到内存使用量的急剧增加。当垃圾收集器运行时，也不会减少。一个链接列表闭包被创建（在这种情况下 theThing 变量是根源），每一个闭包作用域对打数组进行间接引用。 解决方法： 在 replaceThing 的最后添加 originalThing = null 。将所有联系都切断。 4.脱离 DOM 的引用 如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。如果在将来某个时候您决定删除这些行，则需要使两个引用都无法访问，都清除掉。 123456789101112131415161718192021var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text') &#125;; function doStuff() &#123; image.src = 'http://some.url/image'; button.click(); console.log(text.innerHTML); // Much more logic&#125; function removeButton() &#123; // The button is a direct child of body. document.body.removeChild(document.getElementById('button')); // At this point, we still have a reference to #button in the global // elements dictionary. In other words, the button element is still in // memory and cannot be collected by the GC. &#125; 如果代码中保存了表格某一个&lt;td&gt;的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的&lt;td&gt;以外的其它节点。实际情况并非如此：此&lt;td&gt;是表格的子节点，子元素与父元素是引用关系。由于代码保留了&lt;td&gt;的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。 避免内存泄漏在局部作用域中，等函数执行完毕，变量就没有存在的必要了，js垃圾回收机制很快做出判断并且回收，但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。 我们在使用闭包的时候，就会造成严重的内存泄漏，因为闭包的原因，局部变量会一直保存在内存中，所以在使用闭包的时候，要多加小心。 Resources http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156 http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html 如果有别的关于内存泄漏好的资源，可以分享给我嘛谢谢了~ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之内存空间]]></title>
    <url>%2F2019%2F04%2F22%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[对于很多没经验的前端开发来说，觉得JS反正有垃圾回收机制，很容易忽视内存空间的管理，这其实是一个大错误。 直到最近，看了阮一峰老师关于JS内存泄漏的文章，才发现自己以前写的代码，存在许多内存泄漏的问题，再者，因为忽略对内存空间的学习，导致后面很多进阶概念很模糊，比如闭包、作用域链，比如深拷贝与浅拷贝的区别等等。 这里先介绍内存空间，后续还会通过别的文章来介绍深浅拷贝和内存泄漏。 内存空间管理JavaScript的内存生命周期: 1231. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 123var a = 10; // 在内存中给数值变量分配空间alert(a + 90); // 使用分配到的内存a = null; // 使用完毕之后，释放内存空间 在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stack)与堆内存(heap)。 栈与堆栈(stack)是有序的，主要存放一些基本类型的变量和对象的地址，每个区块按照一定次序存放（后进先出），它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小也是确定的，并由系统自动分配和自动释放。 因此，这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间，且寻址速度也更快。 堆(heap)是没有特别的顺序的，数据可以任意存放，多用于复杂数据类型（引用类型）分配空间，例如数组对象、object对象。 其实这样说也不太准确，因为，引用类型数据的地址是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得想要访问对象的地址，然后，再通过地址指向找出堆中的所需数据。就好比书架上的书，虽然已经按顺序放好了，但我们只要知道书的名字，就可以对应的取下来。 变量的存放首先，我们来看一下代码： 12345678910//原始类型都放在栈（stack）里//引用类型都放在堆（heap）里var a = 10;var b = 'lzm';var c = true;var d = &#123; n: 22 &#125;; //地址假设为0x0012ff7f，不代表实际地址var e = &#123; n: 22 &#125;; //重新开辟一段内存空间，地址假设为0x0012ff8cconsole.log(e==d); //falsevar obj = new Object(); //地址假设为0x0012ff9dvar arr = ['a','b','c']; //地址假设为0x0012ff6e 为什么console.log(e == d)的结果为false？可以用下面的内存图解释： 变量a,b,c为基本数据类型，它们的值，直接存放在栈中，d,e,obj,arr为复合数据类型，他们的引用变量及地址存储在栈中，指向于存储在堆中的实际对象。我们是无法直接操纵堆中的数据的，也就是说我们无法直接操纵对象，我们只能通过栈中对对象的引用来操作对象，就像我们通过遥控机操作电视一样，区别在于这台电视本身并没有控制按钮。 变量d,e虽然指向存在堆内存中对象内容的值是相等的，但是它们来自栈内存中变量地址不相同，导致console.log(e == d)的结果为false。 这里就回到了最初的疑问，为什么原始类型值要放在栈中，而引用类型值要放在堆中，为什么要分开放置呢？单列一种内存岂不是更省事吗？那接下来，援引这篇文章里边的解释： 记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题。堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。 比较抠细节的面试题下面的几道是关于内存空间的面试题，虽然不是特别的难，但比较扣细节你稍不注意就错了，我的建议还是老老实实画个内存图再自信的给出正确答案吧。 第一题： 1234var a = 1 var b = a b = 2 请问 a 显示是几？ 上图中可以看出，答案为：1。在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于1，但是他们其实已经是相互独立互不影响的值了。 第二题： 1234var a = &#123;name: 'a'&#125;var b = ab = &#123;name: 'b'&#125;请问现在 a.name 是多少？ 上图中可以看出，答案为：”a”。因为b ={name:&#39;b&#39;}后相当于重新在堆内存中分配内存给对象{name:&#39;b&#39;}，同时栈内存中变量b的指向地址也随之变化，变量a不受影响。 第三题： 1234var a = &#123;name: 'a'&#125; var b = a b.name = 'b' 请问现在 a.name 是多少？ 上图中可以看出，答案为：”b”。我们通过var b = a执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在堆内存中访问到的具体对象实际上是同一个，因此b.name =&#39;b&#39;使堆内存中对象的value值变化，a.name的值也随之变化。 第四题： 1234var a = &#123;name: 'a'&#125; var b = a b = null 请问现在 a 是什么？ 上图中可以看出，答案为：{name: “a”}。因为null为基本类型，存在栈内存当中。因此栈内存中的变量b由之前指向对象的一个地址转变为null，变量a的地址还是指向原先的对象。 第五题： 123456var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n: 2&#125;;a.x // 这时 a.x 的值是多少b.x // 这时 b.x 的值是多少 答案是：a.x –&gt; undefined；b.x –&gt; {n: 2}。这道题的关键在于： 优先级。.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。 赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2} 最后来个图总结一下： 以上都是通过内存图来解释关于内存空间的知识，如有不合理的地方，希望指正一下~后续还会增加内存泄漏以及深浅拷贝的文章，敬请期待！ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（三）]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三周的学习因为拖延稍微拖了那么几天，而这周的主题又刚好是拖延症与记忆的关系。想要高效地学习，就得学会如何运用和提高自己的记忆能力，而这个过程中，必须先克服拖延症。所以上完这节课，我是该好好改改拖延的老毛病了嘻嘻~ 拖延症的形成我们常在那些让人不太舒服的事情上拖延，这点大家或多或少都会有，那事实结果是，拖延是一个极其重要、影响广泛的坏习惯，生活的方方面面都会受到拖延的影响。 这里要强调一下，很多人觉得能靠自己的意志力去战胜拖延症，其实这是适得其反的。人每天的意志力是有限的，调用意志力去克服一件困难的事，会大量消耗能量。为什么拖延症这么容易就产生，是因为它变成了习惯，习惯是不需要意志力去执行的，它能减少大脑的消耗。所以改变习惯，是改变拖延症的正确方法。 习惯习惯可以分为四个阶段： 第一阶段是提示 (cue) ，是指引发你进行某种惯例的信息来源。比如朋友发来的一条微信信息，或是你看到了待办事项清单上的第一件事等等。 第二个阶段就是惯例 (routine)，是指你对提示做出的惯性反应。比如看到微信信息就觉得要立马停下手头上的事情去回信息；看到待办的事情就想着当下去解决掉它。这里一个好的建议是，你可以通过关掉手机或者断网，或者远离其他占用碎片时间的消遣来隔离那些最具杀伤力的信号，就像你在进行番茄工作法那样。 第三阶段是奖励 (reward)，是指你做完这个惯例之后得到的反馈，它会刺激你不断按照之前的惯例行事。任何一种习惯得以发展和延续都是因为它可以回报我们，它会立即给我们带来些许愉悦感。拖延是极易产生的习惯，因为你将关注点转向更令人愉悦的事情后，随之而来的奖励迅速而又简单。好习惯也是有奖励的，对于克服拖延症来说，想办法奖励好习惯非常重要，只有当大脑开始期待那个奖励，旧习惯才能得到重置，你才能养成新习惯。 研究发现需要给奖励设定时间点。比如说，午休与朋友到快餐店吃饭，或是在下午5点结束主要的任务。这样小而实在的截止期限可以激励你很好地去工作。 第四阶段是信念 (belief) 。改变拖延习惯最重要的一点就是“相信自己能够做到”的这个信念，就好比说必须要摒弃“自己不是学这块知识的料”这一习惯想法，而是要保持自己能够学好的信念并为之做出应有的努力。 应对生活和学习要保持对学习目标的展望，一个很好的办法是每周写下本周关键任务列表，试着在前一晚写下第二日的任务，为什么要在前一晚呢？ 研究表明，这可以让你在潜意识下设法解决任务，从而找到完成方法。 列下任务清单后，每天花一个或几个番茄钟的时间完成它们。如果可以短时间完成的任务，可以采用结果导向，如果不是则关注过程。你不必一定要设置25分钟的番茄钟，比如22分钟也是可行的。 其实，当你能对一定时间内自己可以完成的工作量做出较准确的判断时，你将很快进步。计划好完成目标的时间是合理且最为重要的一点，计划你的休息时间和计划工作时间也同样重要，就是在努力学习之余保持健康休闲时间的人，其表现往往胜过那些一味努力学习的人，所以从现在开始，在努力工作学习之余试着挤出点休息时间吧！ 芭芭拉老师还建议在早晨尽量先开始最重要且最讨厌，最难的工作，至少做一个番茄时间，这证明了极其有效！有时会发生一些意料之外的事，我们当然需要对计划作出改变，但是请记住幸运法则——幸运女神会眷顾努力之人。良好的计划也是努力的一部分，关注学习目标，尽量避免因为偶发事件产生的不确定性。 提高记忆力改变了拖延症的坏习惯后，我们才能更好地利用记忆去学习。我们的大脑天生就擅长记忆不同的空间信息，如果你受邀参观一所陌生的房子 ，你会很快对这个房子有一个大致的概念。例如，整体的家具布局、房间位置、颜色的搭配。只需几分钟，你的大脑就能获取并存储数以千计的信息，甚至几周后，就算你面对是一堵白墙，也仍然能记起许多细节。这一系列空间信息，帮助你在脑中形成地图。如果能够充分发挥天生就很强大的视觉和空间记忆能力，你的记忆潜能就可以得到极大提高。 评判一个人的记忆力好坏，主要看他的长期记忆的能力如何，每个人都可以通过集中注意力使某件事物进入你的临时工作记忆，但从工作记忆进入长期记忆则要满足两个条件。首先它要令人难忘，其次，信息需要复习和回顾。那如何让它难忘呢？比如记F=ma（力=质量x加速度）这个物理公式，老师把它想象成一只戴着飞行员眼镜的驴(a flying mule，英文首字母对应公式的简写)，躺在她老家厨房的水槽里，这样就完成了把抽象概念变成具体图像。这个比喻是不是很无厘头啊哈哈，所以说记忆大师们都是一些幻想家。 记忆宫殿（Mind Palace / Memory Palace）就是这么一个虚拟的，让你储存信息的技巧工具。你可以把熟悉的场景，比如你的家，作为一个放置记忆碎片的地方，然后把要记的抽象的东西，通过联想，组团，转化成具体图像，放在那个场景中的某个地方。而且这个图像不需要阐述你要记住的东西的意义，甚至它越是不合常理，越稀奇古怪，效果就越好。因为大脑通常会滤过习以为常的事物，而对令人惊讶的非典型性事件记忆犹新。 比如购物清单上要买的牛奶、面包、鸡蛋，使用这个技巧你可以想象在你的家中，有一大瓶牛奶在前门，面包掉到了沙发上，裂了的鸡蛋从咖啡桌边缘滴落。也就是说，你可以想象自己穿过一个熟悉的地方，伴随着一些与要记忆的物体相关的难忘画面，这种记忆方式往往记得很牢。 题外话，爱看港剧的朋友，相信对TVB剧《读心神探》中的记忆宫殿印象深刻。第三集中有一段对记忆方法的特写，我们一起来细究一下吧！第三集刚开始的时候讲的就是记忆人名头像。那么记忆人名第一步就是观察人物的长相特征，这个特征可以看人物穿的衣服，戴的装饰品，五官的长相特点，发型，声音的特色等等，找出特点以后第二步就是对人物的名字进行联想。比如有个人叫袁泉，而正好她戴了一对圆圆的耳环，那么就很容易联想到“圆圈”（利用名字的谐音记忆）；又比如有人叫邓超，那么你可以联想到这个和你初识时，眼睛“邓”的超大的痴痴的望着你，只要你这么一想，那么这个人物名字肯定就在你脑海里留下了深刻的印象，虽然有点点毛骨悚然哈哈。 看完上面举得例子也许会有人会问你那些名字和特征都是你事先设想好的，所以才容易发现名字与特征之间的联系，但其实这些都是临时想到的真实案例，其实我们能够观察到的特征是有限的，但是人的想象是无限的，只要你的想法足够好那肯定能找到一个人物的特征与名字之间的完美契合点，这也是记忆法的精髓。 最后，在这一周的课外采访中，受采访者是一名美国记忆比赛的冠军，他是“记忆宫殿”这个技巧的专家。他给大家的学习建议是——保持孩童般的想象力与好奇心，通过新奇的想象来帮助你记忆，让学习变得有趣和容易。大家从现在开始不妨试一试~ 下一节课我们会学习复兴式学习与潜力的关系。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Undefined vs Null]]></title>
    <url>%2F2019%2F04%2F19%2FUndefined%20vs%20Null%2F</url>
    <content type="text"><![CDATA[在JavaScript中，将一个变量赋值为undefined或null，感觉没啥区别，都表示“无”；但在实际应用中，远非如此，这两个之间区别的不明确可能会导致一些问题。 在这篇文章中，我已经简略介绍了undefined和null的特性了。 本文将探讨JavaScript中undefined和null之间的相似和差异之处。 相似性（1）undefined和null在if语句中，都会被自动转为false，加!转换为true，相等运算符对于两者比较是相等的。 12345678910if (!undefined) console.log('undefined is false');// undefined is falseif (!null) console.log('null is false');// null is falseundefined == null// true （2）在JavaScript中，只有六个falsy值，null和undefined都包含在六个falsy值中，当进行逻辑判断时所有的Falsy值均为false。 false 0 ‘’ (空字符串，’’和””一样) null undefined NaN 除了这六个值，JavaScript中的任何其他值都被认为是truthy值，当进行逻辑判断时均为true。 （3）同样在JavaScript中，有六个原始值，null和undefined都包含在这六个原始值中。 Boolean Null Undefined Number String Symbol 既然undefined和null的含义与用法都比较相似，那为什么还要无端增加另外一个值，这不是增加混淆吗？ 历史原因最近，在阅读阮一峰老师的博客文章时，才从历史因素里得到答案！ 1995年JavaScript诞生之初，像Java一样，只设置了null作为表示”无”的值。 根据C语言的传统，null被设计成可以自动转为0。 12345Number(null)// 06 + null// 6 但是，JavaScript的设计者Brendan Eich，觉得这样做达不到自己的预想，其中有两个原因。 首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。 其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计增加了一个undefined。 差异性（1）数据类型区别 undefined类型只有一个值，undefined；null类型只有一个值，null。 也就是说undefined值和null值分别属于不同的数据类型，并且这两个数据类型都只有一个值，使用“typeof”运算符判断类型。 12console.log(typeof undefined); // undefinedconsole.log(typeof null); // object 第一行输出没毛病，正确打印出undefined类型；而第二行打印结果为object，难道null不是null类型？ 原因解释：这是JS一个设计失误，原本正确的结果应该是null，现在只能将错就错，或许以后哪个新版本会修正此问题。 （2）转为数值区别 JavaScript的最初版本为了更好区分这两个值，是这样设定的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 12345var a1= 5 + null;console.log(a1) // 5var a2= 5 + undefined;console.log(a2) // NaN （3）null !== undefined 如上所见，null和undefined不同，但有一些相似之处， 因此，ECMAScript规范规定null不严格等于undefined。 123null !== undefined // truenull === undefined // false 但是，上面也提到了，null松散相等于undefined（相比===的相等程度更低）。 1null == undefined // true 在JavaScript中，==适用松散相等，意味着我们在将它们转换为通用类型后比较两个值。 只要记住null==undefined会返回true，因为它们是类似的值；但null===undefined会返回false，因为它们是不同类型的值。后续也会增加==与===区别的文章，敬请期待。 实际用法但是，上面的区分，在实践中都不常用。实际上，null和undefined被视为几乎同义的，只有一些细小的差别。 null表示一个变量被人为的设置为空对象，而不是原始状态，即该处不应该有值。一般会在以下 2 种场景中出现： （1） 利用document.getElementById(‘XXX’) 寻找一个不存在的元素，将返回null。 1console.log(null == document.getElementById('notExistElement')) // true （2） 作为对象原型链的终点。 1Object.getPrototypeOf(Object.prototype) // null undefined表示一个变量自然的、最原始的状态值，就是此处应该有一个值，但是还没有定义。一般会在以下 4 种场景中出现： （1）声明了一个变量，但没有赋值，就等于undefined。 12var aconsole.log(a) // undefined （2) 函数定义了形参，但没有传递实参，该参数等于undefined。 12345//函数定义了形参 a function f(a) &#123; console.log(a); // undefined &#125; f(); //未传递实参 （3）访问对象上不存在的属性，该属性的值为undefined。 12var a = new Object()a.p // undefined （4）函数没有返回值时，默认返回undefined。 12var a = f()a // undefined 所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。 最后引用玉伯大大对null和undefined的解释： 值类型的“虚无”用undefined，引用类型的“虚无”，用null。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之类型转换]]></title>
    <url>%2F2019%2F04%2F18%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[JavaScript 是一种弱类型或者说是一门动态语言，这意味着你不用提前声明变量的类型，而是在程序运行过程中，运算符会自动将值转换为正确的类型，但也有一些情况需要强制类型转换。 以下我将介绍将各种类型的值，分别转换成数字、字符串或者布尔值（基于ES5规范）。 ToNumber（1）Number() 使用Number函数，可以将任意类型的值转化成数值。 12345678910111213141516171819202122//数值Number(123) // 123 转换后为原值//字符串Number('123') // 123 转换为相应的数值，前提能被解析为数值 //字符串Number('123abc') // NaN 如果不能被解析为数值，则返回 NaN//布尔值Number(true) // 1Number(false) // 0//undefinedNumber(undefined) // NaN//nullNumber(null) // 0//对象Number(&#123;a: 1&#125;) // NaNNumber([5]) // 5 //包含单个数值的数组将返回数字 （2）ParseInt() parseInt函数可用于将字符串转为整数。 123456789101112parseInt('123') // 123parseInt(' 123') // 123 如果字符串头部有空格，空格会被自动去除parseInt(1.23) // 1 如果参数不是字符串，则会先转为字符串再转换parseInt('8a') // 8 如果遇到不能转为数字的字符，就不再进行下去，返回可转的部分parseInt('abc') // NaN 如果第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaNparseInt('+1') // 1parseInt('1000', 10) // 1000 第二个参数（2到36之间），表示被解析的值的进制 如上，Number()函数会整体将目标字符串转为数值，只要有一个字符无法转成数值，目标就会被转为NaN，这点要比parseInt()函数严格很多。 这里要注意一点，就是转换’011’时看起来01结构是8进制，实际上JS经过升级，后面加逗号8才是转为8进制或其他进制。 123parseInt('011') // 11parseInt('011' , 8) // 9 （3）ParseFloat()parseFloat函数用于将一个字符串转为浮点数。 1234567parseFloat('3.14') // 3.14parseFloat('3.14more') // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分parseFloat([]) // NaNparseFloat('AAA') // NaNparseFloat('') // NaN 如果参数不是字符串或空，亦或字符串的第一个字符不能转化为浮点数，则返回NaN 上面代码中，尤其注意的是，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011Number(true) // 1parseFloat(true) // NaNNumber(null) // 0parseFloat(null) // NaNNumber('') // 0parseFloat('') // NaNNumber('1.23A') // NaNparseFloat('1.23A') // 1.23 （4）字符串减0 字符串数字后直接减一个0，可将字符串转为数值。 12345678'1' - 0 // 1'123' - 0 // 123'1.23' - 0 // 1.23'12A' - 0 // NaN 字符串里不是数字，则返回NaN'null' - 0 // NaN 上面代码中，字符串减0操作既有parseInt、也有parseFloat的功能。 还比较省代码数量，在实际应用中会比较常见。 （5）字符串前加+ 字符串数字前加一个+，可将字符串转为数字。 123456789+ '1' // 1+ '1.23' // 1.23+ '.1' // 0.1+ '-1' // -1+ '12A' // NaN 上面代码中，字符串前加+操作也有parseInt和parseFloat的功能。 ToString（1）toString() 12345678910111213141516171819// 数值var a = 123a.toString() // "123"// 布尔值var a = truea.toString() // "true"// undefinedvar a = undefineda.toString() // 报错// nullvar a = nulla.toString() // 报错// 对象var a = &#123;&#125;a.toString() // "[object Object]" 上面代码中，注意一点null、undefined用toString()转为字符串是不行的，而且toString()方法占的字节较多，那么有别的解决方法吗？ （2）加’’(双引号) 当然有，更常用的转为字符串方法为： 123456789101112131415161718// 数值1 + '' // "1" '' + 1 // "1" // 布尔值true + '' // "true"'' + true // "true"// undefinedundefined + '' // "undefined"// nullnull + '' // "null"// 对象var obj = &#123;&#125;obj + '' // "[object Object]"[1, 2, 3] + '' // "1,2,3" 数组，返回该数组的字符串形式 相比toString()方法，这种方法更为常用，且和前后加’’的顺序无关。 （3）String() String函数可以将任意类型的值转化成字符串。 123456789101112131415// 数值String(123) // "123"// 布尔值String(true) // "true"// undefinedString(undefined) // "undefined"// nullString(null) // "null"// 对象String(&#123;a: 1&#125;) // "[object Object]"String([1, 2, 3]) // "1,2,3" 数组，返回该数组的字符串形式 ToBoolean（1）Boolean() Boolean函数可以将任意类型的值转为布尔值。 它的转换规则比较简单：除了以下五个falsy值的转换结果为false，其余的值全部为true。 12345Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // false 包括+0、-0Boolean(NaN) // falseBoolean('') // false 和""一样都为空字符串，这里当成同一种 所以的话，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。 123Boolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true 这里需要注意的是，Boolean()操作对于’’和’ ‘（中间有空格）的结果是不一样的： 12Boolean('') // falseBoolean(' ') // true 因为中间有空格，代表有空格键输入，不算真正意义上的无内容 （2）类型值前加！！ 任何数据类型值前面加两个！！，都可以将其转为布尔类型。 12345!!undefined // false!!null // false!!0 // false !!NaN // false!!'' // false 从Boolean()九个字符变为！！两个字符，省了代码量；转换规则也与Boolean函数一致，故老手多用此类方法。 目前总结的就这么多啦，如有一些遗漏或有误的地方，欢迎大家指正~ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些好用的工具、网站]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。 Evernote：一款神奇的笔记✔如果一款工具能满足你对笔记的所有需求的话，那就是Evernote了，写笔记，列清单，时间管理，录音，工作同步，手机和电脑端都可下载… ✔如果你还没用过，推荐你现在关闭答案去应用市场下载一个，相信我你都会爱上它的。 免费人工智能PPT制作平台：beautiful.ai✔这个国外的黑科技网站，网站提供很多超赞的板式，我们将文字放进去，AI智能帮助我们制作PPT。真的让我这个一做PPT就头疼的人，感到开心！ ✔没广告还免费！ 录制GIF工具 ：GifCam✔录制动图对许多人来说也算是必备的东西了。 ✔窗口化录屏，也可以直接设置全屏幕录制，录制完毕后直接保存为 GIF 图片，软件大小不超过 2M，简直太方便太良心了~ 截图/贴图神器：Snipaste✔它在我心中绝对可以堪称神器了！令人惊叹不仅仅是它的强大截图功能，而是它的贴图功能也实在是太好用了！ 设计网址导航网站：牛大拿✔精选国内外优秀的UI设计网站,设计参考文章与免费的UI设计素材与资源，每日更新Dribbble精选内容、Behance精选内容、站酷精选内容、UI中国… ✔一定也有设计师不知道这个网站滴。 国外设计师常用网站：Dribbble✔通过 Dribbble，你可以浏览许多创意设计，它们出自世界各地的个人设计师、设计团队以及设计公司。 ✔这些作品并不仅限于网页或手机 app 设计，还有图片设计、品牌设计、动画、插图、平面艺术等等。 国内设计师常用网站：花瓣网✔花瓣网算是一个国内比较好的素材采集网，平时想要找的各种类型的图片素材在花瓣都能采集到，比如平面、漫画、摄影、UI等等。 ✔而且花瓣的素材普遍都很有设计感和时尚感，很适合年轻一代做设计。 设计师和开发常用网站：iconfont.cn✔阿里巴巴旗下的免费icon百科网站，可免费下载矢量源文件，选择时可以打包所有你感兴趣的放在购物车，Download时还可以选择颜色和大小,很贴心有木有！同时支持下载开发用代码。 ✔比如搜索关键词“love”看到的结果： 壁纸天堂：Wallhaven✔图片量大而且还高清，分类清晰(人物/风景/动画)。 ✔相比一些图库不全，广告遍地，收费下载的壁纸网站，免费下载的wallhaven简直就是业界良心。 在线制作流程图网站：ProcessOn✔ProcessOn在线支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 ✔轻松绘制，基本上是0难度上手。 在线生成图片链接网站：SM.MS✔SM.MS图床网站只需上传一张本地的图片，点击生成链接即可，操作简单快捷。 ✔永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式。 Listary：电脑文件秒搜+路径直达✔软件体积非常小，全局本地搜索的便捷工具，设置热键后，能在任何环境下调出窗口搜索文件，如我设置的是’Win+F’，想要找某文件时按下Win+F调出小长条搜索框就能进行实时搜索，非常便捷。 ✔相信你用了后会觉得它很高效的。 v9porn✔看到上面的标题，想必大多数人都知道了吧嘿嘿嘿 ✔那这个项目就不多介绍了，自行体会，体验好的话就默默点个赞哦 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之类型判断]]></title>
    <url>%2F2019%2F04%2F13%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[类型判断在 web 开发中较为常见，简单的有判断数字还是字符串，判断是数组还是对象稍微复杂一些，再复杂一点的有判断日期、正则、错误类型，再再复杂一点还有比如判断 plainObject、空对象、Window 对象等等。 通过本文，我将尝试概述Javascript中类型判断的几种方法（基于ES5的规范）。 typeoftypeof判断类型方法算是我们最最常用的了，直接上代码： 123456typeof 3 // "number"typeof "abc" // "string"typeof &#123;&#125; // "object"typeof true // "boolean"typeof undefined // "undefined"typeof function()&#123;&#125; // "function" 以上这些类型都比较正常，直到： 1typeof null // "object" 这显然是一个错误。 这可能会在以后的ECMAScript哪个版本中修复，返回值将为“null”。 除此之外 Object 下还有很多细分的类型，比如 Array、Date、RegExp、Error 等。如果用 typeof 去检测这些类型，举其中几个例子： 12345678var array1 = []var array2 = new Array();var date = new Date();var error = new Error();console.log(typeof array1); // objectconsole.log(typeof array2); // objectconsole.log(typeof date); // objectconsole.log(typeof error); // object 因此，typeof非常善于区分不同类型的原始值，并区分它们和对象，但在区分不同类型的对象（包括数组和null）时完全没用，那这该怎么区分？有没有更好的解决方法呢？ Object.prototype.toStringJS作为一门愈加成熟的语言，解决方法当然有！嘿嘿~这就是Object.prototype.toString！ 那 Object.protototype.toString看起来是一长串字母，看起来比较复杂诶~为了讲清楚，在toString方法被调用时,是会执行下面的操作步骤的： 如果this的值为undefined,则返回”[object Undefined]”. 如果this的值为null,则返回”[object Null]”. 让O成为调用ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 最后返回由 &quot;[object &quot;和 class 和 &quot;]&quot; 三个部分组成的字符串. 通过规范，我们至少了解了调用 Object.prototype.toString 最终会返回一个由 &quot;[object &quot; 和 class 和 &quot;]&quot; 组成的字符串，而 class 是要判断的对象的内部属性。 看这些规范还是一知半解的状态吧，直接上代码直观一点： 1234567console.log(Object.prototype.toString.call(3)) // [object Number]console.log(Object.prototype.toString.call([1, 2, 3])) // [object Array]console.log(Object.prototype.toString.call(&#123;&#125;)) // [object Object]console.log(Object.prototype.toString.call(null)) // [object Null]var date = new Date();console.log(Object.prototype.toString.call(date)) // [object Date] 我们可以看到这个 class 值其实就是识别对象类型的关键！ 因此我们可以用 Object.prototype.toString 方法识别出更多类型！那到底能识别多少种类型呢？那还是看代码数个数吧~嘿嘿 1234567891011121314151617181920212223242526272829303132var number = 1; // [object Number]var string = '123'; // [object String]var bool = true; // [object Boolean]var unde = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123;&#125; // [object Object]var array = []; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a()&#123;&#125;; // [object Function]function checkTypes() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(Object.prototype.toString.call(arguments[i])) &#125;&#125;checkTypes(number, string, bool, unde, nul, obj, array, date, error, reg, func)//打印出[object Number][object String][object Boolean][object Undefined][object Null][object Object][object Array][object Date][object Error][object RegExp][object Function] 除了以上 11 种之外，还有3种： 1234567console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]function a() &#123; console.log(Object.prototype.toString.call(arguments)); &#125;a(); // [object Arguments] 这里看我们至少可以识别14 种类型，而[[class]] 属性数量至少有 12 个。 写个类库利用Object.prototype.toString判断类型的方法来写个类库吧，此类库来自(Axis.js)[//github.com/toddmotto/axis]:123456789101112131415161718192021222324252627282930313233(function (root, factory) &#123; // 判断是否使用了模块 if (typeof define === 'function' &amp;&amp; define.amd) &#123; // 使用AMD模块 define(factory); &#125; else if (typeof exports === 'object') &#123; // 使用CMD模块 module.exports = factory; &#125; else &#123; // 没有使用模块，放在全局下 root.axis = factory(); &#125;&#125;)(this, function () &#123; // 严格模式 'use strict'; var exports = &#123;&#125;; // 将字符串转为数组 var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' '); // 判断类型 var type = function () &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125;; // 遍历types，为exports对象添加isArray、isObject...等方法 for (var i = types.length; i--;) &#123; exports['is' + types[i]] = (function (self) &#123; return function (elem) &#123; // type.call(elem)将type方法里的this指针指向elem return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return exports;&#125;); 使用方法也比较简单，直接上代码： 12345678910axis.isArray([]); // trueaxis.isObject(&#123;&#125;); // trueaxis.isString(''); // trueaxis.isDate(new Date()); // trueaxis.isRegExp(/test/i); // trueaxis.isFunction(function () &#123;&#125;); // trueaxis.isBoolean(true); // trueaxis.isNumber(1); // trueaxis.isNull(null); // trueaxis.isUndefined(); // true 考虑到实际情况下并不会检测 Math 和 JSON，而且上面这种方法也检测不了这两种类型，所以去掉这两个类型的检测。同时也不能识别自定义对象类型。 constructor当 typeof 也有无解的时候，那么我们是否还有其他好的方法来判断一个变量是自定义对象类型呢？ 我们知道，javascript 的所有对象都有一个 constructor 属性，这个属性可以帮我们判断 object 数据类型，直接上代码： 12345678910//alert(1.constructor); //报错 数字常量无 constructor 属性 var num = 1; console.log(num.constructor == Number); //true console.log("miqilin".constructor == String); //true var str = "miqilin"; console.log(str.constructor == String); //true var obj= null; console.log(obj.constructor); //报错，null 没有 constructor 属性 var none = undefined; console.log(obj.constructor); //报错，undefined 没有 constructor 属性 可以看出，数字型常量，null 和 undefined 都没有 constructor 属性。 之前以为到这就全部分析完了，看了多篇外文才知道原来还有可挖掘的东西，来看下面的代码： 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj.constructor == Cat); //false ？？因为 Cat.prototype不在obj的原型链上 console.log(obj.constructor == Animal); //true 理解 原来对于原型链继承的情况，constuctor 也不怎么好用了。那怎么办呢？ instanceof嘿嘿~原来还有一种方法可以解决这种困境，那就是 instanceof。instanceof 运算符会告诉您对象是否是某种类型的实例， 这里所谓的“类型”其实就是构造函数。直接上代码： 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj instanceof Cat); //true 毫无疑问 console.log(obj instanceof Animal); //true 可以理解 instanceof 适用于所有原生类型： 1234[1, 2, 3] instanceof Array // true/abc/ instanceof RegExp // true(&#123;&#125;) instanceof Object // true(function()&#123;&#125;) instanceof Function // true 但是 instanceof 不适用于原始类型：字符串，数字，布尔值： 1233 instanceof Number // falsetrue instanceof Boolean // false'abc' instanceof String // false 所以这里constructor又有点优势了，可以适用于原始类型number，string和boolean的判断（constructor小节有例子）。 小结虽然检查任何一种特定类型真的不是那么难，但你可能不得不在此过程中做出很多选择，势必会引起一些混乱。因此，了解所有不同的选项会有所帮助，以下是对四种方法可识别类型的简单概括： typeof： 可以是标准类型（Null 除外） 不可识别具体的对象类型（Function 除外） Object.prototype.toString： 可是识别标准类型及内置对象类型（例如，Object, Date, Array） 不能识别自定义对象类型 constructor： 可以识别标准类型（Undefined/Null 除外） 可识别内置对象类型 可识别自定义对象类型 instanceof： 不可判别原始类型 可判别内置对象类型 可判别自定义对象类型 类型转换的图形化表示（其中红色单元格表示该判断方式不支持的类型）： 还有更复杂的判断比如 plainObject、空对象、Window对象、类数组对象等，还未涉及，后续也会增加。 敬请关注！ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之数据类型]]></title>
    <url>%2F2019%2F04%2F12%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript提供了不同的数据类型来保存不同类型的值，主要有两种类型的数据类型：原始类型和引用类型。 原始类型（值类型） Undefined undefined Null null Boolean true String &#39;hello&#39; Number 123 Symbol(这里先不做介绍) 引用类型（对象类型） Object：由以上几种基本类型组成，而且对象里面还可以包含对象 123456var obj = &#123;&#125;;&lt;!-- 原始类型变量的包装类型如下 --&gt;var bool = new Boolean(true);var str = new String("hello");var num = new Number(1);var obj0 = new Object(); 如MDN所讲，JavaScript 是一种弱类型或者说是一门动态语言。这意味着你不用提前声明变量的类型，而是在程序运行过程中，类型会被自动确定。 当然，原始类型和引用类型会有一些区别： 原始类型的值是直接储存在栈（Stack）内存中的，而引用类型的数据是把 Heap内存地址存在 Stack 里，所以对已引用类型的复制其实只是复制了相同的地址而非实际的变量值。 Number为整型直接量，浮点型直接量，十六进制直接量（0x-)，八进制直接量（0-）等 出现场合： 1024 3.14 1.2e5 0x10 0o377 除以上常规数字外，还有所谓的“特殊数值”，它们也属于这种数据类型：Infinity，-Infinity和NaN。 StringJavaScript中的字符串必须用引号括起来，有3种类型的引号 出现场合：123var str = "Hello, world!"; //双引号var str = 'Hello, world!'; //单引号var str = `Hello, world!`; //反引号 双引号和单引号是“简单”引号，它们在JavaScript中没有区别，但由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。 反引号是“扩展功能”的引用，允许我们通过将变量和表达式包装在$ {…}中来将它们嵌入到字符串中，比如：1234567var name = "miqilin";// embed a variableconsole.log( `Hello, $&#123;name&#125;!` ); // Hello, miqilin!// embed an expressionconsole.log( `the result is $&#123;1 + 2&#125;` ); // the result is 3 加反引号后计算$ {...}内的表达式，结果会成为字符串的一部分。 我们可以在其中放置任何东西：像名称这样的变量或像1 + 2这样的算术表达式或更复杂的东西。 但请注意，这只能在反引号中完成。 其他形式没有这种嵌入功能！1console.log( "the result is $&#123;1 + 2&#125;" ); // the result is $&#123;1 + 2&#125; (双引号不生效) Boolean布尔类型只有两个值：true 和 false 出现场合： 条件语句导致的系统执行的隐式类型转换 if(隐式转换){} 字面量或变量定义 var bool = true; 也出现在比较的结果 ： 123var isGreater = 4 &gt; 1;console.log( isGreater ); // true (the comparison result is "yes") Nullnull 出现场合： 获取不存在的对象 document.getElementById(&#39;not-exist-element&#39;) 在JavaScript中，null不是“对不存在的对象的引用”或者像其他语言中的“空指针”。它只是一个特殊值，代表“无”，“空”或“未知值”。 Undefinedundefined的含义是“未赋值” 出现场合： 变量声明了，但没赋值 var obj; 获取对象不存在的属性 var obj = {x: 0}; obj.y; 无返回值函数的执行结果 function f(){}; var obj = f(); 调用函数时，应该提供的参数没有提供 function f(i){console.log(i)}; f(); void(expression) null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 1undefined == null // true 但也有一丝区别，区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。12Number(undefined) // NaN5 + undefined // NaN Object属性集合 出现场合：1234567var obj = &#123; name: "miqilin" &#125;;var obj = new Cat();var obj = new function() &#123; this.sound = "wow";&#125; 但请注意，我们还没有提到过Array，Date，甚至是函数，因为正式地说，它们都是对象类型。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（二）]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。 Part1 组块什么是组块什么是组块 (chunk) ？对于绝大多数人来说这是一个全新的概念，看上去并没有什么意义，就像一堆乱糟糟的拼图。从神经科学的角度来看，组块就是通过应用或意义连接在一起的信息碎片。而在不加理解或不关注上下文的情况下，单纯的死记硬背并不能帮助你理解其内涵和你所学概念之间的关联，那么这个概念拼图就没有可以拼合的边缘，无法关联到其他的拼图碎片上。 当你全神贯注于某件事上，就好像你的脑子里有一只章鱼。这只注意力的章鱼会在必要时把它的触须穿过工作记忆的四个插槽，从而帮助你把分布于大脑不同区域里的信息联系起来。 这和发散模式下的随机连接不同，创建组块的过程中，它需要集中注意力将大脑的不同部分连接起来，专注模式下将不同的想法联系在一起。但在你很紧张时，你的注意力章鱼会失去一些连接能力，这也是为什么在你生气、紧张、害怕的时候，大脑似乎不能专注工作。 在任何领域获得专业知识的第一步都是先创建出概念组块。这种根据意义将信息碎片拼接起来的思维跃进，可以运用于所有人类能够掌握的领域，如运动、音乐、舞蹈等。最重要的是专注的训练和重复可以建立强的记忆痕迹，从而帮助你创建组块。专业的培养都是一小步一小步的，这个过程中，小的组块可以形成更大的组块。随着你对学习材料的理解越来越深入，所有的专业知识都只是更有创造性的见解的铺路石。 但仅仅通过练习和重复来创建组块，并不能使你得心应手并有创造力地运用它们。组块化可以让大脑工作得更有效，一旦你把某个想法、概念或动作组块化后，你就不再需要记住有关的全部细节，你只需要知道最主要的那个概念就行了，也就是只需要记住组块。这就像清晨起床穿衣服，你只需要一个简单的想法——“我要穿衣服”， 但细想你会发现这个简单想法的组块所包含的活动是非常复杂的。 怎样形成组块如果你是吉他初学者，你想学习弹奏一首有难度的吉他曲，你脑中关于这首曲子的神经表征可被看作是一个巨大的组块。首先你会听这首曲子、看别人弹奏这首曲子，还要从持琴姿势学起。和大多数技能一样，你通常需要将曲子的每一小部分转化为一个小的神经组块，再将这些小组块组合起来形成大组块。经过一段时间的练习，当你掌握了很多乐段之后，你就能流利地弹奏一个乐段了。 对于数学和科学的相关学科来说，关上书本检测自己，能够帮你检验那些你以为已经明白了的问题，并且加快你的学习速度。当你能独自完成某件事时，你才是真正掌握了它。许多事情都是这个道理，就像你只是看别人画画，并不代表你也能画出来，仅仅听别人唱歌并不能使你拥有同样的唱功和洪亮的嗓音。某件事如果你只是在看，或者就算理解了如何去做，也不代表你能真正做到。只有在你自己实际操作和完全掌握的情况下才能建立起神经模型。 组块化的第一步：就是对你想要组块化的信息全神贯注。如果你正开着电视，或是每隔几分钟就检查、回复手机上的消息，这些都会增加你建立组块的难度，因为你的大脑并没有完全投入到新信息的组块化中去。 组块化的第二步：要求你对建立组块的对象有基本的了解。无论是理解概念性的知识，还是寻找故事中不同情节间的关联，通常我们都可以自然而然地领会所学内容的大意。 组块化的第三步：是获取背景知识。不断重复和练习解决相关的或不相关的问题，这样你不仅知道如何使用组块，还明白应该什么时候使用。这样做能帮你认识新建立的组块是如何融入整体知识框架的。 最后第四步，练习能帮你拓宽组块连接的神经网络，并确保它们不仅牢固，还能通过不同途径访问。正如下图所示，学习由两部分组成，自上而下的认识以及由下至上的组块化。 在由下至上组块化的过程中，练习和重复能够帮助你建立和强化每一个组块，这样你就可以在需要它的时候使用它。当自上而下的方法能够让你清楚地看到你正在学习什么以及它适用于哪里。就完全掌握知识而言，这两个过程都非常重要。而背景认识就是这两个过程的交汇处，背景认识意味着学会在特定的时候使用正确的方法。 通常在真正的阅读之前，快速浏览书中某一章的图片以及小标题，能够帮助你知晓大意。听那些有严谨层次结构的课程，可以帮你弄清楚应在哪里建立组块以及如何把不同组块联系起来。一旦完成了这些，再了解具体的信息，那么就算遗漏了一些让你疑惑的部分，你依然可以理解主要部分。 总的来说，最好在精神高度集中的时候建立组块，理解基本的含义后，通过练习来真正掌握知识，并对情境有个大致了解，是建立组块的基本步骤。快把“组块”融入到你正在使用的学习中去吧！ 能力错觉这一小节来介绍一些让学习走上正轨的基本理念。 1.回顾的重要性 学习书本或资料时，最常见方法之一就是反复阅读。不过心理学家Jeffrey Karpicke证明，这种方法的成效远不及另一种简单技巧——回顾。也就是阅读材料后，移开视线，看看你能回忆起多少内容。 Karpicke发表在《科学》杂志上的研究提供了可靠证据。先让学生们学一篇科技文章，然后通过尽力回忆其中信息来巩固练习；接着，让他们重读并再次回想。结果相同时间内仅用回顾法练习的学生较使用其他学习方法的学生而言，对材料的掌握更为全面深入。其他学习方法包括反复阅读资料，或者绘制可以加强学习材料之间联系的思维导图。学生通过正式考试或非正式自测都证明了回顾法有助于学习。这给了我们一个重要提示，即在回顾知识时，我们并非机械地复述，而是在通过回顾这个过程加深理解。这也有助于我们形成知识组块，就好像回忆过程帮助我们在神经上嵌入了“钩子”，以便我们串联起前后知识。 比起被动重复阅读，回顾——即在心里检索关键概念——可以使你的学习更加专注高效，只有隔上一定时间后再重读才会有效果，因为这样，重读就更像是间隔重复练习。 2.能力的错觉 你该明白你才是要解决问题和掌握概念的人，如果你看到某个习题答案后告诉自己，“哦，我明白他们为什么这么做了！” 那么这个答案并不真正属于你，因为你没有真正把这些概念嵌入自己潜在的神经回路中去。这是一种学习中最为常见的自欺欺人式错觉。如果你想要很好地掌握材料以在考试中取得好成绩，并从中创新，就必须让这些知识在你脑海里生根发芽。 另一个类似情况就是做笔记和注释。做笔记时高亮和下划线必须要谨慎，否则不仅没有效果还容易产生误导。在空白处写笔记总结关键概念也被证明是一种很更好的办法。 Karpicke的研究还发现，学生们喜欢重读笔记或课本的原因是，当他们面前打开着课本、笔记或谷歌时，会误以为这些知识同样在他们的脑海里，然而事实却并非如此。因为看书比回顾做起来简单，学生们会陷入一种自欺欺人的错觉。事实上，这种学习方式效率很低。 3.自测与犯错 能力的错觉提醒我们，在学习资料上花太多时间并不能保证你真的懂了。而自测是一种极其有用的办法，来确保你是真的学会了，而不是自欺欺人的错觉。从某种意义上来说，这就是回忆在发挥作用。 让你发现自己是否真的掌握一个概念，犯错实际上是件好事。因为你之后就会想要避免重复犯错，所以实际考试前，在自测中犯的错是很有价值的，因为它们能让你一点点弥补思维漏洞。犯错可以纠正思考方向，让你学得更好、做得更好。 4.多场合回顾 回顾是一种有效工具，而在常规学习场所以外回顾知识则会帮助你加深对知识的理解。通过在不同物理环境下回顾和思考知识，你会脱离对给定场所的依赖，这会帮助你避免由于考试与学习场所的不同而产生的问题。 Part2 看到全局是什么激励了你？你会发现当学的东西并非自己真正喜欢的东西时，学习是非常困难的；而学习自己真正感兴趣的东西的时候，一切都变得非常简单，那这是为什么呢? 你的大脑有一套神经递质的广泛投射系统，它加载的不是经验本身的内容，而是信息的重要性以及对未来的价值。神经递质是可以影响神经元如何回应其他神经元的化学物质。今天我们将要谈谈它们其中的三种，乙酰胆碱、多巴胺和血清素。 乙酰胆碱影响专注学习和集中注意力。当你注意力高度集中的时候，这些乙酰胆碱神经元就会广泛地投射出来，并且激活环路来控制突触可塑性，从而形成新的长期记忆。 多巴胺信号与意料之外的奖励相关。当接受到一个毫无预期的奖励时，这些神经元将分泌出多巴胺，多巴胺的信号将广泛投射，这会对学习产生强有力的影响；同时也会影响决策，甚至是感官输入的价值所在，它控制着我们的动力。比如番茄工作法中的设置奖励就是给自己的多巴胺神经元加油。 血清素影响社会生活和冒险行为。它可以有力地影响你的社交生活。在猴子部落中的雄性首领有着最高的血清素分泌水平，而位列最末的公猴，其血清素水平则最低。血清素也与风险行为有着紧密的联系，在那些血清素低的猴子身上往往能观察到更多的冒险行为。服刑犯人中，因暴力犯罪而入狱的是社会中血清素分泌活动最低的群体之一。 情绪也可以强烈地影响你的学习。你自己应该深有体会，情绪曾一度被认为与认知互不影响，然而近期研究显示，情绪、感觉以及注意力互相交织，并与学习和记忆力互相影响。 对于成功的学习来说，情绪及神经递质系统比感知和动作要反应迟缓，但却同等重要。 组块库的价值将新的组块和原有组块结合起来的能力，体现在很多历史的创新变革中。比如比尔·盖茨与其他工业领袖会留出长达一周的阅读周期，以便在一段时间内掌握多种不同想法，把新鲜想法留在头脑中，与未忘记的想法进行自我交流，可以形成创新性思维。 你的组块库越大，运用越熟练，无论学什么科目，你都将能够更轻易地解决问题。组块化并非创新灵活度所需要的全部，但是它是重要的一环。组块还可以帮助你理解新概念。这是因为当你理解一个组块时，你会发现这一组块能以令人惊讶的方式与相似的组块联系起来。不仅在同一领域中如此，在截然不同的领域中也是这样。这就是所谓的知识迁移(transfer)。 你建立每一个组块，它就为你补上知识拼图的一块，但如果你不训练变大的组块，它们就会保持模糊的状态，你要学习的东西拼到一起就会更为困难。建立组块库就是在训练你的大脑，不仅要认出一个特定的概念，还要识别概念的类别，以便你能够自如地知晓如何快速处理你遇到的问题。你将开始看到一些为你简化解决方法的模式，并很快发现不同的解决方法就潜藏在你的记忆边缘。 有两种途径解决问题，一是顺序性地，一步步推理；二是通过整体性的直觉。顺序性思维涉及到专注模式；而直觉通常需要创造性的发散模式来联系不同的想法。大多数较难的问题和概念都是通过直觉来理解的，因为新的想法和你熟悉的领域相去甚远。发散模式是半随机地进行连接，这意味着它们带来的解决方法，应该由专注模式进行小心验证。直觉性的理解不是永远正确的，你大概会想无论你在学什么，仅在单一的部分或章节里就有那么多问题和概念，根本没法全学会。这时机遇定律就发挥作用了，幸运女神会眷顾努力之人。专注于你正在学习的单元，你会发现一旦你把第一个问题或概念放进组块库，不论那是什么，第二个概念的进入就会容易一些，然后第三个概念也就更容易，这并不都那么简单，但会越来越容易。 过度学习、思维定势、交替学习当你在学习一个新单词、一种新概念或新的问题解法时，你需要在同一学习阶段内反复练习。一定的练习是必要且有用的，但在完全掌握此阶段的所有内容后继续学习训练，就是所谓的过度学习。过度学习在有些场合是有意义的，比如对网球发球、钢琴协奏曲演奏可能非常重要，它能在紧张的时候，帮助其行为自动化。但仍要警惕在单一学习阶段的重复性过度识记，研究表明，这可能会对宝贵的学习时间造成浪费。 一旦你在某一阶段学会了一个基本概念，在这段时间不断地巩固它，并不能加强你所期许的长期记忆联系。学完一段时间之后再复习是更好更有用的，这可以加强并深化你的组块化神经模式。但请注意，重复你已经掌握的东西非常容易，而这可能会造成能力错觉，让你误以为自己已掌握了所有材料，但其实你只掌握了简单的部分。所以，你应该均衡学习，把精力集中在你认为困难的部分。专注于学习的困难部分称为刻意训练 (deliberate practice) ，这种刻意训练 (deliberate practice) 通常是好学生与优秀学生的差别所在。 这些与思维定势(Einstellung) 的概念有关。一个已经形成并加强的神经模式可能阻碍你发现更棒的解决方案。思维定势在这张弹珠脑图里就表现为，你最初的想法向大脑上方移动，而解法的思维模式则位于下方。 密集的专注模式以及先前构造的思维模式，会形成惯性，阻止你走向一个可能发现解决方法的新区域。你可以把思维定势想像为一个路障，而它是你最初的想法所造成的，这种错误的方式在运动和科学学科中就很容易发生。因为有时你最初”发生什么”或”该去做什么”的直觉是有误导性的，在学习新事物时，你必须摒弃错误的旧思想和方法。 学生学习时会犯的一项重大失误是，在学会游泳前就跳入水中。换句话说，他们盲目地开始做作业，不看书、不上课、不看在线课程，或甚至不与熟识此方面的人交谈。这种学习方法只会失败。就像在放任思想在一个专注模式的弹珠器里跳来跳去，而完全不考虑解法到底在哪里。在学习和生活中，理解如何得到真正的解决方法很重要。掌握一门新学科不仅要学习基础组块，更要学会如何选择和应用不同的组块。最佳的学习方法是，在需要不同技术和策略的问题中来回切换、练习，这就是所谓的交替学习。 交替学习非常重要，你需要让自己的大脑习惯这种思想，即仅仅知道如何使用特定的概念、方法或解题技巧是不够的，你也需要知道何时去使用 ，要贯彻交替学习的思想。这样你才能脱离只会练习和重复，而开始学会独立思考。当你在一个学科内交替学习，你就开始在这个学科内发展创造力了。当你在多个不同学科间交替学习，你就能更容易地在不同领域的组块间创造联系，这能进一步提高你的创造性。当然，在不同领域间发展固定知识组块需要时间，所以有时需要取舍。成为几个领域的专家，意味着你可以将一个领域的新思想引入另一个领域，但这也可能意味着，你在某个领域的专业知识 并不如专攻一个领域的人那么深厚。反过来，如果你只专研一个学科，你可能对它有很深刻的理解，但也变得只习惯某种思考方式，这种根深蒂固的思考模式，让你很难把握新思想。 科学哲学家Thomas Kuhn发现，科学中大部分的方式转变都是由年轻人，或者之前学习其他学科的人所提出的。他们不那么容易陷于思维定势，不会被先前的专业训练阻碍思想。有句老话说道，科学会随着每个葬礼的进行而进步，因为葬礼意味着根深蒂固的旧思想的流逝。 最后我转帖一个别人在元学习课程里用拼图的理念去学编程的文章，作为一个实例参考: 元学习课心得和实践（一）——八小时搞定《JavaScript DOM》 下一节课我们会学习怎样应对拖延症，以及拖延症和记忆的关系。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客中遇到的一些"事"]]></title>
    <url>%2F2019%2F04%2F03%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E2%80%9C%E4%BA%8B%E2%80%9D%2F</url>
    <content type="text"><![CDATA[我写的这篇文章已经详细讲解了怎样利用hexo搭建GitHub个人博客，自从入了hexo搭建博客的坑后，发现hexo真的是巨TM好用， 配置好以后对我最大的方便就是想改就改，想删就删，一条 $ hexo g -d 命令搞定了事，支持 Markdown ，还支持非备案域名绑定，开心！ 搭建过程中也并非一切顺利，稍微不注意就出现bug，接下来罗列了几条我搭建过程中所遇到的一些“事”及解决办法。 仓库的名字仓库的名字的正确格式应该是github用户名.github.io，比如说，如果你的github用户名是test，那么你就应该新建test.github.io的仓库（必须是你的github用户名，这里再强调一遍，其它名称无效，之前因为没仔细看，随便起了个名字，果断报错）。 首页文章内容部分展示我用的是next主题，默认会把所有文章内容都展示出来，这可不简洁美观。所以查了一下，有一个小技巧，就是在你觉得要展示在首页的Mrakdown文件内容文字后面添加&lt;!--more--&gt;即可。例如：123456789101112---title: HTML、CSS、JS中unicode字符的处理 ---# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； GitHub Pages绑定域名后每次hexo d都会失效在GitHub Pages绑定域名之后，发现每次hexo d后，域名网址都会报错404，又要重新部署，就有点太麻烦了。 搞了很久还是不行，后面在网上和群里问出，到这里域名绑定并没有结束，还差关键一步： 具体就是在Hexo目录里的source文件下添加一个名为CNAME的文件，注意这个文件是没有后缀的，千万不要设置成.txt文本文件，文件的内容就是域名，格式如： luozongmin.com 添加后重新部署文件到github，这个时候再试，应该就成功了。 创建分类页面添加一个分类页面，并在菜单中显示页面链接。应先新建一个页面，命名为 categories ，命令如下： $ hexo new page categories 注意！！！categories中千万别加””(双引号)，不然会导致部署完后网站中不显示具体分类： 之后在编辑刚新建的页面中，将页面的类型设置为categories； 最后编辑主题的_config.yml，将menu中的categories: /categories注释去掉即可。 Busuanzi 统计浏览量失效由于busuanzi(不蒜子)的网址更新，导致了使用Hexo Next主题时统计浏览量时失效。 解决方法: 到hexo的themes文件夹下, 进入\themes\next\layout_third-party\analytics 打开: busuanzi-counter.swig 将src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js” 修改为src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js” 即可。 不蒜子官网:http://ibruce.info/2015/04/04/busuanzi/ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（一）]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？ 无意中在Coursera上发现了一门神奇适用的课程，叫做“Learning How to Learn”， 旨在利用科学知识以及授课者切身经验教会你学会如何学习，学习这门课我才开始恍然大悟，原来学习应该这样学习，算是初步悟到如何学习的真谛了。下面我将讨论我从第一周课堂中学到的经验教训。 利用专注与发散思维研究发现，人有两种完全不同的思考模式，专注模式（focused mode）和发散模式（diffuse mode）。就目前神经学家所知，专注模式与发散模式只能单独存在，你不能同时使用两种模式。而发散思维是你试图了解新事物时应该采取的思维模式。 课程讲述萨尔瓦多·达利 (20世纪著名的超现实主义画家)有时会坐在椅子上，放空自己的大脑，并常常会漫无目的地思考一下之前的工作。这样他就能把脑海中那些在发散模式下得到的的联想和点子及时地收集起来，然后带着这些在发散模式下得到的新想法回到专注模式里去。 这个例子目的是告诉我们：当你处于长期专注的学习模式时，可以通过小睡或做一些运动，然后过渡到发散模式，有助于你的大脑建立必要的神经连接，在你的长时间记忆中建立持久的知识块。还要强调的是，当你学习一些新的东西，尤其是比较难的东西的时候，你的大脑需要有在两种学习模式之间来回转换的能力，这能帮助你更高效地学习。想要锻炼你的神经，你需要每天做一点练习，逐步建立起支撑你思考的神经骨架，这就是关键所在。 拖延症每个人或多或少有拖延的毛病，只不过有些人比较严重。当你面对一件你极度不情愿做的事情时，就好像激活了大脑中与疼痛相关的区域。 所以拖延的过程大概如下图：首先，某件事可能会让你产生轻微的不安；为了消除这种不适感，你会转而去做一些更让人愉悦的事情，这么做的结果就是你觉得更开心了，但这只是暂时的，后续文章会更深入地去了解拖延症。 番茄工作法课程告诉我们一个小巧方便的意志力工具，这个小工具叫做番茄工作法 (Pomodoro)。这个小技巧所需的只有一个计时器（手机上搜索“番茄ToDo”APP，电脑端也有许多类似的软件，可以自行选择），具体的实行过程是这样的： 首先需要把计时器设定25分钟，屏蔽所有会打扰你的事物； 在25分钟内，集中精力专注你所要专注的事； 最后还有一件很重要的事情是，当你前两步之后要给自己一点小小的奖励。比如：上几分钟网、喝杯咖啡或者简单地做一下运动，来使你的大脑可以愉悦的放松一会儿。 实行后你会发现番茄工作法的使用效果非常明显，这就像是你的大脑在健身房做完一次25分钟的高强度训练，然后进行休息放松一样。当你无法专注的时候不妨试一试！ 记忆与练习当我们回忆数学方程组时，我们使用的是长期记忆。当我们尝试结合脑海中的想法来帮助我们理解某一概念或解决某一问题时，我们使用的是工作记忆。工作记忆和长期记忆是两种主要的记忆系统，工作记忆是大脑在即时且有意识地处理信息时所涉及的那部分记忆。 长期记忆就像一个储存仓库，不同的长期记忆储存在大脑的不同区域。研究表明，当你首次尝试将一段短期记忆转入长期记忆中时，你需要多次回顾以增加需要时找到相关信息的几率。 当你遇到新事物时，你通常会运用工作记忆来处理它，如果你想将这个信息转移到长期记忆里，就需要间隔重复的练习来促进这一过程。 不断重复你尝试记忆的内容，但重复的过程必须间隔开来。如果你尝试在一个晚上重复记忆20次相同的内容，记忆效果还比不上在几天内重复同样的次数这种方法。 练习在数学和科学中学到的思想和概念是很重要的，通过反复实践练习可以帮助你提高和增强学习过程中生成的神经连接，越是抽象的东西越要注重练习。 学习的时候如果一心一意地专注学习，时间一长学习效果反而不好，需要休息一下或者至少稍稍将注意力转移到其他地方。在这段看似放松的时间里，你大脑的发散模式就有机会在后台帮你完成对概念的理解。如果你不这么做，而是进行填鸭式学习，你的知识库看起来将会像杂乱不堪，基础不牢靠的泥堆。 如果你有拖延问题，就需要使用番茄工作法帮助你注意力集中一段时间，并适当休息。这会帮你行动起来，并开始建立你需要的神经模式，使你能更有成效地学习更具挑战性的内容！ 睡眠的重要性你怎么也不会想到，当你绝对清醒时你的大脑会产生一些有毒的物质，那大脑如何除掉这些有毒物质呢？原来当人们睡觉时，大脑细胞会收缩，从而增加脑内细胞之间的距离。这就像疏通了一条溪流，液体会在细胞空隙间流过，冲走有毒的物质。所以，睡觉这件事有时候看起来像是浪费时间，实际上是大脑保持清洁和健康的一种方式。 睡眠不足意味着少量代谢毒素残留在你的大脑之中，而这些有毒物质会让你思维混乱，不仅会让你发挥失常，还会导致头疼、抑郁症、糖尿病、心脏类疾病，甚至寿命缩短，这绝不是在吓你，可以参考一下睡眠不足的危害。 睡眠对人们解决困难问题和理解所学知识的能力有显著影响，大脑会将你学习和思考过的想法、概念进行整理，清除掉一些不太重要的部分；同时增强你需要或想要记住的区域的记忆。在睡梦中，大脑还会将你努力学习到的东西在神经中枢一遍遍排演以增强加深记忆力！ 如果你在打盹或睡觉之前，复习一遍所学东西，那你将有更大可能性梦到它。如果你更进一步，告诉自己你想要梦到这些内容，你梦到它的几率也会大大提高。梦见你所学的知识，本质上能够增强你的理解能力，在一定程度上可以将你的记忆整合成更易被掌握的组块信息。 现在是时候去打个盹儿了！ 采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法1、当你遇到完全陌生的事物时你是如何更容易学习的？ 答：单刀直入地实践，因为实践出真知，且大量的阅读作用甚微，同时最好有专家的指点。 2、你是如何让自己在一场枯燥的讲座中保持专注的？ 答：没有简单的方法是可以让你对不感兴趣的东西一直保持参与度的，但是有一个小技巧，就是用提问来“伏击”演讲者，这种打断通常会带出更有趣的讨论；比起被动的听，积极参与会让你学到更多。 3、你是如何进入发散思维模式，并从中获益的呢？ 答：慢跑或户外锻炼是让思维跳出常规想法的绝佳方法，而且这时极其可能迸发灵感。奔跑中，事物从你身边略过，你会开始思考发生的一些事情，然后意识之外的想法涌上表面，接着通常就会出现有用的新想法。但是，这些转瞬即逝的点子过后很容易忘记，我会随身携带一本小本子及时记下来。 4、你会同时进行多项任务吗？ 答：生活中有大量任务不断地“轰炸”，我们一刻也离不开多线程工作，如果做不到统筹兼顾，日子将会很难熬。但我们不能真正地同时做两件事，容易混淆且效率低下。同时处理多个任务实际是一种切换任务的能力。你可能要花很多时间才能完成这样的切换，切换任务并回到当时中断的地方开始工作，这是高效完成任务的方法之一。 5、神经科学方面的知识有运用到学习上的例子吗？ 答：别把自己关在房间里，充足的空间、能激励你的人、很多可以积极参与的事件，以及运动和锻炼都大有助益，它们会增加新神经元的数量并促进神经元的生长。 6、你有关于高效地集中注意力、学习和创新的技巧吗？ 答：处于富有创新氛围的环境中，是一种提升自身创造力的方法。当你和别人交流、阐述观点，你就会有更好的想法，这一过程通常有助于创新。 7、给大家的建议? 1） 聪明的人并不一定会成功，有很多聪明的人并不成功，而那些富有激情并且坚持努力的人容易达到，是因为人生中的成功多半来自于激情和努力，往往成功的人的身上都具有这样的品质。 2）每天我们周围都有值得发现去重新理解的东西，我们必须要用不同的视角来看待这些普通的东西，这很重要。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令拓展]]></title>
    <url>%2F2019%2F03%2F29%2FGit%E5%91%BD%E4%BB%A4%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[本文的内容基本上是从廖雪峰及阮一峰老师的Git 教程中总结出来的，方便自己以后查阅相关命令。 一般来说，日常使用只需要记住下图6个命令即可。但是想往深度使用Git，恐怕还需要记住其余的几十个命令。 上图中几个专用名词的译名如下： Workspace：工作区 Index / Stage：暂存区 Repository：本地仓库 Remote：远程仓库 配置123456$ git config --list //显示当前的Git配置$ git config -e [--global] //编辑Git配置文件$ git config --global user.name "miqilin21"$ git config --global user.email miqilin21@example.com //设置你的仓库用户名及邮箱，用于标识提交者 新建Git代码库12345$ git init //在当前目录新建一个Git代码库$ git init [project-name] //新建一个目录，将其初始化为Git代码库$ git clone [url] //下载一个项目和它的整个代码历史 添加/删除文件123456789$ git add [file1] [file2] ... //添加一个或多个文件到暂存区$ git add [dir] //添加指定目录到暂存区，包括子目录$ git add //添加当前目录的所有文件到暂存区$ git rm [file1] [file2] .. //删除工作区文件，并放入暂存区$ git rm --cached [file] //停止追踪指定文件，但该文件会保留在工作区 本地文件提交1234567$ git commit -m "Commit message" //提交暂存区到仓库区$ git commit -a //提交工作区自上次commit之后更改的所有文件，直接到仓库区$ git commit -v //提交时显示所有diff信息$ git commit --amend -m "Latest commit message" //使用一次新的commit，替代上一次提交；如果代码没有任何新变化，则用来改写上一次commit的提交信息 同步远程仓库123456789101112131415$ git fetch [remote] //下载远程仓库的所有变动$ git remote -v //显示所有远程仓库$ git remote show [remote] //显示某个远程仓库的信息$ git remote add [shortname] [url] //增加一个新的远程仓库，并命名$ git pull [remote] [branch] //同步远程仓库的变化，并与本地分支合并$ git push [remote] [branch] //上传本地指定分支到远程仓库$ git push [remote] --force //强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --all //推送所有分支到远程仓库 撤销1234567891011121314151617181920212223$ git checkout [file] //恢复暂存区的指定文件到工作区$ git checkout [commit] [file] //恢复某个commit过的文件到暂存区和工作区$ git checkout //恢复暂存区的所有文件到工作区$ git reset [file] //重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset --hard //重置暂存区与工作区，与上一次commit保持一致$ git reset --hard [commit] //重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git revert [commit] //新建一个commit，用来撤销指定commit；后者的所有变化都将被前者抵消，并且应用到当前分支$ git stash //将工作区现场保存起来，等以后恢复后继续工作。通常用于处理更为着急的任务时，例如：bug$ git stash list //查看保存的工作现场$ git stash apply //恢复工作现场$ git stash drop //删除stash内容$ git stash pop //恢复的同时直接删除stash内容 分支12345678910111213141516171819202122232425$ git branch //列出所有本地分支$ git branch -r //列出所有远程分支$ git branch -a //列出所有本地分支和远程分支$ git branch [branch-name] //新建一个分支，但依然停留在当前分支$ git branch [branch] [commit] //新建一个分支，指向指定commit$ git checkout -b [branch] //新建一个分支，并切换到该分支$ git checkout [branch-name] //切换到指定分支，并更新工作区$ git merge [branch] //合并指定分支到当前分支$ git push origin [branch-name] //将分支推送到远程仓库$ git push --all origin //将所有分支推送到远程仓库$ git branch -d [branch-name] //删除分支$ git push origin --delete [branch-name]$ git push origin :[branch-name]$ git branch -dr [remote/branch] //删除远程分支 标签12345678910111213141516$ git tag //列出所有tag$ git tag [tag] //新建一个tag在当前commit$ git tag [tag] [commit] //新建一个tag在指定commit$ git tag -d [tag] //删除本地tag$ git push origin :refs/tags/[tagName] //删除远程tag$ git show [tag] //查看tag信息$ git push [remote] [tag] //提交指定tag$ git push [remote] --tags$ git push --tags origin //提交所有tag 查看信息123456789101112131415161718192021222324252627282930313233343536$ git status //显示有变更的文件$ git log //显示当前分支的版本历史$ git log --stat //显示commit历史，以及每次commit发生变更的文件$ git log -S [keyword] //搜索提交历史，根据关键词$ git log --follow [file]$ git whatchanged [file] //显示某个文件的版本历史，包括文件改名$ git log -p [file] //显示指定文件相关的每一次diff$ git log -5 --pretty --oneline //显示过去5次提交$ git shortlog -sn //显示所有提交过的用户，按提交次数排序$ git blame [file] //显示指定文件是什么人在什么时间修改过$ git diff //显示暂存区和工作区的差异$ git diff --cached [file] //显示暂存区和上一个commit的差异$ git diff HEAD //显示工作区与当前分支最新commit之间的差异$ git diff [first-branch]...[second-branch] //显示两次提交之间的差异$ git diff --shortstat "@&#123;0 day ago&#125;" //显示今天你写了多少行代码$ git show [commit] //显示某次提交的元数据和内容变化$ git show --name-only [commit] //显示某次提交发生变化的文件$ git show [commit]:[filename] //显示某次提交时，某个文件的内容$ git reflog //显示当前分支的最近几次提交]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+GitHub搭建个人博客]]></title>
    <url>%2F2019%2F03%2F21%2F%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo是一个快速、简介且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多，所以就用它啦~ 下面一步一步地说怎么用hexo+github搭建一个个人博客。 说明：本文只针对Windows平台下的搭建过程，其他平台的请自行上网查阅 准备在搭建博客之前，需要安装node.js和git，具体操作请参考这篇文章，并同时申请Github账号，使用的开发工具为VScode。 安装Hexo1、首先新建一个文件夹如myBlog，用于存放整个博客源文件。右击鼠标点击文件夹，选中Git Bash Here在Git命令行中打开。 2、执行以下命令安装Hexo及生成第一篇博客文章：1234$ npm install -g hexo-cli //安装hexo$ hexo init //初始化hexo,这样myBlog就是整个博客的根目录，所有的页面都可以在里面进行增删改操作$ hexo generate //生成静态页面$ hexo server //启动本地服务器，进行博客文章预览 Hexo会默认生成第一篇博客《Hello World》，在浏览器下打开localhost://4000你将会看到： myBlog源文件夹整体目录预览： 其中_config.yml和package.json为项目的配置文件，themes存放了我们博客的主题，source-&gt;_post为我们的博客目录，public为执行hexo generate后生成的静态页面。 关联Github1、在你的Github中建立新的 repo，repo 名称必须是「你的用户名.http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。 2、将myBlog目录中的_config.yml文件在VScode中打开，编辑网站配置： 把第 6 行的 title 改成你想要的名字 把第 10 行的 author 改成你想取大名 把最后一行的 type 改成 type: git 在最后一行后面新增一行，左边与 type 平齐，加上一行 repo: 仓库地址 （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址最好以 git@github.com: 开头） 3、修改完成配置后在myBlog目录下执行命令：12$ npm install hexo-deployer-git --save //安装 git 部署插件$ hexo deploy //将本地博客代码部署到Github上 4、进入「你的用户名.http://github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接；最后用浏览器访问「预览链接/index.html」就应该看到了你的博客啦！ 添加新文章1、打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就相当于在本地添加了新文章 2、利用来VScode编辑新文章 3、hexo generate 4、hexo deploy 5、去看你的博客，应该能看到这篇新文章啦！ 更换主题1、https://github.com/hexojs/hexo/wiki/Themes 上面有主题合集 2、随便找一个主题，进入主题的 GitHub 首页，比如我找的是 https://github.com/iissnan/hexo-theme-next 3、复制它的 SSH 地址或 HTTPS 地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git 4、cd themes 5、git clone git@github.com:iissnan/hexo-theme-next.git 6、cd .. 7、将 _config.yml 的第 75 行改为 theme: hexo-theme-next，保存 8、hexo generate 9、hexo deploy 10、等一分钟，然后刷新你的博客页面，你会看到一个新的外观，如果不喜欢这个主题，就回到第 1 步，重选一个主题。 tips1、最好进入一个安全的目录创建源文件夹，在根目录瞎搞； 2、_config.yml中的缩进和空格一定严格按照文件的默认格式来，不然会报错； 3、想要删除博客的话，直接删除source-&gt;_posts-&gt;对应的博客文章，然后再次执行hexo generate、hexo deploy即可； 4、在_config.yml中修改language为zh-CN，即可将博客中英文转换为中文； 5、常用命令：1234567hexo new "postName" //新建文章 hexo new page "pageName" //新建页面 hexo clean //清除缓存文件db.json和已生成的静态文件 public,网站显示异常时可以执行这条命令试试。hexo generate //生成静态文件 hexo deploy //部署到Giihub hexo server //启动本地服务器 hexo help //查询帮助 6、md文件需要用到markdown语法。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—三栏布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局的页面可分为左中右三部分，然后对中间那部分做自适应的一种布局方式。三栏布局在前端页面的开发中十分常见，那么怎么样的才算是三栏布局呢？ 比如苏宁易购的首页： 上图的布局就是一个常见的三栏布局：即左边商品导航和右边导航为固定宽度，中间内容随浏览器宽度变化自适应。 下面详细介绍了一些经典及新兴的三栏布局方式，且所有方式显示的效果如下图： 绝对定位布局1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; position: relative; &#125; .left &#123; position: absolute; width: 150px; height: 200px; left: 0; top: 0; background-color: red; &#125; .middle &#123; height: 200px; margin: 0 160px; background-color: green; &#125; .right &#123; position: absolute; width: 150px; height: 200px; right: 0; top: 0; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 绝对定位布局是一个比较古老和容易想到的方式，其特点就是简单实用，而且也不容易出问题，缺点就是，容器脱离了文档流，后代元素也脱离了文档流，当高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 float布局12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .left &#123; float: left; height: 200px; width: 150px; background-color: red; &#125; .middle &#123; margin: 0 160px; height: 200px; background-color: green; &#125; .right &#123; float: right; width: 150px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; float布局也是一种较为简单且容易想到的方式，原理是左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应，缺点就是中间部分最后加载，内容较多时会影响体验。 BFC 三栏布局123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .left &#123; float: left; height: 200px; width: 150px; margin-right: 10px; background-color: red; &#125; .middle &#123; height: 200px; overflow: hidden; background-color: green; &#125; .right &#123; float: right; width: 150px; height: 200px; margin-left: 10px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; BFC有一特性：BFC的区域不会与外部浮动元素重叠，这里利用了这一特性，实现了两栏自适应布局。缺点和方法二类似，为了解决这个问题，引出下面要介绍的双飞翼布局。 双飞翼布局1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .content &#123; float: left; width: 100%; &#125; .left &#123; float: left; height: 200px; width: 150px; margin-left: -100%; background-color: red; &#125; .middle &#123; height: 200px; margin-left: 160px; margin-right: 160px; background-color: green; &#125; .right &#123; width: 150px; height: 200px; float: right; margin-left: -200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局是在中间栏的 div 中再嵌套一个 div，内容写在嵌套的 div 里，然后对嵌套的 div 设置 margin-left 和 margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是 100% 宽度，只不过中间栏的内容通过 margin 的值显示在中间。 中间内容可以优先加载，但其HTML 代码结构稍微复杂点。 圣杯布局123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; margin-left: 160px; margin-right: 160px; &#125; .middle &#123; float: left; width: 100%; height: 200px; background-color: green; &#125; .left &#123; float: left; width: 150px; height: 200px; margin-left: -100%; position: relative; left: -160px; background-color: red; &#125; .right &#123; float: left; width: 150px; height: 200px; margin-left: -210px; position: relative; right: -220px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局的核心是左、中、右三栏都通过float进行浮动，然后通过margin负值进行调整。跟双飞翼布局比较像，但还是有一些区别，相对于双飞翼布局来说，其HTML 结构相对简单，但是css语法就稍微复杂，也是优先加载中间内容。 还有注意一点是：中间内容要放在最上面，保证其先渲染。 Flex布局1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: flex; &#125; .middle &#123; flex-grow: 1; height: 200px; background-color: green; &#125; .left &#123; order: -1; flex: 0 1 150px; margin-right: 10px; height: 200px; background-color: red; &#125; .right &#123; flex: 0 1 150px; margin-left: 10px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Flex布局是由CSS3提供的一种较为新兴的、方便的三栏布局方式，简单实用，缺点是其兼容性差一点。 Table 布局12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: table; width: 100%; &#125; .left, .middle, .right &#123; display: table-cell; &#125; .left &#123; width: 150px; height: 200px; background-color: red; &#125; .middle &#123; background-color: green; &#125; .right &#123; width: 150px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 算是一种比较老的布局方式，较为简单，但其缺点是：无法设置栏间距，缺乏点灵活性，如下图： Grid(网格)布局123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: grid; grid-template-columns: 160px auto 160px; height: 200px; &#125; .left &#123; background-color: red; margin-right: 10px; &#125; .middle &#123; background-color: green; &#125; .right &#123; background-color: yellow; margin-left: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 网格布局作为一种比较新潮的实现方式，仅仅几条样式命令就能完成三栏布局，可见其布局之强大，但其兼容性比较差。 以上就是我自己总结及结合文档所列出的8种css实现前端三栏布局的方式，如还有其他方式，欢迎大家告诉我哦。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—左右布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css左右布局是实现前端页面设计的基础，大部分的布局方式都能分割成左右布局，因此理解左右布局，能使我们在初学css的时候更快理解其他复杂的布局方式。 下面是我罗列的几种css实现前端左右布局的方式： position: absolute实现在父级元素内设置两个子元素，绝对定位它们，然后使用百分比将它们分成左右两部分。 这里的好处是，有两个可以容纳自己内容的独立容器。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt; /*以上为html代码*/section &#123; color: white; text-align: center;&#125;div &#123; height: 100%;&#125;article &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; padding: 20px;&#125;h1 &#123; font-size: 20px;&#125;.left-half &#123; background-color: #ea68a2; position: absolute; left: 0px; width: 50%;&#125;.right-half &#123; background-color: pink; position: absolute; right: 0px; width: 50%;&#125; table实现table布局是页面布局中使用的最早的布局方式，随着前端技术的发展，table布局由于自身的局限性逐渐被div布局取代。123456789101112131415161718192021222324252627282930313233&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;body &#123; color: white; text-align: center;&#125;h1 &#123; font-size: 20px;&#125;div &#123; display: table-cell; text-align: center; vertical-align: middle; width: 50%; padding: 50px;&#125;.left-half &#123; background: #ea68a2;&#125;.right-half &#123; background: pink;&#125; float实现float属性是css中关于布局的一个关键属性，可以产生脱离文档流的布局现象，其left属性值使该区域向父级标签区域的左侧边界放置，right属性值使该区域块向父级标签的右侧边界放置，利用该属性可以实现左右布局。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;html, body, section, div &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;section &#123; width: 100%;&#125;article &#123; position: relative; top: 50%; left: 50%; padding: 1rem; transform: translate(-50%, -50%);&#125;h1 &#123; font-size: 20px;&#125;.left-half &#123; background-color: #ea68a2; float: left; width: 50%;&#125;.right-half &#123; background-color: pink; float: left; width: 50%;&#125; 对于float对后面同级元素的影响，既可以采用margin进行影响的清除，还可以在受影响的元素上添加overflow：hidden来清除浮动对该区域块带来的影响。 Inline-Block实现display:inline-block属性是介于行内元素（display: inline）和块级元素（display: block）之间的属性，它既可以像行内元素一样水平布局，也可以像块级元素设置宽高属性，所以左右布局可以利用它这种属性。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt;&lt;/div&gt;&lt;div class="right-half"&gt;&lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt;&lt;/article&gt;&lt;/div&gt;* &#123; box-sizing: border-box;&#125;html, body, div &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;article &#123; position: relative; top: 50%; left: 50%; text-align: center; transform: translate(-50%, -50%);&#125;h1 &#123; font-size: 25px;&#125;div &#123; display: inline-block; vertical-align: top; width: 50%;&#125;.left-half &#123; background: #ea68a2;&#125;.right-half &#123; background: pink;&#125; flexbox实现css3中出现了弹性盒子flexbox布局，使用这种方法，可以将父级容器变成一个灵活的盒子，子容器占用相等的份额， 无需再设置宽高。123456789101112131415161718192021222324252627282930313233343536373839&lt;section class="container"&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;html, body, section &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;div&#123; display: flex; flex-direction: column; justify-content: center;&#125;h1 &#123; font-size: 25px;&#125;.container &#123; display: flex;&#125;.left-half &#123; background-color: #ea68a2; flex: 1;&#125;.right-half &#123; background-color: pink; flex: 1;&#125; grid实现CSS Grid(网格) 布局技术就像是Flexbox和Table的混合体，你可以通过将 CSS 规则应用于父元素(成为 Grid Container 网格容器)和其子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid 布局。12345678910111213141516171819202122232425262728293031323334353637383940&lt;section class="container"&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/secion&gt;html, body, section, div &#123; height: 100%;&#125;body &#123; color: white;&#125;article &#123; position: relative; top: 50%; text-align: center; transform: translate(0, -50%);&#125;h1 &#123; font-size: 25px;&#125;.container &#123; display: grid;&#125;.left-half &#123; background: #ea68a2; grid-column: 1;&#125;.right-half &#123; background: pink; grid-column: 2;&#125; 作为比较新兴的布局技术，相信在未来的前端发展中，Grid 布局技术会越来越受到广大开发者的青睐。 以上就是我自己总结及结合文档所列出的6种css实现前端左右布局的方式，如还有其他方式，欢迎大家告诉我。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—居中布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[我们在网页布局的时候，经常会碰到需要居中的情况，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。 水平居中元素宽高未知当元素的宽高都未知的时候，可以利用以下两种方法将元素水平居中： ①CSS3 transform：12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; ②flexbox：1234.parent &#123; display: flex; justify-content: center;&#125; 居中元素为内联元素常见的内联元素有：span, a, img, input, label 等等。 您可以在块级父元素内水平居中内联元素，只需css中加以下核心语法：123.parent&#123; text-align: center;&#125; 这种方法适用于display 为 inline, inline-block, inline-table, inline-flex 类型的元素。 居中元素为块级元素常见的块元素：div, h1~h6, table, p, ul, li 等等。 ①设置 margin：0 auto123456789.parent &#123; width: 100%;&#125;.child &#123; width: 800px; height: 100px; margin: 0 auto; background: #999;&#125; 此方法只能进行水平的居中，对浮动元素或绝对定位元素是无效的。 ②转换为 inline-block 属性：123456.parent &#123; text-align: center;&#125;.child &#123; display: inline-block;&#125; 居中元素为浮动元素加以下核心语法:1234567.child &#123; width: 100px; float: left; position: relative; left: 50%; margin-left: -50px;&#125; 居中元素为绝对定位元素①123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 50%; margin-left: -50px;&#125; ②12345678910.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 0; right: 0; margin: 0 auto;&#125; 垂直居中元素宽高未知当元素的宽高都未知的时候，也可以利用以下同样两种方法将元素垂直居中： ①CSS3 transform：12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateY(-50%);&#125; ②flexbox：12345.parent &#123; display: flex; flex-direction: column; justify-content: center;&#125; 适用于子元素为浮动、绝对定位、内联元素，均可垂直居中。 其中flexbox 是 CSS3 新增的属性，设计初衷就是为了解决像垂直居中这样的常见布局问题，相信未来flexbox布局会越来越多应用。 元素宽高已知①123456789.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; ②12345678910.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 0; bottom: 0; height: 100px; margin: auto 0;&#125; 居中元素为单行文本①1234.text &#123; line-height: 200px; height: 200px;&#125; 将文本的 line-height 属性值设为和文字父容器一样的高度，但适用于只有一行文字的情况。 ②1234.link &#123; padding-top:30px; padding-bottom:30px;&#125; 有时内联/文本元素可以垂直居中显示，只是因为它们上部和下部都有相等的padding。 居中元素为多行文本①table：12345678.parent &#123; display: table;&#125;.child &#123; display: table-cell; margin: 0; vertical-align: middle;&#125; ②flexbox:123456.parent &#123; display: flex; justify-content: center; flex-direction: column; height:400px;&#125; 水平垂直居中元素宽高已知①负边距居中：123456789101112.parent &#123; position: relative;&#125;.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 此方法灵活性差，不能自适应，且宽高不支持百分比尺寸和 min-/max- 属性。 ②绝对居中：1234567891011div &#123; width: 100px; height: 100px; margin: auto; position: fixed; //absolute is ok top: 0; right: 0; bottom: 0; left: 0;&#125; 元素的宽高支持百分比 % 属性值和 min-/max- 属性。 ③transform :1234567891011.parent &#123; position: relative;&#125;.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; ④table-cell:1234567891011121314.parent &#123; display: table-cell; vertical-align: middle; text-align: center; width: 100px; height: 100px; border: 1px solid red;&#125;.child &#123; width: 50px; height: 50px; display: inline-block; background-color: #999;&#125; 这种方法适用于子元素 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，前提需要知道父元素的宽高，且父元素的宽高不能设为百分比数。 ⑤font-size 结合 vertical-align：1234567891011121314.parent &#123; font-size: 175.4px; height: 200px; text-align: center;&#125;.child &#123; vertical-align: middle; display: inline-block; font-size: 12px; width: 50px; height: 50px; background-color: #999;&#125; 该方法前提条件是需给父元素设一个合适的 font-size 值，该值一般为其父元素的高度除以 1.14 得到的值，并且子元素必须是一个 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，此外还需在子元素内加上 vertical-align: middle 属性。 ⑥文本内容：12345text &#123; height: 100px; line-height: 100px; text-align: center;&#125; 元素宽高未知①transform :123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; transform方法中元素既可以加宽高，也可不加，用于水平垂直居中布局。 ②flexbox :12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; ③grid:1234567body, html &#123; height:100%; display: grid;&#125;span &#123; /* thing to center */ margin: auto;&#125; 该方法适用于只有一个元素的时候，作为非常新的布局方式，其兼容性也比较差。 上面只是把所有方法的代码要点罗列了一下，能满足所有的居中布局方案，如你还有其他好方法，欢迎交流指正哦。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速搭建静态资源服务器]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。以前的时候，都是使用php的本地环境，也算比较方便，但是自从学了nodejs，发现创建http-server更方便。 本文的目的在这篇文章中，我将向您展示如何使用NodeJS创建一个非常简单的HTTP服务器。您可以通过http访问目录中的静态资源，如HTML，Javascript，CSS等，比如： http://localhost:8080/hello.html http://localhost:8080/abc.js 而不是通过默认的file:///来访问 那问题是为什么只有需要一个HTTP才能访问静态资源呢？ 是因为HTML文件含有Javascript文件时，如果通过默认的file://地址来访问此文件的话，浏览器会阻止本地Javascript文件的一些操作，此时就需要安装HTTP-Server来解决这个问题。 报错信息： Failed to load file:///E:/webexamples/reactjs/hello-reactjs/person.jsx: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. 创建HTTP-Server首先，确保已在计算机上安装NodeJS和npm； 否则，请按照以下说明进行安装： 在Windows上安装NodeJS 打开 Git Bash或其他命令行工具，依次输入以下命令，按回车： 123npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress false npm 的配置被存储在 ~/.npmrc，你可以随时改。 ①接下来第一步，先创建一个空目录： ②利用命令行工具进入这个目录，这里用的是Git Bash。右击鼠标，点击Git Bash here，即可用Git Bash打开这个目录： ③运行以下命令安装http-server：1$ npm install -g http-server ④启动HTTP-Server，输入命令：1$ http-server -c-1 到此您的HTTP服务器就已经启动了，它正在端口8080上监听，您可以通过访问以下链接进行检查，3个地址在电脑端打开的是同一份东西： http://192.168.1.116:8080/ （只有这个地址能在手机中预览） 127.0.0.1:8080/ （2和3性质是一样的） localhost:8080/ （较为常用） ⑤在该目录中创建一个HTML文件，您可以通过此HTTP地址访问它： ⑥这里Windows 用户需要注意了，如果你发现你修改了源代码，页面却无法更新，说明http-server 的缓存还未消除，那么可以这样做： 打开 Chrome 开发者工具 点击 Network 勾选 Disable Cache 这样缓存就不存在了~ 其他命令安装HTTP-Server这里就不仔细介绍步骤了，因为大部分操作和结果与第2步是一样的，直接上命令： 第一种方法：安装：1$ npm i startserver -g 快速开启：1$ startserver 第二种方法：安装：1$ npm install -g live-server 快速开启：1$ live-server 如果看到其他有意思的方法，后续还会增加的！ 以上就是我在近期收集到的一些方法资料，不一定全面，如有错误欢迎指正哦。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>前端相关</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>http-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常用标签]]></title>
    <url>%2F2019%2F03%2F19%2FHTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[HTML 是用来描述网页的一种语言，通过添加各种标签，达到在浏览器中展示期望的效果。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 浏览器不会显示 HTML 标签(HTML tag)，而是使用标签来解释页面的内容： HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;p&gt; 和 &lt;/p&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 ⭐越多代表我觉得此标签越重要 标题标签 ⭐⭐⭐HTML提供了6个等级的标题(head)，即：h1、h2、h3、h4、h5和h6，h1是最高级的标题。其基本语法是：&lt;hn&gt; 标题信息 &lt;/hn&gt; 注意：h1因为重要，尽量少用，一般都是给logo用，或者页面中最重要标题信息，其他5个级别标题在一个页面中都可以出现多次，h1只能出现一次。 段落标签 ⭐⭐⭐在网页中要想把文字内容有条理地显示，离不开段落标签（paragraph）,它是网页中文章内容的基本组成部分。其基本语法是：&lt;p&gt; 文本内容 &lt;/p&gt; 注意：段落标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签 ⭐⭐在网页中经常看到一些水平线将段落与段落间隔开，层次分明。这些水平线可以通过插入图片来实现，也可以简单地通过&lt;hr/&gt; 标签(horizontal)来完成。其基本语法是：&lt;hr /&gt;是单标签 换行标签 ⭐⭐⭐在HTML中，一个段落的文字会从左往右按顺序排列，直到浏览器窗口的右端，然后会自动换行，如果希望某段文字强制进行换行，就需要使用换行标签(break)。其基本语法是：&lt;br /&gt; 注意：除了少数应用（比如诗歌的分行），应该尽量避免使用这个标签，因为它并没有特别的语义含义，而且分行的视觉效果完全可以通过p标签、列表标签和CSS命令达到。 div span标签 ⭐⭐⭐⭐div 和 span是没有语义的，是现在网页布局用到的最主要的2个盒子，比如css+div的结合就可以基本上满足页面布局需要。其基本语法是：1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt; 今日行情 &lt;/span&gt; 文本格式化标签 ⭐⭐在网页中，有时要为某些文字设置加粗、加斜或加下划线的效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。其基本语法是： 注意：b i s u 只有使用，没有强调的意思，strong em del ins的语义更强烈。 图像标签img ⭐⭐⭐⭐要想在网页中显示图像就需要使用图像标签，下图详细介绍了图像标签&lt;img /&gt; 以及与其相关的一些属性。其基本语法是： 基本图像插入方式：&lt;img src=&quot;wo.jpg&quot;/&gt; 带有alt的图像插入方式：&lt;img src=&quot;wo.jpg&quot; alt=&quot;这是我吴彦祖的照片&quot;/&gt; 带有title的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot;/&gt; 带有宽度的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; /&gt; 带有边框的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; border=&quot;10&quot; /&gt; 链接标签 ⭐⭐⭐⭐在HTML中创建超链接比较简单，只需用链接标签(anchor)环绕需要被链接的对象即可。其基本语法是：&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; href：Hypertext Reference的缩写，意思是超文本引用，用于指定链接目标的url地址。 target：用于指定链接页面的打开方式，其取值有self(新链接页面覆盖原页面，为默认值)、blank(在新窗口打开)、_parent(载入父级窗口，与iframe结合用得到)、_top(载入顶级窗口，与iframe结合用得到)，注意： 外部链接：需要添加 http://www.baidu.com 内部链接：直接链接内部页面名称即可，如首页；还有可以通过创建锚点链接，能够快速定位到内部页面的目标内容：①.使用链接文本 ②.使用相应的id名标注跳转到目标的位置 如果没有确定的链接目标时，通常将href属性定义为”#”(即href=”#”)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 当然也可以利用base标签来设置整体链接的打开状态，如网易这样设置让页面所有链接按新窗口打开： 特殊字符标签 ⭐ 无序列表ul ⭐⭐⭐⭐无序列表(unordered list)的各个列表项之间没有顺序级别之分，是并列的。其基本语法是：123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 注意： &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签内输入其他标签或者文字的做法是不被允许的。 &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 无序列表会自带样式属性，但还是让css来做！ 有序列表ol ⭐⭐有序列表(ordered list)即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义。其基本语法是：123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ...... &lt;/ol&gt; 所有特性基本和ul一致，且自带顺序。 定义列表 ⭐定义列表(definition list)常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法是：12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ...... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...... &lt;/dl&gt; 表格table ⭐⭐表格还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。其基本语法是：1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 上面的语法中包含三对HTML标签，分别为&lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体解释： table用于定义一个表格。 tr用于定义表格中的一行，必须嵌套在table标签中，且只能嵌套&lt;td&gt;&lt;/td&gt;，在table中包含几对tr，就有几行表格。 td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对&lt;tr&gt;&lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少”列”（或多少个单元格），但表格只有行tr和单元格td，行里面装单元格，没有列的概念；&lt;td&gt;&lt;/td&gt;标签像一个容器，可以容纳所有的元素。 表单标签 ⭐⭐表单的目的是为了收集用户信息，在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，作用是提示用户进行填写和操作。 表单域：相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过它定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input控件 ⭐⭐⭐⭐&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。其常见属性如下所示： text语法:1234&lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="北京" /&gt;&lt;/td&gt; //value为默认值&lt;/tr&gt; password语法：1234&lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" value="123456" /&gt;&lt;/td&gt; &lt;/tr&gt; radio单选按钮语法：12345678&lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; 男&lt;input type="radio" name="sex" /&gt; 女&lt;input type="radio" name="sex" /&gt; 人妖&lt;input type="radio" name="sex" /&gt; &lt;/td&gt; &lt;/tr&gt; label标签 ⭐⭐label标签为input元素定义标注，其中for属性规定了label与哪个表单元素绑定。其基本语法是：12&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; 点击Male会直接跳到右边的文本框内，label通过for和id建立联系快速找到。当然也可以简化成这种形式：1&lt;label&gt;&lt;input type="radio" name="sex" value="male"&gt;Male&lt;/label&gt; textarea文件域 ⭐⭐text 文本框只能写一行文本，如果需要输入大量的信息，就需要用到textarea标签，可以轻松地创建多行文本输入框。其基本语法是：123&lt;textarea cols="每行的字符数" rows="显示的行数"&gt; 文本内容 &lt;/textarea&gt; 但是textarea的宽和高通常是通过css来控制的,cols和rows几乎不用。 下拉菜单 ⭐⭐使用select标签定义下拉菜单的基本语法如下：123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option中定义selected=”selected”时，当前项即为默认选中项。 表单域 ⭐⭐在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。其基本语法是：123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件 &lt;/form&gt; 常见属性： Action：在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接受并处理表单数据的服务器程序的url地址。 method：用于设置表单数据的提交方式，其取值为get或post。 name：用于指定表单的名称，以区分同一个页面中的多个表单。注意：每个表单都应该有自己的表单域。 HTML5常用新标签 ⭐⭐⭐ header：定义文档的页眉 nav：定义导航链接的部分 footer：定义文档或节的页脚 article：标签规定独立的自包含内容 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容（侧边） datalist：标签定义选项列表，与input元素配合使用 fieldset：可将表单内的相关元素分组，打包，与legend搭配使用 HTML5新增的input type属性 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体embed ⭐⭐embed可以用来插入各种多媒体（较大的），格式可以是Wav、AIFF、AU、MP3等。其中url为音频或视频文件的路径，可以是相对路径或绝对路径。其基本语法是：123&lt;embed src='http://player.youku.com/player.php/sid/XMzk4MDUzNTA1Mg==/v.swf' allowFullScreen='true' quality='high' width='480' height='400' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt; 多媒体audio ⭐⭐HTML5通过&lt;audio&gt;标签来解决音频播放的问题。其基本语法是：1&lt;audio src="./music/See You Again.mp3"&gt;&lt;/audio&gt; //通过src指定音频文件路径即可 并且可以通过添加属性来更友好控制音频的播放，如： autoplay 自动播放 controls 是否显示默认播放组件 loop 循环播放 ，loop=2就是循环2次 ，loop或者loop=“-1”无限循环 多媒体video ⭐⭐同音频播放一样，&lt;video&gt;（通常插入较小的视频）使用也相当简单。其基本语法是：1&lt;video src="./video/movie.mp4" controls="controls"&gt;&lt;/video&gt; //通过src指定视频文件路径 同样，通过附加属性可以更友好的控制视频的播放： autoplay 自动播放 controls 是否显示默认播放组件 loop 循环播放 width 设置播放窗口的宽度 height 设置播放窗口的高度]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git/GitHub操作手册]]></title>
    <url>%2F2019%2F03%2F19%2FGit%E5%8F%8AGithub%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Git 是目前最流行的版本管理工具，也是程序员的必备技能之一。这里主要介绍一下git/github远程仓库的使用及相关配置。 SSH KeysSSH Keys是什么呢？简单来说相当于一把钥匙（在机器中即电脑中进行配置），github相当于一把锁，每次发起请求是会去验证钥匙与锁是否配对。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置。 添加远程库你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那如何将我们这个本地仓库上传到 GitHub 呢？下图简单描述了Git常用的操作流程。 1、在本地新建文件夹，命名为blog，在本地的blog仓库的路径下运行命令行。1$ git init // 在当前目录新建一个Git代码库 这个操作在当前目录下生成一个.git文件，默认不显示，可在命令行中输入 ls -a,即可看到所有被隐藏文件，接下来进行如下操作：1234$ echo "# myblog" &gt;&gt; README.md //在当前目录下新建README.md,且文件内容为'myBlog'；如果目录下已经有文件，请省略这一步$ git add README.md //将README.md文件提交到问题暂存区$ git commit -m "first commit" //将暂存区文件提交到本地仓库，且本次提交记录为'first commit'$ git status -sb //显示当前所有文件的状态 这几步操作目的是将上传的文件提交到本地仓库，接下来就是介绍怎么样将本地仓库上传到远端库了。 2、登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，名称随意，一般可以跟本地目录名一致。 在Repository name填入blog，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。 3、点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图: 4、看上图，记得点击 SSH 按钮，如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用HTTPS 地址，因为使用HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但在某些只开放http端口的公司内部就无法使用SSH协议而只能用HTTPS 。 5、目前，在GitHub上的这个blog仓库还是空的，GitHub告诉我们，可以在这个仓库创建一个新的本地仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。现在，我们根据GitHub的提示，在本地的blog仓库下运行命令：1$ git remote add origin git@github.com:miqilin21/blog.git 6、下一步，就可以把本地库的所有内容推送到远程库上：1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样: 7、如果你想查看变更历史，可以通过命令：$ git log 8、从现在起，只要本地仓库作了修改，如果你想让改动保存到远程仓库里，你需要先git add文件或者也可以git add。注意，如果这个 文件以前被我们add过，所以此处的git add操作可以省略，但我建议你使用git的初期阶段，不要省略git add。换句话说，每一次改动，都要经过git add和git commit两个命令，才能被添加到 .git 本地仓库里。接下来就通过命令：1$ git push //将本地仓库修改内容同步到远程仓库 但是，如果远程库先有修改的话，要想本地仓库与其同步，还需通过命令：1$ git pull //将远程库修改的内容下载到本地库 最后把本地master分支的最新修改$ git push推送至GitHub，现在，你就拥有了真正的分布式版本库！ 从远程库clone上面已经讲了 在本地创建仓库 将本地仓库上传到 GitHub 这里将介绍另外一种用法，那就是直接在 GitHub 创建一个仓库，然后克隆下载到本地。 1、在GitHub 上新建一个仓库 git-demo，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下： 请按图中所示，一模一样的操作，然后点击创建按钮。 2、这样一来，这个仓库就会自动生成三个文件： 3、现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库，点击页面中唯一的绿色按钮「clone or download」，会看到一个弹出层： 请确保弹出层里的地址是 SSH 地址，也就是 git@github.com 开头的地址，如果不是，就点击 Use SSH 按钮，然后复制这个地址。 4、打开 Git Bash，找一个安全目录，比如 ~/Desktop 桌面目录就很安全：cd ~/Desktop，然后运行：1$ git clone git@github.com:miqilin21/git-demo.git 运行完了你就会发现，桌面上多出一个 git-demo-2 目录，里面的内容和远程库一模一样，至此从远程库克隆到本地就完成啦！ 小结三种方式都说完了，它们分别是： 1、在本地创建仓库 2、将本地仓库上传到 GitHub 3、GitHub 上的仓库克隆下载到本地 其实呢，还有很多种不同的方式，但是，你记住这几种就行了，已经够你用了。我们并不想要了解 git 的所有高级用法，我们的目的很明确：能通过 Git 命令使用 GitHub 就行。 我们最后再回顾一遍已经学到的命令： git clone git@github.com:xxxx，克隆下载远程仓库git init，初始化本地仓库 .gitgit status -sb，显示当前所有文件的状态git add 文件路径，用来将变动加到暂存区git commit -m “信息”，用来正式提交变动，并备注信息，提交至 .git 仓库如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。git log 查看变更历史 其他学习资源 常用Git命令清单Git菜鸟教程廖雪峰的Git教程 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP入门笔记]]></title>
    <url>%2F2019%2F03%2F19%2FHTTP%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTTP 协议是互联网的基础协议，也是现在网页开发的必备知识，2015年出的最新版本 HTTP/2 更是成为互联网技术热点。 本文介绍了 HTTP 协议的基础知识以及浏览器和web服务器之间请求和响应的详细信息。 什么是HTTP?HTTP代表超文本传输协议。 这是互联网中数据通信的基础， 数据通信以客户端发送的请求开始，并以从Web服务器接收的响应结束，而HTTP的作用就是指导浏览器和服务器如何进行沟通。 HTTP通信过程简图： 客户端（通常为浏览器）负责发起请求 web服务器在 80 端口接收请求 web服务器之后负责响应请求的内容 浏览器负责下载响应内容 curl命令curl是一种命令行工具，作用是发出网络请求，然后得到响应和提取数据，显示在”标准输出”（stdout）上面。后面所说的请求，就是通过使用 curl 命令来实现的。比如输入：curl -s -v -- &quot;www.sina.com&quot;这一行命令，输出的请求内容为： &gt; GET / HTTP/1.1 &gt; Host: www.sina.com &gt; User-Agent: curl/7.55.0 &gt; Accept: */* &gt; 响应内容为: &lt; HTTP/1.1 200 OK &lt; Date: Sun, 03 Mar 2019 06:17:38 GMT &lt; Content-Type: text/html &lt; Content-Length: 23568 &lt; Last-Modified: Sun, 03 Mar 2019 06:16:24 GMT &lt; Connection: keep-alive &lt; ETag: "5c7b7138-5c10" &lt; Expires: Sun, 03 Mar 2019 06:22:38 GMT &lt; Cache-Control: max-age=300 &lt; Accept-Ranges: bytes &lt; Set-Cookie: TS0106d18b=0103cff18ca232a2464de8b94e660a71bf04913ec10acc3f4e7336f5c7620c43c b93a3a1e3e5b394e3b5f0d8d9c8c835e649efa77c; Path=/ &lt; 想了解关于 curl 里的参数，推荐使用explainshell.com来查看解释，很快捷很详细哦。 请求的格式 来自计算机客户端的请求一般包含以下几个部分： 1 请求行：动词 路径 协议/版本 比如： GET /index.html HTTP/1.12 请求头：Key1: value12 Key2: value2Key3: value3Content-Type: application/x-www-form-urlencodedHost: http://www.baidu.comUser-Agent: curl/7.54.0回车：没有内容4 消息体：要上传的数据 请求最多包含四部分，最少包含三部分，最少三部分时消息体可以为空，且第三部分永远是一个回车（\n） 动词有 GET（从服务器获取资源，一项或多项） POST（在服务器新建一个资源） PUT（在服务器整体更新资源，客户端提供改变后的完整资源）PATCH（在服务器局部更新资源，客户端提供改变的属性） DELETE （从服务器删除资源） 等。如果想用POST，就输入：curl -X POST -d “1234567890” -s -v – “https://www.sina.com&quot; 这里的路径包括「查询参数」，但不包括「锚点」 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 响应的格式来自服务器的响应一般包含以下几个部分： 1 状态行：协议/版本号 状态码 状态描述响应头：Key1: value1Key2: value2Content-Length: 17931Content-Type: text/html回车：没有内容消息体：要下载的内容 响应都有4个部分，具体其实跟请求的格式差不多 常见的状态码： 200：请求成功请求的资源被永久转移到其他地方（重定向）404：请求的资源不存在500：内部服务器错误 状态码分类 1开头：信息，服务器已经收到请求，需要请求者继续执行操作（不常用）2开头：成功，操作被成功接收并处理3开头：重定向，需要进一步操作来完成请求4开头：客户端错误，请求包含语法错误或无法完成请求5开头：服务器错误，服务器在处理请求时发成了错误 状态码列表 如何在Chrome上检查HTTP请求和响应？将Google Chrome视为常用浏览器，在其他浏览器中查看详细信息的过程仍然相同。 在Google Chrome中打开网页，然后转到”更多工具 &gt;开发者工具”菜单。 您也可以通过右键单击页面打开开发人员控制台，然后选择“检查”选项。 转到“Network”选项，然后重新加载页面。 现在，您将看到页面上每个组件的加载时间。 点击“Show Overview”图标以删除时间线，以便您可以清楚地查看其他详细信息。 单击左侧栏上的页面URL，然后转到“Response”选项。 （您还可以在“Preview”选项下查看相同的详细信息）。 您可以在上面的部分中详细了解请求和响应的详细信息。 “Headers”选项将显示所选项目的请求和响应的HTTP标头信息的详细信息。 HTTP 标头检查工具与Chrome类似，还有许多其他免费工具可用于检查HTTP标头中收到的响应代码。 例如，转到此HTTP标头检查工具，输入您要检查的任何URL，然后单击“提交”按钮。 例如输入https://www.baidu.com，您将看到如下标头的详细信息： HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 277Content-Type: text/htmlDate: Sun, 03 Mar 2019 07:27:41 GMTEtag: “575e1f6f-115”Last-Modified: Mon, 13 Jun 2016 02:50:23 GMTPragma: no-cacheServer: bfe/1.0.8.18 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
