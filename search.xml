<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS中一切都是对象吗？看这一篇就够了]]></title>
    <url>%2F2019%2F05%2F09%2F%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9D%A5%E8%81%8A%E4%B8%80%E8%81%8AJS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[当你刚开始学习JavaScript时，你是否有遇到许多书籍，教程以及那些说“JavaScript中的所有内容都是对象”的人？这算是一个JavaScript中老生常谈的话题了，虽然它并不是100％正确（JavaScript中不是所有都是对象），但其实这种说法又有那么一点说得过去，这可能有点自相矛盾。 想必有点疑惑吧，那么造成这种现象的原因是什么呢？接下来就由我一一道来。 历史原因说起一切都是对象这种说法的由来，就要好好提一下历史因素了。 1995年，JavaScript诞生之年，Netscape公司（JavaScript的设计者）与Sun公司（Java语言的发明者和所有者）合作开发一种可以嵌入网页的脚本语言，将JavaScript的数据结构借鉴Java而设计，包括将值分成原始值和对象两大类。 Java中一切皆对象，但基本类型却不是对象，为了解决这个问题，Java让每个基本类型都对应了一个包装器类型。包装器类型将基本类型包装起来，添加了属性和方法，包装器类型即为对象，所以可以这么说Java中的一切都可以充当对象，不会说的那么绝对。 因此借鉴了Java数据结构的JavaScript也同样在基本类型中各对应了一个包装器类型，JavaScript中的一切都可以充当对象，接下来将详细进行介绍。 原始类型与对象JavaScript中值可以分为两大类：原始类型和对象。 定义 在JavaScript中，有六种原始数据类型： Boolean - true 或 false null - 用 type of 检验 null 数据类型时为 Object ，但它不是对象，这是JS的一个bug undefined number - JavaScript中的所有数字都是浮点数，没有整数 string symbol (ES6) 除去上面的原始数据类型，所有其他值都是对象。对象可以进一步分为： 原始值的包装类型：Boolean,Number,String. - 很少直接使用。 以下类型生成的对象也可以通过构造函数创建： [] 类同于 new Array() {} 类同于 new Object() function() {} 类同于 new Function() /\s/ 类同于 new RegExp(“\s“) Dates: new Date(“2011-12-24”) 不同点 第一个不同点： 原始类型没有附加方法; 所以你永远不会看到undefined.toString（）。 也正因为如此，原始类型是不可变的，因为它们没有附加的方法可以改变它： 123var s = "boy";s.bar = "girl";console.log(s.bar); // undefined 而默认情况下，对象是可变的，可以添加方法： 123var obj = &#123;&#125;;obj.foo = 123; console.log(obj.foo); // 123 第二个不同点： 此外，与作为引用存储的对象不同，原始类型作为值本身存储。 这在执行相等性检查时会产生影响： 123456"dog" === "dog"; // true14 === 14; // true&#123;&#125; === &#123;&#125;; // false[] === []; // false(function () &#123;&#125;) === (function () &#123;&#125;); // false 原始类型按值存储，对象通过引用存储，存储地址也不同，原始类型直接存放在栈中，而对象是存放在堆里的，具体可以看之前写的关于内存空间这篇文章。 原始值及其包装器三个基本类型string，number和boolean，它们有时被当做包装器类型，并且在原始值和包装类型之间进行转换很简单： 原始类型 to 包装类型: new String(&quot;abc&quot;) 包装类型 to 原始类型: new String(&quot;abc&quot;).valueOf() 比如字符串“abc”之类的原始值与new String（“abc”）之类的包装器实例有根本上的不同。 例如（用typeof和instanceof判断时）： 1234567typeof "pet"; //"string"typeof new String("pet"); //"object" "pet" instanceof String; // falsenew String("pet") instanceof String; // true "pet" === new String("pet"); // false 其实包装器实例就是一个对象，没办法在JavaScript中比较对象，甚至不能通过非严格相等 ==： 1234var a = new String("pet");var b = new String("pet");a == b; // falsea == a; // true 因此JavaScript中的一切都可以充当对象，而JavaScript中的一切都是对象这种说法是欠妥的。 临时包装（Auto-Boxing）有趣的是，原始字符串和对象的构造函数都是String函数。 更有趣的是你可以在原始字符串上调用.constructor这个方法，可是之前说过原始类型不能有方法，咋回事呢？先看下面的代码： 123var pet = new String("dog")pet.constructor === String; // trueString("dog").constructor === String; // true 上面代码所发生的事情是一个叫做Auto-Boxing的过程，我觉得翻译成中文是“临时包装”比较适宜。 当您尝试在某些基本类型上调用属性或方法时，JavaScript首先将其转换为临时包装器对象，并访问其上的属性/方法，而不会影响原始属性。 123var pet = "dog";console.log(pet.length); // 3pet === "dog"; // true 在上面的示例中，要访问属性length，JavaScript发生临时包装过程将pet转换为包装器对象，访问完包装器对象的length属性，然后将其丢弃。 这样做不会影响pet（pet仍然是一个原始字符串）。 这也解释了为什么JavaScript在尝试将属性分配给基本类型时不会出问题，因为赋值是在该临时包装器对象上完成的，而不是基本类型本身，比如： 123var foo = 42;foo.bar = "lzm"; // 是在临时包装器对象上完成的赋值foo.bar; // undefined 但原始类型undefined和null，都是没有包装器对象的，当你尝试赋予属性时，它会报错。 12var foo = null;foo.bar = "lzm"; // Uncaught TypeError: Cannot set property 'bar' of null 小结1.并非JavaScript中的所有内容都是对象，应该说所有内容都可以充当对象。 2.JavaScript中有6种原始类型。 3.所有不是原始类型的值都是一个对象。 4.字符串，布尔值和数字可以表示为基本类型，但作为包装器类型时也可以表示为对象。 5.由于名为autoboxing的JavaScript特性，某些原始类型（字符串，数字，布尔值）似乎表现得有点像对象。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈JavaScript中创建对象(Object)]]></title>
    <url>%2F2019%2F05%2F07%2F%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%BB%BA%E7%AB%8B(Object)%2F</url>
    <content type="text"><![CDATA[在这篇文章中我将会着重说明如何创建和调用JavaScript里的对象（Object）。 对象（Object）是什么？在开始介绍如何创建对象前，我们要知道对象是什么。对象（Object）简单地来说，就是一堆「名称- 值」的配对（key - value pairs）。至于可以放入哪些值呢？ 第一种是原生的值（primitive），像是布尔值（Boolean）、数值（Number）或是字符串（String），而在对象当中，我们把这类的值称为属性（Property）。 第二种可以放入的值是对象（Object），也就是在一个对象里面再嵌入一个对象，这种以对象为值的情况我们也把它称作属性（Property）。 第三种放入的值可以是函数（function），在对象的情况下，我们会把这种函数称做方法（method）。在对象中的每一个Property或是Method都会占据电脑当中一个记忆体的位置，在需要使用到的时候，把它们调取出来。 接下来我将介绍三种创建JavaScript里的对象及如何调用的方法： 方法一：使用 [ ]创建对象 创建对象的第一个方法是使用[ ]，[ ]在JavaScript中被称做Computed Member Access： 让我们看一下底下的例子： 1234// 创建对象var person = new Object();person["firstname"] = "Jay";person["lastname"] = "Chou"; 这是利用[ ]创建对象的方法，首先我们创建一个对象，叫做person，接着开始给它「名称-值」配对，例如，firstname是属性的名称，Jay则是它的值；lastname也是属性名称，Chou则是它的值。通过这种方法，我们就可以创建对象里面的各种「名称-值」配对。 调用对象 紧接上面的例子，我们也同样可以利用[ ]来调用已经建立好的对象，[ ]里面如果放的是字符串而不是变量，注意要记得加上引号’像是这样： 12// 调用对象console.log(person["firstname"]); // Jay 另外，如果是通过[ ]来调用对象的话，还有一个特别的地方，就是[ ]内可以放变量，像是这样（当[ ]里面放的是变量时不用加引号&quot;），一样可以调用到对象的值，这个是用种方法二（.）做不到的： 123// 调用对象var id = "lastname";console.log(person[id]); // Chou 方法二：使用点符号 .创建对象 第二种创建对象的方法是使用英文的句点 .，在JavaScript中被称做Member Access，创建的方法如下：我们在刚刚创建的person这个对象里面，再创建一个对象属性，名称为address。其实，我觉得可以把.翻译成中文的「的」，所以这里的意思就是，在person的里面创建一个名称为address的对象；在person的address的country，创建一个值为&quot;China&quot;，以此类推…。 12345// 创建对象person.address = new Object();person.address.country = "China";person.address.city = "Hangzhou";person.address.location = "Xihu"; 调用对象 同样的方法也可以用来调用出该对象的值： 1234// 调用对象console.log(person.address); //&#123;country: "China", city: "Hangzhou", location: "Xihu"&#125;console.log(person.address.country); // Chinaconsole.log(person["address"]["location"]); // Xihu 从上面可以看出，. 和[ ]是可以交替使用的。 方法三：使用{ }创建对象 其实还有在创建对象上有更快的做法，我们可以直接使用{ }，我们可以把上面的代码，改成这样： 12345678910// 创建对象var person = &#123; firstname: "Jay", lastname: "Chou", address: &#123; country: "China", city: "Hangzhou", location: "Xihu" &#125;&#125; 通过这种方式，可以得到与方法二一模一样的结果，调用方法也一致。 搭配函数使用对象 在我们创建好对象后，我们可以搭配函数(function)来使用对象，例如，我先把刚刚创建的对象person，改成叫做jaychou。 123456789var jaychou = &#123; firstname: "Jay", lastname: "Chou", address: &#123; country: "China", city: "Hangzhou", location: "Xihu" &#125;&#125; 接着创建一个名称为SayHI的函数，并且带入我们的对象： 12345function SayHI(people) &#123; console.log("HI" + people.lastname);&#125;SayHI(jaychou); // HI Chou 直接在函数参数的地方创建对象 我们也可以直接在调用函数的同时创建对象，像是这样子： 1SayHI(&#123;firstname: "Jony", lastname: "J"&#125;); // HI J 一开始看到这样的写法可能会觉得很奇怪，但其实这种方式和我们直接在函数的参数里面输入字符串或数值是一样的意思，只是这里是创建一个对象。我们把这种直接在函数的参数中创建对象的方法称做”creating object on the fly”（即动态创建对象）。 其他说明其实使用new Object不是创建对象最好的方式，这点会在之后的文章再作说明。另外，虽然使用[ ]和.都可以拿来创建对象和调用对象，但还是建议尽量使用点符号.作为创建对象和调用对象的方法，这样比较干净简洁，在debug的时候也比较容易。 还有不论你使用的是new Object、”.“、或者直接用”{ }“来创建对象，其实在JavaScript转译之后，本质上做的都是同样的事。它都会将这个对象建立在记忆体中，并创建该对象的属性（property）和方法（method）在记忆体中。 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Object</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】分享7个好用的JavaScript技巧]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%88%86%E4%BA%AB7%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[就像所有其他编程语言一样，JavaScript也有许多技巧可以完成简单和困难的任务。 一些技巧广为人知，而其他技巧则足以让你大吃一惊。 让我们来看看你今天就可以开始使用的七个JavaScript技巧吧！ 原文链接：https://davidwalsh.name/javascript-tricks#comments 数组去重数组去重可能比您想象的更容易： 12var j = [...new Set([1, 2, 3, 4, 4])]&gt;&gt; [1, 2, 3, 4] 很简单有木有！ 过滤掉falsy值是否需要从数组中过滤出falsy值（0，undefined，null，false等）？ 你可能不知道还有这个技巧： 12let res = [1,2,3,4,0,undefined,null,false,''].filter(Boolean);&gt;&gt; 1,2,3,4 创建空对象您可以使用{ }创建一个看似空的对象，但该对象仍然具有__proto__和通常的hasOwnProperty以及其他对象方法。 但是，有一种方法可以创建一个纯粹的“字典”对象： 1234let dict = Object.create(null);// dict.__proto__ === "undefined"// No object properties exist until you add them 这种方式创建的对象就很纯粹，没有任何属性和对象，非常干净。 合并对象在JavaScript中合并多个对象的需求已经存在，尤其是当我们开始使用选项创建类和小部件时： 12345678910111213141516const person = &#123; name: 'David Walsh', gender: 'Male' &#125;;const tools = &#123; computer: 'Mac', editor: 'Atom' &#125;;const attributes = &#123; handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' &#125;;const summary = &#123;...person, ...tools, ...attributes&#125;;/*Object &#123; "computer": "Mac", "editor": "Atom", "eyes": "Blue", "gender": "Male", "hair": "Brown", "handsomeness": "Extreme", "name": "David Walsh",&#125;*/ 这三个点(...)使任务变得更加容易！ Require函数参数能够为函数参数设置默认值是JavaScript的一个很棒的补充，但是请查看这个技巧，要求为给定的参数传递值： 12345678910111213const isRequired = () =&gt; &#123; throw new Error('param is required'); &#125;;const hello = (name = isRequired()) =&gt; &#123; console.log(`hello $&#123;name&#125;`) &#125;;// This will throw an error because no name is providedhello();// This will also throw an errorhello(undefined);// These are good!hello(null);hello('David'); 解构添加别名解构是JavaScript的一个非常受欢迎的补充，但有时我们更喜欢用其他名称来引用这些属性，所以我们可以利用别名： 1234567const obj = &#123; x: 1 &#125;;// Grabs obj.x as &#123; x &#125;const &#123; x &#125; = obj;// Grabs obj.x as &#123; otherName &#125;const &#123; x: otherName &#125; = obj; 有助于避免与现有变量的命名冲突！ 获取查询字符串参数获取url里面的参数值或者追加查询字符串，在这之前，我们一般通过正则表达式来获取查询字符串值，然而现在有一个新的api，具体详情可以查看这里，可以让我们以很简单的方式去处理url。 比如现在我们有这样一个url，”?post=1234&amp;action=edit”，我们可以利用下面的技巧来处理这个url。 123456789// Assuming "?post=1234&amp;action=edit"var urlParams = new URLSearchParams(window.location.search);console.log(urlParams.has('post')); // trueconsole.log(urlParams.get('action')); // "edit"console.log(urlParams.getAll('action')); // ["edit"]console.log(urlParams.toString()); // "?post=1234&amp;action=edit"console.log(urlParams.append('active', '1')); // "?post=1234&amp;action=edit&amp;active=1" 比我们过去用的容易多了！ 多年来JavaScript已经发生了很大的变化，但是我最喜欢的JavaScript部分是我们所看到的语言改进的速度。 尽管JavaScript的动态不断变化，我们仍然需要采用一些不错的技巧; 将这些技巧保存在工具箱中，以便在需要时使用！ 那你最喜欢的JavaScript技巧是什么？ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>编程技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中任何值的prototype到最后都是Object]]></title>
    <url>%2F2019%2F04%2F27%2FJavaScript%E4%B8%AD%E4%BB%BB%E4%BD%95%E5%80%BC%E7%9A%84prototype%E5%88%B0%E6%9C%80%E5%90%8E%E9%83%BD%E6%98%AFObject%2F</url>
    <content type="text"><![CDATA[这篇笔记延伸上一篇所提到的原型（prototype）的概念，说明了在JavaScript当中，所有的类型（字符串、数值、Boolean值、函数、数组、对象）的prototype的最后都是object！ 什么意思呢？ 假设我们现在分别建立对象、函数和数组，直接上代码： 123456789101112131415161718192021// Object var a = &#123; name : 'miqilin' &#125;// function var b = function ( ) &#123; console . log ( 'Hello' ) ; &#125;// Array var c = [ 'A' , 'r' , 'r' , 'a' , 'y'] ;// string var d = 'This is string' ;// number var e = 2 ;// boolean var f = true ; 接着，我们会在Google Chrome 的console 视窗来分别检验这些类型的prototype。 对象（object）我们可以看到a这个对象本身的prototype也是一个对象，在下去就没了（null），也就是Object → Object → null的过程。 而a.__proto__就是对象的原型，打开来看会发现里面有许多内置的方法。 如果我在console中输入a.，则会出现对于对象而言内置的方法： 由于a.__proto__仍然是一个对象，所以如果我输入a.__proto__.的话，会得到除了name一样对于对象可以使用的方法： 函数（function）接着我们来看看函数，根据上面同样的方法得出是function → function → object → null的过程，所以最后还是结束在object。 如果我们想要看函数有哪些内置的方法可以用，我们可以输入b.或b.__proto__.就可以看到了，这里我们就可以看到我们常用的apply , bind ,和call。 数组（Array）对于数组的话则是array → array → object → null的过程。 如果我们要看数组有哪些方法可以用，一样可以透过c.或c.__proto__.来检视： 同样的方法也可以用来检视字符串、数字和Boolean值，有兴趣的通过chrome 来试试看吧！ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之原型与原型链]]></title>
    <url>%2F2019%2F04%2F25%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[JavaScript 也是一门面向对象的语言，ES6之前并没有引入类（class）的概念，像c++ 这种典型的面向对象语言都是通过类来创建实例对象，而JavaScript是直接通过构造函数来创建实例。 所以理解两种继承模式的差异是需要一定时间的，今天我们就来了解一下原型和原型链，在介绍原型和原型链之前，我们有必要先了解一下构造函数的知识。 构造函数构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。 构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。我们先使用构造函数创建一个对象： 123456function Dog() &#123; this.name = '阿黄'&#125;var dog = new Dog()console.log(dog.name) // 阿黄 上面例子中，Dog 就是一个构造函数，我们使用 new 创建了一个实例对象 dog。 原型prototype JavaScript是一种基于原型的语言(prototype-based language)，每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的prototype属性上，而非对象实例本身。看以下代码： 12345function Dog() &#123; this.name = '阿黄'&#125;console.log(Dog.prototype) 那这个构造函数的 prototype 属性指向的是什么呢？是这个函数的原型吗？ 打开 chrome 浏览器的开发者工具，在 console 栏输入上面的代码，你可以看到 Dog.prototype 的值： 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图来表示构造函数和实例原型之间的关系： 那么我们该怎么表示实例与实例原型，也就是 dog 和 Dog.prototype 之间的关系呢，接下来就应该讲到第二个属性： proto 上面可以看到 Dog 原型（Dog.prototype）上有__proto__属性，这是一个访问器属性（即 getter 函数和 setter 函数），通过它可以访问到对象的内部[[Prototype]](一个对象或null)。 为了证明这一点,我们可以在chrome中输入： 12345678function Dog() &#123; this.name = '阿黄'&#125;var dog = new Dog()console.log(Object.getPrototypeOf(dog) === dog.__proto__) // trueconsole.log(dog.__proto__ === Dog.prototype) // true 这里用dog.__proto__获取对象的原型，__proto__是每个实例上都有的属性，prototype是构造函数的属性，这两个并不一样，但dog.__proto__和Dog.prototype指向同一个对象。于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor 指向实例对象倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们在chrome中输入： 12345function Dog() &#123; this.name = '阿黄'&#125;console.log(Dog.prototype.constructor === Dog) // true 所以再更新下关系图： 综上我们已经得出： 12345678910function Dog() &#123; this.name = '阿黄'&#125;var dog = new Dog()console.log(dog.__proto__ == Dog.prototype) // trueconsole.log(Dog.prototype.constructor == Dog) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(dog) === Dog.prototype) // true 原型链在上文我们理解了原型，从字面意思看原型链肯定是与原型有关了，是一个个原型链接起来的么？我们先通过下面的图来观察一下。 解析： obj.prop1：假设我们现在有一个对象，就称作obj，而这个对象包含一个属性（property），我们称作prop1，现在我们可以使用obj.prop1来读取这个属性的值，就可以直接读取到prop1的属性值了。 obj.prop2：JavaScript中会有一些预设的属性和方法，所有的对象和函数都包含prototype这个属性，假设我们把prototype叫做proto，这时候如果我们使用obj.prop2的时候，JavaScript引擎会先在obj这个对象的属性里去寻找有没有叫作prop2的属性，如果它找不到，这时候它就会再进一步往该对象的proto里面去寻找。所以，虽然我们输入obj.prop2的时候会得到回传值，但实际上这不是obj里面直接的属性名称，而是在obj的proto里面找到的属性名称（即，obj.proto.prop2，但我们不需要这样打）。 obj.prop3：同样地，每一个对象里面都包含一个prototype，包括对象proto本身也不例外，所以，如果输入obj.prop3时，JavaScript会先在obj这个对象里去寻找有没有prop3这个属性名称，找不到时会再往obj的proto去寻找，如果还是找不到时，就再往proto这个对象里面的proto找下去，最后找到后回传属性值给我们（obj.proto.proto.prop3）。 虽然乍看之下，prop3很像是在对象obj里面的属性，但实际上它是在obj → prop → prop的对象里面，而这样从对象本身往proto寻找下去的链我们就称作「原型链（prototype chain）」。这样一直往下找会找到什么时候呢？它会直到某个对象的原型为null为止（也就是不再有原型指向）。 官方解释是：每个对象拥有一个原型对象，通过__proto__指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。 举个例子来帮助理解原型链让我们实际来看个例子帮助我们了解prototype chain这个概念，这个例子只是单纯为了用来说明prototype chain的概念，实际上千万不要使用这样的方式编程！ 首先，我们先建立一个对象person 和一个对象jay： 123456789101112var person = &#123; firstName : 'Default' , lastName : 'Default' , getFullName : function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125; , &#125; ;var jay = &#123; firstName : 'Jay' , lastName : 'Chou' , &#125; ; 接着，我们知道所有的对象里面都会包含原型（prototype）这个对象，在JavaScript中这个对象的名称为proto。如同上述原型链（prototype chain）的概念，如果在原本的对象中找不到指定的属性名称或方法时，就会进一步到__proto__这里面来找。 为了示范，我们来对__proto__做一些事： 12//千万不要照着下面这样做，这么做只是为了示范 jay . __proto__ = person ; 如此，jay这个对象就继承了person对象。在这种情况下，如果我们想要呼叫某个属性或方法，但在原本jay这个对象中找不到这个属性名称或方法时，JavaScript引擎就会到__proto__里面去找，所以当接着执行如下的代码时，并不会报错： 1console . log ( jay . getFullName ( ) ) // Jay Chou; 我们可以得到”Jay Chou”的结果。原本在jay的这个对象中，是没有getFullName()这个方法的，但由于我让__proto__里面继承了person这个对象，所以当JavaScript引擎在jay对象里面找不到getFullName()这个方法时，它便会到__proto__里面去找，最后它找到了，于是它回传”Jay Chou”的结果。 如果我是执行： 1console . log ( jay . firstName ) ; // Jay 我们会得到的是John而不是’Default’，因为JavaScript引擎在寻找jay.firstName这个属性时，在jay这个对象里就可以找到了，因此它不会在往__proto__里面找。这也就是刚刚在上面所的原型链（prototype chain）的概念，一旦它在上层的部分找到该属性或方法时，就不会在往下层的prototype去寻找。 在了解了prototype chain这样的概念后，让我们接着看下面这段代码： 123456var jane = &#123; firstName : 'Jane' &#125;jane . __proto__ = person ; console . log ( jane . getFullName ( ) ) ; 现在，你可以理解到会输出什么结果吗？ 答案是”Jane Default” 。 因为在jane这个对象里只有firstName这个属性，所以当JavaScript引擎要寻找getFullName()这个方法和lastName这个属性时，它都会去找__proto__里面，而这里面找到的就是一开始建立的person这个对象的内容。 全代码如下： 12345678910111213141516171819202122232425var person = &#123; firstName : 'Default' , lastName : 'Default' , getFullName : function ( ) &#123; return this . firstName + ' ' + this . lastName ; &#125; &#125;var jay = &#123; firstName : 'Jay' , lastName : 'Chou' &#125;//千万不要照着下面这样做，这么做只是为了示范 jay . __proto__ = person ; console . log ( jay . getFullName ( ) ) ; // Jay Chouconsole . log ( jay . firstName ) ; // Jayvar jane = &#123; firstName : 'Jane' &#125;jane . __proto__ = person ; console . log ( jane . getFullName ( ) ) ; 以上就是目前能总结的全部了，肯定还是有缺陷的地方，后续还会修改完善的。最后再看底下这张图，是否有了更深入的理解呢？ 如果觉得文章对你有些许帮助，欢迎在我的GitHub博客点赞和关注，感激不尽！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之内存泄漏]]></title>
    <url>%2F2019%2F04%2F22%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[在程序运行过程中不再用到的内存，没有及时释放，会出现内存泄漏（memory leak），会造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 而内存泄漏是每个开发人员最终必须面对的问题。 即使使用内存管理语言，比如C语言有着malloc() 和 free() 这种低级内存管理语言也有可能出现泄露内存的情况。 这很麻烦，所以为了减轻编程中的负担，大多数语言提供了自动内存管理，这被称为”垃圾回收机制”（garbage collector）。 垃圾回收机制现在各大浏览器通常采用的垃圾回收有两种方法：标记清除（mark and sweep）、引用计数(reference counting)。 1、标记清除 这是javascript中最常用的垃圾回收方式。 工作原理：当变量进入执行环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 之后再被加上标记的变量将被视为准备删除的变量。 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 2、引用计数 工作原理：跟踪记录每个值被引用的次数。 工作流程： 将一个引用类型的值赋值给这个声明了的变量，这个引用类型值的引用次数就是1。 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1 当引用次数变成0时，就表示这个值不再用到了。 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 但如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，会导致内存泄漏。 12var arr = [1, 2, 3];console.log('hello miqilin'); 上面代码中，数组[1, 2, 3]会占用内存，赋值给了变量arr，因此引用次数为1。尽管后面的一段代码没有用到arr，它还是会持续占用内存。 如果增加一行代码，解除arr对[1, 2, 3]引用，这块内存就可以被垃圾回收机制释放了。 123var arr = [1, 2, 3];console.log('hello miqilin');arr = null; 上面代码中，arr重置为null，就解除了对[1, 2, 3]的引用，引用次数变成了0，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就无事一身轻了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 接下来，我将介绍四种常见的JavaScript 内存泄漏及如何避免。目前水平有限，借鉴了国外大牛的文章了解这几种内存泄漏，原文链接：https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec 四种常见的 JavaScript 内存泄漏1.意外的全局变量 未定义的变量会在全局对象创建一个新变量，对于在浏览器的情况下，全局对象是window。 看以下代码： 123function foo(arg) &#123; bar = "this is a hidden global variable"; &#125; 函数foo内部使用var声明，实际上JS会把bar挂载在全局对象上，意外创建一个全局变量。等同于： 123function foo(arg) &#123; window.bar = "this is an explicit global variable"; &#125; 在上述情况下， 泄漏一个简单的字符串不会造成太大的伤害，但它肯定会更糟。 另一种可以创建偶然全局变量的情况是this： 123456function foo() &#123; this.variable = "potential accidental global"; &#125; // Foo called on its own, this points to the global object (window)// rather than being undefined. foo(); 解决方法： 在 JavaScript 文件头部加上 &#39;use strict&#39;，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。 2.被遗忘的计时器或回调函数 在JavaScript中使用setInterval非常常见。 1234567var someResource = getData(); setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // Do stuff with node and someResource. node.innerHTML = JSON.stringify(someResource)); &#125; &#125;, 1000); 上面的代码表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。 12345678910111213var element = document.getElementById('button'); function onClick(event) &#123; element.innerHtml = 'text'; &#125; element.addEventListener('click', onClick); // Do stuff element.removeEventListener('click', onClick); element.parentNode.removeChild(element); // Now when element goes out of scope,// both element and onClick will be collected even in old browsers that don't// handle cycles well. 对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。其中IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用removeEventListener了。 诸如jQuery之类的框架和库在处理节点之前会删除侦听器（当使用它们的特定API时）。 这由库内部处理，并确保不会产生任何泄漏，即使在有问题的浏览器（如旧版Internet Explorer）下运行也是如此。 3.闭包 JavaScript 开发的一个关键知识是闭包：这是一个内部函数，它可以访问外部（封闭）函数的变量。由于 JavaScript 运行时的实现细节，用下边这种方式可能会造成内存泄漏： 123456789101112131415var theThing = null; var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log("hi"); &#125;; theThing = &#123; longStr: newArray(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;; &#125;; setInterval(replaceThing, 1000); 每次调用replaceThing，theThing得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量unused是一个引用originalThing的闭包（先前的replaceThing又调用了theThing）。someMethod可以通过theThing使用，someMethod与unused分享闭包作用域，尽管unused从未使用，它引用的originalThing迫使它保留在内存中（防止被回收）。需要记住的是一旦一个闭包作用域被同一个父作用域的闭包所创建，那么这个作用域是共享的。 所有这些都可能导致严重的内存泄漏。当上面的代码片段一次又一次地运行时，你可以看到内存使用量的急剧增加。当垃圾收集器运行时，也不会减少。一个链接列表闭包被创建（在这种情况下 theThing 变量是根源），每一个闭包作用域对打数组进行间接引用。 解决方法： 在 replaceThing 的最后添加 originalThing = null 。将所有联系都切断。 4.脱离 DOM 的引用 如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。如果在将来某个时候您决定删除这些行，则需要使两个引用都无法访问，都清除掉。 123456789101112131415161718192021var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text') &#125;; function doStuff() &#123; image.src = 'http://some.url/image'; button.click(); console.log(text.innerHTML); // Much more logic&#125; function removeButton() &#123; // The button is a direct child of body. document.body.removeChild(document.getElementById('button')); // At this point, we still have a reference to #button in the global // elements dictionary. In other words, the button element is still in // memory and cannot be collected by the GC. &#125; 如果代码中保存了表格某一个&lt;td&gt;的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的&lt;td&gt;以外的其它节点。实际情况并非如此：此&lt;td&gt;是表格的子节点，子元素与父元素是引用关系。由于代码保留了&lt;td&gt;的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。 避免内存泄漏在局部作用域中，等函数执行完毕，变量就没有存在的必要了，js垃圾回收机制很快做出判断并且回收，但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。 我们在使用闭包的时候，就会造成严重的内存泄漏，因为闭包的原因，局部变量会一直保存在内存中，所以在使用闭包的时候，要多加小心。 Resources http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156 http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html 如果有别的关于内存泄漏好的资源，可以分享给我嘛谢谢了~ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之内存空间]]></title>
    <url>%2F2019%2F04%2F22%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[对于很多没经验的前端开发来说，觉得JS反正有垃圾回收机制，很容易忽视内存空间的管理，这其实是一个大错误。 直到最近，看了阮一峰老师关于JS内存泄漏的文章，才发现自己以前写的代码，存在许多内存泄漏的问题，再者，因为忽略对内存空间的学习，导致后面很多进阶概念很模糊，比如闭包、作用域链，比如深拷贝与浅拷贝的区别等等。 这里先介绍内存空间，后续还会通过别的文章来介绍深浅拷贝和内存泄漏。 内存空间管理JavaScript的内存生命周期: 1231. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 123var a = 10; // 在内存中给数值变量分配空间alert(a + 90); // 使用分配到的内存a = null; // 使用完毕之后，释放内存空间 在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stack)与堆内存(heap)。 栈与堆栈(stack)是有序的，主要存放一些基本类型的变量和对象的地址，每个区块按照一定次序存放（后进先出），它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小也是确定的，并由系统自动分配和自动释放。 因此，这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间，且寻址速度也更快。 堆(heap)是没有特别的顺序的，数据可以任意存放，多用于复杂数据类型（引用类型）分配空间，例如数组对象、object对象。 其实这样说也不太准确，因为，引用类型数据的地址是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得想要访问对象的地址，然后，再通过地址指向找出堆中的所需数据。就好比书架上的书，虽然已经按顺序放好了，但我们只要知道书的名字，就可以对应的取下来。 变量的存放首先，我们来看一下代码： 12345678910//原始类型都放在栈（stack）里//引用类型都放在堆（heap）里var a = 10;var b = 'lzm';var c = true;var d = &#123; n: 22 &#125;; //地址假设为0x0012ff7f，不代表实际地址var e = &#123; n: 22 &#125;; //重新开辟一段内存空间，地址假设为0x0012ff8cconsole.log(e==d); //falsevar obj = new Object(); //地址假设为0x0012ff9dvar arr = ['a','b','c']; //地址假设为0x0012ff6e 为什么console.log(e == d)的结果为false？可以用下面的内存图解释： 变量a,b,c为基本数据类型，它们的值，直接存放在栈中，d,e,obj,arr为复合数据类型，他们的引用变量及地址存储在栈中，指向于存储在堆中的实际对象。我们是无法直接操纵堆中的数据的，也就是说我们无法直接操纵对象，我们只能通过栈中对对象的引用来操作对象，就像我们通过遥控机操作电视一样，区别在于这台电视本身并没有控制按钮。 变量d,e虽然指向存在堆内存中对象内容的值是相等的，但是它们来自栈内存中变量地址不相同，导致console.log(e == d)的结果为false。 这里就回到了最初的疑问，为什么原始类型值要放在栈中，而引用类型值要放在堆中，为什么要分开放置呢？单列一种内存岂不是更省事吗？那接下来，援引这篇文章里边的解释： 记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题。堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。 比较抠细节的面试题下面的几道是关于内存空间的面试题，虽然不是特别的难，但比较扣细节你稍不注意就错了，我的建议还是老老实实画个内存图再自信的给出正确答案吧。 第一题： 1234var a = 1 var b = a b = 2 请问 a 显示是几？ 上图中可以看出，答案为：1。在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于1，但是他们其实已经是相互独立互不影响的值了。 第二题： 1234var a = &#123;name: 'a'&#125;var b = ab = &#123;name: 'b'&#125;请问现在 a.name 是多少？ 上图中可以看出，答案为：”a”。因为b ={name:&#39;b&#39;}后相当于重新在堆内存中分配内存给对象{name:&#39;b&#39;}，同时栈内存中变量b的指向地址也随之变化，变量a不受影响。 第三题： 1234var a = &#123;name: 'a'&#125; var b = a b.name = 'b' 请问现在 a.name 是多少？ 上图中可以看出，答案为：”b”。我们通过var b = a执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在堆内存中访问到的具体对象实际上是同一个，因此b.name =&#39;b&#39;使堆内存中对象的value值变化，a.name的值也随之变化。 第四题： 1234var a = &#123;name: 'a'&#125; var b = a b = null 请问现在 a 是什么？ 上图中可以看出，答案为：{name: “a”}。因为null为基本类型，存在栈内存当中。因此栈内存中的变量b由之前指向对象的一个地址转变为null，变量a的地址还是指向原先的对象。 最后来个图总结一下： 以上都是通过内存图来解释关于内存空间的知识，如有不合理的地方，希望指正一下~后续还会增加内存泄漏以及深浅拷贝的文章，敬请期待！ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（三）]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三周的学习因为拖延稍微拖了那么几天，而这周的主题又刚好是拖延症与记忆的关系。想要高效地学习，就得学会如何运用和提高自己的记忆能力，而这个过程中，必须先克服拖延症。所以上完这节课，我是该好好改改拖延的老毛病了嘻嘻~ 拖延症的形成我们常在那些让人不太舒服的事情上拖延，这点大家或多或少都会有，那事实结果是，拖延是一个极其重要、影响广泛的坏习惯，生活的方方面面都会受到拖延的影响。 这里要强调一下，很多人觉得能靠自己的意志力去战胜拖延症，其实这是适得其反的。人每天的意志力是有限的，调用意志力去克服一件困难的事，会大量消耗能量。为什么拖延症这么容易就产生，是因为它变成了习惯，习惯是不需要意志力去执行的，它能减少大脑的消耗。所以改变习惯，是改变拖延症的正确方法。 习惯习惯可以分为四个阶段： 第一阶段是提示 (cue) ，是指引发你进行某种惯例的信息来源。比如朋友发来的一条微信信息，或是你看到了待办事项清单上的第一件事等等。 第二个阶段就是惯例 (routine)，是指你对提示做出的惯性反应。比如看到微信信息就觉得要立马停下手头上的事情去回信息；看到待办的事情就想着当下去解决掉它。这里一个好的建议是，你可以通过关掉手机或者断网，或者远离其他占用碎片时间的消遣来隔离那些最具杀伤力的信号，就像你在进行番茄工作法那样。 第三阶段是奖励 (reward)，是指你做完这个惯例之后得到的反馈，它会刺激你不断按照之前的惯例行事。任何一种习惯得以发展和延续都是因为它可以回报我们，它会立即给我们带来些许愉悦感。拖延是极易产生的习惯，因为你将关注点转向更令人愉悦的事情后，随之而来的奖励迅速而又简单。好习惯也是有奖励的，对于克服拖延症来说，想办法奖励好习惯非常重要，只有当大脑开始期待那个奖励，旧习惯才能得到重置，你才能养成新习惯。 研究发现需要给奖励设定时间点。比如说，午休与朋友到快餐店吃饭，或是在下午5点结束主要的任务。这样小而实在的截止期限可以激励你很好地去工作。 第四阶段是信念 (belief) 。改变拖延习惯最重要的一点就是“相信自己能够做到”的这个信念，就好比说必须要摒弃“自己不是学这块知识的料”这一习惯想法，而是要保持自己能够学好的信念并为之做出应有的努力。 应对生活和学习要保持对学习目标的展望，一个很好的办法是每周写下本周关键任务列表，试着在前一晚写下第二日的任务，为什么要在前一晚呢？ 研究表明，这可以让你在潜意识下设法解决任务，从而找到完成方法。 列下任务清单后，每天花一个或几个番茄钟的时间完成它们。如果可以短时间完成的任务，可以采用结果导向，如果不是则关注过程。你不必一定要设置25分钟的番茄钟，比如22分钟也是可行的。 其实，当你能对一定时间内自己可以完成的工作量做出较准确的判断时，你将很快进步。计划好完成目标的时间是合理且最为重要的一点，计划你的休息时间和计划工作时间也同样重要，就是在努力学习之余保持健康休闲时间的人，其表现往往胜过那些一味努力学习的人，所以从现在开始，在努力工作学习之余试着挤出点休息时间吧！ 芭芭拉老师还建议在早晨尽量先开始最重要且最讨厌，最难的工作，至少做一个番茄时间，这证明了极其有效！有时会发生一些意料之外的事，我们当然需要对计划作出改变，但是请记住幸运法则——幸运女神会眷顾努力之人。良好的计划也是努力的一部分，关注学习目标，尽量避免因为偶发事件产生的不确定性。 提高记忆力改变了拖延症的坏习惯后，我们才能更好地利用记忆去学习。我们的大脑天生就擅长记忆不同的空间信息，如果你受邀参观一所陌生的房子 ，你会很快对这个房子有一个大致的概念。例如，整体的家具布局、房间位置、颜色的搭配。只需几分钟，你的大脑就能获取并存储数以千计的信息，甚至几周后，就算你面对是一堵白墙，也仍然能记起许多细节。这一系列空间信息，帮助你在脑中形成地图。如果能够充分发挥天生就很强大的视觉和空间记忆能力，你的记忆潜能就可以得到极大提高。 评判一个人的记忆力好坏，主要看他的长期记忆的能力如何，每个人都可以通过集中注意力使某件事物进入你的临时工作记忆，但从工作记忆进入长期记忆则要满足两个条件。首先它要令人难忘，其次，信息需要复习和回顾。那如何让它难忘呢？比如记F=ma（力=质量x加速度）这个物理公式，老师把它想象成一只戴着飞行员眼镜的驴(a flying mule，英文首字母对应公式的简写)，躺在她老家厨房的水槽里，这样就完成了把抽象概念变成具体图像。这个比喻是不是很无厘头啊哈哈，所以说记忆大师们都是一些幻想家。 记忆宫殿（Mind Palace / Memory Palace）就是这么一个虚拟的，让你储存信息的技巧工具。你可以把熟悉的场景，比如你的家，作为一个放置记忆碎片的地方，然后把要记的抽象的东西，通过联想，组团，转化成具体图像，放在那个场景中的某个地方。而且这个图像不需要阐述你要记住的东西的意义，甚至它越是不合常理，越稀奇古怪，效果就越好。因为大脑通常会滤过习以为常的事物，而对令人惊讶的非典型性事件记忆犹新。 比如购物清单上要买的牛奶、面包、鸡蛋，使用这个技巧你可以想象在你的家中，有一大瓶牛奶在前门，面包掉到了沙发上，裂了的鸡蛋从咖啡桌边缘滴落。也就是说，你可以想象自己穿过一个熟悉的地方，伴随着一些与要记忆的物体相关的难忘画面，这种记忆方式往往记得很牢。 题外话，爱看港剧的朋友，相信对TVB剧《读心神探》中的记忆宫殿印象深刻。第三集中有一段对记忆方法的特写，我们一起来细究一下吧！第三集刚开始的时候讲的就是记忆人名头像。那么记忆人名第一步就是观察人物的长相特征，这个特征可以看人物穿的衣服，戴的装饰品，五官的长相特点，发型，声音的特色等等，找出特点以后第二步就是对人物的名字进行联想。比如有个人叫袁泉，而正好她戴了一对圆圆的耳环，那么就很容易联想到“圆圈”（利用名字的谐音记忆）；又比如有人叫邓超，那么你可以联想到这个和你初识时，眼睛“邓”的超大的痴痴的望着你，只要你这么一想，那么这个人物名字肯定就在你脑海里留下了深刻的印象，虽然有点点毛骨悚然哈哈。 看完上面举得例子也许会有人会问你那些名字和特征都是你事先设想好的，所以才容易发现名字与特征之间的联系，但其实这些都是临时想到的真实案例，其实我们能够观察到的特征是有限的，但是人的想象是无限的，只要你的想法足够好那肯定能找到一个人物的特征与名字之间的完美契合点，这也是记忆法的精髓。 最后，在这一周的课外采访中，受采访者是一名美国记忆比赛的冠军，他是“记忆宫殿”这个技巧的专家。他给大家的学习建议是——保持孩童般的想象力与好奇心，通过新奇的想象来帮助你记忆，让学习变得有趣和容易。大家从现在开始不妨试一试~ 下一节课我们会学习复兴式学习与潜力的关系。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Undefined vs Null]]></title>
    <url>%2F2019%2F04%2F19%2FUndefined%20vs%20Null%2F</url>
    <content type="text"><![CDATA[在JavaScript中，将一个变量赋值为undefined或null，感觉没啥区别，都表示“无”；但在实际应用中，远非如此，这两个之间区别的不明确可能会导致一些问题。 在这篇文章中，我已经简略介绍了undefined和null的特性了。 本文将探讨JavaScript中undefined和null之间的相似和差异之处。 相似性（1）undefined和null在if语句中，都会被自动转为false，加!转换为true，相等运算符对于两者比较是相等的。 12345678910if (!undefined) console.log('undefined is false');// undefined is falseif (!null) console.log('null is false');// null is falseundefined == null// true （2）在JavaScript中，只有六个falsy值，null和undefined都包含在六个falsy值中，当进行逻辑判断时所有的Falsy值均为false。 false 0 ‘’ (空字符串，’’和””一样) null undefined NaN 除了这六个值，JavaScript中的任何其他值都被认为是truthy值，当进行逻辑判断时均为true。 （3）同样在JavaScript中，有六个原始值，null和undefined都包含在这六个原始值中。 Boolean Null Undefined Number String Symbol 既然undefined和null的含义与用法都比较相似，那为什么还要无端增加另外一个值，这不是增加混淆吗？ 历史原因最近，在阅读阮一峰老师的博客文章时，才从历史因素里得到答案！ 1995年JavaScript诞生之初，像Java一样，只设置了null作为表示”无”的值。 根据C语言的传统，null被设计成可以自动转为0。 12345Number(null)// 06 + null// 6 但是，JavaScript的设计者Brendan Eich，觉得这样做达不到自己的预想，其中有两个原因。 首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。 其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计增加了一个undefined。 差异性（1）数据类型区别 undefined类型只有一个值，undefined；null类型只有一个值，null。 也就是说undefined值和null值分别属于不同的数据类型，并且这两个数据类型都只有一个值，使用“typeof”运算符判断类型。 12console.log(typeof undefined); // undefinedconsole.log(typeof null); // object 第一行输出没毛病，正确打印出undefined类型；而第二行打印结果为object，难道null不是null类型？ 原因解释：这是JS一个设计失误，原本正确的结果应该是null，现在只能将错就错，或许以后哪个新版本会修正此问题。 （2）转为数值区别 JavaScript的最初版本为了更好区分这两个值，是这样设定的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 12345var a1= 5 + null;console.log(a1) // 5var a2= 5 + undefined;console.log(a2) // NaN （3）null !== undefined 如上所见，null和undefined不同，但有一些相似之处， 因此，ECMAScript规范规定null不严格等于undefined。 123null !== undefined // truenull === undefined // false 但是，上面也提到了，null松散相等于undefined（相比===的相等程度更低）。 1null == undefined // true 在JavaScript中，==适用松散相等，意味着我们在将它们转换为通用类型后比较两个值。 只要记住null==undefined会返回true，因为它们是类似的值；但null===undefined会返回false，因为它们是不同类型的值。后续也会增加==与===区别的文章，敬请期待。 实际用法但是，上面的区分，在实践中都不常用。实际上，null和undefined被视为几乎同义的，只有一些细小的差别。 null表示一个变量被人为的设置为空对象，而不是原始状态，即该处不应该有值。一般会在以下 2 种场景中出现： （1） 利用document.getElementById(‘XXX’) 寻找一个不存在的元素，将返回null。 1console.log(null == document.getElementById('notExistElement')) // true （2） 作为对象原型链的终点。 1Object.getPrototypeOf(Object.prototype) // null undefined表示一个变量自然的、最原始的状态值，就是此处应该有一个值，但是还没有定义。一般会在以下 4 种场景中出现： （1）声明了一个变量，但没有赋值，就等于undefined。 12var aconsole.log(a) // undefined （2) 函数定义了形参，但没有传递实参，该参数等于undefined。 12345//函数定义了形参 a function f(a) &#123; console.log(a); // undefined &#125; f(); //未传递实参 （3）访问对象上不存在的属性，该属性的值为undefined。 12var a = new Object()a.p // undefined （4）函数没有返回值时，默认返回undefined。 12var a = f()a // undefined 所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。 最后引用玉伯大大对null和undefined的解释： 值类型的“虚无”用undefined，引用类型的“虚无”，用null。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之类型转换]]></title>
    <url>%2F2019%2F04%2F18%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[JavaScript 是一种弱类型或者说是一门动态语言，这意味着你不用提前声明变量的类型，而是在程序运行过程中，运算符会自动将值转换为正确的类型，但也有一些情况需要强制类型转换。 以下我将介绍将各种类型的值，分别转换成数字、字符串或者布尔值（基于ES5规范）。 ToNumber（1）Number() 使用Number函数，可以将任意类型的值转化成数值。 12345678910111213141516171819202122//数值Number(123) // 123 转换后为原值//字符串Number('123') // 123 转换为相应的数值，前提能被解析为数值 //字符串Number('123abc') // NaN 如果不能被解析为数值，则返回 NaN//布尔值Number(true) // 1Number(false) // 0//undefinedNumber(undefined) // NaN//nullNumber(null) // 0//对象Number(&#123;a: 1&#125;) // NaNNumber([5]) // 5 //包含单个数值的数组将返回数字 （2）ParseInt() parseInt函数可用于将字符串转为整数。 123456789101112parseInt('123') // 123parseInt(' 123') // 123 如果字符串头部有空格，空格会被自动去除parseInt(1.23) // 1 如果参数不是字符串，则会先转为字符串再转换parseInt('8a') // 8 如果遇到不能转为数字的字符，就不再进行下去，返回可转的部分parseInt('abc') // NaN 如果第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaNparseInt('+1') // 1parseInt('1000', 10) // 1000 第二个参数（2到36之间），表示被解析的值的进制 如上，Number()函数会整体将目标字符串转为数值，只要有一个字符无法转成数值，目标就会被转为NaN，这点要比parseInt()函数严格很多。 这里要注意一点，就是转换’011’时看起来01结构是8进制，实际上JS经过升级，后面加逗号8才是转为8进制或其他进制。 123parseInt('011') // 11parseInt('011' , 8) // 9 （3）ParseFloat()parseFloat函数用于将一个字符串转为浮点数。 1234567parseFloat('3.14') // 3.14parseFloat('3.14more') // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分parseFloat([]) // NaNparseFloat('AAA') // NaNparseFloat('') // NaN 如果参数不是字符串或空，亦或字符串的第一个字符不能转化为浮点数，则返回NaN 上面代码中，尤其注意的是，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011Number(true) // 1parseFloat(true) // NaNNumber(null) // 0parseFloat(null) // NaNNumber('') // 0parseFloat('') // NaNNumber('1.23A') // NaNparseFloat('1.23A') // 1.23 （4）字符串减0 字符串数字后直接减一个0，可将字符串转为数值。 12345678'1' - 0 // 1'123' - 0 // 123'1.23' - 0 // 1.23'12A' - 0 // NaN 字符串里不是数字，则返回NaN'null' - 0 // NaN 上面代码中，字符串减0操作既有parseInt、也有parseFloat的功能。 还比较省代码数量，在实际应用中会比较常见。 （5）字符串前加+ 字符串数字前加一个+，可将字符串转为数字。 123456789+ '1' // 1+ '1.23' // 1.23+ '.1' // 0.1+ '-1' // -1+ '12A' // NaN 上面代码中，字符串前加+操作也有parseInt和parseFloat的功能。 ToString（1）toString() 12345678910111213141516171819// 数值var a = 123a.toString() // "123"// 布尔值var a = truea.toString() // "true"// undefinedvar a = undefineda.toString() // 报错// nullvar a = nulla.toString() // 报错// 对象var a = &#123;&#125;a.toString() // "[object Object]" 上面代码中，注意一点null、undefined用toString()转为字符串是不行的，而且toString()方法占的字节较多，那么有别的解决方法吗？ （2）加’’(双引号) 当然有，更常用的转为字符串方法为： 123456789101112131415161718// 数值1 + '' // "1" '' + 1 // "1" // 布尔值true + '' // "true"'' + true // "true"// undefinedundefined + '' // "undefined"// nullnull + '' // "null"// 对象var obj = &#123;&#125;obj + '' // "[object Object]"[1, 2, 3] + '' // "1,2,3" 数组，返回该数组的字符串形式 相比toString()方法，这种方法更为常用，且和前后加’’的顺序无关。 （3）String() String函数可以将任意类型的值转化成字符串。 123456789101112131415// 数值String(123) // "123"// 布尔值String(true) // "true"// undefinedString(undefined) // "undefined"// nullString(null) // "null"// 对象String(&#123;a: 1&#125;) // "[object Object]"String([1, 2, 3]) // "1,2,3" 数组，返回该数组的字符串形式 ToBoolean（1）Boolean() Boolean函数可以将任意类型的值转为布尔值。 它的转换规则比较简单：除了以下五个falsy值的转换结果为false，其余的值全部为true。 12345Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // false 包括+0、-0Boolean(NaN) // falseBoolean('') // false 和""一样都为空字符串，这里当成同一种 所以的话，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。 123Boolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true 这里需要注意的是，Boolean()操作对于’’和’ ‘（中间有空格）的结果是不一样的： 12Boolean('') // falseBoolean(' ') // true 因为中间有空格，代表有空格键输入，不算真正意义上的无内容 （2）类型值前加！！ 任何数据类型值前面加两个！！，都可以将其转为布尔类型。 12345!!undefined // false!!null // false!!0 // false !!NaN // false!!'' // false 从Boolean()九个字符变为！！两个字符，省了代码量；转换规则也与Boolean函数一致，故老手多用此类方法。 目前总结的就这么多啦，如有一些遗漏或有误的地方，欢迎大家指正~ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些好用的工具、网站]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。 Evernote：一款神奇的笔记✔如果一款工具能满足你对笔记的所有需求的话，那就是Evernote了，写笔记，列清单，时间管理，录音，工作同步，手机和电脑端都可下载… ✔如果你还没用过，推荐你现在关闭答案去应用市场下载一个，相信我你都会爱上它的。 免费人工智能PPT制作平台：beautiful.ai✔这个国外的黑科技网站，网站提供很多超赞的板式，我们将文字放进去，AI智能帮助我们制作PPT。真的让我这个一做PPT就头疼的人，感到开心！ ✔没广告还免费！ 录制GIF工具 ：GifCam✔录制动图对许多人来说也算是必备的东西了。 ✔窗口化录屏，也可以直接设置全屏幕录制，录制完毕后直接保存为 GIF 图片，软件大小不超过 2M，简直太方便太良心了~ 截图/贴图神器：Snipaste✔它在我心中绝对可以堪称神器了！令人惊叹不仅仅是它的强大截图功能，而是它的贴图功能也实在是太好用了！ 设计网址导航网站：牛大拿✔精选国内外优秀的UI设计网站,设计参考文章与免费的UI设计素材与资源，每日更新Dribbble精选内容、Behance精选内容、站酷精选内容、UI中国… ✔一定也有设计师不知道这个网站滴。 国外设计师常用网站：Dribbble✔通过 Dribbble，你可以浏览许多创意设计，它们出自世界各地的个人设计师、设计团队以及设计公司。 ✔这些作品并不仅限于网页或手机 app 设计，还有图片设计、品牌设计、动画、插图、平面艺术等等。 国内设计师常用网站：花瓣网✔花瓣网算是一个国内比较好的素材采集网，平时想要找的各种类型的图片素材在花瓣都能采集到，比如平面、漫画、摄影、UI等等。 ✔而且花瓣的素材普遍都很有设计感和时尚感，很适合年轻一代做设计。 设计师和开发常用网站：iconfont.cn✔阿里巴巴旗下的免费icon百科网站，可免费下载矢量源文件，选择时可以打包所有你感兴趣的放在购物车，Download时还可以选择颜色和大小,很贴心有木有！同时支持下载开发用代码。 ✔比如搜索关键词“love”看到的结果： 壁纸天堂：Wallhaven✔图片量大而且还高清，分类清晰(人物/风景/动画)。 ✔相比一些图库不全，广告遍地，收费下载的壁纸网站，免费下载的wallhaven简直就是业界良心。 在线制作流程图网站：ProcessOn✔ProcessOn在线支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 ✔轻松绘制，基本上是0难度上手。 在线生成图片链接网站：SM.MS✔SM.MS图床网站只需上传一张本地的图片，点击生成链接即可，操作简单快捷。 ✔永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式。 Listary：电脑文件秒搜+路径直达✔软件体积非常小，全局本地搜索的便捷工具，设置热键后，能在任何环境下调出窗口搜索文件，如我设置的是’Win+F’，想要找某文件时按下Win+F调出小长条搜索框就能进行实时搜索，非常便捷。 ✔相信你用了后会觉得它很高效的。 v9porn✔看到上面的标题，想必大多数人都知道了吧嘿嘿嘿 ✔那这个项目就不多介绍了，自行体会，体验好的话就默默点个赞哦 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之类型判断]]></title>
    <url>%2F2019%2F04%2F13%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[类型判断在 web 开发中较为常见，简单的有判断数字还是字符串，判断是数组还是对象稍微复杂一些，再复杂一点的有判断日期、正则、错误类型，再再复杂一点还有比如判断 plainObject、空对象、Window 对象等等。 通过本文，我将尝试概述Javascript中类型判断的几种方法（基于ES5的规范）。 typeoftypeof判断类型方法算是我们最最常用的了，直接上代码： 123456typeof 3 // "number"typeof "abc" // "string"typeof &#123;&#125; // "object"typeof true // "boolean"typeof undefined // "undefined"typeof function()&#123;&#125; // "function" 以上这些类型都比较正常，直到： 1typeof null // "object" 这显然是一个错误。 这可能会在以后的ECMAScript哪个版本中修复，返回值将为“null”。 除此之外 Object 下还有很多细分的类型，比如 Array、Date、RegExp、Error 等。如果用 typeof 去检测这些类型，举其中几个例子： 12345678var array1 = []var array2 = new Array();var date = new Date();var error = new Error();console.log(typeof array1); // objectconsole.log(typeof array2); // objectconsole.log(typeof date); // objectconsole.log(typeof error); // object 因此，typeof非常善于区分不同类型的原始值，并区分它们和对象，但在区分不同类型的对象（包括数组和null）时完全没用，那这该怎么区分？有没有更好的解决方法呢？ Object.prototype.toStringJS作为一门愈加成熟的语言，解决方法当然有！嘿嘿~这就是Object.prototype.toString！ 那 Object.protototype.toString看起来是一长串字母，看起来比较复杂诶~为了讲清楚，在toString方法被调用时,是会执行下面的操作步骤的： 如果this的值为undefined,则返回”[object Undefined]”. 如果this的值为null,则返回”[object Null]”. 让O成为调用ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 最后返回由 &quot;[object &quot;和 class 和 &quot;]&quot; 三个部分组成的字符串. 通过规范，我们至少了解了调用 Object.prototype.toString 最终会返回一个由 &quot;[object &quot; 和 class 和 &quot;]&quot; 组成的字符串，而 class 是要判断的对象的内部属性。 看这些规范还是一知半解的状态吧，直接上代码直观一点： 1234567console.log(Object.prototype.toString.call(3)) // [object Number]console.log(Object.prototype.toString.call([1, 2, 3])) // [object Array]console.log(Object.prototype.toString.call(&#123;&#125;)) // [object Object]console.log(Object.prototype.toString.call(null)) // [object Null]var date = new Date();console.log(Object.prototype.toString.call(date)) // [object Date] 我们可以看到这个 class 值其实就是识别对象类型的关键！ 因此我们可以用 Object.prototype.toString 方法识别出更多类型！那到底能识别多少种类型呢？那还是看代码数个数吧~嘿嘿 1234567891011121314151617181920212223242526272829303132var number = 1; // [object Number]var string = '123'; // [object String]var bool = true; // [object Boolean]var unde = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123;&#125; // [object Object]var array = []; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a()&#123;&#125;; // [object Function]function checkTypes() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(Object.prototype.toString.call(arguments[i])) &#125;&#125;checkTypes(number, string, bool, unde, nul, obj, array, date, error, reg, func)//打印出[object Number][object String][object Boolean][object Undefined][object Null][object Object][object Array][object Date][object Error][object RegExp][object Function] 除了以上 11 种之外，还有3种： 1234567console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]function a() &#123; console.log(Object.prototype.toString.call(arguments)); &#125;a(); // [object Arguments] 这里看我们至少可以识别14 种类型，而[[class]] 属性数量至少有 12 个。 写个类库利用Object.prototype.toString判断类型的方法来写个类库吧，此类库来自(Axis.js)[//github.com/toddmotto/axis]:123456789101112131415161718192021222324252627282930313233(function (root, factory) &#123; // 判断是否使用了模块 if (typeof define === 'function' &amp;&amp; define.amd) &#123; // 使用AMD模块 define(factory); &#125; else if (typeof exports === 'object') &#123; // 使用CMD模块 module.exports = factory; &#125; else &#123; // 没有使用模块，放在全局下 root.axis = factory(); &#125;&#125;)(this, function () &#123; // 严格模式 'use strict'; var exports = &#123;&#125;; // 将字符串转为数组 var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' '); // 判断类型 var type = function () &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125;; // 遍历types，为exports对象添加isArray、isObject...等方法 for (var i = types.length; i--;) &#123; exports['is' + types[i]] = (function (self) &#123; return function (elem) &#123; // type.call(elem)将type方法里的this指针指向elem return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return exports;&#125;); 使用方法也比较简单，直接上代码： 12345678910axis.isArray([]); // trueaxis.isObject(&#123;&#125;); // trueaxis.isString(''); // trueaxis.isDate(new Date()); // trueaxis.isRegExp(/test/i); // trueaxis.isFunction(function () &#123;&#125;); // trueaxis.isBoolean(true); // trueaxis.isNumber(1); // trueaxis.isNull(null); // trueaxis.isUndefined(); // true 考虑到实际情况下并不会检测 Math 和 JSON，而且上面这种方法也检测不了这两种类型，所以去掉这两个类型的检测。同时也不能识别自定义对象类型。 constructor当 typeof 也有无解的时候，那么我们是否还有其他好的方法来判断一个变量是自定义对象类型呢？ 我们知道，javascript 的所有对象都有一个 constructor 属性，这个属性可以帮我们判断 object 数据类型，直接上代码： 12345678910//alert(1.constructor); //报错 数字常量无 constructor 属性 var num = 1; console.log(num.constructor == Number); //true console.log("miqilin".constructor == String); //true var str = "miqilin"; console.log(str.constructor == String); //true var obj= null; console.log(obj.constructor); //报错，null 没有 constructor 属性 var none = undefined; console.log(obj.constructor); //报错，undefined 没有 constructor 属性 可以看出，数字型常量，null 和 undefined 都没有 constructor 属性。 之前以为到这就全部分析完了，看了多篇外文才知道原来还有可挖掘的东西，来看下面的代码： 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj.constructor == Cat); //false ？？因为 Cat.prototype不在obj的原型链上 console.log(obj.constructor == Animal); //true 理解 原来对于原型链继承的情况，constuctor 也不怎么好用了。那怎么办呢？ instanceof嘿嘿~原来还有一种方法可以解决这种困境，那就是 instanceof。instanceof 运算符会告诉您对象是否是某种类型的实例， 这里所谓的“类型”其实就是构造函数。直接上代码： 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj instanceof Cat); //true 毫无疑问 console.log(obj instanceof Animal); //true 可以理解 instanceof 适用于所有原生类型： 1234[1, 2, 3] instanceof Array // true/abc/ instanceof RegExp // true(&#123;&#125;) instanceof Object // true(function()&#123;&#125;) instanceof Function // true 但是 instanceof 不适用于原始类型：字符串，数字，布尔值： 1233 instanceof Number // falsetrue instanceof Boolean // false'abc' instanceof String // false 所以这里constructor又有点优势了，可以适用于原始类型number，string和boolean的判断（constructor小节有例子）。 小结虽然检查任何一种特定类型真的不是那么难，但你可能不得不在此过程中做出很多选择，势必会引起一些混乱。因此，了解所有不同的选项会有所帮助，以下是对四种方法可识别类型的简单概括： typeof： 可以是标准类型（Null 除外） 不可识别具体的对象类型（Function 除外） Object.prototype.toString： 可是识别标准类型及内置对象类型（例如，Object, Date, Array） 不能识别自定义对象类型 constructor： 可以识别标准类型（Undefined/Null 除外） 可识别内置对象类型 可识别自定义对象类型 instanceof： 不可判别原始类型 可判别内置对象类型 可判别自定义对象类型 类型转换的图形化表示（其中红色单元格表示该判断方式不支持的类型）： 还有更复杂的判断比如 plainObject、空对象、Window对象、类数组对象等，还未涉及，后续也会增加。 敬请关注！ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之数据类型]]></title>
    <url>%2F2019%2F04%2F12%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript提供了不同的数据类型来保存不同类型的值，主要有两种类型的数据类型：原始类型和引用类型。 原始类型（值类型） Undefined undefined Null null Boolean true String &#39;hello&#39; Number 123 Symbol(这里先不做介绍) 引用类型（对象类型） Object：由以上几种基本类型组成，而且对象里面还可以包含对象 123456var obj = &#123;&#125;;&lt;!-- 原始类型变量的包装类型如下 --&gt;var bool = new Boolean(true);var str = new String("hello");var num = new Number(1);var obj0 = new Object(); 如MDN所讲，JavaScript 是一种弱类型或者说是一门动态语言。这意味着你不用提前声明变量的类型，而是在程序运行过程中，类型会被自动确定。 当然，原始类型和引用类型会有一些区别： 原始类型的值是直接储存在栈（Stack）内存中的，而引用类型的数据是把 Heap内存地址存在 Stack 里，所以对已引用类型的复制其实只是复制了相同的地址而非实际的变量值。 Number为整型直接量，浮点型直接量，十六进制直接量（0x-)，八进制直接量（0-）等 出现场合： 1024 3.14 1.2e5 0x10 0o377 除以上常规数字外，还有所谓的“特殊数值”，它们也属于这种数据类型：Infinity，-Infinity和NaN。 StringJavaScript中的字符串必须用引号括起来，有3种类型的引号 出现场合：123var str = "Hello, world!"; //双引号var str = 'Hello, world!'; //单引号var str = `Hello, world!`; //反引号 双引号和单引号是“简单”引号，它们在JavaScript中没有区别，但由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。 反引号是“扩展功能”的引用，允许我们通过将变量和表达式包装在$ {…}中来将它们嵌入到字符串中，比如：1234567var name = "miqilin";// embed a variableconsole.log( `Hello, $&#123;name&#125;!` ); // Hello, miqilin!// embed an expressionconsole.log( `the result is $&#123;1 + 2&#125;` ); // the result is 3 加反引号后计算$ {...}内的表达式，结果会成为字符串的一部分。 我们可以在其中放置任何东西：像名称这样的变量或像1 + 2这样的算术表达式或更复杂的东西。 但请注意，这只能在反引号中完成。 其他形式没有这种嵌入功能！1console.log( "the result is $&#123;1 + 2&#125;" ); // the result is $&#123;1 + 2&#125; (双引号不生效) Boolean布尔类型只有两个值：true 和 false 出现场合： 条件语句导致的系统执行的隐式类型转换 if(隐式转换){} 字面量或变量定义 var bool = true; 也出现在比较的结果 ： 123var isGreater = 4 &gt; 1;console.log( isGreater ); // true (the comparison result is "yes") Nullnull 出现场合： 获取不存在的对象 document.getElementById(&#39;not-exist-element&#39;) 在JavaScript中，null不是“对不存在的对象的引用”或者像其他语言中的“空指针”。它只是一个特殊值，代表“无”，“空”或“未知值”。 Undefinedundefined的含义是“未赋值” 出现场合： 变量声明了，但没赋值 var obj; 获取对象不存在的属性 var obj = {x: 0}; obj.y; 无返回值函数的执行结果 function f(){}; var obj = f(); 调用函数时，应该提供的参数没有提供 function f(i){console.log(i)}; f(); void(expression) null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 1undefined == null // true 但也有一丝区别，区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。12Number(undefined) // NaN5 + undefined // NaN Object属性集合 出现场合：1234567var obj = &#123; name: "miqilin" &#125;;var obj = new Cat();var obj = new function() &#123; this.sound = "wow";&#125; 但请注意，我们还没有提到过Array，Date，甚至是函数，因为正式地说，它们都是对象类型。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（二）]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。 Part1 组块什么是组块什么是组块 (chunk) ？对于绝大多数人来说这是一个全新的概念，看上去并没有什么意义，就像一堆乱糟糟的拼图。从神经科学的角度来看，组块就是通过应用或意义连接在一起的信息碎片。而在不加理解或不关注上下文的情况下，单纯的死记硬背并不能帮助你理解其内涵和你所学概念之间的关联，那么这个概念拼图就没有可以拼合的边缘，无法关联到其他的拼图碎片上。 当你全神贯注于某件事上，就好像你的脑子里有一只章鱼。这只注意力的章鱼会在必要时把它的触须穿过工作记忆的四个插槽，从而帮助你把分布于大脑不同区域里的信息联系起来。 这和发散模式下的随机连接不同，创建组块的过程中，它需要集中注意力将大脑的不同部分连接起来，专注模式下将不同的想法联系在一起。但在你很紧张时，你的注意力章鱼会失去一些连接能力，这也是为什么在你生气、紧张、害怕的时候，大脑似乎不能专注工作。 在任何领域获得专业知识的第一步都是先创建出概念组块。这种根据意义将信息碎片拼接起来的思维跃进，可以运用于所有人类能够掌握的领域，如运动、音乐、舞蹈等。最重要的是专注的训练和重复可以建立强的记忆痕迹，从而帮助你创建组块。专业的培养都是一小步一小步的，这个过程中，小的组块可以形成更大的组块。随着你对学习材料的理解越来越深入，所有的专业知识都只是更有创造性的见解的铺路石。 但仅仅通过练习和重复来创建组块，并不能使你得心应手并有创造力地运用它们。组块化可以让大脑工作得更有效，一旦你把某个想法、概念或动作组块化后，你就不再需要记住有关的全部细节，你只需要知道最主要的那个概念就行了，也就是只需要记住组块。这就像清晨起床穿衣服，你只需要一个简单的想法——“我要穿衣服”， 但细想你会发现这个简单想法的组块所包含的活动是非常复杂的。 怎样形成组块如果你是吉他初学者，你想学习弹奏一首有难度的吉他曲，你脑中关于这首曲子的神经表征可被看作是一个巨大的组块。首先你会听这首曲子、看别人弹奏这首曲子，还要从持琴姿势学起。和大多数技能一样，你通常需要将曲子的每一小部分转化为一个小的神经组块，再将这些小组块组合起来形成大组块。经过一段时间的练习，当你掌握了很多乐段之后，你就能流利地弹奏一个乐段了。 对于数学和科学的相关学科来说，关上书本检测自己，能够帮你检验那些你以为已经明白了的问题，并且加快你的学习速度。当你能独自完成某件事时，你才是真正掌握了它。许多事情都是这个道理，就像你只是看别人画画，并不代表你也能画出来，仅仅听别人唱歌并不能使你拥有同样的唱功和洪亮的嗓音。某件事如果你只是在看，或者就算理解了如何去做，也不代表你能真正做到。只有在你自己实际操作和完全掌握的情况下才能建立起神经模型。 组块化的第一步：就是对你想要组块化的信息全神贯注。如果你正开着电视，或是每隔几分钟就检查、回复手机上的消息，这些都会增加你建立组块的难度，因为你的大脑并没有完全投入到新信息的组块化中去。 组块化的第二步：要求你对建立组块的对象有基本的了解。无论是理解概念性的知识，还是寻找故事中不同情节间的关联，通常我们都可以自然而然地领会所学内容的大意。 组块化的第三步：是获取背景知识。不断重复和练习解决相关的或不相关的问题，这样你不仅知道如何使用组块，还明白应该什么时候使用。这样做能帮你认识新建立的组块是如何融入整体知识框架的。 最后第四步，练习能帮你拓宽组块连接的神经网络，并确保它们不仅牢固，还能通过不同途径访问。正如下图所示，学习由两部分组成，自上而下的认识以及由下至上的组块化。 在由下至上组块化的过程中，练习和重复能够帮助你建立和强化每一个组块，这样你就可以在需要它的时候使用它。当自上而下的方法能够让你清楚地看到你正在学习什么以及它适用于哪里。就完全掌握知识而言，这两个过程都非常重要。而背景认识就是这两个过程的交汇处，背景认识意味着学会在特定的时候使用正确的方法。 通常在真正的阅读之前，快速浏览书中某一章的图片以及小标题，能够帮助你知晓大意。听那些有严谨层次结构的课程，可以帮你弄清楚应在哪里建立组块以及如何把不同组块联系起来。一旦完成了这些，再了解具体的信息，那么就算遗漏了一些让你疑惑的部分，你依然可以理解主要部分。 总的来说，最好在精神高度集中的时候建立组块，理解基本的含义后，通过练习来真正掌握知识，并对情境有个大致了解，是建立组块的基本步骤。快把“组块”融入到你正在使用的学习中去吧！ 能力错觉这一小节来介绍一些让学习走上正轨的基本理念。 1.回顾的重要性 学习书本或资料时，最常见方法之一就是反复阅读。不过心理学家Jeffrey Karpicke证明，这种方法的成效远不及另一种简单技巧——回顾。也就是阅读材料后，移开视线，看看你能回忆起多少内容。 Karpicke发表在《科学》杂志上的研究提供了可靠证据。先让学生们学一篇科技文章，然后通过尽力回忆其中信息来巩固练习；接着，让他们重读并再次回想。结果相同时间内仅用回顾法练习的学生较使用其他学习方法的学生而言，对材料的掌握更为全面深入。其他学习方法包括反复阅读资料，或者绘制可以加强学习材料之间联系的思维导图。学生通过正式考试或非正式自测都证明了回顾法有助于学习。这给了我们一个重要提示，即在回顾知识时，我们并非机械地复述，而是在通过回顾这个过程加深理解。这也有助于我们形成知识组块，就好像回忆过程帮助我们在神经上嵌入了“钩子”，以便我们串联起前后知识。 比起被动重复阅读，回顾——即在心里检索关键概念——可以使你的学习更加专注高效，只有隔上一定时间后再重读才会有效果，因为这样，重读就更像是间隔重复练习。 2.能力的错觉 你该明白你才是要解决问题和掌握概念的人，如果你看到某个习题答案后告诉自己，“哦，我明白他们为什么这么做了！” 那么这个答案并不真正属于你，因为你没有真正把这些概念嵌入自己潜在的神经回路中去。这是一种学习中最为常见的自欺欺人式错觉。如果你想要很好地掌握材料以在考试中取得好成绩，并从中创新，就必须让这些知识在你脑海里生根发芽。 另一个类似情况就是做笔记和注释。做笔记时高亮和下划线必须要谨慎，否则不仅没有效果还容易产生误导。在空白处写笔记总结关键概念也被证明是一种很更好的办法。 Karpicke的研究还发现，学生们喜欢重读笔记或课本的原因是，当他们面前打开着课本、笔记或谷歌时，会误以为这些知识同样在他们的脑海里，然而事实却并非如此。因为看书比回顾做起来简单，学生们会陷入一种自欺欺人的错觉。事实上，这种学习方式效率很低。 3.自测与犯错 能力的错觉提醒我们，在学习资料上花太多时间并不能保证你真的懂了。而自测是一种极其有用的办法，来确保你是真的学会了，而不是自欺欺人的错觉。从某种意义上来说，这就是回忆在发挥作用。 让你发现自己是否真的掌握一个概念，犯错实际上是件好事。因为你之后就会想要避免重复犯错，所以实际考试前，在自测中犯的错是很有价值的，因为它们能让你一点点弥补思维漏洞。犯错可以纠正思考方向，让你学得更好、做得更好。 4.多场合回顾 回顾是一种有效工具，而在常规学习场所以外回顾知识则会帮助你加深对知识的理解。通过在不同物理环境下回顾和思考知识，你会脱离对给定场所的依赖，这会帮助你避免由于考试与学习场所的不同而产生的问题。 Part2 看到全局是什么激励了你？你会发现当学的东西并非自己真正喜欢的东西时，学习是非常困难的；而学习自己真正感兴趣的东西的时候，一切都变得非常简单，那这是为什么呢? 你的大脑有一套神经递质的广泛投射系统，它加载的不是经验本身的内容，而是信息的重要性以及对未来的价值。神经递质是可以影响神经元如何回应其他神经元的化学物质。今天我们将要谈谈它们其中的三种，乙酰胆碱、多巴胺和血清素。 乙酰胆碱影响专注学习和集中注意力。当你注意力高度集中的时候，这些乙酰胆碱神经元就会广泛地投射出来，并且激活环路来控制突触可塑性，从而形成新的长期记忆。 多巴胺信号与意料之外的奖励相关。当接受到一个毫无预期的奖励时，这些神经元将分泌出多巴胺，多巴胺的信号将广泛投射，这会对学习产生强有力的影响；同时也会影响决策，甚至是感官输入的价值所在，它控制着我们的动力。比如番茄工作法中的设置奖励就是给自己的多巴胺神经元加油。 血清素影响社会生活和冒险行为。它可以有力地影响你的社交生活。在猴子部落中的雄性首领有着最高的血清素分泌水平，而位列最末的公猴，其血清素水平则最低。血清素也与风险行为有着紧密的联系，在那些血清素低的猴子身上往往能观察到更多的冒险行为。服刑犯人中，因暴力犯罪而入狱的是社会中血清素分泌活动最低的群体之一。 情绪也可以强烈地影响你的学习。你自己应该深有体会，情绪曾一度被认为与认知互不影响，然而近期研究显示，情绪、感觉以及注意力互相交织，并与学习和记忆力互相影响。 对于成功的学习来说，情绪及神经递质系统比感知和动作要反应迟缓，但却同等重要。 组块库的价值将新的组块和原有组块结合起来的能力，体现在很多历史的创新变革中。比如比尔·盖茨与其他工业领袖会留出长达一周的阅读周期，以便在一段时间内掌握多种不同想法，把新鲜想法留在头脑中，与未忘记的想法进行自我交流，可以形成创新性思维。 你的组块库越大，运用越熟练，无论学什么科目，你都将能够更轻易地解决问题。组块化并非创新灵活度所需要的全部，但是它是重要的一环。组块还可以帮助你理解新概念。这是因为当你理解一个组块时，你会发现这一组块能以令人惊讶的方式与相似的组块联系起来。不仅在同一领域中如此，在截然不同的领域中也是这样。这就是所谓的知识迁移(transfer)。 你建立每一个组块，它就为你补上知识拼图的一块，但如果你不训练变大的组块，它们就会保持模糊的状态，你要学习的东西拼到一起就会更为困难。建立组块库就是在训练你的大脑，不仅要认出一个特定的概念，还要识别概念的类别，以便你能够自如地知晓如何快速处理你遇到的问题。你将开始看到一些为你简化解决方法的模式，并很快发现不同的解决方法就潜藏在你的记忆边缘。 有两种途径解决问题，一是顺序性地，一步步推理；二是通过整体性的直觉。顺序性思维涉及到专注模式；而直觉通常需要创造性的发散模式来联系不同的想法。大多数较难的问题和概念都是通过直觉来理解的，因为新的想法和你熟悉的领域相去甚远。发散模式是半随机地进行连接，这意味着它们带来的解决方法，应该由专注模式进行小心验证。直觉性的理解不是永远正确的，你大概会想无论你在学什么，仅在单一的部分或章节里就有那么多问题和概念，根本没法全学会。这时机遇定律就发挥作用了，幸运女神会眷顾努力之人。专注于你正在学习的单元，你会发现一旦你把第一个问题或概念放进组块库，不论那是什么，第二个概念的进入就会容易一些，然后第三个概念也就更容易，这并不都那么简单，但会越来越容易。 过度学习、思维定势、交替学习当你在学习一个新单词、一种新概念或新的问题解法时，你需要在同一学习阶段内反复练习。一定的练习是必要且有用的，但在完全掌握此阶段的所有内容后继续学习训练，就是所谓的过度学习。过度学习在有些场合是有意义的，比如对网球发球、钢琴协奏曲演奏可能非常重要，它能在紧张的时候，帮助其行为自动化。但仍要警惕在单一学习阶段的重复性过度识记，研究表明，这可能会对宝贵的学习时间造成浪费。 一旦你在某一阶段学会了一个基本概念，在这段时间不断地巩固它，并不能加强你所期许的长期记忆联系。学完一段时间之后再复习是更好更有用的，这可以加强并深化你的组块化神经模式。但请注意，重复你已经掌握的东西非常容易，而这可能会造成能力错觉，让你误以为自己已掌握了所有材料，但其实你只掌握了简单的部分。所以，你应该均衡学习，把精力集中在你认为困难的部分。专注于学习的困难部分称为刻意训练 (deliberate practice) ，这种刻意训练 (deliberate practice) 通常是好学生与优秀学生的差别所在。 这些与思维定势(Einstellung) 的概念有关。一个已经形成并加强的神经模式可能阻碍你发现更棒的解决方案。思维定势在这张弹珠脑图里就表现为，你最初的想法向大脑上方移动，而解法的思维模式则位于下方。 密集的专注模式以及先前构造的思维模式，会形成惯性，阻止你走向一个可能发现解决方法的新区域。你可以把思维定势想像为一个路障，而它是你最初的想法所造成的，这种错误的方式在运动和科学学科中就很容易发生。因为有时你最初”发生什么”或”该去做什么”的直觉是有误导性的，在学习新事物时，你必须摒弃错误的旧思想和方法。 学生学习时会犯的一项重大失误是，在学会游泳前就跳入水中。换句话说，他们盲目地开始做作业，不看书、不上课、不看在线课程，或甚至不与熟识此方面的人交谈。这种学习方法只会失败。就像在放任思想在一个专注模式的弹珠器里跳来跳去，而完全不考虑解法到底在哪里。在学习和生活中，理解如何得到真正的解决方法很重要。掌握一门新学科不仅要学习基础组块，更要学会如何选择和应用不同的组块。最佳的学习方法是，在需要不同技术和策略的问题中来回切换、练习，这就是所谓的交替学习。 交替学习非常重要，你需要让自己的大脑习惯这种思想，即仅仅知道如何使用特定的概念、方法或解题技巧是不够的，你也需要知道何时去使用 ，要贯彻交替学习的思想。这样你才能脱离只会练习和重复，而开始学会独立思考。当你在一个学科内交替学习，你就开始在这个学科内发展创造力了。当你在多个不同学科间交替学习，你就能更容易地在不同领域的组块间创造联系，这能进一步提高你的创造性。当然，在不同领域间发展固定知识组块需要时间，所以有时需要取舍。成为几个领域的专家，意味着你可以将一个领域的新思想引入另一个领域，但这也可能意味着，你在某个领域的专业知识 并不如专攻一个领域的人那么深厚。反过来，如果你只专研一个学科，你可能对它有很深刻的理解，但也变得只习惯某种思考方式，这种根深蒂固的思考模式，让你很难把握新思想。 科学哲学家Thomas Kuhn发现，科学中大部分的方式转变都是由年轻人，或者之前学习其他学科的人所提出的。他们不那么容易陷于思维定势，不会被先前的专业训练阻碍思想。有句老话说道，科学会随着每个葬礼的进行而进步，因为葬礼意味着根深蒂固的旧思想的流逝。 最后我转帖一个别人在元学习课程里用拼图的理念去学编程的文章，作为一个实例参考: 元学习课心得和实践（一）——八小时搞定《JavaScript DOM》 下一节课我们会学习怎样应对拖延症，以及拖延症和记忆的关系。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客中遇到的一些"事"]]></title>
    <url>%2F2019%2F04%2F03%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E2%80%9C%E4%BA%8B%E2%80%9D%2F</url>
    <content type="text"><![CDATA[我写的这篇文章已经详细讲解了怎样利用hexo搭建GitHub个人博客，自从入了hexo搭建博客的坑后，发现hexo真的是巨TM好用， 配置好以后对我最大的方便就是想改就改，想删就删，一条 $ hexo g -d 命令搞定了事，支持 Markdown ，还支持非备案域名绑定，开心！ 搭建过程中也并非一切顺利，稍微不注意就出现bug，接下来罗列了几条我搭建过程中所遇到的一些“事”及解决办法。 仓库的名字仓库的名字的正确格式应该是github用户名.github.io，比如说，如果你的github用户名是test，那么你就应该新建test.github.io的仓库（必须是你的github用户名，这里再强调一遍，其它名称无效，之前因为没仔细看，随便起了个名字，果断报错）。 首页文章内容部分展示我用的是next主题，默认会把所有文章内容都展示出来，这可不简洁美观。所以查了一下，有一个小技巧，就是在你觉得要展示在首页的Mrakdown文件内容文字后面添加&lt;!--more--&gt;即可。例如：123456789101112---title: HTML、CSS、JS中unicode字符的处理 ---# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； GitHub Pages绑定域名后每次hexo d都会失效在GitHub Pages绑定域名之后，发现每次hexo d后，域名网址都会报错404，又要重新部署，就有点太麻烦了。 搞了很久还是不行，后面在网上和群里问出，到这里域名绑定并没有结束，还差关键一步： 具体就是在Hexo目录里的source文件下添加一个名为CNAME的文件，注意这个文件是没有后缀的，千万不要设置成.txt文本文件，文件的内容就是域名，格式如： luozongmin.com 添加后重新部署文件到github，这个时候再试，应该就成功了。 创建分类页面添加一个分类页面，并在菜单中显示页面链接。应先新建一个页面，命名为 categories ，命令如下： $ hexo new page categories 注意！！！categories中千万别加””(双引号)，不然会导致部署完后网站中不显示具体分类： 之后在编辑刚新建的页面中，将页面的类型设置为categories； 最后编辑主题的_config.yml，将menu中的categories: /categories注释去掉即可。 Busuanzi 统计浏览量失效由于busuanzi(不蒜子)的网址更新，导致了使用Hexo Next主题时统计浏览量时失效。 解决方法: 到hexo的themes文件夹下, 进入\themes\next\layout_third-party\analytics 打开: busuanzi-counter.swig 将src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js” 修改为src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js” 即可。 不蒜子官网:http://ibruce.info/2015/04/04/busuanzi/ 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（一）]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？ 无意中在Coursera上发现了一门神奇适用的课程，叫做“Learning How to Learn”， 旨在利用科学知识以及授课者切身经验教会你学会如何学习，学习这门课我才开始恍然大悟，原来学习应该这样学习，算是初步悟到如何学习的真谛了。下面我将讨论我从第一周课堂中学到的经验教训。 利用专注与发散思维研究发现，人有两种完全不同的思考模式，专注模式（focused mode）和发散模式（diffuse mode）。就目前神经学家所知，专注模式与发散模式只能单独存在，你不能同时使用两种模式。而发散思维是你试图了解新事物时应该采取的思维模式。 课程讲述萨尔瓦多·达利 (20世纪著名的超现实主义画家)有时会坐在椅子上，放空自己的大脑，并常常会漫无目的地思考一下之前的工作。这样他就能把脑海中那些在发散模式下得到的的联想和点子及时地收集起来，然后带着这些在发散模式下得到的新想法回到专注模式里去。 这个例子目的是告诉我们：当你处于长期专注的学习模式时，可以通过小睡或做一些运动，然后过渡到发散模式，有助于你的大脑建立必要的神经连接，在你的长时间记忆中建立持久的知识块。还要强调的是，当你学习一些新的东西，尤其是比较难的东西的时候，你的大脑需要有在两种学习模式之间来回转换的能力，这能帮助你更高效地学习。想要锻炼你的神经，你需要每天做一点练习，逐步建立起支撑你思考的神经骨架，这就是关键所在。 拖延症每个人或多或少有拖延的毛病，只不过有些人比较严重。当你面对一件你极度不情愿做的事情时，就好像激活了大脑中与疼痛相关的区域。 所以拖延的过程大概如下图：首先，某件事可能会让你产生轻微的不安；为了消除这种不适感，你会转而去做一些更让人愉悦的事情，这么做的结果就是你觉得更开心了，但这只是暂时的，后续文章会更深入地去了解拖延症。 番茄工作法课程告诉我们一个小巧方便的意志力工具，这个小工具叫做番茄工作法 (Pomodoro)。这个小技巧所需的只有一个计时器（手机上搜索“番茄ToDo”APP，电脑端也有许多类似的软件，可以自行选择），具体的实行过程是这样的： 首先需要把计时器设定25分钟，屏蔽所有会打扰你的事物； 在25分钟内，集中精力专注你所要专注的事； 最后还有一件很重要的事情是，当你前两步之后要给自己一点小小的奖励。比如：上几分钟网、喝杯咖啡或者简单地做一下运动，来使你的大脑可以愉悦的放松一会儿。 实行后你会发现番茄工作法的使用效果非常明显，这就像是你的大脑在健身房做完一次25分钟的高强度训练，然后进行休息放松一样。当你无法专注的时候不妨试一试！ 记忆与练习当我们回忆数学方程组时，我们使用的是长期记忆。当我们尝试结合脑海中的想法来帮助我们理解某一概念或解决某一问题时，我们使用的是工作记忆。工作记忆和长期记忆是两种主要的记忆系统，工作记忆是大脑在即时且有意识地处理信息时所涉及的那部分记忆。 长期记忆就像一个储存仓库，不同的长期记忆储存在大脑的不同区域。研究表明，当你首次尝试将一段短期记忆转入长期记忆中时，你需要多次回顾以增加需要时找到相关信息的几率。 当你遇到新事物时，你通常会运用工作记忆来处理它，如果你想将这个信息转移到长期记忆里，就需要间隔重复的练习来促进这一过程。 不断重复你尝试记忆的内容，但重复的过程必须间隔开来。如果你尝试在一个晚上重复记忆20次相同的内容，记忆效果还比不上在几天内重复同样的次数这种方法。 练习在数学和科学中学到的思想和概念是很重要的，通过反复实践练习可以帮助你提高和增强学习过程中生成的神经连接，越是抽象的东西越要注重练习。 学习的时候如果一心一意地专注学习，时间一长学习效果反而不好，需要休息一下或者至少稍稍将注意力转移到其他地方。在这段看似放松的时间里，你大脑的发散模式就有机会在后台帮你完成对概念的理解。如果你不这么做，而是进行填鸭式学习，你的知识库看起来将会像杂乱不堪，基础不牢靠的泥堆。 如果你有拖延问题，就需要使用番茄工作法帮助你注意力集中一段时间，并适当休息。这会帮你行动起来，并开始建立你需要的神经模式，使你能更有成效地学习更具挑战性的内容！ 睡眠的重要性你怎么也不会想到，当你绝对清醒时你的大脑会产生一些有毒的物质，那大脑如何除掉这些有毒物质呢？原来当人们睡觉时，大脑细胞会收缩，从而增加脑内细胞之间的距离。这就像疏通了一条溪流，液体会在细胞空隙间流过，冲走有毒的物质。所以，睡觉这件事有时候看起来像是浪费时间，实际上是大脑保持清洁和健康的一种方式。 睡眠不足意味着少量代谢毒素残留在你的大脑之中，而这些有毒物质会让你思维混乱，不仅会让你发挥失常，还会导致头疼、抑郁症、糖尿病、心脏类疾病，甚至寿命缩短，这绝不是在吓你，可以参考一下睡眠不足的危害。 睡眠对人们解决困难问题和理解所学知识的能力有显著影响，大脑会将你学习和思考过的想法、概念进行整理，清除掉一些不太重要的部分；同时增强你需要或想要记住的区域的记忆。在睡梦中，大脑还会将你努力学习到的东西在神经中枢一遍遍排演以增强加深记忆力！ 如果你在打盹或睡觉之前，复习一遍所学东西，那你将有更大可能性梦到它。如果你更进一步，告诉自己你想要梦到这些内容，你梦到它的几率也会大大提高。梦见你所学的知识，本质上能够增强你的理解能力，在一定程度上可以将你的记忆整合成更易被掌握的组块信息。 现在是时候去打个盹儿了！ 采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法1、当你遇到完全陌生的事物时你是如何更容易学习的？ 答：单刀直入地实践，因为实践出真知，且大量的阅读作用甚微，同时最好有专家的指点。 2、你是如何让自己在一场枯燥的讲座中保持专注的？ 答：没有简单的方法是可以让你对不感兴趣的东西一直保持参与度的，但是有一个小技巧，就是用提问来“伏击”演讲者，这种打断通常会带出更有趣的讨论；比起被动的听，积极参与会让你学到更多。 3、你是如何进入发散思维模式，并从中获益的呢？ 答：慢跑或户外锻炼是让思维跳出常规想法的绝佳方法，而且这时极其可能迸发灵感。奔跑中，事物从你身边略过，你会开始思考发生的一些事情，然后意识之外的想法涌上表面，接着通常就会出现有用的新想法。但是，这些转瞬即逝的点子过后很容易忘记，我会随身携带一本小本子及时记下来。 4、你会同时进行多项任务吗？ 答：生活中有大量任务不断地“轰炸”，我们一刻也离不开多线程工作，如果做不到统筹兼顾，日子将会很难熬。但我们不能真正地同时做两件事，容易混淆且效率低下。同时处理多个任务实际是一种切换任务的能力。你可能要花很多时间才能完成这样的切换，切换任务并回到当时中断的地方开始工作，这是高效完成任务的方法之一。 5、神经科学方面的知识有运用到学习上的例子吗？ 答：别把自己关在房间里，充足的空间、能激励你的人、很多可以积极参与的事件，以及运动和锻炼都大有助益，它们会增加新神经元的数量并促进神经元的生长。 6、你有关于高效地集中注意力、学习和创新的技巧吗？ 答：处于富有创新氛围的环境中，是一种提升自身创造力的方法。当你和别人交流、阐述观点，你就会有更好的想法，这一过程通常有助于创新。 7、给大家的建议? 1） 聪明的人并不一定会成功，有很多聪明的人并不成功，而那些富有激情并且坚持努力的人容易达到，是因为人生中的成功多半来自于激情和努力，往往成功的人的身上都具有这样的品质。 2）每天我们周围都有值得发现去重新理解的东西，我们必须要用不同的视角来看待这些普通的东西，这很重要。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令拓展]]></title>
    <url>%2F2019%2F03%2F29%2FGit%E5%91%BD%E4%BB%A4%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[本文的内容基本上是从廖雪峰及阮一峰老师的Git 教程中总结出来的，方便自己以后查阅相关命令。 一般来说，日常使用只需要记住下图6个命令即可。但是想往深度使用Git，恐怕还需要记住其余的几十个命令。 上图中几个专用名词的译名如下： Workspace：工作区 Index / Stage：暂存区 Repository：本地仓库 Remote：远程仓库 配置123456$ git config --list //显示当前的Git配置$ git config -e [--global] //编辑Git配置文件$ git config --global user.name "miqilin21"$ git config --global user.email miqilin21@example.com //设置你的仓库用户名及邮箱，用于标识提交者 新建Git代码库12345$ git init //在当前目录新建一个Git代码库$ git init [project-name] //新建一个目录，将其初始化为Git代码库$ git clone [url] //下载一个项目和它的整个代码历史 添加/删除文件123456789$ git add [file1] [file2] ... //添加一个或多个文件到暂存区$ git add [dir] //添加指定目录到暂存区，包括子目录$ git add //添加当前目录的所有文件到暂存区$ git rm [file1] [file2] .. //删除工作区文件，并放入暂存区$ git rm --cached [file] //停止追踪指定文件，但该文件会保留在工作区 本地文件提交1234567$ git commit -m "Commit message" //提交暂存区到仓库区$ git commit -a //提交工作区自上次commit之后更改的所有文件，直接到仓库区$ git commit -v //提交时显示所有diff信息$ git commit --amend -m "Latest commit message" //使用一次新的commit，替代上一次提交；如果代码没有任何新变化，则用来改写上一次commit的提交信息 同步远程仓库123456789101112131415$ git fetch [remote] //下载远程仓库的所有变动$ git remote -v //显示所有远程仓库$ git remote show [remote] //显示某个远程仓库的信息$ git remote add [shortname] [url] //增加一个新的远程仓库，并命名$ git pull [remote] [branch] //同步远程仓库的变化，并与本地分支合并$ git push [remote] [branch] //上传本地指定分支到远程仓库$ git push [remote] --force //强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --all //推送所有分支到远程仓库 撤销1234567891011121314151617181920212223$ git checkout [file] //恢复暂存区的指定文件到工作区$ git checkout [commit] [file] //恢复某个commit过的文件到暂存区和工作区$ git checkout //恢复暂存区的所有文件到工作区$ git reset [file] //重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset --hard //重置暂存区与工作区，与上一次commit保持一致$ git reset --hard [commit] //重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git revert [commit] //新建一个commit，用来撤销指定commit；后者的所有变化都将被前者抵消，并且应用到当前分支$ git stash //将工作区现场保存起来，等以后恢复后继续工作。通常用于处理更为着急的任务时，例如：bug$ git stash list //查看保存的工作现场$ git stash apply //恢复工作现场$ git stash drop //删除stash内容$ git stash pop //恢复的同时直接删除stash内容 分支12345678910111213141516171819202122232425$ git branch //列出所有本地分支$ git branch -r //列出所有远程分支$ git branch -a //列出所有本地分支和远程分支$ git branch [branch-name] //新建一个分支，但依然停留在当前分支$ git branch [branch] [commit] //新建一个分支，指向指定commit$ git checkout -b [branch] //新建一个分支，并切换到该分支$ git checkout [branch-name] //切换到指定分支，并更新工作区$ git merge [branch] //合并指定分支到当前分支$ git push origin [branch-name] //将分支推送到远程仓库$ git push --all origin //将所有分支推送到远程仓库$ git branch -d [branch-name] //删除分支$ git push origin --delete [branch-name]$ git push origin :[branch-name]$ git branch -dr [remote/branch] //删除远程分支 标签12345678910111213141516$ git tag //列出所有tag$ git tag [tag] //新建一个tag在当前commit$ git tag [tag] [commit] //新建一个tag在指定commit$ git tag -d [tag] //删除本地tag$ git push origin :refs/tags/[tagName] //删除远程tag$ git show [tag] //查看tag信息$ git push [remote] [tag] //提交指定tag$ git push [remote] --tags$ git push --tags origin //提交所有tag 查看信息123456789101112131415161718192021222324252627282930313233343536$ git status //显示有变更的文件$ git log //显示当前分支的版本历史$ git log --stat //显示commit历史，以及每次commit发生变更的文件$ git log -S [keyword] //搜索提交历史，根据关键词$ git log --follow [file]$ git whatchanged [file] //显示某个文件的版本历史，包括文件改名$ git log -p [file] //显示指定文件相关的每一次diff$ git log -5 --pretty --oneline //显示过去5次提交$ git shortlog -sn //显示所有提交过的用户，按提交次数排序$ git blame [file] //显示指定文件是什么人在什么时间修改过$ git diff //显示暂存区和工作区的差异$ git diff --cached [file] //显示暂存区和上一个commit的差异$ git diff HEAD //显示工作区与当前分支最新commit之间的差异$ git diff [first-branch]...[second-branch] //显示两次提交之间的差异$ git diff --shortstat "@&#123;0 day ago&#125;" //显示今天你写了多少行代码$ git show [commit] //显示某次提交的元数据和内容变化$ git show --name-only [commit] //显示某次提交发生变化的文件$ git show [commit]:[filename] //显示某次提交时，某个文件的内容$ git reflog //显示当前分支的最近几次提交]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+GitHub搭建个人博客]]></title>
    <url>%2F2019%2F03%2F21%2F%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo是一个快速、简介且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多，所以就用它啦~ 下面一步一步地说怎么用hexo+github搭建一个个人博客。 说明：本文只针对Windows平台下的搭建过程，其他平台的请自行上网查阅 准备在搭建博客之前，需要安装node.js和git，具体操作请参考这篇文章，并同时申请Github账号，使用的开发工具为VScode。 安装Hexo1、首先新建一个文件夹如myBlog，用于存放整个博客源文件。右击鼠标点击文件夹，选中Git Bash Here在Git命令行中打开。 2、执行以下命令安装Hexo及生成第一篇博客文章：1234$ npm install -g hexo-cli //安装hexo$ hexo init //初始化hexo,这样myBlog就是整个博客的根目录，所有的页面都可以在里面进行增删改操作$ hexo generate //生成静态页面$ hexo server //启动本地服务器，进行博客文章预览 Hexo会默认生成第一篇博客《Hello World》，在浏览器下打开localhost://4000你将会看到： myBlog源文件夹整体目录预览： 其中_config.yml和package.json为项目的配置文件，themes存放了我们博客的主题，source-&gt;_post为我们的博客目录，public为执行hexo generate后生成的静态页面。 关联Github1、在你的Github中建立新的 repo，repo 名称必须是「你的用户名.http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。 2、将myBlog目录中的_config.yml文件在VScode中打开，编辑网站配置： 把第 6 行的 title 改成你想要的名字 把第 10 行的 author 改成你想取大名 把最后一行的 type 改成 type: git 在最后一行后面新增一行，左边与 type 平齐，加上一行 repo: 仓库地址 （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址最好以 git@github.com: 开头） 3、修改完成配置后在myBlog目录下执行命令：12$ npm install hexo-deployer-git --save //安装 git 部署插件$ hexo deploy //将本地博客代码部署到Github上 4、进入「你的用户名.http://github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接；最后用浏览器访问「预览链接/index.html」就应该看到了你的博客啦！ 添加新文章1、打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就相当于在本地添加了新文章 2、利用来VScode编辑新文章 3、hexo generate 4、hexo deploy 5、去看你的博客，应该能看到这篇新文章啦！ 更换主题1、https://github.com/hexojs/hexo/wiki/Themes 上面有主题合集 2、随便找一个主题，进入主题的 GitHub 首页，比如我找的是 https://github.com/iissnan/hexo-theme-next 3、复制它的 SSH 地址或 HTTPS 地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git 4、cd themes 5、git clone git@github.com:iissnan/hexo-theme-next.git 6、cd .. 7、将 _config.yml 的第 75 行改为 theme: hexo-theme-next，保存 8、hexo generate 9、hexo deploy 10、等一分钟，然后刷新你的博客页面，你会看到一个新的外观，如果不喜欢这个主题，就回到第 1 步，重选一个主题。 tips1、最好进入一个安全的目录创建源文件夹，在根目录瞎搞； 2、_config.yml中的缩进和空格一定严格按照文件的默认格式来，不然会报错； 3、想要删除博客的话，直接删除source-&gt;_posts-&gt;对应的博客文章，然后再次执行hexo generate、hexo deploy即可； 4、在_config.yml中修改language为zh-CN，即可将博客中英文转换为中文； 5、常用命令：1234567hexo new "postName" //新建文章 hexo new page "pageName" //新建页面 hexo clean //清除缓存文件db.json和已生成的静态文件 public,网站显示异常时可以执行这条命令试试。hexo generate //生成静态文件 hexo deploy //部署到Giihub hexo server //启动本地服务器 hexo help //查询帮助 6、md文件需要用到markdown语法。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—三栏布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局的页面可分为左中右三部分，然后对中间那部分做自适应的一种布局方式。三栏布局在前端页面的开发中十分常见，那么怎么样的才算是三栏布局呢？ 比如苏宁易购的首页： 上图的布局就是一个常见的三栏布局：即左边商品导航和右边导航为固定宽度，中间内容随浏览器宽度变化自适应。 下面详细介绍了一些经典及新兴的三栏布局方式，且所有方式显示的效果如下图： 绝对定位布局1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; position: relative; &#125; .left &#123; position: absolute; width: 150px; height: 200px; left: 0; top: 0; background-color: red; &#125; .middle &#123; height: 200px; margin: 0 160px; background-color: green; &#125; .right &#123; position: absolute; width: 150px; height: 200px; right: 0; top: 0; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 绝对定位布局是一个比较古老和容易想到的方式，其特点就是简单实用，而且也不容易出问题，缺点就是，容器脱离了文档流，后代元素也脱离了文档流，当高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 float布局12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .left &#123; float: left; height: 200px; width: 150px; background-color: red; &#125; .middle &#123; margin: 0 160px; height: 200px; background-color: green; &#125; .right &#123; float: right; width: 150px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; float布局也是一种较为简单且容易想到的方式，原理是左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应，缺点就是中间部分最后加载，内容较多时会影响体验。 BFC 三栏布局123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .left &#123; float: left; height: 200px; width: 150px; margin-right: 10px; background-color: red; &#125; .middle &#123; height: 200px; overflow: hidden; background-color: green; &#125; .right &#123; float: right; width: 150px; height: 200px; margin-left: 10px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; BFC有一特性：BFC的区域不会与外部浮动元素重叠，这里利用了这一特性，实现了两栏自适应布局。缺点和方法二类似，为了解决这个问题，引出下面要介绍的双飞翼布局。 双飞翼布局1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .content &#123; float: left; width: 100%; &#125; .left &#123; float: left; height: 200px; width: 150px; margin-left: -100%; background-color: red; &#125; .middle &#123; height: 200px; margin-left: 160px; margin-right: 160px; background-color: green; &#125; .right &#123; width: 150px; height: 200px; float: right; margin-left: -200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局是在中间栏的 div 中再嵌套一个 div，内容写在嵌套的 div 里，然后对嵌套的 div 设置 margin-left 和 margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是 100% 宽度，只不过中间栏的内容通过 margin 的值显示在中间。 中间内容可以优先加载，但其HTML 代码结构稍微复杂点。 圣杯布局123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; margin-left: 160px; margin-right: 160px; &#125; .middle &#123; float: left; width: 100%; height: 200px; background-color: green; &#125; .left &#123; float: left; width: 150px; height: 200px; margin-left: -100%; position: relative; left: -160px; background-color: red; &#125; .right &#123; float: left; width: 150px; height: 200px; margin-left: -210px; position: relative; right: -220px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局的核心是左、中、右三栏都通过float进行浮动，然后通过margin负值进行调整。跟双飞翼布局比较像，但还是有一些区别，相对于双飞翼布局来说，其HTML 结构相对简单，但是css语法就稍微复杂，也是优先加载中间内容。 还有注意一点是：中间内容要放在最上面，保证其先渲染。 Flex布局1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: flex; &#125; .middle &#123; flex-grow: 1; height: 200px; background-color: green; &#125; .left &#123; order: -1; flex: 0 1 150px; margin-right: 10px; height: 200px; background-color: red; &#125; .right &#123; flex: 0 1 150px; margin-left: 10px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Flex布局是由CSS3提供的一种较为新兴的、方便的三栏布局方式，简单实用，缺点是其兼容性差一点。 Table 布局12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: table; width: 100%; &#125; .left, .middle, .right &#123; display: table-cell; &#125; .left &#123; width: 150px; height: 200px; background-color: red; &#125; .middle &#123; background-color: green; &#125; .right &#123; width: 150px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 算是一种比较老的布局方式，较为简单，但其缺点是：无法设置栏间距，缺乏点灵活性，如下图： Grid(网格)布局123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: grid; grid-template-columns: 160px auto 160px; height: 200px; &#125; .left &#123; background-color: red; margin-right: 10px; &#125; .middle &#123; background-color: green; &#125; .right &#123; background-color: yellow; margin-left: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 网格布局作为一种比较新潮的实现方式，仅仅几条样式命令就能完成三栏布局，可见其布局之强大，但其兼容性比较差。 以上就是我自己总结及结合文档所列出的8种css实现前端三栏布局的方式，如还有其他方式，欢迎大家告诉我哦。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—左右布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css左右布局是实现前端页面设计的基础，大部分的布局方式都能分割成左右布局，因此理解左右布局，能使我们在初学css的时候更快理解其他复杂的布局方式。 下面是我罗列的几种css实现前端左右布局的方式： position: absolute实现在父级元素内设置两个子元素，绝对定位它们，然后使用百分比将它们分成左右两部分。 这里的好处是，有两个可以容纳自己内容的独立容器。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt; /*以上为html代码*/section &#123; color: white; text-align: center;&#125;div &#123; height: 100%;&#125;article &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; padding: 20px;&#125;h1 &#123; font-size: 20px;&#125;.left-half &#123; background-color: #ea68a2; position: absolute; left: 0px; width: 50%;&#125;.right-half &#123; background-color: pink; position: absolute; right: 0px; width: 50%;&#125; table实现table布局是页面布局中使用的最早的布局方式，随着前端技术的发展，table布局由于自身的局限性逐渐被div布局取代。123456789101112131415161718192021222324252627282930313233&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;body &#123; color: white; text-align: center;&#125;h1 &#123; font-size: 20px;&#125;div &#123; display: table-cell; text-align: center; vertical-align: middle; width: 50%; padding: 50px;&#125;.left-half &#123; background: #ea68a2;&#125;.right-half &#123; background: pink;&#125; float实现float属性是css中关于布局的一个关键属性，可以产生脱离文档流的布局现象，其left属性值使该区域向父级标签区域的左侧边界放置，right属性值使该区域块向父级标签的右侧边界放置，利用该属性可以实现左右布局。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;html, body, section, div &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;section &#123; width: 100%;&#125;article &#123; position: relative; top: 50%; left: 50%; padding: 1rem; transform: translate(-50%, -50%);&#125;h1 &#123; font-size: 20px;&#125;.left-half &#123; background-color: #ea68a2; float: left; width: 50%;&#125;.right-half &#123; background-color: pink; float: left; width: 50%;&#125; 对于float对后面同级元素的影响，既可以采用margin进行影响的清除，还可以在受影响的元素上添加overflow：hidden来清除浮动对该区域块带来的影响。 Inline-Block实现display:inline-block属性是介于行内元素（display: inline）和块级元素（display: block）之间的属性，它既可以像行内元素一样水平布局，也可以像块级元素设置宽高属性，所以左右布局可以利用它这种属性。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt;&lt;/div&gt;&lt;div class="right-half"&gt;&lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt;&lt;/article&gt;&lt;/div&gt;* &#123; box-sizing: border-box;&#125;html, body, div &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;article &#123; position: relative; top: 50%; left: 50%; text-align: center; transform: translate(-50%, -50%);&#125;h1 &#123; font-size: 25px;&#125;div &#123; display: inline-block; vertical-align: top; width: 50%;&#125;.left-half &#123; background: #ea68a2;&#125;.right-half &#123; background: pink;&#125; flexbox实现css3中出现了弹性盒子flexbox布局，使用这种方法，可以将父级容器变成一个灵活的盒子，子容器占用相等的份额， 无需再设置宽高。123456789101112131415161718192021222324252627282930313233343536373839&lt;section class="container"&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;html, body, section &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;div&#123; display: flex; flex-direction: column; justify-content: center;&#125;h1 &#123; font-size: 25px;&#125;.container &#123; display: flex;&#125;.left-half &#123; background-color: #ea68a2; flex: 1;&#125;.right-half &#123; background-color: pink; flex: 1;&#125; grid实现CSS Grid(网格) 布局技术就像是Flexbox和Table的混合体，你可以通过将 CSS 规则应用于父元素(成为 Grid Container 网格容器)和其子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid 布局。12345678910111213141516171819202122232425262728293031323334353637383940&lt;section class="container"&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/secion&gt;html, body, section, div &#123; height: 100%;&#125;body &#123; color: white;&#125;article &#123; position: relative; top: 50%; text-align: center; transform: translate(0, -50%);&#125;h1 &#123; font-size: 25px;&#125;.container &#123; display: grid;&#125;.left-half &#123; background: #ea68a2; grid-column: 1;&#125;.right-half &#123; background: pink; grid-column: 2;&#125; 作为比较新兴的布局技术，相信在未来的前端发展中，Grid 布局技术会越来越受到广大开发者的青睐。 以上就是我自己总结及结合文档所列出的6种css实现前端左右布局的方式，如还有其他方式，欢迎大家告诉我。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—居中布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[我们在网页布局的时候，经常会碰到需要居中的情况，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。 水平居中元素宽高未知当元素的宽高都未知的时候，可以利用以下两种方法将元素水平居中： ①CSS3 transform：12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; ②flexbox：1234.parent &#123; display: flex; justify-content: center;&#125; 居中元素为内联元素常见的内联元素有：span, a, img, input, label 等等。 您可以在块级父元素内水平居中内联元素，只需css中加以下核心语法：123.parent&#123; text-align: center;&#125; 这种方法适用于display 为 inline, inline-block, inline-table, inline-flex 类型的元素。 居中元素为块级元素常见的块元素：div, h1~h6, table, p, ul, li 等等。 ①设置 margin：0 auto123456789.parent &#123; width: 100%;&#125;.child &#123; width: 800px; height: 100px; margin: 0 auto; background: #999;&#125; 此方法只能进行水平的居中，对浮动元素或绝对定位元素是无效的。 ②转换为 inline-block 属性：123456.parent &#123; text-align: center;&#125;.child &#123; display: inline-block;&#125; 居中元素为浮动元素加以下核心语法:1234567.child &#123; width: 100px; float: left; position: relative; left: 50%; margin-left: -50px;&#125; 居中元素为绝对定位元素①123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 50%; margin-left: -50px;&#125; ②12345678910.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 0; right: 0; margin: 0 auto;&#125; 垂直居中元素宽高未知当元素的宽高都未知的时候，也可以利用以下同样两种方法将元素垂直居中： ①CSS3 transform：12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateY(-50%);&#125; ②flexbox：12345.parent &#123; display: flex; flex-direction: column; justify-content: center;&#125; 适用于子元素为浮动、绝对定位、内联元素，均可垂直居中。 其中flexbox 是 CSS3 新增的属性，设计初衷就是为了解决像垂直居中这样的常见布局问题，相信未来flexbox布局会越来越多应用。 元素宽高已知①123456789.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; ②12345678910.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 0; bottom: 0; height: 100px; margin: auto 0;&#125; 居中元素为单行文本①1234.text &#123; line-height: 200px; height: 200px;&#125; 将文本的 line-height 属性值设为和文字父容器一样的高度，但适用于只有一行文字的情况。 ②1234.link &#123; padding-top:30px; padding-bottom:30px;&#125; 有时内联/文本元素可以垂直居中显示，只是因为它们上部和下部都有相等的padding。 居中元素为多行文本①table：12345678.parent &#123; display: table;&#125;.child &#123; display: table-cell; margin: 0; vertical-align: middle;&#125; ②flexbox:123456.parent &#123; display: flex; justify-content: center; flex-direction: column; height:400px;&#125; 水平垂直居中元素宽高已知①负边距居中：123456789101112.parent &#123; position: relative;&#125;.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 此方法灵活性差，不能自适应，且宽高不支持百分比尺寸和 min-/max- 属性。 ②绝对居中：1234567891011div &#123; width: 100px; height: 100px; margin: auto; position: fixed; //absolute is ok top: 0; right: 0; bottom: 0; left: 0;&#125; 元素的宽高支持百分比 % 属性值和 min-/max- 属性。 ③transform :1234567891011.parent &#123; position: relative;&#125;.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; ④table-cell:1234567891011121314.parent &#123; display: table-cell; vertical-align: middle; text-align: center; width: 100px; height: 100px; border: 1px solid red;&#125;.child &#123; width: 50px; height: 50px; display: inline-block; background-color: #999;&#125; 这种方法适用于子元素 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，前提需要知道父元素的宽高，且父元素的宽高不能设为百分比数。 ⑤font-size 结合 vertical-align：1234567891011121314.parent &#123; font-size: 175.4px; height: 200px; text-align: center;&#125;.child &#123; vertical-align: middle; display: inline-block; font-size: 12px; width: 50px; height: 50px; background-color: #999;&#125; 该方法前提条件是需给父元素设一个合适的 font-size 值，该值一般为其父元素的高度除以 1.14 得到的值，并且子元素必须是一个 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，此外还需在子元素内加上 vertical-align: middle 属性。 ⑥文本内容：12345text &#123; height: 100px; line-height: 100px; text-align: center;&#125; 元素宽高未知①transform :123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; transform方法中元素既可以加宽高，也可不加，用于水平垂直居中布局。 ②flexbox :12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; ③grid:1234567body, html &#123; height:100%; display: grid;&#125;span &#123; /* thing to center */ margin: auto;&#125; 该方法适用于只有一个元素的时候，作为非常新的布局方式，其兼容性也比较差。 上面只是把所有方法的代码要点罗列了一下，能满足所有的居中布局方案，如你还有其他好方法，欢迎交流指正哦。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速搭建静态资源服务器]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。以前的时候，都是使用php的本地环境，也算比较方便，但是自从学了nodejs，发现创建http-server更方便。 本文的目的在这篇文章中，我将向您展示如何使用NodeJS创建一个非常简单的HTTP服务器。您可以通过http访问目录中的静态资源，如HTML，Javascript，CSS等，比如： http://localhost:8080/hello.html http://localhost:8080/abc.js 而不是通过默认的file:///来访问 那问题是为什么只有需要一个HTTP才能访问静态资源呢？ 是因为HTML文件含有Javascript文件时，如果通过默认的file://地址来访问此文件的话，浏览器会阻止本地Javascript文件的一些操作，此时就需要安装HTTP-Server来解决这个问题。 报错信息： Failed to load file:///E:/webexamples/reactjs/hello-reactjs/person.jsx: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. 创建HTTP-Server首先，确保已在计算机上安装NodeJS和npm； 否则，请按照以下说明进行安装： 在Windows上安装NodeJS 打开 Git Bash或其他命令行工具，依次输入以下命令，按回车： 123npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress false npm 的配置被存储在 ~/.npmrc，你可以随时改。 ①接下来第一步，先创建一个空目录： ②利用命令行工具进入这个目录，这里用的是Git Bash。右击鼠标，点击Git Bash here，即可用Git Bash打开这个目录： ③运行以下命令安装http-server：1$ npm install -g http-server ④启动HTTP-Server，输入命令：1$ http-server -c-1 到此您的HTTP服务器就已经启动了，它正在端口8080上监听，您可以通过访问以下链接进行检查，3个地址在电脑端打开的是同一份东西： http://192.168.1.116:8080/ （只有这个地址能在手机中预览） 127.0.0.1:8080/ （2和3性质是一样的） localhost:8080/ （较为常用） ⑤在该目录中创建一个HTML文件，您可以通过此HTTP地址访问它： ⑥这里Windows 用户需要注意了，如果你发现你修改了源代码，页面却无法更新，说明http-server 的缓存还未消除，那么可以这样做： 打开 Chrome 开发者工具 点击 Network 勾选 Disable Cache 这样缓存就不存在了~ 其他命令安装HTTP-Server这里就不仔细介绍步骤了，因为大部分操作和结果与第2步是一样的，直接上命令： 第一种方法：安装：1$ npm i startserver -g 快速开启：1$ startserver 第二种方法：安装：1$ npm install -g live-server 快速开启：1$ live-server 如果看到其他有意思的方法，后续还会增加的！ 以上就是我在近期收集到的一些方法资料，不一定全面，如有错误欢迎指正哦。 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>前端相关</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>http-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常用标签]]></title>
    <url>%2F2019%2F03%2F19%2FHTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[HTML 是用来描述网页的一种语言，通过添加各种标签，达到在浏览器中展示期望的效果。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 浏览器不会显示 HTML 标签(HTML tag)，而是使用标签来解释页面的内容： HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;p&gt; 和 &lt;/p&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 ⭐越多代表我觉得此标签越重要 标题标签 ⭐⭐⭐HTML提供了6个等级的标题(head)，即：h1、h2、h3、h4、h5和h6，h1是最高级的标题。其基本语法是：&lt;hn&gt; 标题信息 &lt;/hn&gt; 注意：h1因为重要，尽量少用，一般都是给logo用，或者页面中最重要标题信息，其他5个级别标题在一个页面中都可以出现多次，h1只能出现一次。 段落标签 ⭐⭐⭐在网页中要想把文字内容有条理地显示，离不开段落标签（paragraph）,它是网页中文章内容的基本组成部分。其基本语法是：&lt;p&gt; 文本内容 &lt;/p&gt; 注意：段落标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签 ⭐⭐在网页中经常看到一些水平线将段落与段落间隔开，层次分明。这些水平线可以通过插入图片来实现，也可以简单地通过&lt;hr/&gt; 标签(horizontal)来完成。其基本语法是：&lt;hr /&gt;是单标签 换行标签 ⭐⭐⭐在HTML中，一个段落的文字会从左往右按顺序排列，直到浏览器窗口的右端，然后会自动换行，如果希望某段文字强制进行换行，就需要使用换行标签(break)。其基本语法是：&lt;br /&gt; 注意：除了少数应用（比如诗歌的分行），应该尽量避免使用这个标签，因为它并没有特别的语义含义，而且分行的视觉效果完全可以通过p标签、列表标签和CSS命令达到。 div span标签 ⭐⭐⭐⭐div 和 span是没有语义的，是现在网页布局用到的最主要的2个盒子，比如css+div的结合就可以基本上满足页面布局需要。其基本语法是：1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt; 今日行情 &lt;/span&gt; 文本格式化标签 ⭐⭐在网页中，有时要为某些文字设置加粗、加斜或加下划线的效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。其基本语法是： 注意：b i s u 只有使用，没有强调的意思，strong em del ins的语义更强烈。 图像标签img ⭐⭐⭐⭐要想在网页中显示图像就需要使用图像标签，下图详细介绍了图像标签&lt;img /&gt; 以及与其相关的一些属性。其基本语法是： 基本图像插入方式：&lt;img src=&quot;wo.jpg&quot;/&gt; 带有alt的图像插入方式：&lt;img src=&quot;wo.jpg&quot; alt=&quot;这是我吴彦祖的照片&quot;/&gt; 带有title的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot;/&gt; 带有宽度的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; /&gt; 带有边框的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; border=&quot;10&quot; /&gt; 链接标签 ⭐⭐⭐⭐在HTML中创建超链接比较简单，只需用链接标签(anchor)环绕需要被链接的对象即可。其基本语法是：&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; href：Hypertext Reference的缩写，意思是超文本引用，用于指定链接目标的url地址。 target：用于指定链接页面的打开方式，其取值有self(新链接页面覆盖原页面，为默认值)、blank(在新窗口打开)、_parent(载入父级窗口，与iframe结合用得到)、_top(载入顶级窗口，与iframe结合用得到)，注意： 外部链接：需要添加 http://www.baidu.com 内部链接：直接链接内部页面名称即可，如首页；还有可以通过创建锚点链接，能够快速定位到内部页面的目标内容：①.使用链接文本 ②.使用相应的id名标注跳转到目标的位置 如果没有确定的链接目标时，通常将href属性定义为”#”(即href=”#”)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 当然也可以利用base标签来设置整体链接的打开状态，如网易这样设置让页面所有链接按新窗口打开： 特殊字符标签 ⭐ 无序列表ul ⭐⭐⭐⭐无序列表(unordered list)的各个列表项之间没有顺序级别之分，是并列的。其基本语法是：123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 注意： &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签内输入其他标签或者文字的做法是不被允许的。 &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 无序列表会自带样式属性，但还是让css来做！ 有序列表ol ⭐⭐有序列表(ordered list)即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义。其基本语法是：123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ...... &lt;/ol&gt; 所有特性基本和ul一致，且自带顺序。 定义列表 ⭐定义列表(definition list)常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法是：12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ...... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...... &lt;/dl&gt; 表格table ⭐⭐表格还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。其基本语法是：1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 上面的语法中包含三对HTML标签，分别为&lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体解释： table用于定义一个表格。 tr用于定义表格中的一行，必须嵌套在table标签中，且只能嵌套&lt;td&gt;&lt;/td&gt;，在table中包含几对tr，就有几行表格。 td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对&lt;tr&gt;&lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少”列”（或多少个单元格），但表格只有行tr和单元格td，行里面装单元格，没有列的概念；&lt;td&gt;&lt;/td&gt;标签像一个容器，可以容纳所有的元素。 表单标签 ⭐⭐表单的目的是为了收集用户信息，在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，作用是提示用户进行填写和操作。 表单域：相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过它定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input控件 ⭐⭐⭐⭐&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。其常见属性如下所示： text语法:1234&lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="北京" /&gt;&lt;/td&gt; //value为默认值&lt;/tr&gt; password语法：1234&lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" value="123456" /&gt;&lt;/td&gt; &lt;/tr&gt; radio单选按钮语法：12345678&lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; 男&lt;input type="radio" name="sex" /&gt; 女&lt;input type="radio" name="sex" /&gt; 人妖&lt;input type="radio" name="sex" /&gt; &lt;/td&gt; &lt;/tr&gt; label标签 ⭐⭐label标签为input元素定义标注，其中for属性规定了label与哪个表单元素绑定。其基本语法是：12&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; 点击Male会直接跳到右边的文本框内，label通过for和id建立联系快速找到。当然也可以简化成这种形式：1&lt;label&gt;&lt;input type="radio" name="sex" value="male"&gt;Male&lt;/label&gt; textarea文件域 ⭐⭐text 文本框只能写一行文本，如果需要输入大量的信息，就需要用到textarea标签，可以轻松地创建多行文本输入框。其基本语法是：123&lt;textarea cols="每行的字符数" rows="显示的行数"&gt; 文本内容 &lt;/textarea&gt; 但是textarea的宽和高通常是通过css来控制的,cols和rows几乎不用。 下拉菜单 ⭐⭐使用select标签定义下拉菜单的基本语法如下：123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option中定义selected=”selected”时，当前项即为默认选中项。 表单域 ⭐⭐在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。其基本语法是：123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件 &lt;/form&gt; 常见属性： Action：在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接受并处理表单数据的服务器程序的url地址。 method：用于设置表单数据的提交方式，其取值为get或post。 name：用于指定表单的名称，以区分同一个页面中的多个表单。注意：每个表单都应该有自己的表单域。 HTML5常用新标签 ⭐⭐⭐ header：定义文档的页眉 nav：定义导航链接的部分 footer：定义文档或节的页脚 article：标签规定独立的自包含内容 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容（侧边） datalist：标签定义选项列表，与input元素配合使用 fieldset：可将表单内的相关元素分组，打包，与legend搭配使用 HTML5新增的input type属性 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体embed ⭐⭐embed可以用来插入各种多媒体（较大的），格式可以是Wav、AIFF、AU、MP3等。其中url为音频或视频文件的路径，可以是相对路径或绝对路径。其基本语法是：123&lt;embed src='http://player.youku.com/player.php/sid/XMzk4MDUzNTA1Mg==/v.swf' allowFullScreen='true' quality='high' width='480' height='400' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt; 多媒体audio ⭐⭐HTML5通过&lt;audio&gt;标签来解决音频播放的问题。其基本语法是：1&lt;audio src="./music/See You Again.mp3"&gt;&lt;/audio&gt; //通过src指定音频文件路径即可 并且可以通过添加属性来更友好控制音频的播放，如： autoplay 自动播放 controls 是否显示默认播放组件 loop 循环播放 ，loop=2就是循环2次 ，loop或者loop=“-1”无限循环 多媒体video ⭐⭐同音频播放一样，&lt;video&gt;（通常插入较小的视频）使用也相当简单。其基本语法是：1&lt;video src="./video/movie.mp4" controls="controls"&gt;&lt;/video&gt; //通过src指定视频文件路径 同样，通过附加属性可以更友好的控制视频的播放： autoplay 自动播放 controls 是否显示默认播放组件 loop 循环播放 width 设置播放窗口的宽度 height 设置播放窗口的高度]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git/GitHub操作手册]]></title>
    <url>%2F2019%2F03%2F19%2FGit%E5%8F%8AGithub%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Git 是目前最流行的版本管理工具，也是程序员的必备技能之一。这里主要介绍一下git/github远程仓库的使用及相关配置。 SSH KeysSSH Keys是什么呢？简单来说相当于一把钥匙（在机器中即电脑中进行配置），github相当于一把锁，每次发起请求是会去验证钥匙与锁是否配对。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置。 添加远程库你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那如何将我们这个本地仓库上传到 GitHub 呢？下图简单描述了Git常用的操作流程。 1、在本地新建文件夹，命名为blog，在本地的blog仓库的路径下运行命令行。1$ git init // 在当前目录新建一个Git代码库 这个操作在当前目录下生成一个.git文件，默认不显示，可在命令行中输入 ls -a,即可看到所有被隐藏文件，接下来进行如下操作：123456789101112131415161718192021$ echo "# myblog" &gt;&gt; README.md //在当前目录下新建README.md,且文件内容为'myBlog'；如果目录下已经有文件，请省略这一步$ git add README.md //将README.md文件提交到问题暂存区$ git commit -m "first commit" //将暂存区文件提交到本地仓库，且本次提交记录为'first commit'$ git status -sb //显示当前所有文件的状态``` 这几步操作目的是将上传的文件提交到本地仓库，接下来就是介绍怎么样将本地仓库上传到远端库了。 2、登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，名称随意，一般可以跟本地目录名一致。 &lt;div align=center&gt;![](https://i.loli.net/2019/03/19/5c9089bb5e271.jpg) 在Repository name填入blog，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。 3、点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图: &lt;div align=center&gt;![](https://i.loli.net/2019/03/19/5c9089f6b1548.jpg) 4、看上图，记得点击 SSH 按钮，如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用HTTPS 地址，因为使用HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但在某些只开放http端口的公司内部就无法使用SSH协议而只能用HTTPS 。 5、目前，在GitHub上的这个blog仓库还是空的，GitHub告诉我们，可以在这个仓库创建一个新的本地仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的blog仓库下运行命令： ```bash$ git remote add origin git@github.com:miqilin21/blog.git 6、下一步，就可以把本地库的所有内容推送到远程库上：1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样: 7、如果你想查看变更历史，可以通过命令：$ git log 8、从现在起，只要本地仓库作了修改，如果你想让改动保存到远程仓库里，你需要先git add文件或者也可以git add。注意，如果这个 文件以前被我们add过，所以此处的git add操作可以省略，但我建议你使用git的初期阶段，不要省略git add。换句话说，每一次改动，都要经过git add和git commit两个命令，才能被添加到 .git 本地仓库里。接下来就通过命令：1$ git push //将本地仓库修改内容同步到远程仓库 但是，如果远程库先有修改的话，要想本地仓库与其同步，还需通过命令：1$ git pull //将远程库修改的内容下载到本地库 最后把本地master分支的最新修改$ git push推送至GitHub，现在，你就拥有了真正的分布式版本库！ 从远程库clone上面已经讲了 在本地创建仓库 将本地仓库上传到 GitHub 这里将介绍另外一种用法，那就是直接在 GitHub 创建一个仓库，然后克隆下载到本地。 1、在GitHub 上新建一个仓库 git-demo，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下： 请按图中所示，一模一样的操作，然后点击创建按钮。 2、这样一来，这个仓库就会自动生成三个文件： 3、现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库，点击页面中唯一的绿色按钮「clone or download」，会看到一个弹出层： 请确保弹出层里的地址是 SSH 地址，也就是 git@github.com 开头的地址，如果不是，就点击 Use SSH 按钮，然后复制这个地址。 4、打开 Git Bash，找一个安全目录，比如 ~/Desktop 桌面目录就很安全：cd ~/Desktop，然后运行：1$ git clone git@github.com:miqilin21/git-demo.git 运行完了你就会发现，桌面上多出一个 git-demo-2 目录，里面的内容和远程库一模一样，至此从远程库克隆到本地就完成啦！ 小结三种方式都说完了，它们分别是： 1、在本地创建仓库 2、将本地仓库上传到 GitHub 3、GitHub 上的仓库克隆下载到本地 其实呢，还有很多种不同的方式，但是，你记住这几种就行了，已经够你用了。我们并不想要了解 git 的所有高级用法，我们的目的很明确：能通过 Git 命令使用 GitHub 就行。 我们最后再回顾一遍已经学到的命令： git clone git@github.com:xxxx，克隆下载远程仓库git init，初始化本地仓库 .gitgit status -sb，显示当前所有文件的状态git add 文件路径，用来将变动加到暂存区git commit -m “信息”，用来正式提交变动，并备注信息，提交至 .git 仓库如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。git log 查看变更历史 其他学习资源 常用Git命令清单Git菜鸟教程廖雪峰的Git教程 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP入门笔记]]></title>
    <url>%2F2019%2F03%2F19%2FHTTP%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTTP 协议是互联网的基础协议，也是现在网页开发的必备知识，2015年出的最新版本 HTTP/2 更是成为互联网技术热点。 本文介绍了 HTTP 协议的基础知识以及浏览器和web服务器之间请求和响应的详细信息。 什么是HTTP?HTTP代表超文本传输协议。 这是互联网中数据通信的基础， 数据通信以客户端发送的请求开始，并以从Web服务器接收的响应结束，而HTTP的作用就是指导浏览器和服务器如何进行沟通。 HTTP通信过程简图： 客户端（通常为浏览器）负责发起请求 web服务器在 80 端口接收请求 web服务器之后负责响应请求的内容 浏览器负责下载响应内容 curl命令curl是一种命令行工具，作用是发出网络请求，然后得到响应和提取数据，显示在”标准输出”（stdout）上面。后面所说的请求，就是通过使用 curl 命令来实现的。比如输入：curl -s -v -- &quot;www.sina.com&quot;这一行命令，输出的请求内容为： &gt; GET / HTTP/1.1 &gt; Host: www.sina.com &gt; User-Agent: curl/7.55.0 &gt; Accept: */* &gt; 响应内容为: &lt; HTTP/1.1 200 OK &lt; Date: Sun, 03 Mar 2019 06:17:38 GMT &lt; Content-Type: text/html &lt; Content-Length: 23568 &lt; Last-Modified: Sun, 03 Mar 2019 06:16:24 GMT &lt; Connection: keep-alive &lt; ETag: "5c7b7138-5c10" &lt; Expires: Sun, 03 Mar 2019 06:22:38 GMT &lt; Cache-Control: max-age=300 &lt; Accept-Ranges: bytes &lt; Set-Cookie: TS0106d18b=0103cff18ca232a2464de8b94e660a71bf04913ec10acc3f4e7336f5c7620c43c b93a3a1e3e5b394e3b5f0d8d9c8c835e649efa77c; Path=/ &lt; 想了解关于 curl 里的参数，推荐使用explainshell.com来查看解释，很快捷很详细哦。 请求的格式 来自计算机客户端的请求一般包含以下几个部分： 1 请求行：动词 路径 协议/版本 比如： GET /index.html HTTP/1.12 请求头：Key1: value12 Key2: value2Key3: value3Content-Type: application/x-www-form-urlencodedHost: http://www.baidu.comUser-Agent: curl/7.54.0回车：没有内容4 消息体：要上传的数据 请求最多包含四部分，最少包含三部分，最少三部分时消息体可以为空，且第三部分永远是一个回车（\n） 动词有 GET（从服务器获取资源，一项或多项） POST（在服务器新建一个资源） PUT（在服务器整体更新资源，客户端提供改变后的完整资源）PATCH（在服务器局部更新资源，客户端提供改变的属性） DELETE （从服务器删除资源） 等。如果想用POST，就输入：curl -X POST -d “1234567890” -s -v – “https://www.sina.com&quot; 这里的路径包括「查询参数」，但不包括「锚点」 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 响应的格式来自服务器的响应一般包含以下几个部分： 1 状态行：协议/版本号 状态码 状态描述响应头：Key1: value1Key2: value2Content-Length: 17931Content-Type: text/html回车：没有内容消息体：要下载的内容 响应都有4个部分，具体其实跟请求的格式差不多 常见的状态码： 200：请求成功请求的资源被永久转移到其他地方（重定向）404：请求的资源不存在500：内部服务器错误 状态码分类 1开头：信息，服务器已经收到请求，需要请求者继续执行操作（不常用）2开头：成功，操作被成功接收并处理3开头：重定向，需要进一步操作来完成请求4开头：客户端错误，请求包含语法错误或无法完成请求5开头：服务器错误，服务器在处理请求时发成了错误 状态码列表 如何在Chrome上检查HTTP请求和响应？将Google Chrome视为常用浏览器，在其他浏览器中查看详细信息的过程仍然相同。 在Google Chrome中打开网页，然后转到”更多工具 &gt;开发者工具”菜单。 您也可以通过右键单击页面打开开发人员控制台，然后选择“检查”选项。 转到“Network”选项，然后重新加载页面。 现在，您将看到页面上每个组件的加载时间。 点击“Show Overview”图标以删除时间线，以便您可以清楚地查看其他详细信息。 单击左侧栏上的页面URL，然后转到“Response”选项。 （您还可以在“Preview”选项下查看相同的详细信息）。 您可以在上面的部分中详细了解请求和响应的详细信息。 “Headers”选项将显示所选项目的请求和响应的HTTP标头信息的详细信息。 HTTP 标头检查工具与Chrome类似，还有许多其他免费工具可用于检查HTTP标头中收到的响应代码。 例如，转到此HTTP标头检查工具，输入您要检查的任何URL，然后单击“提交”按钮。 例如输入https://www.baidu.com，您将看到如下标头的详细信息： HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 277Content-Type: text/htmlDate: Sun, 03 Mar 2019 07:27:41 GMTEtag: “575e1f6f-115”Last-Modified: Mon, 13 Jun 2016 02:50:23 GMTPragma: no-cacheServer: bfe/1.0.8.18 本人Github链接如下，欢迎各位Star https://github.com/miqilin21/miqilin21.github.io]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
