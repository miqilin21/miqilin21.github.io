<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一些好用的工具、网站]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。 Evernote：一款神奇的笔记✔如果一款工具能满足你对笔记的所有需求的话，那就是Evernote了，写笔记，列清单，时间管理，录音，工作同步，手机和电脑端都可下载… ✔如果你还没用过，推荐你现在关闭答案去应用市场下载一个，相信我你都会爱上它的。 免费人工智能PPT制作平台：beautiful.ai✔这个国外的黑科技网站，网站提供很多超赞的板式，我们将文字放进去，AI智能帮助我们制作PPT。真的让我这个一做PPT就头疼的人，感到开心！ ✔没广告还免费！ 录制GIF工具 ：GifCam✔录制动图对许多人来说也算是必备的东西了。 ✔窗口化录屏，也可以直接设置全屏幕录制，录制完毕后直接保存为 GIF 图片，软件大小不超过 2M，简直太方便太良心了~ 截图/贴图神器：Snipaste✔它在我心中绝对可以堪称神器了！令人惊叹不仅仅是它的强大截图功能，而是它的贴图功能也实在是太好用了！ 设计网址导航网站：牛大拿✔精选国内外优秀的UI设计网站,设计参考文章与免费的UI设计素材与资源，每日更新Dribbble精选内容、Behance精选内容、站酷精选内容、UI中国… ✔一定也有设计师不知道这个网站滴。 国外设计师常用网站：Dribbble✔通过 Dribbble，你可以浏览许多创意设计，它们出自世界各地的个人设计师、设计团队以及设计公司。 ✔这些作品并不仅限于网页或手机 app 设计，还有图片设计、品牌设计、动画、插图、平面艺术等等。 国内设计师常用网站：花瓣网✔花瓣网算是一个国内比较好的素材采集网，平时想要找的各种类型的图片素材在花瓣都能采集到，比如平面、漫画、摄影、UI等等。 ✔而且花瓣的素材普遍都很有设计感和时尚感，很适合年轻一代做设计。 设计师和开发常用网站：iconfont.cn✔阿里巴巴旗下的免费icon百科网站，可免费下载矢量源文件，选择时可以打包所有你感兴趣的放在购物车，Download时还可以选择颜色和大小,很贴心有木有！同时支持下载开发用代码。 ✔比如搜索关键词“love”看到的结果： 壁纸天堂：Wallhaven✔图片量大而且还高清，分类清晰(人物/风景/动画)。 ✔相比一些图库不全，广告遍地，收费下载的壁纸网站，免费下载的wallhaven简直就是业界良心。 在线制作流程图网站：ProcessOn✔ProcessOn在线支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 ✔轻松绘制，基本上是0难度上手。 在线生成图片链接网站：SM.MS✔SM.MS图床网站只需上传一张本地的图片，点击生成链接即可，操作简单快捷。 ✔永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式。 Listary：电脑文件秒搜+路径直达✔软件体积非常小，全局本地搜索的便捷工具，设置热键后，能在任何环境下调出窗口搜索文件，如我设置的是’Win+F’，想要找某文件时按下Win+F调出小长条搜索框就能进行实时搜索，非常便捷。 ✔相信你用了后会觉得它很高效的。 v9porn✔看到上面的标题，想必大多数人都知道了吧嘿嘿嘿 ✔那这个项目就不多介绍了，自行体会，体验好的话回来扣个赞哦]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之类型判断]]></title>
    <url>%2F2019%2F04%2F13%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[类型判断在 web 开发中较为常见，简单的有判断数字还是字符串，判断是数组还是对象稍微复杂一些，再复杂一点的有判断日期、正则、错误类型，再再复杂一点还有比如判断 plainObject、空对象、Window 对象等等。 通过本文，我将尝试概述Javascript中类型判断的几种方法（基于ES5的规范）。 typeoftypeof判断类型方法算是我们最最常用的了，直接上代码： 123456typeof 3 // "number"typeof "abc" // "string"typeof &#123;&#125; // "object"typeof true // "boolean"typeof undefined // "undefined"typeof function()&#123;&#125; // "function" 以上这些类型都比较正常，直到： 1typeof null // "object" 这显然是一个错误。 这可能会在以后的ECMAScript哪个版本中修复，返回值将为“null”。 除此之外 Object 下还有很多细分的类型，比如 Array、Date、RegExp、Error 等。如果用 typeof 去检测这些类型，举其中几个例子： 12345678var array1 = []var array2 = new Array();var date = new Date();var error = new Error();console.log(typeof array1); // objectconsole.log(typeof array2); // objectconsole.log(typeof date); // objectconsole.log(typeof error); // object 因此，typeof非常善于区分不同类型的原始值，并区分它们和对象，但在区分不同类型的对象（包括数组和null）时完全没用，那这该怎么区分？有没有更好的解决方法呢？ Object.prototype.toStringJS作为一门愈加成熟的语言，解决方法当然有！嘿嘿~这就是Object.prototype.toString！ 那 Object.protototype.toString看起来是一长串字母，看起来比较复杂诶~为了讲清楚，在toString方法被调用时,是会执行下面的操作步骤的： 如果this的值为undefined,则返回”[object Undefined]”. 如果this的值为null,则返回”[object Null]”. 让O成为调用ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 最后返回由 &quot;[object &quot;和 class 和 &quot;]&quot; 三个部分组成的字符串. 通过规范，我们至少了解了调用 Object.prototype.toString 最终会返回一个由 &quot;[object &quot; 和 class 和 &quot;]&quot; 组成的字符串，而 class 是要判断的对象的内部属性。 看这些规范还是一知半解的状态吧，直接上代码直观一点： 1234567console.log(Object.prototype.toString.call(3)) // [object Number]console.log(Object.prototype.toString.call([1, 2, 3])) // [object Array]console.log(Object.prototype.toString.call(&#123;&#125;)) // [object Object]console.log(Object.prototype.toString.call(null)) // [object Null]var date = new Date();console.log(Object.prototype.toString.call(date)) // [object Date] 我们可以看到这个 class 值其实就是识别对象类型的关键！ 因此我们可以用 Object.prototype.toString 方法识别出更多类型！那到底能识别多少种类型呢？那还是看代码数个数吧~嘿嘿 1234567891011121314151617181920212223242526272829303132var number = 1; // [object Number]var string = '123'; // [object String]var bool = true; // [object Boolean]var unde = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123;&#125; // [object Object]var array = []; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a()&#123;&#125;; // [object Function]function checkTypes() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(Object.prototype.toString.call(arguments[i])) &#125;&#125;checkTypes(number, string, bool, unde, nul, obj, array, date, error, reg, func)//打印出[object Number][object String][object Boolean][object Undefined][object Null][object Object][object Array][object Date][object Error][object RegExp][object Function] 除了以上 11 种之外，还有3种： 1234567console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]function a() &#123; console.log(Object.prototype.toString.call(arguments)); &#125;a(); // [object Arguments] 这里看我们至少可以识别14 种类型，而[[class]] 属性数量至少有 12 个。 写个类库利用Object.prototype.toString判断类型的方法来写个类库吧，此类库来自(Axis.js)[//github.com/toddmotto/axis]:123456789101112131415161718192021222324252627282930313233(function (root, factory) &#123; // 判断是否使用了模块 if (typeof define === 'function' &amp;&amp; define.amd) &#123; // 使用AMD模块 define(factory); &#125; else if (typeof exports === 'object') &#123; // 使用CMD模块 module.exports = factory; &#125; else &#123; // 没有使用模块，放在全局下 root.axis = factory(); &#125;&#125;)(this, function () &#123; // 严格模式 'use strict'; var exports = &#123;&#125;; // 将字符串转为数组 var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' '); // 判断类型 var type = function () &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125;; // 遍历types，为exports对象添加isArray、isObject...等方法 for (var i = types.length; i--;) &#123; exports['is' + types[i]] = (function (self) &#123; return function (elem) &#123; // type.call(elem)将type方法里的this指针指向elem return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return exports;&#125;); 使用方法也比较简单，直接上代码： 12345678910axis.isArray([]); // trueaxis.isObject(&#123;&#125;); // trueaxis.isString(''); // trueaxis.isDate(new Date()); // trueaxis.isRegExp(/test/i); // trueaxis.isFunction(function () &#123;&#125;); // trueaxis.isBoolean(true); // trueaxis.isNumber(1); // trueaxis.isNull(null); // trueaxis.isUndefined(); // true 考虑到实际情况下并不会检测 Math 和 JSON，而且上面这种方法也检测不了这两种类型，所以去掉这两个类型的检测。同时也不能识别自定义对象类型。 constructor当 typeof 也有无解的时候，那么我们是否还有其他好的方法来判断一个变量是自定义对象类型呢？ 我们知道，javascript 的所有对象都有一个 constructor 属性，这个属性可以帮我们判断 object 数据类型，直接上代码： 12345678910//alert(1.constructor); //报错 数字常量无 constructor 属性 var num = 1; console.log(num.constructor == Number); //true console.log("miqilin".constructor == String); //true var str = "miqilin"; console.log(str.constructor == String); //true var obj= null; console.log(obj.constructor); //报错，null 没有 constructor 属性 var none = undefined; console.log(obj.constructor); //报错，undefined 没有 constructor 属性 可以看出，数字型常量，null 和 undefined 都没有 constructor 属性。 之前以为到这就全部分析完了，看了多篇外文才知道原来还有可挖掘的东西，来看下面的代码： 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj.constructor == Cat); //false ？？因为 Cat.prototype不在obj的原型链上 console.log(obj.constructor == Animal); //true 理解 原来对于原型链继承的情况，constuctor 也不怎么好用了。那怎么办呢？ instanceof嘿嘿~原来还有一种方法可以解决这种困境，那就是 instanceof。instanceof 运算符会告诉您对象是否是某种类型的实例， 这里所谓的“类型”其实就是构造函数。直接上代码： 1234567891011function Animal() &#123; &#125; function Cat() &#123; &#125; Cat.prototype = new Animal(); Cat.prototype.CatchMouse = function () &#123; //do some thing &#125; var obj = new Cat(); console.log(obj instanceof Cat); //true 毫无疑问 console.log(obj instanceof Animal); //true 可以理解 instanceof 适用于所有原生类型： 1234[1, 2, 3] instanceof Array // true/abc/ instanceof RegExp // true(&#123;&#125;) instanceof Object // true(function()&#123;&#125;) instanceof Function // true 但是 instanceof 不适用于原始类型：字符串，数字，布尔值： 1233 instanceof Number // falsetrue instanceof Boolean // false'abc' instanceof String // false 所以这里constructor又有点优势了，可以适用于原始类型number，string和boolean的判断（constructor小节有例子）。 小结虽然检查任何一种特定类型真的不是那么难，但你可能不得不在此过程中做出很多选择，势必会引起一些混乱。因此，了解所有不同的选项会有所帮助，以下是对四种方法可识别类型的简单概括： typeof： 可以是标准类型（Null 除外） 不可识别具体的对象类型（Function 除外） Object.prototype.toString： 可是识别标准类型及内置对象类型（例如，Object, Date, Array） 不能识别自定义对象类型 constructor： 可以识别标准类型（Undefined/Null 除外） 可识别内置对象类型 可识别自定义对象类型 instanceof： 不可判别原始类型 可判别内置对象类型 可判别自定义对象类型 类型转换的图形化表示（其中红色单元格表示该判断方式不支持的类型）： 还有更复杂的判断比如 plainObject、空对象、Window对象、类数组对象等，还未涉及，后续也会增加。 敬请关注！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript系列之数据类型]]></title>
    <url>%2F2019%2F04%2F12%2FJavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript提供了不同的数据类型来保存不同类型的值，主要有两种类型的数据类型：原始类型和引用类型。 原始类型（值类型） Undefined undefined Null null Boolean true String &#39;hello&#39; Number 123 Symbol(这里先不做介绍) 引用类型（对象类型） Object：由以上几种基本类型组成，而且对象里面还可以包含对象 123456var obj = &#123;&#125;;&lt;!-- 原始类型变量的包装类型如下 --&gt;var bool = new Boolean(true);var str = new String("hello");var num = new Number(1);var obj0 = new Object(); 如MDN所讲，JavaScript 是一种弱类型或者说是一门动态语言。这意味着你不用提前声明变量的类型，而是在程序运行过程中，类型会被自动确定。 当然，原始类型和引用类型会有一些区别： 原始类型的值是直接储存在栈（Stack）内存中的，而引用类型的数据是把 Heap内存地址存在 Stack 里，所以对已引用类型的复制其实只是复制了相同的地址而非实际的变量值。 Number为整型直接量，浮点型直接量，十六进制直接量（0x-)，八进制直接量（0-）等 出现场合： 1024 3.14 1.2e5 0x10 0o377 除以上常规数字外，还有所谓的“特殊数值”，它们也属于这种数据类型：Infinity，-Infinity和NaN。 StringJavaScript中的字符串必须用引号括起来，有3种类型的引号 出现场合：123var str = "Hello, world!"; //双引号var str = 'Hello, world!'; //单引号var str = `Hello, world!`; //反引号 双引号和单引号是“简单”引号，它们在JavaScript中没有区别，但由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。 反引号是“扩展功能”的引用，允许我们通过将变量和表达式包装在$ {…}中来将它们嵌入到字符串中，比如：1234567var name = "miqilin";// embed a variableconsole.log( `Hello, $&#123;name&#125;!` ); // Hello, miqilin!// embed an expressionconsole.log( `the result is $&#123;1 + 2&#125;` ); // the result is 3 加反引号后计算$ {...}内的表达式，结果会成为字符串的一部分。 我们可以在其中放置任何东西：像名称这样的变量或像1 + 2这样的算术表达式或更复杂的东西。 但请注意，这只能在反引号中完成。 其他形式没有这种嵌入功能！1console.log( "the result is $&#123;1 + 2&#125;" ); // the result is $&#123;1 + 2&#125; (双引号不生效) Boolean布尔类型只有两个值：true 和 false 出现场合： 条件语句导致的系统执行的隐式类型转换 if(隐式转换){} 字面量或变量定义 var bool = true; 也出现在比较的结果 ： 123var isGreater = 4 &gt; 1;console.log( isGreater ); // true (the comparison result is "yes") Nullnull 出现场合： 获取不存在的对象 document.getElementById(&#39;not-exist-element&#39;) 在JavaScript中，null不是“对不存在的对象的引用”或者像其他语言中的“空指针”。它只是一个特殊值，代表“无”，“空”或“未知值”。 Undefinedundefined的含义是“未赋值” 出现场合： 变量声明了，但没赋值 var obj; 获取对象不存在的属性 var obj = {x: 0}; obj.y; 无返回值函数的执行结果 function f(){}; var obj = f(); 调用函数时，应该提供的参数没有提供 function f(i){console.log(i)}; f(); void(expression) null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 1undefined == null // true 但也有一丝区别，区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。12Number(undefined) // NaN5 + undefined // NaN Object属性集合 出现场合：1234567var obj = &#123; name: "miqilin" &#125;;var obj = new Cat();var obj = new function() &#123; this.sound = "wow";&#125; 但请注意，我们还没有提到过Array，Date，甚至是函数，因为正式地说，它们都是对象类型。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（二）]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。 Part1 组块什么是组块什么是组块 (chunk) ？对于绝大多数人来说这是一个全新的概念，看上去并没有什么意义，就像一堆乱糟糟的拼图。从神经科学的角度来看，组块就是通过应用或意义连接在一起的信息碎片。而在不加理解或不关注上下文的情况下，单纯的死记硬背并不能帮助你理解其内涵和你所学概念之间的关联，那么这个概念拼图就没有可以拼合的边缘，无法关联到其他的拼图碎片上。 当你全神贯注于某件事上，就好像你的脑子里有一只章鱼。这只注意力的章鱼会在必要时把它的触须穿过工作记忆的四个插槽，从而帮助你把分布于大脑不同区域里的信息联系起来。 这和发散模式下的随机连接不同，创建组块的过程中，它需要集中注意力将大脑的不同部分连接起来，专注模式下将不同的想法联系在一起。但在你很紧张时，你的注意力章鱼会失去一些连接能力，这也是为什么在你生气、紧张、害怕的时候，大脑似乎不能专注工作。 在任何领域获得专业知识的第一步都是先创建出概念组块。这种根据意义将信息碎片拼接起来的思维跃进，可以运用于所有人类能够掌握的领域，如运动、音乐、舞蹈等。最重要的是专注的训练和重复可以建立强的记忆痕迹，从而帮助你创建组块。专业的培养都是一小步一小步的，这个过程中，小的组块可以形成更大的组块。随着你对学习材料的理解越来越深入，所有的专业知识都只是更有创造性的见解的铺路石。 但仅仅通过练习和重复来创建组块，并不能使你得心应手并有创造力地运用它们。组块化可以让大脑工作得更有效，一旦你把某个想法、概念或动作组块化后，你就不再需要记住有关的全部细节，你只需要知道最主要的那个概念就行了，也就是只需要记住组块。这就像清晨起床穿衣服，你只需要一个简单的想法——“我要穿衣服”， 但细想你会发现这个简单想法的组块所包含的活动是非常复杂的。 怎样形成组块如果你是吉他初学者，你想学习弹奏一首有难度的吉他曲，你脑中关于这首曲子的神经表征可被看作是一个巨大的组块。首先你会听这首曲子、看别人弹奏这首曲子，还要从持琴姿势学起。和大多数技能一样，你通常需要将曲子的每一小部分转化为一个小的神经组块，再将这些小组块组合起来形成大组块。经过一段时间的练习，当你掌握了很多乐段之后，你就能流利地弹奏一个乐段了。 对于数学和科学的相关学科来说，关上书本检测自己，能够帮你检验那些你以为已经明白了的问题，并且加快你的学习速度。当你能独自完成某件事时，你才是真正掌握了它。许多事情都是这个道理，就像你只是看别人画画，并不代表你也能画出来，仅仅听别人唱歌并不能使你拥有同样的唱功和洪亮的嗓音。某件事如果你只是在看，或者就算理解了如何去做，也不代表你能真正做到。只有在你自己实际操作和完全掌握的情况下才能建立起神经模型。 组块化的第一步：就是对你想要组块化的信息全神贯注。如果你正开着电视，或是每隔几分钟就检查、回复手机上的消息，这些都会增加你建立组块的难度，因为你的大脑并没有完全投入到新信息的组块化中去。 组块化的第二步：要求你对建立组块的对象有基本的了解。无论是理解概念性的知识，还是寻找故事中不同情节间的关联，通常我们都可以自然而然地领会所学内容的大意。 组块化的第三步：是获取背景知识。不断重复和练习解决相关的或不相关的问题，这样你不仅知道如何使用组块，还明白应该什么时候使用。这样做能帮你认识新建立的组块是如何融入整体知识框架的。 最后第四步，练习能帮你拓宽组块连接的神经网络，并确保它们不仅牢固，还能通过不同途径访问。正如下图所示，学习由两部分组成，自上而下的认识以及由下至上的组块化。 在由下至上组块化的过程中，练习和重复能够帮助你建立和强化每一个组块，这样你就可以在需要它的时候使用它。当自上而下的方法能够让你清楚地看到你正在学习什么以及它适用于哪里。就完全掌握知识而言，这两个过程都非常重要。而背景认识就是这两个过程的交汇处，背景认识意味着学会在特定的时候使用正确的方法。 通常在真正的阅读之前，快速浏览书中某一章的图片以及小标题，能够帮助你知晓大意。听那些有严谨层次结构的课程，可以帮你弄清楚应在哪里建立组块以及如何把不同组块联系起来。一旦完成了这些，再了解具体的信息，那么就算遗漏了一些让你疑惑的部分，你依然可以理解主要部分。 总的来说，最好在精神高度集中的时候建立组块，理解基本的含义后，通过练习来真正掌握知识，并对情境有个大致了解，是建立组块的基本步骤。快把“组块”融入到你正在使用的学习中去吧！ 能力错觉这一小节来介绍一些让学习走上正轨的基本理念。 1.回顾的重要性 学习书本或资料时，最常见方法之一就是反复阅读。不过心理学家Jeffrey Karpicke证明，这种方法的成效远不及另一种简单技巧——回顾。也就是阅读材料后，移开视线，看看你能回忆起多少内容。 Karpicke发表在《科学》杂志上的研究提供了可靠证据。先让学生们学一篇科技文章，然后通过尽力回忆其中信息来巩固练习；接着，让他们重读并再次回想。结果相同时间内仅用回顾法练习的学生较使用其他学习方法的学生而言，对材料的掌握更为全面深入。其他学习方法包括反复阅读资料，或者绘制可以加强学习材料之间联系的思维导图。学生通过正式考试或非正式自测都证明了回顾法有助于学习。这给了我们一个重要提示，即在回顾知识时，我们并非机械地复述，而是在通过回顾这个过程加深理解。这也有助于我们形成知识组块，就好像回忆过程帮助我们在神经上嵌入了“钩子”，以便我们串联起前后知识。 比起被动重复阅读，回顾——即在心里检索关键概念——可以使你的学习更加专注高效，只有隔上一定时间后再重读才会有效果，因为这样，重读就更像是间隔重复练习。 2.能力的错觉 你该明白你才是要解决问题和掌握概念的人，如果你看到某个习题答案后告诉自己，“哦，我明白他们为什么这么做了！” 那么这个答案并不真正属于你，因为你没有真正把这些概念嵌入自己潜在的神经回路中去。这是一种学习中最为常见的自欺欺人式错觉。如果你想要很好地掌握材料以在考试中取得好成绩，并从中创新，就必须让这些知识在你脑海里生根发芽。 另一个类似情况就是做笔记和注释。做笔记时高亮和下划线必须要谨慎，否则不仅没有效果还容易产生误导。在空白处写笔记总结关键概念也被证明是一种很更好的办法。 Karpicke的研究还发现，学生们喜欢重读笔记或课本的原因是，当他们面前打开着课本、笔记或谷歌时，会误以为这些知识同样在他们的脑海里，然而事实却并非如此。因为看书比回顾做起来简单，学生们会陷入一种自欺欺人的错觉。事实上，这种学习方式效率很低。 3.自测与犯错 能力的错觉提醒我们，在学习资料上花太多时间并不能保证你真的懂了。而自测是一种极其有用的办法，来确保你是真的学会了，而不是自欺欺人的错觉。从某种意义上来说，这就是回忆在发挥作用。 让你发现自己是否真的掌握一个概念，犯错实际上是件好事。因为你之后就会想要避免重复犯错，所以实际考试前，在自测中犯的错是很有价值的，因为它们能让你一点点弥补思维漏洞。犯错可以纠正思考方向，让你学得更好、做得更好。 4.多场合回顾 回顾是一种有效工具，而在常规学习场所以外回顾知识则会帮助你加深对知识的理解。通过在不同物理环境下回顾和思考知识，你会脱离对给定场所的依赖，这会帮助你避免由于考试与学习场所的不同而产生的问题。 Part2 看到全局是什么激励了你？你会发现当学的东西并非自己真正喜欢的东西时，学习是非常困难的；而学习自己真正感兴趣的东西的时候，一切都变得非常简单，那这是为什么呢? 你的大脑有一套神经递质的广泛投射系统，它加载的不是经验本身的内容，而是信息的重要性以及对未来的价值。神经递质是可以影响神经元如何回应其他神经元的化学物质。今天我们将要谈谈它们其中的三种，乙酰胆碱、多巴胺和血清素。 乙酰胆碱影响专注学习和集中注意力。当你注意力高度集中的时候，这些乙酰胆碱神经元就会广泛地投射出来，并且激活环路来控制突触可塑性，从而形成新的长期记忆。 多巴胺信号与意料之外的奖励相关。当接受到一个毫无预期的奖励时，这些神经元将分泌出多巴胺，多巴胺的信号将广泛投射，这会对学习产生强有力的影响；同时也会影响决策，甚至是感官输入的价值所在，它控制着我们的动力。比如番茄工作法中的设置奖励就是给自己的多巴胺神经元加油。 血清素影响社会生活和冒险行为。它可以有力地影响你的社交生活。在猴子部落中的雄性首领有着最高的血清素分泌水平，而位列最末的公猴，其血清素水平则最低。血清素也与风险行为有着紧密的联系，在那些血清素低的猴子身上往往能观察到更多的冒险行为。服刑犯人中，因暴力犯罪而入狱的是社会中血清素分泌活动最低的群体之一。 情绪也可以强烈地影响你的学习。你自己应该深有体会，情绪曾一度被认为与认知互不影响，然而近期研究显示，情绪、感觉以及注意力互相交织，并与学习和记忆力互相影响。 对于成功的学习来说，情绪及神经递质系统比感知和动作要反应迟缓，但却同等重要。 组块库的价值将新的组块和原有组块结合起来的能力，体现在很多历史的创新变革中。比如比尔·盖茨与其他工业领袖会留出长达一周的阅读周期，以便在一段时间内掌握多种不同想法，把新鲜想法留在头脑中，与未忘记的想法进行自我交流，可以形成创新性思维。 你的组块库越大，运用越熟练，无论学什么科目，你都将能够更轻易地解决问题。组块化并非创新灵活度所需要的全部，但是它是重要的一环。组块还可以帮助你理解新概念。这是因为当你理解一个组块时，你会发现这一组块能以令人惊讶的方式与相似的组块联系起来。不仅在同一领域中如此，在截然不同的领域中也是这样。这就是所谓的知识迁移(transfer)。 你建立每一个组块，它就为你补上知识拼图的一块，但如果你不训练变大的组块，它们就会保持模糊的状态，你要学习的东西拼到一起就会更为困难。建立组块库就是在训练你的大脑，不仅要认出一个特定的概念，还要识别概念的类别，以便你能够自如地知晓如何快速处理你遇到的问题。你将开始看到一些为你简化解决方法的模式，并很快发现不同的解决方法就潜藏在你的记忆边缘。 有两种途径解决问题，一是顺序性地，一步步推理；二是通过整体性的直觉。顺序性思维涉及到专注模式；而直觉通常需要创造性的发散模式来联系不同的想法。大多数较难的问题和概念都是通过直觉来理解的，因为新的想法和你熟悉的领域相去甚远。发散模式是半随机地进行连接，这意味着它们带来的解决方法，应该由专注模式进行小心验证。直觉性的理解不是永远正确的，你大概会想无论你在学什么，仅在单一的部分或章节里就有那么多问题和概念，根本没法全学会。这时机遇定律就发挥作用了，幸运女神会眷顾努力之人。专注于你正在学习的单元，你会发现一旦你把第一个问题或概念放进组块库，不论那是什么，第二个概念的进入就会容易一些，然后第三个概念也就更容易，这并不都那么简单，但会越来越容易。 过度学习、思维定势、交替学习当你在学习一个新单词、一种新概念或新的问题解法时，你需要在同一学习阶段内反复练习。一定的练习是必要且有用的，但在完全掌握此阶段的所有内容后继续学习训练，就是所谓的过度学习。过度学习在有些场合是有意义的，比如对网球发球、钢琴协奏曲演奏可能非常重要，它能在紧张的时候，帮助其行为自动化。但仍要警惕在单一学习阶段的重复性过度识记，研究表明，这可能会对宝贵的学习时间造成浪费。 一旦你在某一阶段学会了一个基本概念，在这段时间不断地巩固它，并不能加强你所期许的长期记忆联系。学完一段时间之后再复习是更好更有用的，这可以加强并深化你的组块化神经模式。但请注意，重复你已经掌握的东西非常容易，而这可能会造成能力错觉，让你误以为自己已掌握了所有材料，但其实你只掌握了简单的部分。所以，你应该均衡学习，把精力集中在你认为困难的部分。专注于学习的困难部分称为刻意训练 (deliberate practice) ，这种刻意训练 (deliberate practice) 通常是好学生与优秀学生的差别所在。 这些与思维定势(Einstellung) 的概念有关。一个已经形成并加强的神经模式可能阻碍你发现更棒的解决方案。思维定势在这张弹珠脑图里就表现为，你最初的想法向大脑上方移动，而解法的思维模式则位于下方。 密集的专注模式以及先前构造的思维模式，会形成惯性，阻止你走向一个可能发现解决方法的新区域。你可以把思维定势想像为一个路障，而它是你最初的想法所造成的，这种错误的方式在运动和科学学科中就很容易发生。因为有时你最初”发生什么”或”该去做什么”的直觉是有误导性的，在学习新事物时，你必须摒弃错误的旧思想和方法。 学生学习时会犯的一项重大失误是，在学会游泳前就跳入水中。换句话说，他们盲目地开始做作业，不看书、不上课、不看在线课程，或甚至不与熟识此方面的人交谈。这种学习方法只会失败。就像在放任思想在一个专注模式的弹珠器里跳来跳去，而完全不考虑解法到底在哪里。在学习和生活中，理解如何得到真正的解决方法很重要。掌握一门新学科不仅要学习基础组块，更要学会如何选择和应用不同的组块。最佳的学习方法是，在需要不同技术和策略的问题中来回切换、练习，这就是所谓的交替学习。 交替学习非常重要，你需要让自己的大脑习惯这种思想，即仅仅知道如何使用特定的概念、方法或解题技巧是不够的，你也需要知道何时去使用 ，要贯彻交替学习的思想。这样你才能脱离只会练习和重复，而开始学会独立思考。当你在一个学科内交替学习，你就开始在这个学科内发展创造力了。当你在多个不同学科间交替学习，你就能更容易地在不同领域的组块间创造联系，这能进一步提高你的创造性。当然，在不同领域间发展固定知识组块需要时间，所以有时需要取舍。成为几个领域的专家，意味着你可以将一个领域的新思想引入另一个领域，但这也可能意味着，你在某个领域的专业知识 并不如专攻一个领域的人那么深厚。反过来，如果你只专研一个学科，你可能对它有很深刻的理解，但也变得只习惯某种思考方式，这种根深蒂固的思考模式，让你很难把握新思想。 科学哲学家Thomas Kuhn发现，科学中大部分的方式转变都是由年轻人，或者之前学习其他学科的人所提出的。他们不那么容易陷于思维定势，不会被先前的专业训练阻碍思想。有句老话说道，科学会随着每个葬礼的进行而进步，因为葬礼意味着根深蒂固的旧思想的流逝。 下一节课我们会学习怎样应对拖延症，以及拖延症和记忆的关联。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客中遇到的一些"事"]]></title>
    <url>%2F2019%2F04%2F03%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E2%80%9C%E4%BA%8B%E2%80%9D%2F</url>
    <content type="text"><![CDATA[我写的这篇文章已经详细讲解了怎样利用hexo搭建GitHub个人博客，自从入了hexo搭建博客的坑后，发现hexo真的是巨TM好用， 配置好以后对我最大的方便就是想改就改，想删就删，一条 $ hexo g -d 命令搞定了事，支持 Markdown ，还支持非备案域名绑定，开心！ 搭建过程中也并非一切顺利，稍微不注意就出现bug，接下来罗列了几条我搭建过程中所遇到的一些“事”及解决办法。 仓库的名字仓库的名字的正确格式应该是github用户名.github.io，比如说，如果你的github用户名是test，那么你就应该新建test.github.io的仓库（必须是你的github用户名，这里再强调一遍，其它名称无效，之前因为没仔细看，随便起了个名字，果断报错）。 首页文章内容部分展示我用的是next主题，默认会把所有文章内容都展示出来，这可不简洁美观。所以查了一下，有一个小技巧，就是在你觉得要展示在首页的Mrakdown文件内容文字后面添加&lt;!--more--&gt;即可。例如：123456789101112---title: HTML、CSS、JS中unicode字符的处理 ---# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； GitHub Pages绑定域名后每次hexo d都会失效在GitHub Pages绑定域名之后，发现每次hexo d后，域名网址都会报错404，又要重新部署，就有点太麻烦了。 搞了很久还是不行，后面在网上和群里问出，到这里域名绑定并没有结束，还差关键一步： 具体就是在Hexo目录里的source文件下添加一个名为CNAME的文件，注意这个文件是没有后缀的，千万不要设置成.txt文本文件，文件的内容就是域名，格式如： luozongmin.com 添加后重新部署文件到github，这个时候再试，应该就成功了。 创建分类页面添加一个分类页面，并在菜单中显示页面链接。应先新建一个页面，命名为 categories ，命令如下： $ hexo new page categories 注意！！！categories中千万别加””(双引号)，不然会导致部署完后网站中不显示具体分类： 之后在编辑刚新建的页面中，将页面的类型设置为categories； 最后编辑主题的_config.yml，将menu中的categories: /categories注释去掉即可。 Busuanzi 统计浏览量失效由于busuanzi(不蒜子)的网址更新，导致了使用Hexo Next主题时统计浏览量时失效。 解决方法: 到hexo的themes文件夹下, 进入\themes\next\layout_third-party\analytics 打开: busuanzi-counter.swig 将src=“https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js” 修改为src=“https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js” 即可。 不蒜子官网:http://ibruce.info/2015/04/04/busuanzi/]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会如何学习（一）]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？ 无意中在Coursera上发现了一门神奇适用的课程，叫做“Learning How to Learn”， 旨在利用科学知识以及授课者切身经验教会你学会如何学习，学习这门课我才开始恍然大悟，原来学习应该这样学习，算是初步悟到如何学习的真谛了。下面我将讨论我从第一周课堂中学到的经验教训。 利用专注与发散思维研究发现，人有两种完全不同的思考模式，专注模式（focused mode）和发散模式（diffuse mode）。就目前神经学家所知，专注模式与发散模式只能单独存在，你不能同时使用两种模式。而发散思维是你试图了解新事物时应该采取的思维模式。 课程讲述萨尔瓦多·达利 (20世纪著名的超现实主义画家)有时会坐在椅子上，放空自己的大脑，并常常会漫无目的地思考一下之前的工作。这样他就能把脑海中那些在发散模式下得到的的联想和点子及时地收集起来，然后带着这些在发散模式下得到的新想法回到专注模式里去。 这个例子目的是告诉我们：当你处于长期专注的学习模式时，可以通过小睡或做一些运动，然后过渡到发散模式，有助于你的大脑建立必要的神经连接，在你的长时间记忆中建立持久的知识块。还要强调的是，当你学习一些新的东西，尤其是比较难的东西的时候，你的大脑需要有在两种学习模式之间来回转换的能力，这能帮助你更高效地学习。想要锻炼你的神经，你需要每天做一点练习，逐步建立起支撑你思考的神经骨架，这就是关键所在。 拖延症每个人或多或少有拖延的毛病，只不过有些人比较严重。当你面对一件你极度不情愿做的事情时，就好像激活了大脑中与疼痛相关的区域。 所以拖延的过程大概如下图：首先，某件事可能会让你产生轻微的不安；为了消除这种不适感，你会转而去做一些更让人愉悦的事情，这么做的结果就是你觉得更开心了，但这只是暂时的，后续文章会更深入地去了解拖延症。 番茄工作法课程告诉我们一个小巧方便的意志力工具，这个小工具叫做番茄工作法 (Pomodoro)。这个小技巧所需的只有一个计时器（手机上搜索“番茄ToDo”APP，电脑端也有许多类似的软件，可以自行选择），具体的实行过程是这样的： 首先需要把计时器设定25分钟，屏蔽所有会打扰你的事物； 在25分钟内，集中精力专注你所要专注的事； 最后还有一件很重要的事情是，当你前两步之后要给自己一点小小的奖励。比如：上几分钟网、喝杯咖啡或者简单地做一下运动，来使你的大脑可以愉悦的放松一会儿。 实行后你会发现番茄工作法的使用效果非常明显，这就像是你的大脑在健身房做完一次25分钟的高强度训练，然后进行休息放松一样。当你无法专注的时候不妨试一试！ 记忆与练习当我们回忆数学方程组时，我们使用的是长期记忆。当我们尝试结合脑海中的想法来帮助我们理解某一概念或解决某一问题时，我们使用的是工作记忆。工作记忆和长期记忆是两种主要的记忆系统，工作记忆是大脑在即时且有意识地处理信息时所涉及的那部分记忆。 长期记忆就像一个储存仓库，不同的长期记忆储存在大脑的不同区域。研究表明，当你首次尝试将一段短期记忆转入长期记忆中时，你需要多次回顾以增加需要时找到相关信息的几率。 当你遇到新事物时，你通常会运用工作记忆来处理它，如果你想将这个信息转移到长期记忆里，就需要间隔重复的练习来促进这一过程。 不断重复你尝试记忆的内容，但重复的过程必须间隔开来。如果你尝试在一个晚上重复记忆20次相同的内容，记忆效果还比不上在几天内重复同样的次数这种方法。 练习在数学和科学中学到的思想和概念是很重要的，通过反复实践练习可以帮助你提高和增强学习过程中生成的神经连接，越是抽象的东西越要注重练习。 学习的时候如果一心一意地专注学习，时间一长学习效果反而不好，需要休息一下或者至少稍稍将注意力转移到其他地方。在这段看似放松的时间里，你大脑的发散模式就有机会在后台帮你完成对概念的理解。如果你不这么做，而是进行填鸭式学习，你的知识库看起来将会像杂乱不堪，基础不牢靠的泥堆。 如果你有拖延问题，就需要使用番茄工作法帮助你注意力集中一段时间，并适当休息。这会帮你行动起来，并开始建立你需要的神经模式，使你能更有成效地学习更具挑战性的内容！ 睡眠的重要性你怎么也不会想到，当你绝对清醒时你的大脑会产生一些有毒的物质，那大脑如何除掉这些有毒物质呢？原来当人们睡觉时，大脑细胞会收缩，从而增加脑内细胞之间的距离。这就像疏通了一条溪流，液体会在细胞空隙间流过，冲走有毒的物质。所以，睡觉这件事有时候看起来像是浪费时间，实际上是大脑保持清洁和健康的一种方式。 睡眠不足意味着少量代谢毒素残留在你的大脑之中，而这些有毒物质会让你思维混乱，不仅会让你发挥失常，还会导致头疼、抑郁症、糖尿病、心脏类疾病，甚至寿命缩短，这绝不是在吓你，可以参考一下睡眠不足的危害。 睡眠对人们解决困难问题和理解所学知识的能力有显著影响，大脑会将你学习和思考过的想法、概念进行整理，清除掉一些不太重要的部分；同时增强你需要或想要记住的区域的记忆。在睡梦中，大脑还会将你努力学习到的东西在神经中枢一遍遍排演以增强加深记忆力！ 如果你在打盹或睡觉之前，复习一遍所学东西，那你将有更大可能性梦到它。如果你更进一步，告诉自己你想要梦到这些内容，你梦到它的几率也会大大提高。梦见你所学的知识，本质上能够增强你的理解能力，在一定程度上可以将你的记忆整合成更易被掌握的组块信息。 现在是时候去打个盹儿了！ 采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法1、当你遇到完全陌生的事物时你是如何更容易学习的？ 答：单刀直入地实践，因为实践出真知，且大量的阅读作用甚微，同时最好有专家的指点。 2、你是如何让自己在一场枯燥的讲座中保持专注的？ 答：没有简单的方法是可以让你对不感兴趣的东西一直保持参与度的，但是有一个小技巧，就是用提问来“伏击”演讲者，这种打断通常会带出更有趣的讨论；比起被动的听，积极参与会让你学到更多。 3、你是如何进入发散思维模式，并从中获益的呢？ 答：慢跑或户外锻炼是让思维跳出常规想法的绝佳方法，而且这时极其可能迸发灵感。奔跑中，事物从你身边略过，你会开始思考发生的一些事情，然后意识之外的想法涌上表面，接着通常就会出现有用的新想法。但是，这些转瞬即逝的点子过后很容易忘记，我会随身携带一本小本子及时记下来。 4、你会同时进行多项任务吗？ 答：生活中有大量任务不断地“轰炸”，我们一刻也离不开多线程工作，如果做不到统筹兼顾，日子将会很难熬。但我们不能真正地同时做两件事，容易混淆且效率低下。同时处理多个任务实际是一种切换任务的能力。你可能要花很多时间才能完成这样的切换，切换任务并回到当时中断的地方开始工作，这是高效完成任务的方法之一。 5、神经科学方面的知识有运用到学习上的例子吗？ 答：别把自己关在房间里，充足的空间、能激励你的人、很多可以积极参与的事件，以及运动和锻炼都大有助益，它们会增加新神经元的数量并促进神经元的生长。 6、你有关于高效地集中注意力、学习和创新的技巧吗？ 答：处于富有创新氛围的环境中，是一种提升自身创造力的方法。当你和别人交流、阐述观点，你就会有更好的想法，这一过程通常有助于创新。 7、给大家的建议? 1） 聪明的人并不一定会成功，有很多聪明的人并不成功，而那些富有激情并且坚持努力的人容易达到，是因为人生中的成功多半来自于激情和努力，往往成功的人的身上都具有这样的品质。 2）每天我们周围都有值得发现去重新理解的东西，我们必须要用不同的视角来看待这些普通的东西，这很重要。]]></content>
      <categories>
        <category>学习之道</category>
      </categories>
      <tags>
        <tag>高效学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令拓展]]></title>
    <url>%2F2019%2F03%2F29%2FGit%E5%91%BD%E4%BB%A4%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[本文的内容基本上是从廖雪峰及阮一峰老师的Git 教程中总结出来的，方便自己以后查阅相关命令。 一般来说，日常使用只需要记住下图6个命令即可。但是想往深度使用Git，恐怕还需要记住其余的几十个命令。 上图中几个专用名词的译名如下： Workspace：工作区 Index / Stage：暂存区 Repository：本地仓库 Remote：远程仓库 配置123456$ git config --list //显示当前的Git配置$ git config -e [--global] //编辑Git配置文件$ git config --global user.name "miqilin21"$ git config --global user.email miqilin21@example.com //设置你的仓库用户名及邮箱，用于标识提交者 新建Git代码库12345$ git init //在当前目录新建一个Git代码库$ git init [project-name] //新建一个目录，将其初始化为Git代码库$ git clone [url] //下载一个项目和它的整个代码历史 添加/删除文件123456789$ git add [file1] [file2] ... //添加一个或多个文件到暂存区$ git add [dir] //添加指定目录到暂存区，包括子目录$ git add //添加当前目录的所有文件到暂存区$ git rm [file1] [file2] .. //删除工作区文件，并放入暂存区$ git rm --cached [file] //停止追踪指定文件，但该文件会保留在工作区 本地文件提交1234567$ git commit -m "Commit message" //提交暂存区到仓库区$ git commit -a //提交工作区自上次commit之后更改的所有文件，直接到仓库区$ git commit -v //提交时显示所有diff信息$ git commit --amend -m "Latest commit message" //使用一次新的commit，替代上一次提交；如果代码没有任何新变化，则用来改写上一次commit的提交信息 同步远程仓库123456789101112131415$ git fetch [remote] //下载远程仓库的所有变动$ git remote -v //显示所有远程仓库$ git remote show [remote] //显示某个远程仓库的信息$ git remote add [shortname] [url] //增加一个新的远程仓库，并命名$ git pull [remote] [branch] //同步远程仓库的变化，并与本地分支合并$ git push [remote] [branch] //上传本地指定分支到远程仓库$ git push [remote] --force //强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --all //推送所有分支到远程仓库 撤销1234567891011121314151617181920212223$ git checkout [file] //恢复暂存区的指定文件到工作区$ git checkout [commit] [file] //恢复某个commit过的文件到暂存区和工作区$ git checkout //恢复暂存区的所有文件到工作区$ git reset [file] //重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset --hard //重置暂存区与工作区，与上一次commit保持一致$ git reset --hard [commit] //重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git revert [commit] //新建一个commit，用来撤销指定commit；后者的所有变化都将被前者抵消，并且应用到当前分支$ git stash //将工作区现场保存起来，等以后恢复后继续工作。通常用于处理更为着急的任务时，例如：bug$ git stash list //查看保存的工作现场$ git stash apply //恢复工作现场$ git stash drop //删除stash内容$ git stash pop //恢复的同时直接删除stash内容 分支12345678910111213141516171819202122232425$ git branch //列出所有本地分支$ git branch -r //列出所有远程分支$ git branch -a //列出所有本地分支和远程分支$ git branch [branch-name] //新建一个分支，但依然停留在当前分支$ git branch [branch] [commit] //新建一个分支，指向指定commit$ git checkout -b [branch] //新建一个分支，并切换到该分支$ git checkout [branch-name] //切换到指定分支，并更新工作区$ git merge [branch] //合并指定分支到当前分支$ git push origin [branch-name] //将分支推送到远程仓库$ git push --all origin //将所有分支推送到远程仓库$ git branch -d [branch-name] //删除分支$ git push origin --delete [branch-name]$ git push origin :[branch-name]$ git branch -dr [remote/branch] //删除远程分支 标签12345678910111213141516$ git tag //列出所有tag$ git tag [tag] //新建一个tag在当前commit$ git tag [tag] [commit] //新建一个tag在指定commit$ git tag -d [tag] //删除本地tag$ git push origin :refs/tags/[tagName] //删除远程tag$ git show [tag] //查看tag信息$ git push [remote] [tag] //提交指定tag$ git push [remote] --tags$ git push --tags origin //提交所有tag 查看信息123456789101112131415161718192021222324252627282930313233343536$ git status //显示有变更的文件$ git log //显示当前分支的版本历史$ git log --stat //显示commit历史，以及每次commit发生变更的文件$ git log -S [keyword] //搜索提交历史，根据关键词$ git log --follow [file]$ git whatchanged [file] //显示某个文件的版本历史，包括文件改名$ git log -p [file] //显示指定文件相关的每一次diff$ git log -5 --pretty --oneline //显示过去5次提交$ git shortlog -sn //显示所有提交过的用户，按提交次数排序$ git blame [file] //显示指定文件是什么人在什么时间修改过$ git diff //显示暂存区和工作区的差异$ git diff --cached [file] //显示暂存区和上一个commit的差异$ git diff HEAD //显示工作区与当前分支最新commit之间的差异$ git diff [first-branch]...[second-branch] //显示两次提交之间的差异$ git diff --shortstat "@&#123;0 day ago&#125;" //显示今天你写了多少行代码$ git show [commit] //显示某次提交的元数据和内容变化$ git show --name-only [commit] //显示某次提交发生变化的文件$ git show [commit]:[filename] //显示某次提交时，某个文件的内容$ git reflog //显示当前分支的最近几次提交]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+GitHub搭建个人博客]]></title>
    <url>%2F2019%2F03%2F21%2F%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo是一个快速、简介且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多，所以就用它啦~ 下面一步一步地说怎么用hexo+github搭建一个个人博客。 说明：本文只针对Windows平台下的搭建过程，其他平台的请自行上网查阅 准备在搭建博客之前，需要安装node.js和git，具体操作请参考这篇文章，并同时申请Github账号，使用的开发工具为VScode。 安装Hexo1、首先新建一个文件夹如myBlog，用于存放整个博客源文件。右击鼠标点击文件夹，选中Git Bash Here在Git命令行中打开。 2、执行以下命令安装Hexo及生成第一篇博客文章：1234$ npm install -g hexo-cli //安装hexo$ hexo init //初始化hexo,这样myBlog就是整个博客的根目录，所有的页面都可以在里面进行增删改操作$ hexo generate //生成静态页面$ hexo server //启动本地服务器，进行博客文章预览 Hexo会默认生成第一篇博客《Hello World》，在浏览器下打开localhost://4000你将会看到： myBlog源文件夹整体目录预览： 其中_config.yml和package.json为项目的配置文件，themes存放了我们博客的主题，source-&gt;_post为我们的博客目录，public为执行hexo generate后生成的静态页面。 关联Github1、在你的Github中建立新的 repo，repo 名称必须是「你的用户名.http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。 2、将myBlog目录中的_config.yml文件在VScode中打开，编辑网站配置： 把第 6 行的 title 改成你想要的名字 把第 10 行的 author 改成你想取大名 把最后一行的 type 改成 type: git 在最后一行后面新增一行，左边与 type 平齐，加上一行 repo: 仓库地址 （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址最好以 git@github.com: 开头） 3、修改完成配置后在myBlog目录下执行命令：12$ npm install hexo-deployer-git --save //安装 git 部署插件$ hexo deploy //将本地博客代码部署到Github上 4、进入「你的用户名.http://github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接；最后用浏览器访问「预览链接/index.html」就应该看到了你的博客啦！ 添加新文章1、打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就相当于在本地添加了新文章 2、利用来VScode编辑新文章 3、hexo generate 4、hexo deploy 5、去看你的博客，应该能看到这篇新文章啦！ 更换主题1、https://github.com/hexojs/hexo/wiki/Themes 上面有主题合集 2、随便找一个主题，进入主题的 GitHub 首页，比如我找的是 https://github.com/iissnan/hexo-theme-next 3、复制它的 SSH 地址或 HTTPS 地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git 4、cd themes 5、git clone git@github.com:iissnan/hexo-theme-next.git 6、cd .. 7、将 _config.yml 的第 75 行改为 theme: hexo-theme-next，保存 8、hexo generate 9、hexo deploy 10、等一分钟，然后刷新你的博客页面，你会看到一个新的外观，如果不喜欢这个主题，就回到第 1 步，重选一个主题。 tips1、最好进入一个安全的目录创建源文件夹，在根目录瞎搞； 2、_config.yml中的缩进和空格一定严格按照文件的默认格式来，不然会报错； 3、想要删除博客的话，直接删除source-&gt;_posts-&gt;对应的博客文章，然后再次执行hexo generate、hexo deploy即可； 4、在_config.yml中修改language为zh-CN，即可将博客中英文转换为中文； 5、常用命令：1234567hexo new "postName" //新建文章 hexo new page "pageName" //新建页面 hexo clean //清除缓存文件db.json和已生成的静态文件 public,网站显示异常时可以执行这条命令试试。hexo generate //生成静态文件 hexo deploy //部署到Giihub hexo server //启动本地服务器 hexo help //查询帮助 6、md文件需要用到markdown语法。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—三栏布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局的页面可分为左中右三部分，然后对中间那部分做自适应的一种布局方式。三栏布局在前端页面的开发中十分常见，那么怎么样的才算是三栏布局呢？ 比如苏宁易购的首页： 上图的布局就是一个常见的三栏布局：即左边商品导航和右边导航为固定宽度，中间内容随浏览器宽度变化自适应。 下面详细介绍了一些经典及新兴的三栏布局方式，且所有方式显示的效果如下图： 绝对定位布局1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; position: relative; &#125; .left &#123; position: absolute; width: 150px; height: 200px; left: 0; top: 0; background-color: red; &#125; .middle &#123; height: 200px; margin: 0 160px; background-color: green; &#125; .right &#123; position: absolute; width: 150px; height: 200px; right: 0; top: 0; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 绝对定位布局是一个比较古老和容易想到的方式，其特点就是简单实用，而且也不容易出问题，缺点就是，容器脱离了文档流，后代元素也脱离了文档流，当高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 float布局12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .left &#123; float: left; height: 200px; width: 150px; background-color: red; &#125; .middle &#123; margin: 0 160px; height: 200px; background-color: green; &#125; .right &#123; float: right; width: 150px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; float布局也是一种较为简单且容易想到的方式，原理是左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应，缺点就是中间部分最后加载，内容较多时会影响体验。 BFC 三栏布局123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .left &#123; float: left; height: 200px; width: 150px; margin-right: 10px; background-color: red; &#125; .middle &#123; height: 200px; overflow: hidden; background-color: green; &#125; .right &#123; float: right; width: 150px; height: 200px; margin-left: 10px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; BFC有一特性：BFC的区域不会与外部浮动元素重叠，这里利用了这一特性，实现了两栏自适应布局。缺点和方法二类似，为了解决这个问题，引出下面要介绍的双飞翼布局。 双飞翼布局1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .content &#123; float: left; width: 100%; &#125; .left &#123; float: left; height: 200px; width: 150px; margin-left: -100%; background-color: red; &#125; .middle &#123; height: 200px; margin-left: 160px; margin-right: 160px; background-color: green; &#125; .right &#123; width: 150px; height: 200px; float: right; margin-left: -200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="content"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局是在中间栏的 div 中再嵌套一个 div，内容写在嵌套的 div 里，然后对嵌套的 div 设置 margin-left 和 margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是 100% 宽度，只不过中间栏的内容通过 margin 的值显示在中间。 中间内容可以优先加载，但其HTML 代码结构稍微复杂点。 圣杯布局123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; margin-left: 160px; margin-right: 160px; &#125; .middle &#123; float: left; width: 100%; height: 200px; background-color: green; &#125; .left &#123; float: left; width: 150px; height: 200px; margin-left: -100%; position: relative; left: -160px; background-color: red; &#125; .right &#123; float: left; width: 150px; height: 200px; margin-left: -210px; position: relative; right: -220px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局的核心是左、中、右三栏都通过float进行浮动，然后通过margin负值进行调整。跟双飞翼布局比较像，但还是有一些区别，相对于双飞翼布局来说，其HTML 结构相对简单，但是css语法就稍微复杂，也是优先加载中间内容。 还有注意一点是：中间内容要放在最上面，保证其先渲染。 Flex布局1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: flex; &#125; .middle &#123; flex-grow: 1; height: 200px; background-color: green; &#125; .left &#123; order: -1; flex: 0 1 150px; margin-right: 10px; height: 200px; background-color: red; &#125; .right &#123; flex: 0 1 150px; margin-left: 10px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Flex布局是由CSS3提供的一种较为新兴的、方便的三栏布局方式，简单实用，缺点是其兼容性差一点。 Table 布局12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: table; width: 100%; &#125; .left, .middle, .right &#123; display: table-cell; &#125; .left &#123; width: 150px; height: 200px; background-color: red; &#125; .middle &#123; background-color: green; &#125; .right &#123; width: 150px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 算是一种比较老的布局方式，较为简单，但其缺点是：无法设置栏间距，缺乏点灵活性，如下图： Grid(网格)布局123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;style&gt; .container &#123; display: grid; grid-template-columns: 160px auto 160px; height: 200px; &#125; .left &#123; background-color: red; margin-right: 10px; &#125; .middle &#123; background-color: green; &#125; .right &#123; background-color: yellow; margin-left: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 网格布局作为一种比较新潮的实现方式，仅仅几条样式命令就能完成三栏布局，可见其布局之强大，但其兼容性比较差。 以上就是我自己总结及结合文档所列出的8种css实现前端三栏布局的方式，如还有其他方式，欢迎大家告诉我哦。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—左右布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css左右布局是实现前端页面设计的基础，大部分的布局方式都能分割成左右布局，因此理解左右布局，能使我们在初学css的时候更快理解其他复杂的布局方式。 下面是我罗列的几种css实现前端左右布局的方式： position: absolute实现在父级元素内设置两个子元素，绝对定位它们，然后使用百分比将它们分成左右两部分。 这里的好处是，有两个可以容纳自己内容的独立容器。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt; /*以上为html代码*/section &#123; color: white; text-align: center;&#125;div &#123; height: 100%;&#125;article &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; padding: 20px;&#125;h1 &#123; font-size: 20px;&#125;.left-half &#123; background-color: #ea68a2; position: absolute; left: 0px; width: 50%;&#125;.right-half &#123; background-color: pink; position: absolute; right: 0px; width: 50%;&#125; table实现table布局是页面布局中使用的最早的布局方式，随着前端技术的发展，table布局由于自身的局限性逐渐被div布局取代。123456789101112131415161718192021222324252627282930313233&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;body &#123; color: white; text-align: center;&#125;h1 &#123; font-size: 20px;&#125;div &#123; display: table-cell; text-align: center; vertical-align: middle; width: 50%; padding: 50px;&#125;.left-half &#123; background: #ea68a2;&#125;.right-half &#123; background: pink;&#125; float实现float属性是css中关于布局的一个关键属性，可以产生脱离文档流的布局现象，其left属性值使该区域向父级标签区域的左侧边界放置，right属性值使该区域块向父级标签的右侧边界放置，利用该属性可以实现左右布局。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;section&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;html, body, section, div &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;section &#123; width: 100%;&#125;article &#123; position: relative; top: 50%; left: 50%; padding: 1rem; transform: translate(-50%, -50%);&#125;h1 &#123; font-size: 20px;&#125;.left-half &#123; background-color: #ea68a2; float: left; width: 50%;&#125;.right-half &#123; background-color: pink; float: left; width: 50%;&#125; 对于float对后面同级元素的影响，既可以采用margin进行影响的清除，还可以在受影响的元素上添加overflow：hidden来清除浮动对该区域块带来的影响。 Inline-Block实现display:inline-block属性是介于行内元素（display: inline）和块级元素（display: block）之间的属性，它既可以像行内元素一样水平布局，也可以像块级元素设置宽高属性，所以左右布局可以利用它这种属性。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt;&lt;/div&gt;&lt;div class="right-half"&gt;&lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt;&lt;/article&gt;&lt;/div&gt;* &#123; box-sizing: border-box;&#125;html, body, div &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;article &#123; position: relative; top: 50%; left: 50%; text-align: center; transform: translate(-50%, -50%);&#125;h1 &#123; font-size: 25px;&#125;div &#123; display: inline-block; vertical-align: top; width: 50%;&#125;.left-half &#123; background: #ea68a2;&#125;.right-half &#123; background: pink;&#125; flexbox实现css3中出现了弹性盒子flexbox布局，使用这种方法，可以将父级容器变成一个灵活的盒子，子容器占用相等的份额， 无需再设置宽高。123456789101112131415161718192021222324252627282930313233343536373839&lt;section class="container"&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/section&gt;html, body, section &#123; height: 80%;&#125;body &#123; color: white; text-align: center;&#125;div&#123; display: flex; flex-direction: column; justify-content: center;&#125;h1 &#123; font-size: 25px;&#125;.container &#123; display: flex;&#125;.left-half &#123; background-color: #ea68a2; flex: 1;&#125;.right-half &#123; background-color: pink; flex: 1;&#125; grid实现CSS Grid(网格) 布局技术就像是Flexbox和Table的混合体，你可以通过将 CSS 规则应用于父元素(成为 Grid Container 网格容器)和其子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid 布局。12345678910111213141516171819202122232425262728293031323334353637383940&lt;section class="container"&gt; &lt;div class="left-half"&gt; &lt;article&gt; &lt;h1&gt;Left Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt; &lt;div class="right-half"&gt; &lt;article&gt; &lt;h1&gt;Right Half&lt;/h1&gt; &lt;/article&gt; &lt;/div&gt;&lt;/secion&gt;html, body, section, div &#123; height: 100%;&#125;body &#123; color: white;&#125;article &#123; position: relative; top: 50%; text-align: center; transform: translate(0, -50%);&#125;h1 &#123; font-size: 25px;&#125;.container &#123; display: grid;&#125;.left-half &#123; background: #ea68a2; grid-column: 1;&#125;.right-half &#123; background: pink; grid-column: 2;&#125; 作为比较新兴的布局技术，相信在未来的前端发展中，Grid 布局技术会越来越受到广大开发者的青睐。 以上就是我自己总结及结合文档所列出的6种css实现前端左右布局的方式，如还有其他方式，欢迎大家告诉我。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记—居中布局]]></title>
    <url>%2F2019%2F03%2F20%2FCSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[我们在网页布局的时候，经常会碰到需要居中的情况，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。 水平居中元素宽高未知当元素的宽高都未知的时候，可以利用以下两种方法将元素水平居中： ①CSS3 transform：12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; ②flexbox：1234.parent &#123; display: flex; justify-content: center;&#125; 居中元素为内联元素常见的内联元素有：span, a, img, input, label 等等。 您可以在块级父元素内水平居中内联元素，只需css中加以下核心语法：123.parent&#123; text-align: center;&#125; 这种方法适用于display 为 inline, inline-block, inline-table, inline-flex 类型的元素。 居中元素为块级元素常见的块元素：div, h1~h6, table, p, ul, li 等等。 ①设置 margin：0 auto123456789.parent &#123; width: 100%;&#125;.child &#123; width: 800px; height: 100px; margin: 0 auto; background: #999;&#125; 此方法只能进行水平的居中，对浮动元素或绝对定位元素是无效的。 ②转换为 inline-block 属性：123456.parent &#123; text-align: center;&#125;.child &#123; display: inline-block;&#125; 居中元素为浮动元素加以下核心语法:1234567.child &#123; width: 100px; float: left; position: relative; left: 50%; margin-left: -50px;&#125; 居中元素为绝对定位元素①123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 50%; margin-left: -50px;&#125; ②12345678910.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 0; right: 0; margin: 0 auto;&#125; 垂直居中元素宽高未知当元素的宽高都未知的时候，也可以利用以下同样两种方法将元素垂直居中： ①CSS3 transform：12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateY(-50%);&#125; ②flexbox：12345.parent &#123; display: flex; flex-direction: column; justify-content: center;&#125; 适用于子元素为浮动、绝对定位、内联元素，均可垂直居中。 其中flexbox 是 CSS3 新增的属性，设计初衷就是为了解决像垂直居中这样的常见布局问题，相信未来flexbox布局会越来越多应用。 元素宽高已知①123456789.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; ②12345678910.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 0; bottom: 0; height: 100px; margin: auto 0;&#125; 居中元素为单行文本①1234.text &#123; line-height: 200px; height: 200px;&#125; 将文本的 line-height 属性值设为和文字父容器一样的高度，但适用于只有一行文字的情况。 ②1234.link &#123; padding-top:30px; padding-bottom:30px;&#125; 有时内联/文本元素可以垂直居中显示，只是因为它们上部和下部都有相等的padding。 居中元素为多行文本①table：12345678.parent &#123; display: table;&#125;.child &#123; display: table-cell; margin: 0; vertical-align: middle;&#125; ②flexbox:123456.parent &#123; display: flex; justify-content: center; flex-direction: column; height:400px;&#125; 水平垂直居中元素宽高已知①负边距居中：123456789101112.parent &#123; position: relative;&#125;.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 此方法灵活性差，不能自适应，且宽高不支持百分比尺寸和 min-/max- 属性。 ②绝对居中：1234567891011div &#123; width: 100px; height: 100px; margin: auto; position: fixed; //absolute is ok top: 0; right: 0; bottom: 0; left: 0;&#125; 元素的宽高支持百分比 % 属性值和 min-/max- 属性。 ③transform :1234567891011.parent &#123; position: relative;&#125;.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; ④table-cell:1234567891011121314.parent &#123; display: table-cell; vertical-align: middle; text-align: center; width: 100px; height: 100px; border: 1px solid red;&#125;.child &#123; width: 50px; height: 50px; display: inline-block; background-color: #999;&#125; 这种方法适用于子元素 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，前提需要知道父元素的宽高，且父元素的宽高不能设为百分比数。 ⑤font-size 结合 vertical-align：1234567891011121314.parent &#123; font-size: 175.4px; height: 200px; text-align: center;&#125;.child &#123; vertical-align: middle; display: inline-block; font-size: 12px; width: 50px; height: 50px; background-color: #999;&#125; 该方法前提条件是需给父元素设一个合适的 font-size 值，该值一般为其父元素的高度除以 1.14 得到的值，并且子元素必须是一个 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，此外还需在子元素内加上 vertical-align: middle 属性。 ⑥文本内容：12345text &#123; height: 100px; line-height: 100px; text-align: center;&#125; 元素宽高未知①transform :123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; transform方法中元素既可以加宽高，也可不加，用于水平垂直居中布局。 ②flexbox :12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; ③grid:1234567body, html &#123; height:100%; display: grid;&#125;span &#123; /* thing to center */ margin: auto;&#125; 该方法适用于只有一个元素的时候，作为非常新的布局方式，其兼容性也比较差。 上面只是把所有方法的代码要点罗列了一下，能满足所有的居中布局方案，如你还有其他好方法，欢迎交流指正哦。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速搭建静态资源服务器]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。以前的时候，都是使用php的本地环境，也算比较方便，但是自从学了nodejs，发现创建http-server更方便。 本文的目的在这篇文章中，我将向您展示如何使用NodeJS创建一个非常简单的HTTP服务器。您可以通过http访问目录中的静态资源，如HTML，Javascript，CSS等，比如： http://localhost:8080/hello.html http://localhost:8080/abc.js 而不是通过默认的file:///来访问 那问题是为什么只有需要一个HTTP才能访问静态资源呢？ 是因为HTML文件含有Javascript文件时，如果通过默认的file://地址来访问此文件的话，浏览器会阻止本地Javascript文件的一些操作，此时就需要安装HTTP-Server来解决这个问题。 报错信息： Failed to load file:///E:/webexamples/reactjs/hello-reactjs/person.jsx: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. 创建HTTP-Server首先，确保已在计算机上安装NodeJS和npm； 否则，请按照以下说明进行安装： 在Windows上安装NodeJS 打开 Git Bash或其他命令行工具，依次输入以下命令，按回车： 123npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress false npm 的配置被存储在 ~/.npmrc，你可以随时改。 ①接下来第一步，先创建一个空目录： ②利用命令行工具进入这个目录，这里用的是Git Bash。右击鼠标，点击Git Bash here，即可用Git Bash打开这个目录： ③运行以下命令安装http-server：1$ npm install -g http-server ④启动HTTP-Server，输入命令：1$ http-server -c-1 到此您的HTTP服务器就已经启动了，它正在端口8080上监听，您可以通过访问以下链接进行检查，3个地址在电脑端打开的是同一份东西： http://192.168.1.116:8080/ （只有这个地址能在手机中预览） 127.0.0.1:8080/ （2和3性质是一样的） localhost:8080/ （较为常用） ⑤在该目录中创建一个HTML文件，您可以通过此HTTP地址访问它： ⑥这里Windows 用户需要注意了，如果你发现你修改了源代码，页面却无法更新，说明http-server 的缓存还未消除，那么可以这样做： 打开 Chrome 开发者工具 点击 Network 勾选 Disable Cache 这样缓存就不存在了~ 其他命令安装HTTP-Server这里就不仔细介绍步骤了，因为大部分操作和结果与第2步是一样的，直接上命令： 第一种方法：安装：1$ npm i startserver -g 快速开启：1$ startserver 第二种方法：安装：1$ npm install -g live-server 快速开启：1$ live-server 如果看到其他有意思的方法，后续还会增加的！ 以上就是我在近期收集到的一些方法资料，不一定全面，如有错误欢迎指正哦。]]></content>
      <categories>
        <category>前端相关</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>http-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常用标签]]></title>
    <url>%2F2019%2F03%2F19%2FHTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[HTML 是用来描述网页的一种语言，通过添加各种标签，达到在浏览器中展示期望的效果。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 浏览器不会显示 HTML 标签(HTML tag)，而是使用标签来解释页面的内容： HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;p&gt; 和 &lt;/p&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 ⭐越多代表我觉得此标签越重要 标题标签 ⭐⭐⭐HTML提供了6个等级的标题(head)，即：h1、h2、h3、h4、h5和h6，h1是最高级的标题。其基本语法是：&lt;hn&gt; 标题信息 &lt;/hn&gt; 注意：h1因为重要，尽量少用，一般都是给logo用，或者页面中最重要标题信息，其他5个级别标题在一个页面中都可以出现多次，h1只能出现一次。 段落标签 ⭐⭐⭐在网页中要想把文字内容有条理地显示，离不开段落标签（paragraph）,它是网页中文章内容的基本组成部分。其基本语法是：&lt;p&gt; 文本内容 &lt;/p&gt; 注意：段落标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签 ⭐⭐在网页中经常看到一些水平线将段落与段落间隔开，层次分明。这些水平线可以通过插入图片来实现，也可以简单地通过&lt;hr/&gt; 标签(horizontal)来完成。其基本语法是：&lt;hr /&gt;是单标签 换行标签 ⭐⭐⭐在HTML中，一个段落的文字会从左往右按顺序排列，直到浏览器窗口的右端，然后会自动换行，如果希望某段文字强制进行换行，就需要使用换行标签(break)。其基本语法是：&lt;br /&gt; 注意：除了少数应用（比如诗歌的分行），应该尽量避免使用这个标签，因为它并没有特别的语义含义，而且分行的视觉效果完全可以通过p标签、列表标签和CSS命令达到。 div span标签 ⭐⭐⭐⭐div 和 span是没有语义的，是现在网页布局用到的最主要的2个盒子，比如css+div的结合就可以基本上满足页面布局需要。其基本语法是：1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt; 今日行情 &lt;/span&gt; 文本格式化标签 ⭐⭐在网页中，有时要为某些文字设置加粗、加斜或加下划线的效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。其基本语法是： 注意：b i s u 只有使用，没有强调的意思，strong em del ins的语义更强烈。 图像标签img ⭐⭐⭐⭐要想在网页中显示图像就需要使用图像标签，下图详细介绍了图像标签&lt;img /&gt; 以及与其相关的一些属性。其基本语法是： 基本图像插入方式：&lt;img src=&quot;wo.jpg&quot;/&gt; 带有alt的图像插入方式：&lt;img src=&quot;wo.jpg&quot; alt=&quot;这是我吴彦祖的照片&quot;/&gt; 带有title的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot;/&gt; 带有宽度的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; /&gt; 带有边框的图像插入方式：&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; border=&quot;10&quot; /&gt; 链接标签 ⭐⭐⭐⭐在HTML中创建超链接比较简单，只需用链接标签(anchor)环绕需要被链接的对象即可。其基本语法是：&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; href：Hypertext Reference的缩写，意思是超文本引用，用于指定链接目标的url地址。 target：用于指定链接页面的打开方式，其取值有self(新链接页面覆盖原页面，为默认值)、blank(在新窗口打开)、_parent(载入父级窗口，与iframe结合用得到)、_top(载入顶级窗口，与iframe结合用得到)，注意： 外部链接：需要添加 http://www.baidu.com 内部链接：直接链接内部页面名称即可，如首页；还有可以通过创建锚点链接，能够快速定位到内部页面的目标内容：①.使用链接文本 ②.使用相应的id名标注跳转到目标的位置 如果没有确定的链接目标时，通常将href属性定义为”#”(即href=”#”)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 当然也可以利用base标签来设置整体链接的打开状态，如网易这样设置让页面所有链接按新窗口打开： 特殊字符标签 ⭐ 无序列表ul ⭐⭐⭐⭐无序列表(unordered list)的各个列表项之间没有顺序级别之分，是并列的。其基本语法是：123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 注意： &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签内输入其他标签或者文字的做法是不被允许的。 &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 无序列表会自带样式属性，但还是让css来做！ 有序列表ol ⭐⭐有序列表(ordered list)即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义。其基本语法是：123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ...... &lt;/ol&gt; 所有特性基本和ul一致，且自带顺序。 定义列表 ⭐定义列表(definition list)常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法是：12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ...... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...... &lt;/dl&gt; 表格table ⭐⭐表格还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。其基本语法是：1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 上面的语法中包含三对HTML标签，分别为&lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体解释： table用于定义一个表格。 tr用于定义表格中的一行，必须嵌套在table标签中，且只能嵌套&lt;td&gt;&lt;/td&gt;，在table中包含几对tr，就有几行表格。 td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对&lt;tr&gt;&lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少”列”（或多少个单元格），但表格只有行tr和单元格td，行里面装单元格，没有列的概念；&lt;td&gt;&lt;/td&gt;标签像一个容器，可以容纳所有的元素。 表单标签 ⭐⭐表单的目的是为了收集用户信息，在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，作用是提示用户进行填写和操作。 表单域：相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过它定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input控件 ⭐⭐⭐⭐&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。其常见属性如下所示： text语法:1234&lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type="text" value="北京" /&gt;&lt;/td&gt; //value为默认值&lt;/tr&gt; password语法：1234&lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" value="123456" /&gt;&lt;/td&gt; &lt;/tr&gt; radio单选按钮语法：12345678&lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; 男&lt;input type="radio" name="sex" /&gt; 女&lt;input type="radio" name="sex" /&gt; 人妖&lt;input type="radio" name="sex" /&gt; &lt;/td&gt; &lt;/tr&gt; label标签 ⭐⭐label标签为input元素定义标注，其中for属性规定了label与哪个表单元素绑定。其基本语法是：12&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; 点击Male会直接跳到右边的文本框内，label通过for和id建立联系快速找到。当然也可以简化成这种形式：1&lt;label&gt;&lt;input type="radio" name="sex" value="male"&gt;Male&lt;/label&gt; textarea文件域 ⭐⭐text 文本框只能写一行文本，如果需要输入大量的信息，就需要用到textarea标签，可以轻松地创建多行文本输入框。其基本语法是：123&lt;textarea cols="每行的字符数" rows="显示的行数"&gt; 文本内容 &lt;/textarea&gt; 但是textarea的宽和高通常是通过css来控制的,cols和rows几乎不用。 下拉菜单 ⭐⭐使用select标签定义下拉菜单的基本语法如下：123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option中定义selected=”selected”时，当前项即为默认选中项。 表单域 ⭐⭐在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。其基本语法是：123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件 &lt;/form&gt; 常见属性： Action：在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接受并处理表单数据的服务器程序的url地址。 method：用于设置表单数据的提交方式，其取值为get或post。 name：用于指定表单的名称，以区分同一个页面中的多个表单。注意：每个表单都应该有自己的表单域。 HTML5常用新标签 ⭐⭐⭐ header：定义文档的页眉 nav：定义导航链接的部分 footer：定义文档或节的页脚 article：标签规定独立的自包含内容 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容（侧边） datalist：标签定义选项列表，与input元素配合使用 fieldset：可将表单内的相关元素分组，打包，与legend搭配使用 HTML5新增的input type属性 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体embed ⭐⭐embed可以用来插入各种多媒体（较大的），格式可以是Wav、AIFF、AU、MP3等。其中url为音频或视频文件的路径，可以是相对路径或绝对路径。其基本语法是：123&lt;embed src='http://player.youku.com/player.php/sid/XMzk4MDUzNTA1Mg==/v.swf' allowFullScreen='true' quality='high' width='480' height='400' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt; 多媒体audio ⭐⭐HTML5通过&lt;audio&gt;标签来解决音频播放的问题。其基本语法是：1&lt;audio src="./music/See You Again.mp3"&gt;&lt;/audio&gt; //通过src指定音频文件路径即可 并且可以通过添加属性来更友好控制音频的播放，如： autoplay 自动播放 controls 是否显示默认播放组件 loop 循环播放 ，loop=2就是循环2次 ，loop或者loop=“-1”无限循环 多媒体video ⭐⭐同音频播放一样，&lt;video&gt;（通常插入较小的视频）使用也相当简单。其基本语法是：1&lt;video src="./video/movie.mp4" controls="controls"&gt;&lt;/video&gt; //通过src指定视频文件路径 同样，通过附加属性可以更友好的控制视频的播放： autoplay 自动播放 controls 是否显示默认播放组件 loop 循环播放 width 设置播放窗口的宽度 height 设置播放窗口的高度]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git/GitHub操作手册]]></title>
    <url>%2F2019%2F03%2F19%2FGit%E5%8F%8AGithub%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Git 是目前最流行的版本管理工具，也是程序员的必备技能之一。这里主要介绍一下git/github远程仓库的使用及相关配置。 SSH KeysSSH Keys是什么呢？简单来说相当于一把钥匙（在机器中即电脑中进行配置），github相当于一把锁，每次发起请求是会去验证钥匙与锁是否配对。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置。 添加远程库你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那如何将我们这个本地仓库上传到 GitHub 呢？下图简单描述了Git常用的操作流程。 1、在本地新建文件夹，命名为blog，在本地的blog仓库的路径下运行命令行。1$ git init // 在当前目录新建一个Git代码库 这个操作在当前目录下生成一个.git文件，默认不显示，可在命令行中输入 ls -a,即可看到所有被隐藏文件，接下来进行如下操作：123456789101112131415161718192021$ echo "# myblog" &gt;&gt; README.md //在当前目录下新建README.md,且文件内容为'myBlog'；如果目录下已经有文件，请省略这一步$ git add README.md //将README.md文件提交到问题暂存区$ git commit -m "first commit" //将暂存区文件提交到本地仓库，且本次提交记录为'first commit'$ git status -sb //显示当前所有文件的状态``` 这几步操作目的是将上传的文件提交到本地仓库，接下来就是介绍怎么样将本地仓库上传到远端库了。 2、登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，名称随意，一般可以跟本地目录名一致。 &lt;div align=center&gt;![](https://i.loli.net/2019/03/19/5c9089bb5e271.jpg) 在Repository name填入blog，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。 3、点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图: &lt;div align=center&gt;![](https://i.loli.net/2019/03/19/5c9089f6b1548.jpg) 4、看上图，记得点击 SSH 按钮，如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用HTTPS 地址，因为使用HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但在某些只开放http端口的公司内部就无法使用SSH协议而只能用HTTPS 。 5、目前，在GitHub上的这个blog仓库还是空的，GitHub告诉我们，可以在这个仓库创建一个新的本地仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的blog仓库下运行命令： ```bash$ git remote add origin git@github.com:miqilin21/blog.git 6、下一步，就可以把本地库的所有内容推送到远程库上：1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样: 7、如果你想查看变更历史，可以通过命令：$ git log 8、从现在起，只要本地仓库作了修改，如果你想让改动保存到远程仓库里，你需要先git add文件或者也可以git add。注意，如果这个 文件以前被我们add过，所以此处的git add操作可以省略，但我建议你使用git的初期阶段，不要省略git add。换句话说，每一次改动，都要经过git add和git commit两个命令，才能被添加到 .git 本地仓库里。接下来就通过命令：1$ git push //将本地仓库修改内容同步到远程仓库 但是，如果远程库先有修改的话，要想本地仓库与其同步，还需通过命令：1$ git pull //将远程库修改的内容下载到本地库 最后把本地master分支的最新修改$ git push推送至GitHub，现在，你就拥有了真正的分布式版本库！ 从远程库clone上面已经讲了 在本地创建仓库 将本地仓库上传到 GitHub 这里将介绍另外一种用法，那就是直接在 GitHub 创建一个仓库，然后克隆下载到本地。 1、在GitHub 上新建一个仓库 git-demo，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下： 请按图中所示，一模一样的操作，然后点击创建按钮。 2、这样一来，这个仓库就会自动生成三个文件： 3、现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库，点击页面中唯一的绿色按钮「clone or download」，会看到一个弹出层： 请确保弹出层里的地址是 SSH 地址，也就是 git@github.com 开头的地址，如果不是，就点击 Use SSH 按钮，然后复制这个地址。 4、打开 Git Bash，找一个安全目录，比如 ~/Desktop 桌面目录就很安全：cd ~/Desktop，然后运行：1$ git clone git@github.com:miqilin21/git-demo.git 运行完了你就会发现，桌面上多出一个 git-demo-2 目录，里面的内容和远程库一模一样，至此从远程库克隆到本地就完成啦！ 小结三种方式都说完了，它们分别是： 1、在本地创建仓库 2、将本地仓库上传到 GitHub 3、GitHub 上的仓库克隆下载到本地 其实呢，还有很多种不同的方式，但是，你记住这几种就行了，已经够你用了。我们并不想要了解 git 的所有高级用法，我们的目的很明确：能通过 Git 命令使用 GitHub 就行。 我们最后再回顾一遍已经学到的命令： git clone git@github.com:xxxx，克隆下载远程仓库git init，初始化本地仓库 .gitgit status -sb，显示当前所有文件的状态git add 文件路径，用来将变动加到暂存区git commit -m “信息”，用来正式提交变动，并备注信息，提交至 .git 仓库如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m ‘xxx’ 两个命令即可。git log 查看变更历史 其他学习资源 常用Git命令清单Git菜鸟教程廖雪峰的Git教程]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP入门笔记]]></title>
    <url>%2F2019%2F03%2F19%2FHTTP%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTTP 协议是互联网的基础协议，也是现在网页开发的必备知识，2015年出的最新版本 HTTP/2 更是成为互联网技术热点。 本文介绍了 HTTP 协议的基础知识以及浏览器和web服务器之间请求和响应的详细信息。 什么是HTTP?HTTP代表超文本传输协议。 这是互联网中数据通信的基础， 数据通信以客户端发送的请求开始，并以从Web服务器接收的响应结束，而HTTP的作用就是指导浏览器和服务器如何进行沟通。 HTTP通信过程简图： 客户端（通常为浏览器）负责发起请求 web服务器在 80 端口接收请求 web服务器之后负责响应请求的内容 浏览器负责下载响应内容 curl命令curl是一种命令行工具，作用是发出网络请求，然后得到响应和提取数据，显示在”标准输出”（stdout）上面。后面所说的请求，就是通过使用 curl 命令来实现的。比如输入：curl -s -v -- &quot;www.sina.com&quot;这一行命令，输出的请求内容为： &gt; GET / HTTP/1.1 &gt; Host: www.sina.com &gt; User-Agent: curl/7.55.0 &gt; Accept: */* &gt; 响应内容为: &lt; HTTP/1.1 200 OK &lt; Date: Sun, 03 Mar 2019 06:17:38 GMT &lt; Content-Type: text/html &lt; Content-Length: 23568 &lt; Last-Modified: Sun, 03 Mar 2019 06:16:24 GMT &lt; Connection: keep-alive &lt; ETag: "5c7b7138-5c10" &lt; Expires: Sun, 03 Mar 2019 06:22:38 GMT &lt; Cache-Control: max-age=300 &lt; Accept-Ranges: bytes &lt; Set-Cookie: TS0106d18b=0103cff18ca232a2464de8b94e660a71bf04913ec10acc3f4e7336f5c7620c43c b93a3a1e3e5b394e3b5f0d8d9c8c835e649efa77c; Path=/ &lt; 想了解关于 curl 里的参数，推荐使用explainshell.com来查看解释，很快捷很详细哦。 请求的格式 来自计算机客户端的请求一般包含以下几个部分： 1 请求行：动词 路径 协议/版本 比如： GET /index.html HTTP/1.12 请求头：Key1: value12 Key2: value2Key3: value3Content-Type: application/x-www-form-urlencodedHost: http://www.baidu.comUser-Agent: curl/7.54.0回车：没有内容4 消息体：要上传的数据 请求最多包含四部分，最少包含三部分，最少三部分时消息体可以为空，且第三部分永远是一个回车（\n） 动词有 GET（从服务器获取资源，一项或多项） POST（在服务器新建一个资源） PUT（在服务器整体更新资源，客户端提供改变后的完整资源）PATCH（在服务器局部更新资源，客户端提供改变的属性） DELETE （从服务器删除资源） 等。如果想用POST，就输入：curl -X POST -d “1234567890” -s -v – “https://www.sina.com&quot; 这里的路径包括「查询参数」，但不包括「锚点」 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 响应的格式来自服务器的响应一般包含以下几个部分： 1 状态行：协议/版本号 状态码 状态描述响应头：Key1: value1Key2: value2Content-Length: 17931Content-Type: text/html回车：没有内容消息体：要下载的内容 响应都有4个部分，具体其实跟请求的格式差不多 常见的状态码： 200：请求成功请求的资源被永久转移到其他地方（重定向）404：请求的资源不存在500：内部服务器错误 状态码分类 1开头：信息，服务器已经收到请求，需要请求者继续执行操作（不常用）2开头：成功，操作被成功接收并处理3开头：重定向，需要进一步操作来完成请求4开头：客户端错误，请求包含语法错误或无法完成请求5开头：服务器错误，服务器在处理请求时发成了错误 状态码列表 如何在Chrome上检查HTTP请求和响应？将Google Chrome视为常用浏览器，在其他浏览器中查看详细信息的过程仍然相同。 在Google Chrome中打开网页，然后转到”更多工具 &gt;开发者工具”菜单。 您也可以通过右键单击页面打开开发人员控制台，然后选择“检查”选项。 转到“Network”选项，然后重新加载页面。 现在，您将看到页面上每个组件的加载时间。 点击“Show Overview”图标以删除时间线，以便您可以清楚地查看其他详细信息。 单击左侧栏上的页面URL，然后转到“Response”选项。 （您还可以在“Preview”选项下查看相同的详细信息）。 您可以在上面的部分中详细了解请求和响应的详细信息。 “Headers”选项将显示所选项目的请求和响应的HTTP标头信息的详细信息。 HTTP 标头检查工具与Chrome类似，还有许多其他免费工具可用于检查HTTP标头中收到的响应代码。 例如，转到此HTTP标头检查工具，输入您要检查的任何URL，然后单击“提交”按钮。 例如输入https://www.baidu.com，您将看到如下标头的详细信息： HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 277Content-Type: text/htmlDate: Sun, 03 Mar 2019 07:27:41 GMTEtag: “575e1f6f-115”Last-Modified: Mon, 13 Jun 2016 02:50:23 GMTPragma: no-cacheServer: bfe/1.0.8.18]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
