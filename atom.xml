<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米淇淋の个人博客</title>
  
  <subtitle>Stay hungry. Stay young.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luozongmin.com/"/>
  <updated>2019-07-24T01:37:02.014Z</updated>
  <id>https://luozongmin.com/</id>
  
  <author>
    <name>米淇淋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript系列之立即执行函数IIFE</title>
    <link href="https://luozongmin.com/2019/07/24/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0IIFE/"/>
    <id>https://luozongmin.com/2019/07/24/JavaScript系列之立即执行函数IIFE/</id>
    <published>2019-07-24T01:19:51.091Z</published>
    <updated>2019-07-24T01:37:02.014Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们已经介绍了函数的参数，arguments对象以及回调函数，那么今天的分享中，我们继续来看看函数在JavaScript的另外一种面貌——立即执行函数表达式（Immediately Invoked Functions Expressions，IIFE）。<a id="more"></a></p><p><strong>IIFE(Immediately Invoked Functions Expressions)</strong>其实可以就字面上直接来理解，Immediately就是立即的意思，invoked则是执行某个函数时「执行」的意思，function expression是一种用来创建函数的方法，<strong>总的来说，就是用函数表达式的方式建立函数后并立即执行它</strong>。</p><p>下面我们将做更进一步的介绍和说明。</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>JavaScript 中有两种常见的声明函数的方法，分别是通过<strong>function 命令</strong>或<strong>函数表达式声明</strong>，来看个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function 命令 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">sayHi</span> (<span class="params"> name </span>)  </span>&#123; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="string">'Hi'</span>  + name ) ; </span><br><span class="line">&#125; </span><br><span class="line">sayHi( <span class="string">'miqilin'</span> ) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span>  sayHello  =  <span class="function"><span class="keyword">function</span> (<span class="params"> name </span>)  </span>&#123; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="string">'Hello '</span>  + name ) ; </span><br><span class="line">&#125; </span><br><span class="line">sayHello( <span class="string">'miqilin'</span> ) ;</span><br></pre></td></tr></table></figure><h3 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h3><p>那么什么是<strong>IIFE</strong>呢？如同文章一开始所叙述的，<strong>IIFE指的就是通过函数表达式的方式来创建函数，并且立即执行它</strong>。那我们要怎么做呢？</p><p>首先我们可以用console.log的方式，先来看一下，我们刚刚创建的sayHello打印出来会长什么样子呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span>  sayHello  =  <span class="function"><span class="keyword">function</span> (<span class="params"> name </span>)  </span>&#123; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="string">'Hello '</span>  + name ) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(sayHello);</span><br></pre></td></tr></table></figure><p>结果会发现，直接把sayHello打印出来后，它会直接返回整个函数的代码内容，这是尚未”执行（Invoked）”代码前的结果。</p><p><img src="/images/IIFE-1.jpg" alt></p><p>如果是IIFE就在这段代码的最后，加上一个执行的指令，也就是括号<code>( )</code>：</p><p><img src="/images/IIFE-2.jpg" alt></p><p>上图就可以看出，在我们定义函数的同时，这段函数就会立即被执行了，当然最后的<code>( )</code>中可以加入参数：</p><p><img src="/images/IIFE-3.jpg" alt></p><p>那如果我们把前面的声明变量去了呢，变成一个匿名函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不可行的做法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"> name </span>)  </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'Hello '</span>  + name ) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么做是不可行的，因为JavaScript引擎在解析代码的时候，你用<code>function</code>作为开头，引擎会认为你现在要输入<code>function</code> 命令去创建函数，<strong>可是你却没有给该function名称，于是它无法正确理解这段代码便抛出错误</strong>：</p><p><img src="/images/IIFE-4.jpg" alt></p><p>所以，这时候我们要做的是告诉JavaScript 引擎说，这一整个并不是<code>function</code> 命令。要达到这样的目的，我们要让引擎在解析代码的时候，不是以读到<code>function</code> 作为开头。</p><p>为了要达到这样的目的，我们最常使用的做法就是用括号<code>()</code>将<code>function(){ ...}</code>包起来，像是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"> name </span>)  </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'Hello '</span>  + name ) ; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>因为我们只会在括号内放入表达式，例如(3+2)，而不会放命令在括号内，所以JavaScript就会以表达式的方式来读取这段函数。</strong></p><p>在这种情况下，这个函数会被建立，但是不会被存在任何变量当中，也不会被执行。</p><p>结合刚刚上面IIFE的概念，我们可以在创建这个函数的同时，将这个函数加以执行，我们同样只需要在最后加上括号<code>()</code>就可以了：</p><p><img src="/images/IIFE-5.jpg" alt></p><p>这样IIFE的型式，会在许多的JavaScript框架中都看得到，比如jQuery，jQuery用了这样的手法将<code>window</code>与<code>undefined</code>保留起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line"></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure><p>其中<code>undefined</code>是可以被修改的，虽然jQuery在IIFE定义了两个参数，但只传了一个<code>winodw</code>，就是为了保持<code>undefined</code>原本的样子。</p><p><strong>通过这样的方式，我们可以「直接执行某个函数」，一个很重要的一点是，这样做不仅避免了外界访问此 IIFE 内的变量，而且又不会污染全局作用域。</strong></p><h3 id="IIFE执行过程解析"><a href="#IIFE执行过程解析" class="headerlink" title="IIFE执行过程解析"></a>IIFE执行过程解析</h3><p>先看段IIFE实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IIFE </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">'Hello'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(greeting+ <span class="string">' '</span> +name);</span><br><span class="line">&#125;)(<span class="string">"miqilin"</span>);</span><br></pre></td></tr></table></figure><p>让我们看看，当我们在执行这段代码的过程中，JavaScript引擎实际发生了什么事吧！</p><p>首先，当我执行这段代码时，会先建立全局执行上下文（Global Execution Context），但这时候这个执行上下文里面是没有任何内容的，因为我们并没有在全局这层建立任何变量（如果有的话，变量的名称会先提升在全局上下文中。）</p><p><img src="/images/IIFE-6.jpg" alt></p><p>接着，JavaScript引擎会执行到我们所建立的这段IIFE，它会将这个匿名函数储存在全局执行上下文。</p><p><img src="/images/IIFE-7.jpg" alt></p><p>由于我们在函数的最后有加上<code>( )</code>，所以这段函数会立即被执行，也因此，JavaScript会为这个匿名函数建立一个新的执行上下文。</p><p><img src="/images/IIFE-8.jpg" alt></p><p>接着，它会去逐行执行我们这个函数中的代码内容，它发现到我们的代码中建立了一个变量，名称是”greeting”，因此，这个变量就被建立在函数的这个执行上下文中，而不是被建立在全局上下文中。</p><p><img src="/images/IIFE-9.jpg" alt></p><p>因此，通过IIFE，我们可以发现，在IIFE中所建立的变量，都不会影响到全局执行上下文所建立的变量，这里再次提一下，通过IIFE，它避免了我们的变量间可能会互相干扰覆盖的情况。</p><h3 id="IIFE的实际应用"><a href="#IIFE的实际应用" class="headerlink" title="IIFE的实际应用"></a>IIFE的实际应用</h3><p>让我们先回到上面的代码，这时候我们在函数的外面，声明一个同样的变量名(greeting)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局执行上下文</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">'Hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">'Hello'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(greeting+ <span class="string">' '</span> +name);</span><br><span class="line">&#125;)(<span class="string">"miqilin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting);</span><br></pre></td></tr></table></figure><p>这时候的打印出的顺序为：</p><p><img src="/images/IIFE-10.jpg" alt></p><p>你会发现，虽然同样都是调用greeting这个变量，但是一个是在函数执行上下文内的greeting，一个是在全局执行上下文的greeting，两者是不会互相影响的。</p><p>同样把它画成上面一样的图形，它们两个是不同的执行上下文被储存在不同的内存中，所以不会相互影响。</p><p><img src="/images/IIFE-11.jpg" alt></p><p>如此，我们可以很直观地确定，放在IIFE里面的变量，并不会影响到其他外层的变量，也不会被外层的变量影响到。</p><h3 id="如果执意要影响外层变量呢？"><a href="#如果执意要影响外层变量呢？" class="headerlink" title="如果执意要影响外层变量呢？"></a>如果执意要影响外层变量呢？</h3><p>虽然我们使用IIFE的主要目的就是希望不同执行上下文之间的变量不要互相影响，但如果我们还是想让函数执行上下文这层的变量能够同时影响到全局执行上下文的变量时，我们可以怎么操作呢？</p><p>首先，我们得多一个参数，叫做global，在最后带入参数的地方，我们填入对象<code>window</code>，由于我们知道对象是引用类型的特性，因此我们可以直接针对<code>window</code>里面的对象去做改变，像这里，我就可以直接把<code>global</code>层次的对象改成<code>hola</code>（<code>global.greeting = &#39;Hola&#39;</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局执行上下文</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">'Hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global, name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">'Hello'</span>;</span><br><span class="line">  global.greeting = <span class="string">'Hola'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(greeting+ <span class="string">' '</span> +name);</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="string">"miqilin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting);</span><br></pre></td></tr></table></figure><p>结果如下，原本在全局执行上下文的<code>Hi</code>，被变换为<code>Hola</code>了：</p><p><img src="/images/IIFE-12.jpg" alt></p><p>这操作够骚吧！哈哈~</p><h3 id="一道IIFE经典面试题"><a href="#一道IIFE经典面试题" class="headerlink" title="一道IIFE经典面试题"></a>一道IIFE经典面试题</h3><p>题目是这样的：假设想通过循环+ setTimeout来做到，在五秒钟之内，每秒钟依序通过<code>console.log</code>打印出：<code>0 1 2 3 4</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的是这样吗？我们来看看执行的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//过了接近一秒五个五同时打出</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>为什么会这样呢？</p><p>我们知道， JavaScript是一个「异步」的语言，所以当我们执行这段代码时，<code>for</code>循环并不会等待<code>window.setTimeout</code>结束后才继续，而是在执行阶段就<strong>一口气跑完</strong>。</p><p>也就是说，当<code>window.setTimeout</code>内的回调函数执行时，拿到的<code>i</code>已经是跑完<code>for()</code>循环的<code>5</code>。</p><p><img src="/images/IIFE-13.jpg" alt></p><p>那么要怎么解决这个问题呢？</p><p>我们可以把<code>window.setTimeout</code>包装成一个IIFE，这个问题就迎刃而解了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了凸显差异，我们将传入后的参数改名为 x</span></span><br><span class="line">  <span class="comment">// 当然由于作用域的不同，要继续在内部沿用 i 也是可以的。</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候你会发现，执行的结果就会是我们预期的<code>0 1 2 3 4</code>了，但还是有一个问题：就是<code>0 1 2 3 4</code>还是在一秒钟后同时出现啊？怎么解决？</p><p>嘿嘿，相信聪明的你已经发现，由于<code>for</code>循环在一瞬间就跑完，等于那一瞬间它向<code>window</code>依序注册了五次timer，每个timer都只等待一秒钟，当然同时出现喽。</p><p>所以我们稍微修改一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将原来的 1000 改成 1000 * x</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span> * x);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样，就可以依序打印出我们想要的结果喽！</p><p>[注] ES6以后新增了<code>let</code>与<code>const</code>，且改以<code>{ }</code>作为它的作用域。</p><p>换句话说，将上例中的<code>for</code>改为<code>let</code>就可以做到保留<code>i</code>在执行循环当下的「值」，打出一样的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>*(i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章当中，我们已经介绍了函数的参数，arguments对象以及回调函数，那么今天的分享中，我们继续来看看函数在JavaScript的另外一种面貌——立即执行函数表达式（Immediately Invoked Functions Expressions，IIFE）。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="IIFE" scheme="https://luozongmin.com/tags/IIFE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之回调函数</title>
    <link href="https://luozongmin.com/2019/07/20/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>https://luozongmin.com/2019/07/20/JavaScript系列之回调函数/</id>
    <published>2019-07-20T12:49:12.558Z</published>
    <updated>2019-07-20T12:56:18.697Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们已经介绍了函数的参数与arguments对象，那么今天的分享中，我们继续来看看函数在JavaScript的各种不同面貌——回调函数。<a id="more"></a></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>你可能常听到人家在谈论回调函数（Callback function），但你真的知道回调函数是什么吗？其实回调函数跟一般的函数没什么不同，差别只在于被调用执行的时机。</p><p>先前介绍事件的时候有说过，「JavaScript 是一个事件驱动(Event-driven) 的编程语言」，而事件的概念就如同：</p><p><strong>办公室电话响了(事件被触发Event fired) -&gt; 接电话(处理事件Event Handler)</strong></p><p>而写成代码形式就类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：这里只是比喻，并没有电话响这个事件</span></span><br><span class="line">Office.addEventListener( <span class="string">'电话响'</span>, <span class="function"><span class="keyword">function</span> 接电话(<span class="params"></span>)</span>&#123; &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>可以看到，<code>Office</code>通过<code>addEventListener</code>方法去注册了一个事件，当这个事件被触发时，它会去执行我们所指定的第二个参数，也就是某个「函数」(接电话)。</p><p>换句话说，这个函数只会在满足了某个条件才会被动地去执行，我们就可以说这是一个<strong>回调函数</strong>。</p><p>经历过各种「事件」的你，想必也发现了一件事，所谓的回调函数其实就是「<strong>把函数作为参数传递给另一个函数，然后通过另一个函数来调用它</strong>」。</p><p>不知大家有没有听懂？那我再讲一个简单案例吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果我们希望隔某段时间之后，执行某件事，就可以通过<code>window.setTimeout</code>来帮助我们完成。</p><p>像是上面的范例中，<code>window.setTimeout</code>带有两个参数，第一个是要做的事情，用一个函数来代表，第二个则是时间(1/1000秒, milliseconds)。而第一个参数的函数也是回调函数的一种：「在经过了某段时间之后，才执行的函数」。</p><p>当然，上面两个范例中的回调函数我们也可以把它单独抽出来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> 接电话(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Office.addEventListener( <span class="string">'电话响'</span>, handler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这样会使你的代码看起来更清楚。</p><p>除了事件以外，还有另一个会需要用到回调函数的场景，就是「<strong>控制多个函数间执行的顺序</strong>」。</p><p>啥意思呢？来看个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function A'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funB = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function B'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">funA();</span><br><span class="line">funB();</span><br></pre></td></tr></table></figure><p>因为<code>funcA</code>与<code>funcB</code>都会立即执行，并且JavaScript 的单线程模型决定了同时只能执行一个任务，其他任务都必须在后面排队等待，所以执行结果必定为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function A</span><br><span class="line">function B</span><br></pre></td></tr></table></figure><p>但是，如果<code>funcA</code>是异步操作，<code>funcB</code>会立即执行，不会等到<code>funcA</code>结束再执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function A'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funB = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function B'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">funA();</span><br><span class="line">funB();</span><br></pre></td></tr></table></figure><p>像这种时候，为了确保先执行<code>funcA</code>，就可以通过回调函数的形式来进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了确保先执行 funA 再执行 funB</span></span><br><span class="line"><span class="comment">// 我们在 funA 加上 callback 参数</span></span><br><span class="line"><span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function A'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 callback 是个函数就调用它</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> callback === <span class="string">'function'</span> )&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funB = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function B'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 funB 作为参数带入 funA()</span></span><br><span class="line">funA( funB );</span><br></pre></td></tr></table></figure><p>像这样，无论<code>funA</code>在执行的时候要等多久，<code>funB</code>都会等到<code>console.log(&#39;function A&#39;);</code>之后才执行。</p><p>不过需要注意的是，我们可以将不止一个的回调函数作为参数传递给一个函数，就像我们能够传递不止一个变量一样，过多的异步编程嵌套在一起产生的多重回调函数甚至叫回调地狱，维护起来真的如名字一样会很可怕！</p><p>多重回调函数就类似下面这样的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">async</span>(<span class="number">3</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">async</span>(<span class="number">4</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">async</span>(<span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">async</span>(<span class="number">6</span>, final);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数为 1 , 1秒后返回结果</span><br><span class="line">参数为 2 , 1秒后返回结果</span><br><span class="line">参数为 3 , 1秒后返回结果</span><br><span class="line">参数为 4 , 1秒后返回结果</span><br><span class="line">参数为 5 , 1秒后返回结果</span><br><span class="line">参数为 6 , 1秒后返回结果</span><br><span class="line">完成:  12</span><br></pre></td></tr></table></figure><p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p><p>如果真的不幸需要写到这么多层，这点后续我们介绍到<code>Promise</code>时会再说明如何摆脱这种困境。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章当中，我们已经介绍了函数的参数与arguments对象，那么今天的分享中，我们继续来看看函数在JavaScript的各种不同面貌——回调函数。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Callback function" scheme="https://luozongmin.com/tags/Callback-function/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件三部曲之事件的兄弟姐妹们</title>
    <link href="https://luozongmin.com/2019/07/16/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%84%E5%BC%9F%E5%A7%90%E5%A6%B9%E4%BB%AC/"/>
    <id>https://luozongmin.com/2019/07/16/JavaScript事件三部曲之事件的兄弟姐妹们/</id>
    <published>2019-07-16T12:14:01.817Z</published>
    <updated>2019-07-17T00:46:51.453Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的两篇文章中，已经介绍了事件的传达机制，以及如何阻止事件的冒泡与默认的行为。 那么，作为「事件三部曲」的最后一篇，我们就来大概介绍一下，DOM 规范之中究竟提供了哪些事件。<a id="more"></a></p><h3 id="事件的种类"><a href="#事件的种类" class="headerlink" title="事件的种类"></a>事件的种类</h3><p>浏览器可能发生的事件有很多种，了解这些事件的情境及效果，是 Web 开发不能忽略的基础，接下来介绍一下常见的几种事件：</p><h4 id="界面相关事件"><a href="#界面相关事件" class="headerlink" title="界面相关事件"></a>界面相关事件</h4><p>界面相关的事件不一定会与使用者对 DOM 的操作有关系，反而大多数与window对象比较有关系。</p><ul><li><code>load</code> 事件：</li></ul><p>注册在 <code>window</code> 对象上，指的是在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'所有资源都加载完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>unload</code> 、 <code>beforeunload</code> 事件：</li></ul><p>与 <code>load</code> 事件相反，<code>unload</code> 与 <code>beforeunload</code> 事件分别会在离开页面或重新整理时触发，而 <code>beforeunload</code> 会跳出对话框询问使用者是否要离开当前页面。</p><p><img src="/images/shijian-7.jpg" alt></p><ul><li><code>error</code> 事件：</li></ul><p><code>error</code> 事件会在 <code>document</code> 或是图片载入错误时触发。由于考虑到维护性，大多事件的注册我会强烈建议使用「非侵入式 JavaScript」的写法，即JavaScript代码和标记的分离。只有 <code>error</code> 事件最适合以 <code>on-event</code> 的写法来处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.jpg"</span> <span class="attr">onerror</span>=<span class="string">"this.src='default.jpg'"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>像这样，当<code>image.jpg</code>这张图片不存在的时候，马上就会触发<code>error</code>事件，就会通过<code>this.src</code>将<code>&lt;img&gt;</code>的 <code>src</code> 属性替换成指定的图片，是相当实用的技巧。</p><p>若是在网页 <code>load</code> 完成后才注册了<code>error</code>事件，你只会看到破图的结果，因为<code>error</code>事件不会再次被触发，后来挂上去的事件处理函数就等于没有一样。</p><ul><li><p><code>resize</code>事件：在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p></li><li><p><code>scroll</code>事件：在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p></li><li><p><code>DOMContentLoaded</code>事件：</p></li></ul><p>类似于<code>load</code>事件，但不同的是，<code>load</code>事件是在网页「所有」资源都已经载入完成后才会触发，而<code>DOMContentLoaded</code>事件是在 DOM 结构被完整的读取跟解析后就会被触发，不须等待外部资源读取完成，因此可以这么说，这两者所监听的阶段不同，可以用下面这张图来解释：</p><p><img src="/images/shijian-8.jpg" alt></p><p>我们在<a href="https://zhuanlan.zhihu.com/p/66576306" target="_blank" rel="noopener">《通过DOM API 查找节点》</a>这篇文章中曾介绍过，<code>&lt;script&gt;</code>标签要是放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间，因为还没解析到网页本体会有选取不到 DOM 的问题对吧？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 因 Document 结构未载入，无效</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>).textContent = <span class="string">'Hello'</span>;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，改成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 当 document 结构已解析完成才会执行</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>).textContent = <span class="string">'Hello'</span>;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就可以排除<code>&lt;script&gt;</code>标签放在<code>&lt;head&gt; ... &lt;/head&gt;</code>抓不到 DOM 的问题啦。</p><p>与大家所熟知的 <code>jQuery$( document ).ready( handler )</code>作用类似。</p><h4 id="鼠标相关事件"><a href="#鼠标相关事件" class="headerlink" title="鼠标相关事件"></a>鼠标相关事件</h4><ul><li><p><code>mousedown</code> / <code>mouseup</code> 事件: 这两个事件分别会在鼠标点击了某元素「按下」(mousedown) 按钮，以及「放开」(mouseup)按钮时触发。</p></li><li><p><code>click</code> 事件: 当鼠标「点击」了某元素时触发。</p></li><li><p><code>dblclick</code>事件: 当鼠标「连点两次」某元素时触发。</p></li><li><p><code>mouseenter</code> / <code>mousemove</code> / <code>mouseleave</code> 事件：这三个事件要放在一起看：</p></li></ul><ol><li>当鼠标光标移入了某元素时，会先触发 <code>mouseenter</code> 事件。</li><li>鼠标光标在这个元素內「移动」时，会连续触发 <code>mousemove</code> 事件。</li><li>直到鼠标光标离开了这个元素，才触发 <code>mouseleave</code> 事件。</li></ol><p><img src="/images/shijian-9.gif" alt></p><p>这些鼠标相关的事件，都可以通过<code>event.pageX</code> 与 <code>event.pageY</code>属性去取得目前鼠标在网页对应的坐标。</p><h4 id="键盘相关事件"><a href="#键盘相关事件" class="headerlink" title="键盘相关事件"></a>键盘相关事件</h4><p>键盘常用相关事件有下列三种，在大多数情况下会将键盘事件注册在 <code>input</code> 的输入框上。</p><ul><li><p><code>keydown</code> 事件: 「压下」键盘按键时会触发 <code>keydown</code> 事件。</p></li><li><p><code>keypress</code> 事件: 除了 Shift, Fn, CapsLock 这三种按键外按住时会触发，若按着不放则会连续触发。</p></li><li><p><code>keyup</code> 事件: 「放开」键盘按键时会触发。</p></li></ul><p>如果我们针对同个元素同时绑定了这三个键盘事件，那么这三个事件执行的顺序会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keydown</span><br><span class="line">keypress</span><br><span class="line">keyup</span><br></pre></td></tr></table></figure><p>若此时想要知道使用者按下的按键是哪个，则可以通过<code>event.keyCode</code>属性来查询。<code>keyCode</code>的对应表可以到<a href="https://gist.github.com/tylerbuchea/8011573" target="_blank" rel="noopener">这里</a>查看：</p><p>例如，今天你想要当使用者在<code>input</code>输入框按下 「enter」 时，发动<code>submit</code>，就可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">textBox.addEventListener(<span class="string">'keydown'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// enter 的 keyCode 是 13</span></span><br><span class="line">  <span class="keyword">if</span>( e.keyCode === <span class="number">13</span> )&#123;</span><br><span class="line">    formSubmit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>像这样，通过<code>e.keyCode</code>就可以判断使用者目前按下的是哪个按钮。</p><h4 id="表单相关事件"><a href="#表单相关事件" class="headerlink" title="表单相关事件"></a>表单相关事件</h4><ul><li><p><code>input</code> 事件： 当 <code>input</code>、 <code>textarea</code> 以及带有 <code>contenteditable</code> 的元素內容被改变时，就会触发 <code>input</code> 事件。</p></li><li><p><code>change</code> 事件： 当 <code>input</code>、<code>select</code>、<code>textarea</code>、<code>radio</code>、<code>checkbox</code> 等表单元素被改变时触发。 但与 <code>input</code> 事件不同的是，<code>input</code> 事件会在输入框输入內容的当下触发，而 <code>change</code> 事件则是在目前焦点离开输入框后才触发。</p></li><li><p><code>submit</code> 事件：当表单被送出时触发，通常表单验证都会在这一步处理，若验证未通过则 <code>return false;</code>。</p></li><li><p><code>focus</code> 事件：当元素被聚焦时触发。</p></li><li><p><code>blur</code> 事件：当元素失去焦点时触发。</p></li></ul><h4 id="特殊事件"><a href="#特殊事件" class="headerlink" title="特殊事件"></a>特殊事件</h4><ul><li>Composition Event (组成事件):</li></ul><p><strong>Composition Event</strong> 其实指的是 <code>compositionstart</code> 、 <code>compositionend</code> ，以及 <code>compositionupdate</code> 这三个事件。</p><p>介绍 Composition Events 之前先来谈谈 DOM API 过去对输入框侦测变化的几个方式：</p><p>常见的表单输入框如: <code>&lt;input type=&quot;text&quot;&gt;</code> 如果要动态监听输入框的文字变化时， 大多会通过监听 <code>keydown</code>、<code>keypress</code>、<code>keyup</code> 等键盘事件来判断 <code>value</code> 是否变动，但如果是通过「<strong>复制粘贴</strong>」之类的操作，就无法通过键盘事件来判断。</p><p>而即使是 <code>change</code> 事件则是要在使用者改变內容，且<strong>焦点离开输入框</strong>的前一刻才会被触发。</p><p>所以后来有了 <code>input</code> 事件， <code>input</code> 事件会在输入框的<strong>內容被改变时即时触发</strong>，确实也解决了过去在 <code>onChange</code> 以及键盘相关事件功能不足所产生的问题。</p><p>但是，新的问题来了！</p><p>通常像这样的搜索框，我们会用类似 <code>autocomplete</code> (自动完成) 的方式给使用者搜索建议 (以 google 为例)：</p><p><img src="/images/shijian-10.jpg" alt></p><p>如上图，在输入中文的时候，通常会需要通过注音之类的输入法来做拼字。</p><p>但是在大部分的情況下，针对「注音符号」或是「拼音文字」去给搜索建议是没有太大意义的。</p><p>这个时候就需要通过 <code>Composition Events</code> 来为输入框做增强。</p><p>通过 <code>Composition Events</code> 我们可以观察使用者在输入框內开启输入法 (Input Method Editor, IME) 时，组字或选字的状态。</p><p>Composition Events 提供三个事件给开发者监听：分別是 <code>compositionstart</code> 、 <code>compositionend</code> ，以及 <code>compositionupdate</code>。</p><ul><li><code>compositionstart</code>: 输入框內开启输入法，且正在拼字时触发。</li><li><code>compositionupdate</code>: 输入框內开启输入法，且正在拼字或选字时更改了內容时触发。</li><li><code>compositionend</code>: 输入框內开启输入法，拼字或选字完成，正要送出至输入框时触发。</li></ul><p>执行的时候像这样：</p><p><img src="/images/shijian-11.jpg" alt></p><p>可以看到，如果要确认使用者输入完成并送出文字时，就可以通过<code>compositionend</code>来做最后确认。</p><h4 id="自订事件"><a href="#自订事件" class="headerlink" title="自订事件"></a>自订事件</h4><p>自订事件可以用<code>Event constructor</code>建立，同样通过<code>addEventListener</code>去监听，由<code>dispatchEvent</code>决定触发的时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">elem.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p>若是想要在自订事件內增加更多资料，则可以改用<code>CustomEvent</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="string">'detail'</span>: elem.dataset.time &#125;);</span><br></pre></td></tr></table></figure><p>那么在 Event 处理函数就可以通过<code>event</code>来接收：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">'The time is: '</span> + e.detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，浏览器提供的事件相当多，今天分享的部分主要是比较常见的一些事件，以及工作上实际需要特別注意的部分。</p><p>其他的多数事件你都可以在 MDN 的 <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">Event reference</a> 找到。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的两篇文章中，已经介绍了事件的传达机制，以及如何阻止事件的冒泡与默认的行为。 那么，作为「事件三部曲」的最后一篇，我们就来大概介绍一下，DOM 规范之中究竟提供了哪些事件。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="事件" scheme="https://luozongmin.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="event" scheme="https://luozongmin.com/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件三部曲之隐藏在其中的&quot;秘密&quot;</title>
    <link href="https://luozongmin.com/2019/07/13/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9A%90%E8%97%8F%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>https://luozongmin.com/2019/07/13/JavaScript事件三部曲之隐藏在其中的秘密/</id>
    <published>2019-07-13T14:33:45.953Z</published>
    <updated>2019-07-16T00:37:13.847Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/73091706" target="_blank" rel="noopener">上篇文章</a>我们提到，注册事件的方法addEventListener()内有三个参数，分别是「事件名称」、「事件的处理程序」，以及「捕获」或「冒泡」的机制切换。<a id="more"></a></p><p>那么，今天我们要来看的第一个部分，就是隐藏在事件处理程序中的<code>event</code> 。</p><h3 id="隐藏在监听函数中的”event”"><a href="#隐藏在监听函数中的”event”" class="headerlink" title="隐藏在监听函数中的”event”"></a>隐藏在监听函数中的”event”</h3><p>当监听的事件发生时，浏览器会去执行我们通过<code>addEventListener()</code>注册的事件处理程序函数。</p><p>这个时候，EventListener 会去创建一个「事件对象」 (Event Object)，里面包含了所有与这个事件相关的属性，并且以「参数」的形式传给我们的处理程序函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn"</span>&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">var btn = document.getElementById('btn');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 参数 e 就是上面所说的事件对象 </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 因为是参数，当然可以自己定名称</span></span><br><span class="line"><span class="regexp">btn.addEventListener('click', function(e)&#123;</span></span><br><span class="line"><span class="regexp">  console.log(e);</span></span><br><span class="line"><span class="regexp">&#125;, false);</span></span><br></pre></td></tr></table></figure><p>当点击<code>&lt;button&gt;</code>后，可以从<code>console</code>看到<code>event</code>对象中提供了这么多东西：</p><p><img src="/images/shijian-5.jpg" alt></p><p>像是</p><ul><li><code>type</code> : 表示事件的名称</li><li><code>target</code> : 表示触发事件的元素</li><li><code>bubbles</code>:表示这事件是否是在「冒泡」阶段触发( <code>true</code>/ <code>false</code>)</li><li><code>pageX</code>/ <code>pageY</code>:表示事件触发时，鼠标座标在网页的相对位置</li></ul><p>其余的属性这里就不一一介绍，不过要注意的是，每个「事件对象」所提供的属性都会根据触发的事件而稍微不同。</p><h3 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event. preventDefault()"></a>event. preventDefault()</h3><p>HTML中部分元素会有默认行为，像是<code>&lt;a&gt;</code>标签默认页面跳转或是锚点定位，或是表单的<code>submit</code>等等…</p><p>如果我们需要在这些元素上绑定事件，那么适当地<strong>取消它们的默认行为</strong>就是很重要的一件事。</p><p>比如，有一个通往baidu的链接<code>&lt;a&gt;</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"link"</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设今天点击这个link时，我希望浏览器执行<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;那么根据先前所说，我可以先注册<code>click</code>事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>);</span><br><span class="line"></span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'米淇淋你好帅!'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>结果你却发现，即便我们在<code>&lt;a&gt;</code>中去注册了<code>click</code>事件，但是当我点击这个link的时候，浏览器开始会console.log出”米淇淋你好帅!”，但最后baidu的网页依旧会覆盖我想要的内容。</p><p>可是我希望执行的是<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;而不是直接把我带偏了去到baidu的网站，那么我们该怎么做，才能避免呢？</p><p>这时候如果<strong>调用<code>event.preventDefault()</code>方法，默认事件行为将不再触发</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 事件处理函数中 加上 e.preventDefault();</span></span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'米淇淋你好帅!'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这个时候，再试着点击link一次，你会发现浏览器默认的跳转页面的行为不见了，<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;也可顺利执行啦哈哈。</p><p>但要注意的是，<code>event.preventDefault()</code>并不会阻止事件向上传递(即事件冒泡) 。</p><p>另外，值得一提的是，下面这样设置也可以让a标签仅仅当做一个普通的按钮，点击实现一个功能，不想页面跳转，也不想锚点定位：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，在事件处理函数的<strong>最后</strong>加上<code>return false</code>;也会有<code>event.preventDefault()</code>的效果，但切记不可以加在前面，若是加在前面事件处理函数就直接gg了。</p><h3 id="event-stopPropagation-amp-event-stopImmediatePropagation"><a href="#event-stopPropagation-amp-event-stopImmediatePropagation" class="headerlink" title="event.stopPropagation() &amp; event.stopImmediatePropagation()"></a>event.stopPropagation() &amp; event.stopImmediatePropagation()</h3><p>1.<code>event.stopPropagation()</code> 方法阻止事件向上冒泡传递，阻止任何父事件处理程序被执行。</p><p>接下来我们看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">    父元素</span><br><span class="line">    &lt;div id=<span class="string">"child"</span>&gt;子元素&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">var parent = document.getElementById('parent');</span></span><br><span class="line"><span class="regexp">var child = document.getElementById('child');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">child.addEventListener('click', function () &#123;</span></span><br><span class="line"><span class="regexp">  console.log('child bubbling');</span></span><br><span class="line"><span class="regexp">&#125;, false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">parent.addEventListener('click', function () &#123;</span></span><br><span class="line"><span class="regexp">  console.log('parent bubbling');</span></span><br><span class="line"><span class="regexp">&#125;, false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">document.body.addEventListener('click', function () &#123;</span></span><br><span class="line"><span class="regexp">  console.log('body bubbling');</span></span><br><span class="line"><span class="regexp">&#125;, false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">document.documentElement.addEventListener('click', function () &#123;</span></span><br><span class="line"><span class="regexp">  console.log('html bubbling');</span></span><br><span class="line"><span class="regexp">&#125;, false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">document.addEventListener('click', function () &#123;</span></span><br><span class="line"><span class="regexp">  console.log('document bubbling');</span></span><br><span class="line"><span class="regexp">&#125;, false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">window.addEventListener('click', function () &#123;</span></span><br><span class="line"><span class="regexp">  console.log('window bubbling');</span></span><br><span class="line"><span class="regexp">&#125;, false);</span></span><br></pre></td></tr></table></figure><p>当我点击的是「子元素」的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">child bubbling</span><br><span class="line">parent bubbling</span><br><span class="line">body bubbling</span><br><span class="line">html bubbling</span><br><span class="line">document bubbling</span><br><span class="line">window bubbling</span><br></pre></td></tr></table></figure><p>而如果在「子元素」中加入<code>event.stopPropagation()</code> 方法，其余保持原样的话：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'child bubbling'</span>);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>再次点击「子元素」，则只出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child bubbling</span><br></pre></td></tr></table></figure><p>其余父事件不会触发，即<code>event.stopPropagation()</code> 方法阻止了事件向上冒泡传递，阻止任何父事件处理程序被执行。</p><p>2.<code>stopImmediatePropagation()</code>方法 <strong>既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发</strong>。而 stopPropagation 只能实现前者的效果。</p><p>我们来看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button id=<span class="string">"btn"</span>&gt;click me to stop propagation&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'btn click 1'</span>);</span><br><span class="line">  <span class="comment">//e.stopImmediatePropagation();</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'btn click 2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'body click'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'html click'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'document click'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'window click'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当我点击button的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn click 1</span><br><span class="line">btn click 2</span><br><span class="line">body click</span><br><span class="line">html click</span><br><span class="line">document click</span><br><span class="line">window click</span><br></pre></td></tr></table></figure><p>而如果在「btn的第一个监听函数」中加入<code>event.stopImmediatePropagation()</code> 方法，其余保持原样的话：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'btn click 1'</span>);</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次点击button，则只出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn click 1</span><br></pre></td></tr></table></figure><p>所以说，使用 <code>stopImmediatePropagation()</code> 方法后，点击按钮时，仅触发设置了<code>stopImmediatePropagation()</code> 方法的监听器，与此同时按钮的其余同类型点击事件不触发。</p><h3 id="event-target-amp-event-currentTarget"><a href="#event-target-amp-event-currentTarget" class="headerlink" title="event.target &amp; event.currentTarget"></a>event.target &amp; event.currentTarget</h3><p>老实说并不能好好用文字描述这两者的区别，我们直接看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  #a&#123;</span><br><span class="line">    width: <span class="number">200</span>px;</span><br><span class="line">    height: <span class="number">200</span>px;</span><br><span class="line">    background: yellow       ;</span><br><span class="line">  &#125;</span><br><span class="line">  #b&#123;</span><br><span class="line">    width: <span class="number">150</span>px;</span><br><span class="line">    height: <span class="number">150</span>px;</span><br><span class="line">    background: green;</span><br><span class="line">  &#125;</span><br><span class="line">  #c&#123;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">    background: grey;</span><br><span class="line">  &#125;</span><br><span class="line">  #d&#123;</span><br><span class="line">    width: <span class="number">50</span>px;</span><br><span class="line">    height: <span class="number">50</span>px;</span><br><span class="line">    background: black;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">&lt;div id="a"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div id="b"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="c"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div id="d"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">document.getElementById('a').addEventListener('click', function(e) &#123;</span></span><br><span class="line"><span class="regexp">    console.log(</span></span><br><span class="line"><span class="regexp">      'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">  document.getElementById('b').addEventListener('click', function(e) &#123;</span></span><br><span class="line"><span class="regexp">    console.log(</span></span><br><span class="line"><span class="regexp">      'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">  document.getElementById('c').addEventListener('click', function(e) &#123;</span></span><br><span class="line"><span class="regexp">    console.log(</span></span><br><span class="line"><span class="regexp">      'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">  document.getElementById('d').addEventListener('click', function(e) &#123;</span></span><br><span class="line"><span class="regexp">    console.log(</span></span><br><span class="line"><span class="regexp">      'target:' + e.target.id + '&amp;currentTarget:' + e.currentTarget.id</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/rubedoqepi/edit?html,js,output" target="_blank" rel="noopener">jsbin</a> 点这里。</p><p><img src="/images/shijian-6.gif" alt></p><p>当我们点击最里层黑色区域的元素d的时候，会依次输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target:d&amp;currentTarget:d</span><br><span class="line">target:d&amp;currentTarget:c</span><br><span class="line">target:d&amp;currentTarget:b</span><br><span class="line">target:d&amp;currentTarget:a</span><br></pre></td></tr></table></figure><p>从输出中我们可以看到，<code>event.target</code>指向引起触发事件的元素，而<code>event.currentTarget</code>则是事件绑定的元素，只有被点击的那个目标元素的<code>event.target</code>才会等于<code>event.currentTarget</code>。<strong>也就是说，<code>event.currentTarget</code>始终是监听事件者，而<code>event.target</code>是事件的真正发出者</strong>。</p><p>另外，值得一提的是，function内部的<code>this</code>指的也就是<code>event.currentTarget</code>。</p><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件代理或叫事件委托（Event Delegation）。</p><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><ul><li>减少内存消耗，提高性能</li></ul><p>假设有一个列表，列表之中有大量的列表项，我们需要在点击每个列表项的时候响应一个事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item n<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果给每个列表项都绑定一个函数，假如此时列表项很多，那无疑对内存的消耗是非常大的，并且效率上需要消耗很多性能。借助事件代理，我们只需要给父容器 <code>ul</code> 绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。</p><ul><li>动态绑定事件</li></ul><p>在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。</p><h4 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h4><p>接下来我们来实现上例中父层元素 <code>#myList</code> 下的 <code>li</code> 元素的事件委托到它的父层元素上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得容器</span></span><br><span class="line"><span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让父层 myList 来监听 click 事件</span></span><br><span class="line">myList.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断目标元素若是 li 则执行 console.log</span></span><br><span class="line">  <span class="keyword">if</span>( e.target.tagName.toLowerCase() === <span class="string">'li'</span> )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.textContent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立新的 &lt;li&gt; 元素</span></span><br><span class="line"><span class="keyword">var</span> newList = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 textNode 文字节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 appendChild 将 textNode 加入至 newList</span></span><br><span class="line">newList.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 appendChild 将 newList 加入至 myList</span></span><br><span class="line">myList.appendChild(newList);</span><br></pre></td></tr></table></figure><p>我们把<code>click</code>事件改由父层的<code>myList</code>来监听，利用事件传递的原理，判断<code>e.target</code>是我们想要的目标节点时，才去执行后续的动作。</p><p>这样的好处是你的事件管理会非常轻松，而且后续加上的<code>newList</code>也会有<code>click</code>的效果，无需另外再去绑定<code>click</code>事件。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73091706&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;我们提到，注册事件的方法addEventListener()内有三个参数，分别是「事件名称」、「事件的处理程序」，以及「捕获」或「冒泡」的机制切换。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="事件" scheme="https://luozongmin.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="event" scheme="https://luozongmin.com/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件三部曲之事件机制的原理</title>
    <link href="https://luozongmin.com/2019/07/11/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://luozongmin.com/2019/07/11/JavaScript事件三部曲之事件机制的原理/</id>
    <published>2019-07-11T06:56:16.556Z</published>
    <updated>2019-07-11T08:01:56.212Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 是一个事件驱动(Event-driven) 的语言，当浏览器载入网页开始读取后，虽然马上会读取JavaScript 事件相关的代码，但是必须要等到「事件」被触发(如使用者点击、按下键盘等)后，才会再进行对应代码段的执行。<a id="more"></a></p><p>啥意思呢？</p><p>就好比放了一部电话在家里，但是电话要是没响，我们不会主动去「接电话」 (没人打来当然也无法主动接) ，这里电话响了就好比事件被触发，接电话就好比去做对应的事情。</p><h3 id="电话响了-事件被触发-gt-接电话-去做对应的事"><a href="#电话响了-事件被触发-gt-接电话-去做对应的事" class="headerlink" title="电话响了(事件被触发) -&gt; 接电话(去做对应的事)"></a>电话响了(事件被触发) -&gt; 接电话(去做对应的事)</h3><p>换以我们很常见的网页对话框UI 来说，当使用者「按下了按钮」之后，才会启动对话框的显示。如果使用者没有按下按钮，就狂跳对话框，那使用者一定觉得这网站瓦特了吧。</p><p>以Bootstrap Modal 为例：</p><p><img src="/images/shijian-1.gif" alt></p><p>在上面的例子中，当使用者点击了按钮，才会启动对话框的显示，那么「点击按钮」这件事，就被称作「<strong>事件</strong>」(Event)，而负责处理事件的代码段通常被称为「<strong>事件处理程序</strong>」(Event Handler)，也就是「启动对话框的显示」这个动作。</p><p>看完上面的例子，想必大家对事件有了一定的理解了吧，接下来就深入来探讨DOM事件。</p><h3 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h3><p>DOM有4次版本更新，与DOM版本变更，产生了3种不同的DOM事件：<strong>DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理</strong>。由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件。</p><h4 id="DOM-0级事件"><a href="#DOM-0级事件" class="headerlink" title="DOM 0级事件"></a>DOM 0级事件</h4><p>1.on-event (HTML 属性)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">"alert('xxx')"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，基于代码的使用性与维护性考量，现在已经不建议用此方式来绑定事件。</p><p>on-event (非HTML 属性)：</p><p>像是<code>window</code>或<code>document</code>此类没有实体元素的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若是实体元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// JavaScript</span><br><span class="line">var btn = document.getElementById('btn');</span><br><span class="line"> btn.onclick = function()&#123;</span><br><span class="line">     alert('xxx');</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>若想解除事件的话，则重新指定<code>on-event</code>为<code>null</code>即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>2.同一个元素的同一种事件只能绑定一个函数，否则后面的函数会覆盖之前的函数</p><p>3.不存在兼容性问题</p><h4 id="DOM-2级事件"><a href="#DOM-2级事件" class="headerlink" title="DOM 2级事件"></a>DOM 2级事件</h4><p>1.Dom 2级事件是通过 <code>addEventListener</code> 绑定的事件</p><p>2.同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行</p><p>3.解绑Dom 2级事件时，使用 <code>removeEventListener</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.removeEventListener( <span class="string">"click"</span> ,a)</span><br></pre></td></tr></table></figure><p>Dom 2级事件有三个参数：第一个参数是事件名（如<code>click</code>）；第二个参数是事件处理程序函数；第三个参数如果是<code>true</code>的话表示在捕获阶段调用，为<code>false</code>的话表示在冒泡阶段调用。捕获阶段和冒泡阶段在下一节具体介绍。</p><p>还有注意<code>removeEventListener()</code>:不能移除匿名添加的函数。</p><h4 id="DOM-3级事件"><a href="#DOM-3级事件" class="headerlink" title="DOM 3级事件"></a>DOM 3级事件</h4><p>DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，增加的类型如下：</p><ul><li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li><li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</li><li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li><li>文本事件，当在文档中输入文本时触发，如：textInput</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li><li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li><li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</li><li>同时DOM3级事件也允许使用者自定义一些事件。</li></ul><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>事件流(Event Flow)指的就是「<strong>网页元素接收事件的顺序</strong>」。事件流可以分成两种机制：</p><ul><li>事件捕获(Event Capturing)</li><li>事件冒泡(Event Bubbling)</li></ul><p>当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段：</p><ol><li>捕获阶段：事件从<code>window</code>对象自上而下向目标节点传播的阶段；</li><li>目标阶段：真正的目标节点正在处理事件的阶段；</li><li>冒泡阶段：事件从目标节点自下而上向<code>window</code>对象传播的阶段。</li></ol><p>接着就来分别介绍事件捕获和事件冒泡这两种机制。</p><h4 id="事件捕获-Event-Capturing"><a href="#事件捕获-Event-Capturing" class="headerlink" title="事件捕获(Event Capturing)"></a>事件捕获(Event Capturing)</h4><p><img src="/images/shijian-2.jpg" alt></p><p>事件捕获指的是「从启动事件的元素节点开始，逐层往下传递」，直到最下层节点，也就是<code>div</code>。</p><p>假设HTML 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>米淇淋是个大帅哥<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设我们点击(click)了<code>&lt;div&gt;点我&lt;/div&gt;</code>元素，那么在「事件捕获」的机制下，触发事件的顺序会是：</p><ol><li><code>document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;div&gt;点我&lt;/div&gt;</code></li></ol><p>像这样<code>click</code>事件由上往下依序被触发，就是「事件捕获」机制。</p><h4 id="事件冒泡-Event-Bubbling"><a href="#事件冒泡-Event-Bubbling" class="headerlink" title="事件冒泡(Event Bubbling)"></a>事件冒泡(Event Bubbling)</h4><p><img src="/images/shijian-3.jpg" alt></p><p>刚刚说过「事件捕获」机制是由上往下来传递，那么「事件冒泡」(Event Bubbling) 机制则正好相反。</p><p>假设HTML 同样如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>米淇淋是个大帅哥<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设我们点击(click)了<code>&lt;div&gt;点我&lt;/div&gt;</code>元素，那么在「事件冒泡」的机制下，触发事件的顺序会是：</p><ol><li><code>&lt;div&gt;点我&lt;/div&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;html&gt;</code></li><li><code>document</code></li></ol><p>像这样<code>click</code>事件逐层向上依序被触发，就是「事件冒泡」机制。</p><p>既然事件传递顺序有这两种机制，那<strong>我怎么知道事件是依据哪种机制</strong>执行的呢？</p><p>答案是：两种都会执行。</p><p><img src="/images/shijian-4.jpg" alt></p><p>假设现在的事件是点击上图中蓝色的<code>&lt;td&gt;</code>。</p><p>那么当td的<code>click</code>事件发生时，会先走红色的「capture phase」：</p><ol><li><code>Document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;table&gt;</code></li><li><code>&lt;tbody&gt;</code></li><li><code>&lt;tr&gt;</code></li><li><code>&lt;td&gt;</code> (实际被点击的元素)</li></ol><p>由上而下依序触发它们的<code>click</code>事件。</p><p>然后到达「Target phase」后再继续执行绿色的「bubble phase」，反方向由<code>&lt;td&gt;</code>一路往上传至<code>Document</code>，整个事件流到此结束。</p><p>要检验事件流，我们可以通过<code>addEventListener()</code>方法来绑定<code>click</code>事件：</p><p>假设HTML 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    父元素</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span>子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">document</span>.getElementById(<span class="string">'child'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 addEventListener 指定事件的绑定</span></span><br><span class="line"><span class="comment">// 第三个参数 true / false 分別代表 捕获/ 冒泡 机制</span></span><br><span class="line"></span><br><span class="line">parent.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Parent Capturing'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">parent.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Parent Bubbling'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Child Capturing'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Child Bubbling'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>当我点击的是「子元素」的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Parent Capturing"</span></span><br><span class="line"><span class="string">"Child Capturing"</span></span><br><span class="line"><span class="string">"Child Bubbling"</span></span><br><span class="line"><span class="string">"Parent Bubbling"</span></span><br></pre></td></tr></table></figure><p>而如果直接点击「父元素」，则出现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Parent Capturing"</span></span><br><span class="line"><span class="string">"Parent Bubbling"</span></span><br></pre></td></tr></table></figure><p>由此可知，点击子元素的时候，父层的<code>Capturing</code>会先被触发，然后再到子层内部的<code>Capturing</code>或<code>Bubbling</code>事件。最后才又回到父层的<code>Bubbling</code>结束。点击父元素的时候，不会经过子元素，子层的<code>Capturing</code>和<code>Bubbling</code>都不会触发。</p><p>那么，子层中的<code>Capturing</code>或<code>Bubbling</code>谁先谁后呢？要看你代码的顺序而定：</p><p>若是<code>Capturing</code>在<code>Bubbling</code>前面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Child Capturing'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Child Bubbling'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>则会得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Child Capturing"</span></span><br><span class="line"><span class="string">"Child Bubbling"</span></span><br></pre></td></tr></table></figure><p>若是将两段代码段顺序反过来的话，就会是这样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Child Bubbling'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Child Capturing'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>则会得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Child Bubbling"</span></span><br><span class="line"><span class="string">"Child Capturing"</span></span><br></pre></td></tr></table></figure><h3 id="事件监听-EventTarget-addEventListener"><a href="#事件监听-EventTarget-addEventListener" class="headerlink" title="事件监听 EventTarget.addEventListener()"></a>事件监听 EventTarget.addEventListener()</h3><p><code>addEventListener()</code>基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的<code>function</code>)，以及一个「Boolean」值，由这个Boolean决定事件是以「捕获」还是「冒泡」机制执行，若不指定则预设为「冒泡」。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// JavaScript</span><br><span class="line">var btn = document.getElementById('btn');</span><br><span class="line"></span><br><span class="line">btn.addEventListener('click', function()&#123;</span><br><span class="line">  console.log('HI');</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>使用这种方式来注册事件的好处是：同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'HI'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'HELLO'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>点击后<code>console</code>出现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"HI"</span></span><br><span class="line"><span class="string">"HELLO"</span></span><br></pre></td></tr></table></figure><p>若要解除事件的监听，则是通过<code>removeEventListener()</code>来取消。</p><p><code>removeEventListener()</code>的三个参数与<code>addEventListener()</code>一样，分别是「事件名称」、「事件的处理程序」以及代表「捕获」或「冒泡」机制的「Boolean」值。</p><p>但是需要注意的是，由于<code>addEventListener()</code>可以同时针对某个事件绑定多个函数，所以通过<code>removeEventListener()</code>解除事件的时候，第二个参数的函数必须要与先前在<code>addEventListener()</code>绑定的函数是同一个「实体」。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'HI'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件，但是没用</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'HI'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>像上面这样，即使执行了<code>removeEventListener</code>来移除事件，但<code>click</code>时仍会出现’HI’。因为<code>addEventListener</code>与<code>removeEventListener</code>所移除的函数实际上是两个不同实体的function对象。</p><p>不知道为什么这两个function是两个不同实体的朋友请参考：<a href="https://zhuanlan.zhihu.com/p/63114665" target="_blank" rel="noopener">《JavaScript系列之内存空间》</a>。简单理解就是两个function指向不同的内存地址，代表来自于不同实体。</p><p>稍加改进后就能如愿移除了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 event 函数程序拉出來</span></span><br><span class="line"><span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'HI'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, clickHandler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 clickHandler， ok!</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, clickHandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>那么以上就是今天为各位介绍JavaScript事件机制原理的部分。</p><p>接下来的文章我会继续来介绍事件的种类，以及更多实际上处理「事件」时需要注意的事项。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 是一个事件驱动(Event-driven) 的语言，当浏览器载入网页开始读取后，虽然马上会读取JavaScript 事件相关的代码，但是必须要等到「事件」被触发(如使用者点击、按下键盘等)后，才会再进行对应代码段的执行。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="事件" scheme="https://luozongmin.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="event" scheme="https://luozongmin.com/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之类数组对象arguments</title>
    <link href="https://luozongmin.com/2019/07/06/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1arguments/"/>
    <id>https://luozongmin.com/2019/07/06/JavaScript系列之类数组对象arguments/</id>
    <published>2019-07-06T15:15:18.554Z</published>
    <updated>2019-07-11T00:37:38.348Z</updated>
    
    <content type="html"><![CDATA[<p>之前在<a href="https://zhuanlan.zhihu.com/p/71490991" target="_blank" rel="noopener">《JavaScript系列之this是什么》</a>这篇文章中，我们曾谈过”this”这个关键字，本章将会谈到另一个JavaScript中的关键字，叫做”arguments”。<a id="more"></a></p><p>那<code>arguments</code>到底是什么呢？下面我将尽可能地用简洁明了的言语来描述 <code>arguments</code>。</p><h3 id="什么是参数-parameters"><a href="#什么是参数-parameters" class="headerlink" title="什么是参数(parameters)"></a>什么是参数(parameters)</h3><p>在了解<code>arguments</code>之前，我们必须要先了解一下什么是参数(parameter)。参数其实就是我们会带入函数的变量，以下面例子来说，”house”、”car”、”money”，就是我们在执行函式的时候可以任意填入的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFavorite</span>(<span class="params">house, car, money</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(house);</span><br><span class="line">    <span class="built_in">console</span>.log(car);</span><br><span class="line">    <span class="built_in">console</span>.log(money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyFavorite();</span><br></pre></td></tr></table></figure><p>首先，当我建立好这样的函数，我可以不带任何参数值就去执行这个函数，只要输入<code>MyFavorite()</code>这样就可以了！</p><p>一般如果有参数却又没有给它参数值，函数的执行上往往会有错误！但在JavaScript中不太一样的地方在于，即使你没有给它任何参数值就加以执行，也不会报错，而是会返回<code>undefined</code>。</p><p><img src="/images/arguments-1.jpg" alt></p><p>为什么会得到”<code>undefined</code>“呢？</p><p>之所以会这样是因为当JavaScript在执行这个函数的时候，由于提升机制，它会先把我们的参数(<code>house</code>, <code>car</code>, <code>money</code>)存到内存中了，并且赋予它的值是<code>undefined</code>。</p><p>参数值会由左至右读取，如果我依序执行这样的代码就理解了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyFavorite();</span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>);</span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>, <span class="string">"法拉利"</span>);</span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>, <span class="string">"法拉利"</span>, <span class="string">"一亿元"</span>);</span><br></pre></td></tr></table></figure><p>会分别读到以下的结果，表示JavaScript会由左至右来读取参数值，而且即使某些参数值有缺值的情况，JavaScript还是可以正常执行。</p><p><img src="/images/arguments-2.jpg" alt></p><h3 id="设置函数中参数的预设值"><a href="#设置函数中参数的预设值" class="headerlink" title="设置函数中参数的预设值"></a>设置函数中参数的预设值</h3><p>由于目前的几款浏览器使用的JavaScript版本都尚不支持直接在参数的地方设置预设值（ES6的将可以），所以很多的框架都还不会用这种方式设置预设值。</p><p><strong>方法一：在ES6的JavaScript中，可以直接通过这种方式设置参数预设值：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFavorite</span>(<span class="params">house, car, money = <span class="string">'一亿元'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(house);</span><br><span class="line">    <span class="built_in">console</span>.log(car);</span><br><span class="line">    <span class="built_in">console</span>.log(money);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：利用强制转换的概念设置预设值</strong></p><p>由于版本兼容的差异，现今多数的编程都是使用这种方式设置参数的预设值，利用简单的”=”和”||”就可以达到参数预设值的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFavorite</span>(<span class="params">house, car, money</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    money = money || <span class="string">'一亿元'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(house);</span><br><span class="line">    <span class="built_in">console</span>.log(car);</span><br><span class="line">    <span class="built_in">console</span>.log(money);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候即使在没有给值的情况下，<code>money</code>一样可以得到预设值为”一亿元”：</p><p><img src="/images/arguments-3.jpg" alt></p><h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><p>了解了<code>parameters</code>的概念后，让我们回来谈谈<code>arguments</code>，MDN将它叫做类数组对象，那么什么是类数组对象呢？</p><p>所谓的类数组对象:</p><blockquote><p>就是拥有一个 <code>length</code> 属性和若干索引属性的对象</p></blockquote><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">'house'</span>, <span class="string">'car'</span>, <span class="string">'money'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">'house'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'car'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'money'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]); <span class="comment">// house</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike[<span class="number">0</span>]); <span class="comment">// house</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'new house'</span>;</span><br><span class="line">arrayLike[<span class="number">0</span>] = <span class="string">'new house'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="built_in">console</span>.log(array.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arrayLike.length; i &lt; len; i++) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们可以看得出来，类数组对象与数组在读取、获取长度、遍历三个方面一样，都能取到，那为什么还叫做类数组对象呢？</p><p>因为类数组对象不可以使用数组的方法，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayLike.push(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure><p>然而上述代码会报错: <code>arrayLike.push is not a function</code>，所以终归还是类数组呐……</p><h3 id="调用数组方法"><a href="#调用数组方法" class="headerlink" title="调用数组方法"></a>调用数组方法</h3><p>如果类数组想用数组的方法怎么办呢？</p><p>直接调用是不可取的，那我们可以通过 <code>Function.call</code> 的方法进行间接调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">'house'</span>, <span class="number">1</span>: <span class="string">'car'</span>, <span class="number">2</span>: <span class="string">'money'</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.join.call(arrayLike, <span class="string">'&amp;'</span>)); <span class="comment">// house&amp;car&amp;money</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(arrayLike, <span class="number">0</span>)); <span class="comment">// ["house", "car", "money"] </span></span><br><span class="line"><span class="comment">// slice可以做到类数组转数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(arrayLike, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// ["HOUSE", "CAR", "MONEY"]</span></span><br></pre></td></tr></table></figure><p>在上面已经提到了一种类数组转数组的方法，再补充三个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">'house'</span>, <span class="number">1</span>: <span class="string">'car'</span>, <span class="number">2</span>: <span class="string">'money'</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="comment">// 1. slice</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(arrayLike)); <span class="comment">// ["house", "car", "money"] </span></span><br><span class="line"><span class="comment">// 2. splice</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>)); <span class="comment">// ["house", "car", "money"] </span></span><br><span class="line"><span class="comment">// 3. ES6 Array.from</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrayLike)); <span class="comment">// ["house", "car", "money"] </span></span><br><span class="line"><span class="comment">// 4. apply</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.concat.apply([], arrayLike));</span><br></pre></td></tr></table></figure><p>接下来重点讲讲 <code>Arguments</code> 这个类数组对象。</p><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p><code>arguments</code>比起<code>this</code>来说，要容易理解的多，<code>arguments</code>对象只定义在函数体中，包括了函数的参数和其他属性。</p><p>同样地通过上面的例子加以理解，我们直接在函数中去打印出”arguments”这个关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFavorite</span>(<span class="params">house, car, money</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    money = money || <span class="string">'一亿元'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyFavorite();</span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>);</span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>, <span class="string">"法拉利"</span>);</span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>, <span class="string">"法拉利"</span>, <span class="string">"一亿元"</span>);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="/images/arguments-4.jpg" alt></p><p>我们可以看到除了类数组的索引属性和<code>length</code>属性之外，还有一个<code>callee</code>属性，而且我们可以看到<code>arguments</code>对象的<code>__ proto __</code>是指向<code>object</code>的，这也说明了他是个类数组对象，而不是一个数组。下面我们进行一一介绍。</p><h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><p><code>arguments.length</code>为函数实参个数，举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">house, car, money</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"实参的长度为："</span> + <span class="built_in">arguments</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"形参的长度为："</span> + foo.length)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参的长度为：3</span></span><br><span class="line"><span class="comment">// 实参的长度为：1</span></span><br></pre></td></tr></table></figure><h4 id="callee属性"><a href="#callee属性" class="headerlink" title="callee属性"></a>callee属性</h4><p>每个参数实例都有一个<code>callee</code>属性，通过它可以调用函数自身。 ES5的严格模式不允许访问<code>arguments.callee</code>。</p><p>讲个闭包经典面试题使用 <code>callee</code> 的解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.i) </span><br><span class="line">    &#125;).i = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="最后来看看展开运算符spread-…"><a href="#最后来看看展开运算符spread-…" class="headerlink" title="最后来看看展开运算符spread(…)"></a>最后来看看展开运算符spread(…)</h3><p>除了<code>arguments</code>这个关键字，在新版ES6的JavaScript中另外提供了一个展开运算符(spread)，它就是「<code>...</code>」三个点，这个<code>...</code>有什么用呢？</p><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">MDN</a>对于展开运算符spread的描述如下：</p><blockquote><p>The spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) or multiple variables (for destructuring assignment) are expected.</p></blockquote><p>简单来说，就是它可以把函数中许多的参数(<code>arguments</code>)或数组中许多的元素(<code>elements</code>)形成一个新的变量。</p><p>举例来说：</p><p>在函数的部分，在参数的地方我们用”<code>...other</code>“，<code>other</code>是你想要储存成的数组变量名称，可以自己取。</p><p>在执行函数的地方，原本我们只有三个参数(<code>house</code>, <code>car</code>, <code>money</code>)，也只能填写三个参数；但使用了展开运算符”<code>...</code>“后，我们在执行函数的地方就可以带入不只三个参数（例如，我在最后面又加了”老婆”和”孩子”），这些多的参数值最后都会被放到<code>other</code>这个数组当中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFavorite</span>(<span class="params">house, car, money, ...other</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(other);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'What my favorite are'</span> + house + <span class="string">','</span> + car + <span class="string">','</span> + money + <span class="string">','</span> + other);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>, <span class="string">"法拉利"</span>, <span class="string">"一亿"</span>);</span><br><span class="line">MyFavorite(<span class="string">"别墅"</span>, <span class="string">"法拉利"</span>, <span class="string">"一亿"</span>, <span class="string">"老婆"</span>, <span class="string">"孩子"</span>);</span><br></pre></td></tr></table></figure><p>结果就会长的像这样子：</p><p><img src="/images/arguments-5.jpg" alt></p><p>展开运算符还有其他的使用方式，像是把数组元素做连接等等，使用灵活的话相当方便，如果有需要的话，可以参考引1。</p><p>引1：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">Microsoft Developer Netword：展开运算符(…)</a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>1.利用arguments实现方法的重载</strong></p><p>下面我们利用<code>arguments</code>对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length,</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;len--;)&#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) );   <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log( add(<span class="number">1</span>,<span class="number">3</span>) );     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log( add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>) );   <span class="comment">//17</span></span><br></pre></td></tr></table></figure><p>由于JS是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用<code>arguments</code>，来判断传入的实参类型与数量进行不同的操作，然后返回不同的数值。</p><p><strong>2.利用arguments.callee实现递归</strong></p><p>先来看看平常我们是怎么实现递归的，这是一个结算阶乘的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * foo(num<span class="number">-1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当这个函数变成了一个匿名函数时，我们就可以利用<code>callee</code>来递归这个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然好用，但是有一点值得注意，ECMAScript4中为了限制JS的灵活度，让JS变得严格，新增了严格模式，在严格模式中我们被禁止不使用<code>var</code>来直接声明一个全局变量，当然这不是重点，重点是<code>arguments.callee</code>这个属性也被禁止了。不过这都不是事儿，ES6为我们新增了很多好用的变量声明方式和新的语法糖，作为一个时髦的前端，我们赶紧学习一些ES6的新语法吧。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71490991&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JavaScript系列之this是什么》&lt;/a&gt;这篇文章中，我们曾谈过”this”这个关键字，本章将会谈到另一个JavaScript中的关键字，叫做”arguments”。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="arguments" scheme="https://luozongmin.com/tags/arguments/"/>
    
  </entry>
  
  <entry>
    <title>Flexbox 对你说爱不完</title>
    <link href="https://luozongmin.com/2019/07/04/CSS%20Flexbox%20%E5%AF%B9%E4%BD%A0%E8%AF%B4%E7%88%B1%E4%B8%8D%E5%AE%8C/"/>
    <id>https://luozongmin.com/2019/07/04/CSS Flexbox 对你说爱不完/</id>
    <published>2019-07-04T06:59:08.842Z</published>
    <updated>2019-07-04T07:50:59.076Z</updated>
    
    <content type="html"><![CDATA[<p>Flexbox 意为弹性布局，是一种新的CSS 3 布局方式，与传统布局方式(基于盒模型，依赖display属性 +position属性 +float属性)相比，flex布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。<a id="more"></a></p><p>废话就不多说了，下面我将尽可能地用简洁明了的言语来描述 Flex 布局。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/images/flex-1.jpg" alt> </p><p>使用了flex布局，则有flex容器（flex container），子元素为项目(flex item）。</p><p>在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，start和end表示对应轴的起始位置，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴。比如将Flexbox的方向设置为row，则主轴就是横轴，而交叉轴就是纵轴；反之设置成column，则主轴就是纵轴，而交叉轴就是横轴，这个下面会具体讲。</p><p>每个项目(flex item)占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。</p><p>这里还需要注意的是，不能直截了当地认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。</p><p>实际上，要实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    display: flex | inline-flex;       //可以有两种取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给div这类块元素设置<code>display: flex</code>或者给span这类行内元素设<code>display: inline-flex</code>，flex布局即创建！</p><p>而Flex布局相关属性正好分为两拨，一拨作用在flex容器上，还有一拨作用在flex子项上。</p><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 的属性将会失效。</strong></p><h3 id="Flex容器上的属性"><a href="#Flex容器上的属性" class="headerlink" title="Flex容器上的属性"></a>Flex容器上的属性</h3><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><p><strong>1. flex-direction: 决定主轴的方向(即项目的排列方向)</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>row</code>（默认）：主轴为水平方向，起点在左端</li></ul><p><img src="/images/flex-2.jpg" alt> </p><ul><li><code>row-reverse</code>：主轴为水平方向，起点在右端</li></ul><p><img src="/images/flex-3.jpg" alt> </p><ul><li><code>column</code>：主轴为垂直方向，起点在上沿</li></ul><p><img src="/images/flex-4.jpg" alt> </p><ul><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿</li></ul><p><img src="/images/flex-5.jpg" alt> </p><p><strong>2. flex-wrap: 决定容器内项目是否可换行</strong></p><p>默认情况下，项目都排在主轴线上，使用 <code>flex-wrap</code> 可实现项目的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>nowrap</code>（默认）：不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行</li></ul><p><img src="/images/flex-6.jpg" alt> </p><ul><li><code>wrap</code>：项目主轴总尺寸超出容器时换行，第一行在上方</li></ul><p><img src="/images/flex-7.jpg" alt></p><ul><li><code>wrap-reverse</code>：换行并反向，第一行在下方</li></ul><p><img src="/images/flex-8.jpg" alt></p><p><strong>3. flex-flow: flex-direction 和 flex-wrap 的复合简写形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为: row nowrap，这个属性其实没多大卵用，不就是两个属性的缩写嘛。</p><p><strong>4. justify-content：定义项目在主轴的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>flex-start</code>（默认）：左对齐</li></ul><p><img src="/images/flex-9.jpg" alt></p><ul><li><code>flex-end</code>：右对齐</li></ul><p><img src="/images/flex-10.jpg" alt></p><ul><li><code>center</code>：居中</li></ul><p><img src="/images/flex-11.jpg" alt></p><ul><li><code>space-between</code>：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙</li></ul><p><img src="/images/flex-12.jpg" alt></p><ul><li><code>space-around</code>：每个项目两侧的间隔相等，所以项目之间的间隔是项目与边缘的间隔的两倍</li></ul><p><img src="/images/flex-13.jpg" alt></p><p><strong>5. align-items: 定义项目在交叉轴上的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: stretch | flex-start | flex-end | center | baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>stretch</code>（默认）：如果项目未设置高度或设为<code>auto</code>，将占满整个容器的高度</li></ul><p><img src="/images/flex-14.jpg" alt></p><p>假设容器高度设置为 50px，而项目都没有设置高度或设为<code>auto</code>的情况下，则项目的高度也为 50px</p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li></ul><p><img src="/images/flex-15.jpg" alt></p><ul><li><code>flex-end</code>：交叉轴的终点对齐</li></ul><p><img src="/images/flex-16.jpg" alt></p><ul><li><code>center</code>：交叉轴的中点对齐</li></ul><p><img src="/images/flex-17.jpg" alt></p><ul><li><code>baseline</code>: 项目的第一行文字的基线对齐</li></ul><p><img src="/images/flex-18.jpg" alt></p><p>以文字的底部为主</p><p><strong>6. align-content: 定义多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: stretch | flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫项目只有一根轴线呢？其实可以这么理解：</p><p>当你 <code>flex-wrap</code> 设置为 <code>nowrap</code> 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p><p>当你 <code>flex-wrap</code> 设置为 <code>wrap</code> 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p><p>建立在主轴为水平方向时测试，即 <code>flex-direction: row</code>, <code>flex-wrap: wrap</code></p><ul><li><code>stretch</code>（默认）：轴线占满整个交叉轴</li></ul><p><img src="/images/flex-19.jpg" alt></p><ul><li><code>flex-start</code>：轴线全部与交叉轴上的起点对齐</li></ul><p><img src="/images/flex-20.jpg" alt></p><ul><li><code>flex-end</code>：轴线全部与交叉轴上的终点对齐</li></ul><p><img src="/images/flex-21.jpg" alt></p><ul><li><code>center</code>：轴线全部在交叉轴上的中间对齐</li></ul><p><img src="/images/flex-22.jpg" alt></p><ul><li><code>space-between</code>：轴线与交叉轴两端对齐，轴线之间的间隔平均分布</li></ul><p><img src="/images/flex-23.jpg" alt></p><ul><li><code>space-around</code>：每个轴线两侧的间隔都相等，所以轴线之间的间隔是轴线与边缘的间隔的两倍</li></ul><p><img src="/images/flex-24.jpg" alt></p><p>到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item（项目） 上的属性。</p><h3 id="Flex-项目上的属性"><a href="#Flex-项目上的属性" class="headerlink" title="Flex 项目上的属性"></a>Flex 项目上的属性</h3><p>item 项目上有六种属性可运用，它们分别是：</p><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><p><strong>1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/flex-25.jpg" alt></p><p><strong>2. flex-grow: 定义项目的放大比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为 0，即如果存在剩余空间，也不放大。</p><p>如果所有项目的 <code>flex-grow</code> 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code>flex-grow</code> 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p><strong>3. flex-shrink: 定义项目的缩小比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><img src="/images/flex-26.jpg" alt></p><p>如果所有项目的 <code>flex-shrink</code> 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code> 属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><p><strong>4. flex-basis: 定义了在分配容器剩余空间之前项目的默认大小。相当于对浏览器提前告知：浏览器兄弟，我要占据这么大的空间，提前帮我预留好</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：<code>auto</code>，即项目本来的大小, 这时候 item 项目的宽高取决于 <code>width</code> 或 <code>height</code> 的值。</p><p>当主轴为水平方向的时候，同时设置 <code>width</code> 和 <code>flex-basis</code>，会忽略 <code>width</code>。flex顾名思义就是弹性的意思，因此，实际上不建议对flex项目使用 <code>width</code> 属性，因为不够弹性。</p><p>当容器剩余空间不足的时候，flex子项目的实际宽度通常不是设置的 <code>flex-basis</code> 尺寸，因为flex布局剩余空间不足的时候默认会收缩，如果有3个子项目，则默认按1:1:1收缩。</p><p><strong>5. flex: flex-grow, flex-shrink 和 flex-basis的复合缩写</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值为<code>0 1 auto</code>。</p><p>有关快捷值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex: auto  //等同于flex:1 1 auto</span><br><span class="line">flex: none  //等同于flex:0 0 auto</span><br></pre></td></tr></table></figure><p><strong>6. align-self: 控制单独某一个项目的垂直对齐方式，与align-items属性语法区别不大</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一区别就是<code>align-self</code>多了个<code>auto</code>（默认值），表示继承自flex容器的<code>align-items</code>属性值，如果没有父元素，则等同于 <code>stretch</code>。</p><p>跟 <code>align-items</code> 其他属性值含义一样，只不过 <code>align-self</code> 是对单个项目生效的，而 <code>align-items</code> 则是对容器下的所有项目生效的。</p><h3 id="从垂直居中看出flex的强大"><a href="#从垂直居中看出flex的强大" class="headerlink" title="从垂直居中看出flex的强大"></a>从垂直居中看出flex的强大</h3><p>以往让元素垂直居中并不容易，直到CSS3的出现，使用绝对定位配合<code>translate</code>属性才让垂直居中变得简单，不过还有一个更爽的办法，那就是使用flex，让垂直居中变得异常简单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“wrapper”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“div”</span>&gt;</span></span><br><span class="line">        flexbox 对你说爱不完</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>几行简单代码，即可让div垂直居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最重要的就是包裹元素的三个关键属性:</p><ul><li><code>display: flex</code> 将容器指定为flex布局，任何一个元素都可以指定</li><li><code>align-items: center</code> 沿交叉轴对齐项目，这里指的是垂直方向</li><li><code>justify-content: center</code> 设置主轴内容对齐方式</li></ul><h3 id="其他Flex知识点"><a href="#其他Flex知识点" class="headerlink" title="其他Flex知识点"></a>其他Flex知识点</h3><ul><li>在Flex布局中，再强调一遍flex子元素中设置<code>float</code>，<code>clear</code>以及<code>vertical-align</code>属性都是没有用的。</li><li>Flexbox布局最适合应用程序的组件和小规模布局（一维布局），而Grid布局则适用于更大规模的布局（二维布局），有关Grid布局的文章后面会补充。</li><li>已经9102年了，Flex老语法不用在管了，果断放弃，然后私有前缀也不用再加了，看到就烦。</li><li>如果想更好地理解Flex的工作原理，可以在此页面上尝试<a href="http://www.csstutorial.org/flex-both.html" target="_blank" rel="noopener">flex 布局编辑器</a>。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flexbox 意为弹性布局，是一种新的CSS 3 布局方式，与传统布局方式(基于盒模型，依赖display属性 +position属性 +float属性)相比，flex布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。
    
    </summary>
    
      <category term="CSS" scheme="https://luozongmin.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://luozongmin.com/tags/CSS/"/>
    
      <category term="布局" scheme="https://luozongmin.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之闭包</title>
    <link href="https://luozongmin.com/2019/07/02/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/"/>
    <id>https://luozongmin.com/2019/07/02/JavaScript系列之闭包(Closure)/</id>
    <published>2019-07-02T14:42:47.913Z</published>
    <updated>2019-07-18T05:05:39.796Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多初学者在学习JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。<a id="more"></a></p><p>在具体介绍闭包之前，为了更好的理解本文要介绍的内容，建议先去阅读前面的文章<a href="https://zhuanlan.zhihu.com/p/69142071" target="_blank" rel="noopener">《JavaScript系列之变量对象》</a>和<a href="https://zhuanlan.zhihu.com/p/69910449" target="_blank" rel="noopener">《JavaScript系列之作用域和作用域链》</a>，因为它们相互之间都是有关联的。</p><h3 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h3><p>首先，先来看看MDN 对闭包的定义：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是一个既不是函数的形参，也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>好，如果上面三行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 不过如果你是初学者的话，我想应该不会，如果仅用三言两语就把闭包讲通，那还能称为Javascript 语言的一个难点吗？</p><p>先来举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p><code>f1</code> 函数可以访问变量 <code>n</code>，但是 <code>n</code> 既不是 <code>f1</code> 函数的形参，也不是 <code>f1</code> 函数的局部变量，所以这种情况下的 <code>n</code> 就是自由变量。其实上面代码中就存在闭包了，即函数 <code>f1</code> + <code>f1</code> 函数访问的自由变量 <code>n</code> 就构成了一个<strong>闭包</strong>。</p><p>上面代码中，函数 <code>f1</code> 可以读取全局自由变量 <code>n</code>。但是，函数外部无法读取函数内部声明的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n)  <span class="comment">// Uncaught ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure><p>如果有时需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过改变形式才能实现。那就是在函数的内部，再定义一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = f1();</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们就可以在<code>f1</code>外部读取它的内部变量了。</p><p>所以<strong>闭包是一个可以从另一个函数的作用域访问变量的函数。这是通过在函数内创建函数来实现的。当然，外部函数无法访问内部范围</strong>。</p><p>在我们深入研究闭包之前，有必要先从不使用闭包的情况切入，了解为什么要用闭包。</p><h3 id="不使用闭包的情况"><a href="#不使用闭包的情况" class="headerlink" title="不使用闭包的情况"></a>不使用闭包的情况</h3><p>在JavaScript 中，全局变量的错用可能会使得我们的代码出现不可预期的错误。</p><p>假设我们现在要做一个计数的函数，一开始我们想要先写一个给狗的计数函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗的计数函数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(count + <span class="string">' dog(s)'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// 1 dog(s)</span></span><br><span class="line">countDogs()    <span class="comment">// 2 dog(s)</span></span><br><span class="line">countDogs()    <span class="comment">// 3 dog(s)</span></span><br></pre></td></tr></table></figure><p>接着继续写代码的其他部分，当写到后面时，我发现我也需要写猫的计数函数，于是我又开始写了猫的计数函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗的计数函数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(count + <span class="string">' dog(s)'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间的其它代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫的计数函数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countCats</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(count + <span class="string">' cat(s)'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countCats()    <span class="comment">// 1 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 2 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 3 cat(s)</span></span><br></pre></td></tr></table></figure><p>乍看之下好像没啥问题，当我执行<code>countDogs()</code>或<code>countCats()</code>，都会让<code>count</code>增加，然而问题在于当我在不注意的情况下把<code>count</code>这个变量建立在了全局作用域底下时，不论是执行<code>countDogs()</code>或是<code>countCats()</code>时，都是用到了全局的<code>count</code>变量，这使得当我执行下面的代码时，它没有办法分辨现在到底是在对狗计数还是对猫计数，进而导致把猫的数量和狗的数量交错计算的错误情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">countCats()    <span class="comment">// 1 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 2 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 3 cat(s)</span></span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// 4 dog(s)，我希望是 1 dog(s)</span></span><br><span class="line">countDogs()    <span class="comment">// 5 dog(s)，我希望是 2 dog(s)</span></span><br><span class="line"></span><br><span class="line">countCats()    <span class="comment">// 6 cat(s)，我希望是 4 cat(s)</span></span><br></pre></td></tr></table></figure><h3 id="闭包让函数有私有变量"><a href="#闭包让函数有私有变量" class="headerlink" title="闭包让函数有私有变量"></a>闭包让函数有私有变量</h3><p>从上面的例子我们知道，如果错误的使用全局变量，很容易会出现一些莫名其妙的bug ，这时候我们就可以利用闭包（closure）的写法，让函数有自己私有变量，简单来说就是<code>countDogs</code>里面能有一个计算<code>dogs</code>的<code>count</code>变数；而<code>countCats</code>里面也能有一个计算<code>cats</code>的<code>count</code>变量，两者是不会互相干扰的。</p><p>为了达到这样的效果，我们就要利用闭包，让变量保留在该函数中而不会被外在环境干扰。</p><p>改成闭包的写法会像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countDogs = dogHouse()</span><br><span class="line">countDogs()    <span class="comment">// "1 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "2 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "3 dogs"</span></span><br></pre></td></tr></table></figure><p>这样我们就将专门计算狗的变量<code>count</code>闭包在<code>dogHouse</code>这个函数中，在<code>dogHouse</code>这个函数中里面的<code>countDogs()</code>才是我们真正执行计数的函数，而在<code>dogHouse</code>这个函数中存在<code>count</code>这个变量，由于JavaScript变量会被缩限在函数的执行上下文中，因此这个<code>count</code>的值只有在<code>dogHouse</code>里面才能被取用，在<code>dogHouse</code>函数外是取用不到这个值的。</p><p>接着因为我们要能够执行在<code>dogHouse</code>中真正核心<code>countDogs()</code>这个函数，因此我们会在最后把这个函数给return出来，好让我们可以在外面去调用到<code>dogHouse</code>里面的这个<code>countDogs()</code>函数。</p><p>最后当我们在使用闭包时，我们先把存在<code>dogHouse</code>里面的<code>countDogs</code>拿出来用，并一样命名为<code>countDogs</code>（这里变量名称可以自己取），因此当我执行全局中的<code>countDogs</code>时，实际上会执行的是<code>dogHouse</code>里面的<code>countDogs</code>函数。</p><p>上面这是闭包的基本写法：<strong>一个函数里面包了另一个函数，同时会 return 里面的函数让我们可以在外面使用到它</strong>。</p><p>我们可以把我们最一开始的代码都改成使用闭包的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countCats</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' cats'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countCats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countDogs = dogHouse()</span><br><span class="line"><span class="keyword">const</span> countCats = catHouse()</span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// "1 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "2 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "3 dogs"</span></span><br><span class="line"></span><br><span class="line">countCats()    <span class="comment">// "1 cats"</span></span><br><span class="line">countCats()    <span class="comment">// "2 cats"</span></span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// "4 dogs"</span></span><br></pre></td></tr></table></figure><p>当我们正确地使用闭包时，虽然一样都是使用<code>count</code>来计数，但是是在不同执行环境内的<code>count</code>因此也不会相互干扰。</p><h3 id="进一步了解和使用闭包"><a href="#进一步了解和使用闭包" class="headerlink" title="进一步了解和使用闭包"></a>进一步了解和使用闭包</h3><p>另外，甚至在运用的是同一个<code>dogHouse</code> 时，变量间也都是独立的执行环境不会干扰，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然都是使用 dogHouse ，但是各是不同的执行环境</span></span><br><span class="line"><span class="comment">// 因此彼此的变量不会互相干扰</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> countGolden = dogHouse()</span><br><span class="line"><span class="keyword">var</span> countPug = dogHouse()</span><br><span class="line"><span class="keyword">var</span> countPuppy = dogHouse()</span><br><span class="line"></span><br><span class="line">countGolden()     <span class="comment">// 1 dogs</span></span><br><span class="line">countGolden()     <span class="comment">// 2 dogs</span></span><br><span class="line"></span><br><span class="line">countPug()        <span class="comment">// 1 dogs</span></span><br><span class="line">countPuppy()      <span class="comment">// 1 dogs</span></span><br><span class="line"></span><br><span class="line">countGolden()     <span class="comment">// 3 dogs</span></span><br><span class="line">countPug()        <span class="comment">// 2 dogs</span></span><br></pre></td></tr></table></figure><h3 id="将参数代入闭包中"><a href="#将参数代入闭包中" class="headerlink" title="将参数代入闭包中"></a>将参数代入闭包中</h3><p>但是这么做的话你可能觉得还不够清楚，因为都是叫做<code>dogs</code>，这时候我们一样可以把外面的变量通过函数的参数代入闭包中，像是下面这样，返回的结果就清楚多了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过函数的参数将值代入闭包中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样是使用 dogHouse 但是使用不同的参数</span></span><br><span class="line"><span class="keyword">var</span> countGolden = dogHouse(<span class="string">'Golden'</span>)</span><br><span class="line"><span class="keyword">var</span> countPug = dogHouse(<span class="string">'Pug'</span>)</span><br><span class="line"><span class="keyword">var</span> countPuppy = dogHouse(<span class="string">'Puppy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果看起来更清楚了</span></span><br><span class="line">countGolden()     <span class="comment">// 1 Golden</span></span><br><span class="line">countGolden()     <span class="comment">// 2 Golden</span></span><br><span class="line"></span><br><span class="line">countPug()        <span class="comment">// 1 Pug</span></span><br><span class="line">countPuppy()      <span class="comment">// 1 Puppy</span></span><br><span class="line"></span><br><span class="line">countGolden()     <span class="comment">// 3 Golden</span></span><br><span class="line">countPug()        <span class="comment">// 2 Pug</span></span><br></pre></td></tr></table></figure><p>为了进一步简化代码，我们可以在闭包中直接return一个函数出来，我们就可以不必为里面的函数命名了，而是用匿名函数的方式直接把它返回出来。</p><p>因此写法可以简化成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 把原本 countDogs 函数改成匿名函数直接放进来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 把原本 countCats 函数改成匿名函数直接放进来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' cats'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们刚刚有提到，可以透过函数参数的方式把值代入闭包当中，因此实际上我们只需要一个counter ，在不同的时间点给它参数区分就好。这样子不管你是要记录哪一种动物都很方便了，而且代码也相当简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCounter</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dogCounter = createCounter(<span class="string">'dogs'</span>)</span><br><span class="line"><span class="keyword">const</span> catCounter = createCounter(<span class="string">'cats'</span>)</span><br><span class="line"><span class="keyword">const</span> pigCounter = createCounter(<span class="string">'pigs'</span>)</span><br><span class="line"></span><br><span class="line">dogCounter()     <span class="comment">// 1 dogs</span></span><br><span class="line">dogCounter()     <span class="comment">// 2 dogs</span></span><br><span class="line">catCounter()     <span class="comment">// 1 cats</span></span><br><span class="line">catCounter()     <span class="comment">// 2 cats</span></span><br><span class="line">pigCounter()     <span class="comment">// 1 pigs</span></span><br><span class="line">dogCounter()     <span class="comment">// 3 dogs</span></span><br><span class="line">catCounter()     <span class="comment">// 3 cats</span></span><br></pre></td></tr></table></figure><h3 id="闭包的实际应用"><a href="#闭包的实际应用" class="headerlink" title="闭包的实际应用"></a>闭包的实际应用</h3><p>我们要实现这样的一个需求：点击某个按钮，提示点击的是”第n个”按钮，此处我们先不用事件代理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">&lt;button&gt;测试<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button&gt;测试2&lt;/</span>button&gt;</span><br><span class="line">&lt;button&gt;测试<span class="number">3</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">   var buttons = document.getElementsByTagName('button')</span></span><br><span class="line"><span class="string">    for (var i = 0; i &lt; buttons.length; i++) &#123;</span></span><br><span class="line"><span class="string">      buttons[i].onclick = function () &#123;</span></span><br><span class="line"><span class="string">        console.log('第' + (i + 1) + '个')</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>这时候可能会预期点选不同的按钮时，会根据每个button 点击顺序的不同而得到不同的结果。但是实际执行后，你会发现返回的结果都是“第四个”。这是因为<code>i</code>是全局变量，执行到点击事件时，此时<code>i</code>的值为3。</p><p>如果要强制返回预期的结果，那该如何修改呢？最简单的是用<code>let</code>声明<code>i</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">    buttons[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第'</span> + (i + <span class="number">1</span>) + <span class="string">'个'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，通过<code>let</code>可以帮我们把所定义的变量缩限在块级作用域中，也就是变量的作用域只有在<code>{ }</code>内，来避免 <code>i</code> 这个变量跑到全局变量被重复覆盖。</p><p>另外我们可以通过闭包的方式来修改:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        buttons[j].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'第'</span> + (j + <span class="number">1</span>) + <span class="string">'个'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实也是「立即执行函数表达式 (Immediately Invoked Function Expression, IIFE)」的概念，后续会有专门的文章进行介绍。</p><p>希望看完这篇文章后，你能对于闭包有更清楚的认识。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多初学者在学习JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="闭包" scheme="https://luozongmin.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之this是什么</title>
    <link href="https://luozongmin.com/2019/07/01/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8Bthis%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://luozongmin.com/2019/07/01/JavaScript系列之this是什么/</id>
    <published>2019-07-01T06:45:02.144Z</published>
    <updated>2019-07-03T00:44:03.849Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://zhuanlan.zhihu.com/p/69910449" target="_blank" rel="noopener">《JavaScript系列之作用域和作用域链》</a>中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。<a id="more"></a></p><p>再来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain-1.jpg" alt></p><p>本章将专门介绍与执行上下文创建阶段直接相关的最后一个细节——<strong>this</strong>是什么？以及它的指向到底是什么。</p><h3 id="了解this"><a href="#了解this" class="headerlink" title="了解this"></a>了解this</h3><p>也许你在其他面向对象的编程语言曾经看过<code>this</code>，也知道它会指向某个构造器(constructor)所建立的对象。但事实上在JavaScript里面，<code>this</code>所代表的不仅仅是那个被建立的对象。</p><p>先来看看ECMAScript 标准规范对this 的定义：</p><blockquote><p>「The this keyword evaluates to the value of the ThisBinding of the current execution context.」<br>「this 这个关键字代表的值为当前执行上下文的ThisBinding。」</p></blockquote><p>然后再来看看MDN 对this 的定义：</p><blockquote><p>「In most cases, the value of this is determined by how a function is called.」<br>「在大多数的情况下，this 其值取决于函数的调用方式。」</p></blockquote><p>好，如果上面两行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 我想应该不会，至少我光看这两行还是不懂。</p><p>先来看个例子吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> people1.gender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people1 = &#123;</span><br><span class="line">    gender: <span class="string">'female'</span>,</span><br><span class="line">    getGender: getGender</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people2 = &#123;</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    getGender: getGender</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(people1.getGender());    <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(people2.getGender());    <span class="comment">// female</span></span><br></pre></td></tr></table></figure><p>what?怎么<code>people2</code>变性了呢，这不是我想要的结果啊，为什么呢？</p><p>因为<code>getGender()</code>返回(return)写死了<code>people1.gender</code>的关系，结果自然是’female’。</p><p>那么，如果我们把<code>getGender</code>稍改一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gender;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个时候，你应该会分别得到<code>female</code>与<code>male</code>两种结果。</p><p>所以回到前面讲的重点，从这个例子可以看出，即便<code>people1</code>与<code>people2</code>的<code>getGender</code>方法参照的都是同一个<code>getGender function</code>，但由于调用的对象不同，所以执行的结果也会不同。</p><p>现在我们知道了第一个重点，<strong><code>this</code>实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数的调用方式</strong>。如何的区分<code>this</code>呢？</p><h3 id="this到底是谁"><a href="#this到底是谁" class="headerlink" title="this到底是谁"></a>this到底是谁</h3><p>看完上面的例子，还是有点似懂非懂吧？那接下来我们来看看不同的调用方式对 <code>this</code> 值的影响。</p><h4 id="情况一：全局对象-amp-调用普通函数"><a href="#情况一：全局对象-amp-调用普通函数" class="headerlink" title="情况一：全局对象&amp;调用普通函数"></a>情况一：全局对象&amp;调用普通函数</h4><p>在全局环境中，<code>this</code> 指向全局对象，在浏览器中，它就是 <code>window</code> 对象。下面的示例中，无论是否是在严格模式下，<code>this</code> 都是指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x)               <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x === x)         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>)      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果普通函数是在全局环境中被调用，在非严格模式下，普通函数中 <code>this</code> 也指向全局对象；如果是在严格模式下，<code>this</code> 将会是 <code>undefined</code>。ES5 为了使 JavaScript 运行在更有限制性的环境而添加了严格模式，严格模式为了消除安全隐患，禁止了 <code>this</code> 关键字指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Window 全局对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>使用严格模式后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>     <span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);  <span class="comment">// 报错 "Cannot read property 'x' of undefined"，因为此时 this 是 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h4 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h4><p>我们知道，在对象里的值如果是原生值（primitive type；例如，字符串、数值、布尔值），我们会把这个新建立的东西称为「<strong>属性（property）</strong>」；如果对象里面的值是函数（function）的话，我们则会把这个新建立的东西称为「<strong>方法（method）</strong>」。</p><p>如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，<strong>函数中的<code>this</code>指向这个上一级对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">2</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()     </span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.fn()结果打印出;</span></span><br><span class="line"><span class="comment">// Object &#123;x: 2, fn: function&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = obj.fn</span><br><span class="line">a()   </span><br><span class="line"></span><br><span class="line"><span class="comment">// a()结果打印出:   </span></span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，直接运行 <code>obj.fn()</code> ，调用该函数的上一级对象是 <code>obj</code>，所以 <code>this</code> 指向 <code>obj</code>，得到 <code>this.x</code> 的值是 2；之后我们将 <code>fn</code> 方法首先赋值给变量 <code>a</code>，<code>a</code> 运行在全局环境中，所以此时 <code>this</code> 指向全局对象<code>Window</code>，得到 <code>this.x</code> 为 1。</p><p>我们再来看一个例子，如果函数被多个对象嵌套调用，this 会指向什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: &#123;</span><br><span class="line">    x: <span class="number">3</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;x: 3, fn: function&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y.fn();</span><br></pre></td></tr></table></figure><p>为什么结果不是 2 呢，因为在这种情况下记住一句话：<strong><code>this</code> 始终会指向直接调用函数的上一级对象</strong>，即 <code>y</code>，上面例子实际执行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;x: 3, fn: function&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y.fn();</span><br></pre></td></tr></table></figure><p>对象可以嵌套，函数也可以，如果函数嵌套，<code>this</code> 会有变化吗？我们通过下面代码来探讨一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    y: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line">        fn();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Window 全局对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y();</span><br></pre></td></tr></table></figure><p>在函数 <code>y</code> 中，<code>this</code> 指向了调用它的上一级对象 <code>obj</code>，这是没有问题的。但是在嵌套函数 <code>fn</code> 中，<code>this</code> 并不指向 <code>obj</code>。嵌套的函数不会从调用它的函数中继承 <code>this</code>，当嵌套函数作为函数调用时，其 <code>this</code> 值在非严格模式下指向全局对象，在严格模式是 <code>undefined</code>，所以上面例子实际执行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Window 全局对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    y: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y();</span><br></pre></td></tr></table></figure><h4 id="情况三：作为构造函数调用"><a href="#情况三：作为构造函数调用" class="headerlink" title="情况三：作为构造函数调用"></a>情况三：作为构造函数调用</h4><p>我们可以使用 <code>new</code> 关键字，通过构造函数生成一个实例对象。此时，<strong><code>this</code> 便指向这个新对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　  <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Fn &#123;x: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Fn();   <span class="comment">// obj和Fn(..)调用中的this进行绑定</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.x)   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用<code>new</code>来调用<code>Fn(..)</code>时，会构造一个新对象并把它（<code>obj</code>）绑定到<code>Fn(..)</code>调用中的<code>this</code>。还有值得一提的是，如果构造函数返回了非引用类型（<code>string</code>，<code>number</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>），<code>this</code> 仍然指向实例化的新对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x)      <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>因为<code>Fn()</code>返回(return)的是一个对象（引用类型），<code>this</code> 会指向这个return的对象。如果return的是一个非引用类型的值呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x)      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="情况四：call-和-apply-方法调用"><a href="#情况四：call-和-apply-方法调用" class="headerlink" title="情况四：call 和 apply 方法调用"></a>情况四：call 和 apply 方法调用</h4><p>如果你想改变 <code>this</code> 的指向，可以使用 <code>call</code> 或 <code>apply</code> 方法。<strong>它们的第一个参数都是指定函数运行时其中的<code>this</code>指向</strong>。如果第一个参数不传（参数为空）或者传 <code>null</code> 、<code>undefined</code>，默认 <code>this</code> 指向全局对象（非严格模式）或 <code>undefined</code>（严格模式）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj)</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">fn.apply(obj)     </span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">fn.call()         </span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">fn.apply(<span class="literal">null</span>)    </span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">fn.call(<span class="literal">undefined</span>)    </span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>使用 <code>call</code> 和 <code>apply</code> 时，如果给 <code>this</code> 传的不是对象，JavaScript 会使用相关构造函数将其转化为对象，比如传 <code>number</code> 类型，会进行<code>new Number()</code>操作，如传 <code>string</code> 类型，会进行<code>new String()</code>操作，如传 <code>boolean</code> 类型，会进行<code>new Boolean()</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(<span class="string">'love'</span>)      <span class="comment">// [object String]</span></span><br><span class="line">fn.apply(<span class="number">1</span>)          <span class="comment">// [object Number]</span></span><br><span class="line">fn.call(<span class="literal">true</span>)          <span class="comment">// [object Boolean]</span></span><br></pre></td></tr></table></figure><p><code>call</code> 和 <code>apply</code> 的区别在于，<code>call</code> 的第二个及后续参数是一个参数列表，<code>apply</code> 的第二个参数是数组。参数列表和参数数组都将作为函数的参数进行执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span>(<span class="params">y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sum.call(obj, <span class="number">3</span>, <span class="number">4</span>)       <span class="comment">// 9</span></span><br><span class="line">Sum.apply(obj, [<span class="number">3</span>, <span class="number">4</span>])    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h4 id="情况五：bind-方法调用"><a href="#情况五：bind-方法调用" class="headerlink" title="情况五：bind 方法调用"></a>情况五：bind 方法调用</h4><p>调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，新函数的 <code>this</code> <strong>会永久的指向 <code>bind</code> 传入的第一个参数</strong>，无论这个函数是如何被调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    x: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fn.bind(obj1);</span><br><span class="line"><span class="keyword">var</span> b = a.bind(obj2);</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">a.call(obj2);</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，虽然我们尝试给函数 <code>a</code> 重新指定 <code>this</code> 的指向，但是它依旧指向第一次 <code>bind</code> 传入的对象，即使是使用 <code>call</code> 或 <code>apply</code> 方法也不能改变这一事实，即永久的指向 <code>bind</code> 传入的第一次参数。</p><h4 id="情况六：箭头函数中this指向"><a href="#情况六：箭头函数中this指向" class="headerlink" title="情况六：箭头函数中this指向"></a>情况六：箭头函数中this指向</h4><p>值得一提的是，从ES6 开始新增了箭头函数，先来看看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">MDN 上对箭头函数的说明</a>：</p><blockquote><p>An arrow function expression has a shorter syntax than a function expression and does notbind its own <code>this</code>,<code>arguments</code>,<code>super</code>, or <code>new.target</code>. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors.</p></blockquote><p>这里已经清楚了说明了，箭头函数没有自己的<code>this</code>绑定。<strong>箭头函数中使用的<code>this</code>，其实是直接包含它的那个函数或函数表达式中的<code>this</code></strong>。在前面情况二中函数嵌套函数的例子中，被嵌套的函数不会继承上层函数的 <code>this</code>，如果使用箭头函数，会发生什么变化呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y()</span><br></pre></td></tr></table></figure><p>和普通函数不一样，箭头函数中的 <code>this</code> 指向了 <code>obj</code>，这是因为它从上一层的函数中继承了 <code>this</code>，你可以理解为箭头函数修正了 <code>this</code> 的指向。所以<strong>箭头函数的<code>this</code>不是调用的时候决定的，而是在定义的时候处在的对象就是它的<code>this</code></strong>。</p><p>换句话说，箭头函数的<code>this</code>看外层的是否有函数，如果有，外层函数的<code>this</code>就是内部箭头函数的<code>this</code>，如果没有，则<code>this</code>是<code>Window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  y: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Window 全局对象 </span></span><br><span class="line">       </span><br><span class="line">      <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Window 全局对象 </span></span><br><span class="line">      &#125;</span><br><span class="line">      fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y()</span><br></pre></td></tr></table></figure><p>上例中，虽然存在两个箭头函数，其实<code>this</code>取决于最外层的箭头函数，由于<code>obj</code>是个对象而非函数，所以<code>this</code>指向为<code>Window</code>全局对象。</p><p>同 bind 一样，箭头函数也很“顽固”，我们无法通过 <code>call</code> 和 <code>apply</code> 来改变 <code>this</code> 的指向，即传入的第一个参数被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call(obj)       </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"></span><br><span class="line">a.apply(obj)      </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇文章介绍了 <code>this</code> 指向的几种情况，不同的运行环境和调用方式都会对 <code>this</code> 产生影响。总的来说，函数 <code>this</code> 的指向取决于当前调用该函数的对象，也就是执行时的对象。在这一节中，你需要掌握：</p><ul><li><code>this</code> 指向全局对象的情况；</li><li>严格模式和非严格模式下 <code>this</code> 的区别；</li><li>函数作为对象的方法调用时 <code>this</code> 指向的几种情况；</li><li>作为构造函数时 <code>this</code> 的指向，以及是否 <code>return</code> 的区别；</li><li>使用 <code>call</code> 和 <code>apply</code> 改变调用函数的对象；</li><li><code>bind</code> 创建的函数中 <code>this</code> 的指向；</li><li>箭头函数中的 <code>this</code> 指向。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69910449&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JavaScript系列之作用域和作用域链》&lt;/a&gt;中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="this" scheme="https://luozongmin.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>贵州黔东南之行</title>
    <link href="https://luozongmin.com/2019/06/30/%E8%B4%B5%E5%B7%9E%E9%BB%94%E4%B8%9C%E5%8D%97%E4%B9%8B%E8%A1%8C/"/>
    <id>https://luozongmin.com/2019/06/30/贵州黔东南之行/</id>
    <published>2019-06-30T08:30:31.565Z</published>
    <updated>2019-07-01T07:55:07.358Z</updated>
    
    <content type="html"><![CDATA[<p>2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。<a id="more"></a></p><h4 id="镇远古镇"><a href="#镇远古镇" class="headerlink" title="镇远古镇"></a>镇远古镇</h4><p>第一站来到镇远古镇，路上听导游说这里还是一位皇帝的故乡呢！哈哈~当然不是古代的皇帝啦，其实是延禧攻略里面皇帝扮演者聂远的故乡啦😜。</p><p>我们到古城的时间也接近傍晚了，吃完晚饭散步在古城河边，天空中飘着乌云，真有一种“天青色等烟雨”的既视感了。</p><p><img src="/images/zhengyuan-1.jpg" alt></p><p><img src="/images/zhengyuan-2.jpg" alt></p><p><img src="/images/zhengyuan-3.jpg" alt></p><p>河边坐落了许多充满文艺的小店和清吧。</p><p><img src="/images/zhengyuan-4.jpg" alt></p><p>晚上的镇远古镇，虽说夜景和去过的其它几个古镇有些相似，但镇远独特之处在于宁静，有一种与世无争的感觉。</p><p><img src="/images/zhengyuan-5.jpg" alt></p><p><img src="/images/zhengyuan-6.jpg" alt></p><p>在镇远古镇悠悠闲闲的一天里，给我最大的感受还是来自于它的静，很静，很舒服。</p><h4 id="西江千户苗寨"><a href="#西江千户苗寨" class="headerlink" title="西江千户苗寨"></a>西江千户苗寨</h4><p>第二站到达的西江千户苗寨，号称世界上最大的苗寨，一眼望去全是木质结构的屋子，层层叠叠错落有致。</p><p><img src="/images/miaozhai-1.jpg" alt></p><p><img src="/images/miaozhai-2.jpg" alt></p><p>在苗寨里面瞎逛的途中遇到了当地苗族朋友的游行表演。</p><p><img src="/images/miaozhai-3.jpg" alt></p><p>来千户苗寨当然不能错过来自苗族朋友的热情，热情之一就是宴席上的“高山流水”，其实就是灌客人们喝甜甜的米酒，自知酒量不行，仪式开始之前就躲得远远的了哈哈，同桌几个男的就被灌了😄。</p><p><img src="/images/miaozhai-4.jpg" alt></p><p>因为苗寨难得遇到断电，“幸运地”被我们给遇上了，晚上只好回州府凯里住了，晚饭刚好感受了侗族形式的“高山流水”以及侗族的歌舞表演，表演倒是没啥好看的，不过有几个侗族小姐姐还是比较好看的~哈哈不知道她能不能看到，看到的话感觉会被打屎哦😥~</p><p><img src="/images/dongzu-1.jpg" alt></p><p><img src="/images/dongzu-2.jpg" alt></p><h4 id="高要梯田"><a href="#高要梯田" class="headerlink" title="高要梯田"></a>高要梯田</h4><p>第三站抵达高要梯田，高要的梯田虽没有像广西龙胜、云南元阳被外界所熟知，但其美景完全不逊于前者，可惜不是金秋时节来，不然景色应该会更美。</p><p><img src="/images/titian-1.jpg" alt></p><p><img src="/images/titian-2.jpg" alt></p><p>总体来说，此次贵州之行还是很轻松的，可惜的是没时间去到黄果树，希望下次再带她一起来哦~嘻嘻🤭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。
    
    </summary>
    
      <category term="游记" scheme="https://luozongmin.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="贵州" scheme="https://luozongmin.com/tags/%E8%B4%B5%E5%B7%9E/"/>
    
      <category term="游记" scheme="https://luozongmin.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之作用域和作用域链</title>
    <link href="https://luozongmin.com/2019/06/28/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>https://luozongmin.com/2019/06/28/JavaScript系列之作用域和作用域链/</id>
    <published>2019-06-28T11:53:24.965Z</published>
    <updated>2019-06-29T07:49:51.043Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://zhuanlan.zhihu.com/p/69142071" target="_blank" rel="noopener">《JavaScript系列之变量对象》</a>中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。<a id="more"></a></p><p>此外，我们也知道每次进入上下文时都会创建变量对象并填充初始值，并且值会在代码执行阶段进行更新，现在就对执行上下文做更深一步的了解。</p><p>先来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain-1.jpg" alt></p><p>本章将专门介绍与执行上下文创建阶段直接相关的另一个细节——<strong>作用域链</strong>。</p><h3 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h3><p>在介绍作用域链前，有必要先来了解一下被称为作用域(Scope)的特性，那什么是作用域呢？</p><p>作用域就是在运行时代码中不同部分中函数和变量的可访问性。可能这句话并不太好理解，我们先来看段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">"inner variable"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(inVariable); <span class="comment">// inner variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); </span><br><span class="line"><span class="built_in">console</span>.log(inVariable); <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以很直观地体会作用域的概念，变量<code>inVariable</code>在全局作用域没有声明，所以在全局作用域下直接取值会报错。所以我们可以这样理解：<strong>作用域就像一个地头蛇，我的地盘我做主，让属于自己域内的变量不会轻易外泄出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong>。这几句话总比前面那句好理解多了吧。</p><p>关于JavaScript 中的作用域类型，<strong>ES6 之前 JavaScript 并没有块级作用域，只有全局作用域和函数作用域</strong>。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现：</p><ul><li>全局作用域 — 变量可以随处访问</li><li>函数作用域— 变量可以在定义它们的函数的边界内访问</li><li>块级作用域—变量可以在定义它们的块中访问，块由 { 和 } 分隔</li></ul><h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> global = <span class="string">'global scoped'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> global = <span class="string">'function scoped'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(global); <span class="comment">// function scoped</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(global); <span class="comment">// global scoped</span></span><br></pre></td></tr></table></figure><p>从上面例子可以看出全局作用域和函数作用域的作用范围，即使全局变量在函数内部分配了不同的值，它也只保留在同一函数的边界内，互相并不影响，我们也不会因使用相同的变量名而出错。再来看个例子加深理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> global = <span class="string">'global scoped'</span></span><br><span class="line"><span class="keyword">const</span> anotherGlobal = <span class="string">'also global scoped'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> global = <span class="string">'function scoped'</span></span><br><span class="line">    <span class="built_in">console</span>.log(global) <span class="comment">// function scoped</span></span><br><span class="line">    <span class="keyword">const</span> scoped = <span class="string">'also function scoped'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(scoped); <span class="comment">// also function scoped</span></span><br><span class="line">        <span class="built_in">console</span>.log(anotherGlobal) <span class="comment">// also global scoped</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(global); <span class="comment">// global scoped</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherGlobal); <span class="comment">// also global scoped</span></span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line">inner(); <span class="comment">// Uncaught ReferenceError: inner is not defined</span></span><br></pre></td></tr></table></figure><p>在这里我们可以看到 <code>inner()</code> 函数可以访问在其父函数中声明的变量—<code>fn()</code>。每当我们需要函数内部的变量时，引擎将首先在当前函数作用域内查找它。如果它没有当前函数作用域内找到它，它将继续上升，向上一级查找，直到它找到全局作用域内的变量，如果找不到变量，我们将得到一个ReferenceError。格外注意<strong>函数内层作用域可以访问外层作用域的变量，反之则不行</strong>。</p><p>除了上面所讲的最外层函数外面定义的变量拥有全局作用域，全局作用域还有一种特殊的出现场合：就是<strong>所有末声明直接赋值的变量将自动声明为拥有全局作用域的变量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    variable = <span class="string">"undeclared variable"</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">"inner variable"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(variable); <span class="comment">// undeclared variable</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable); <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br></pre></td></tr></table></figure><p>全局作用域有个弊端：如果我们写了很多行 JavaScript 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中，这样就会污染全局命名空间，容易引起命名冲突。同时意外的全局变量还会引起内存泄漏，所以在编程时，尽量避免全局变量的使用，以便后期更快地调试。</p><p>还有值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 <code>if</code> 和 <code>switch</code> 条件语句或 <code>for</code> 和 <code>while</code> 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 'if' 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'miqilin'</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// miqilin</span></span><br></pre></td></tr></table></figure><p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致bug出现 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在ES6中，我们得到了两个新的变量声明关键字 - <code>let</code>和<code>const</code>。它们和<code>var</code>之间的主要区别在于，使用ES6关键字声明的变量是块作用域，这意味着它们仅在它们定义的代码块中可用。块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p><code>let</code> 声明的语法与 <code>var</code> 的语法一致。你基本上可以用 <code>let</code> 来代替 <code>var</code> 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li><strong>声明变量不会提升到代码块顶部</strong></li></ul><p><code>let</code>/<code>const</code>创建的变量不会像使用<code>var</code>声明的变量那样被提升到顶部，因此你需要手动将 <code>let</code>/<code>const</code> 声明放置到顶部，以便让变量在整个代码块内部可用。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosole.log(name); <span class="comment">// Uncaught ReferenceError: cosole is not defined</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">"miqilin"</span>;</span><br></pre></td></tr></table></figure><p>所以确保代码没有引用错误的一种方法是确保只使用<code>let</code>和<code>const</code>进行变量声明。</p><ul><li><strong>禁止重复声明</strong></li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符再进行 <code>let</code> 声明就会抛出错误。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'count' has already been declared</span></span><br></pre></td></tr></table></figure><p>上面例子中<code>count</code> 变量被前后声明了两次：第一次使用 <code>var</code> ，另一次使用 <code>let</code> 。因为 <code>let</code> 不能在同一作用域内重复声明一个已有标识符，此处的 <code>let</code> 声明就会抛出错误。但如果在嵌套的作用域内使用 <code>let</code> 声明一个同名的新变量，则不会抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>循环中的绑定块作用域的妙用</strong></li></ul><p>开发者可能最希望实现<code>for</code>循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为用<code>let</code>声明计数器<code>i</code>，只在<code>for</code>循环体内有效，所以在循环体外引用就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果换使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码正确运行，输出了 5 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><h3 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h3><p>上面用一大篇幅来讲解作用域，其实在里面就有涉及到作用域链的知识了。简单的来说，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做<strong>作用域链</strong>。看下面一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line">a(); <span class="comment">// 2</span></span><br><span class="line">b(); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><p>最后加以执行<code>a()</code>和<code>b()</code>，这时候我们会发现两件事：</p><p>1.执行<code>a()</code>会得到2的结果：之所以会有这样的结果，是因为当我们执行<code>function a</code>里面的<code>function b</code>时，因为在<code>function b</code>里面它找不到<code>myVar</code>这个变量，因此它开始往它的外层去搜寻，而这时候它的父级作用域是<code>function a</code>，在<code>function a</code>里面它便找到了<code>myVar = 2</code>，因此它就不再往外部环境 (<code>myVar = 1</code>)去找了，直接返回了2这样的结果。</p><p>2.<code>b()</code>会得到<code>b is not defined</code>的结果：之所以<code>b</code>会是<code>not defined</code>（记得是<code>not defined</code>不是<code>undefined</code>哦！)，是因为这时候在最外层的全局上下文（<code>global execution context</code>）中，找不到<code>function b</code>。</p><p>而从<code>b() --&gt; a() --&gt; global execution context</code>这样的链，就称为<strong>作用域链（Scope Chain）</strong>：</p><p><img src="/images/scopechain-2.jpg" alt></p><p>如果我们把<code>function a</code>里面对于<code>myVar</code>的声明拿掉的话，它才会继续往外层搜寻<code>myVar</code>，直到找到全局作用域中的声明<code>myVar = 1</code>，这时候才会返回1的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var myVar = 2;</span></span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line">a(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如果我们更进一步的把全局作用域中，对于<code>myVar</code>的声明也拿掉，那么现在在全局作用域中也找不到<code>myVar</code>这个变量了，也就是说，在这整个作用域链中都找不到<code>myVar</code>，因此可想而知，最后的结果是<code>not defined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var myVar = 2;</span></span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var myVar = 1;</span></span><br><span class="line">a(); <span class="comment">// Uncaught ReferenceError: myVar is not defined</span></span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69142071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JavaScript系列之变量对象》&lt;/a&gt;中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Scope" scheme="https://luozongmin.com/tags/Scope/"/>
    
      <category term="Scope Chain" scheme="https://luozongmin.com/tags/Scope-Chain/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之变量对象</title>
    <link href="https://luozongmin.com/2019/06/19/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://luozongmin.com/2019/06/19/JavaScript系列之变量对象/</id>
    <published>2019-06-19T11:15:13.526Z</published>
    <updated>2019-06-29T07:55:21.941Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇<a href="https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">《JavaScript系列之执行上下文和执行栈》</a>，通过对变量对象(Variable Object)的介绍对执行上下文有一个更深一步的了解。<a id="more"></a></p><p>上一篇文章也提到了，一个执行上下文的生命周期可以分为三个阶段：</p><p><img src="/images/scopechain-1.jpg" alt></p><p>详细了解执行上下文对于初学者来说极为重要，因为其中涉及到了变量对象，作用域链，this等很多JavaScript初学者没完全搞懂，且极为重要的概念，它关系到我们能不能真正理解JavaScript，真正理解也能更为轻松地胜任后续工作，在后面的文章中我们会一一详细介绍，这里我们先重点了解一下<strong>变量对象</strong>。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>变量对象（Variable Object）是一个与执行上下文相关的数据作用域，存储了在上下文中定义的<strong>变量</strong>和<strong>函数声明</strong>，先来看一段代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;     </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);   <span class="comment">// function b()&#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(c);   <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>foo（）</code>函数的变量对象包含<strong>变量<code>a</code></strong>和<strong>函数<code>b（）</code>的声明</strong>。这里要注意的一点是，函数表达式并不像函数声明一样包含在变量对象中，在示例中所看到的那样，访问c（）函数会导致引用错误。因为变量对象是抽象的和特殊的，它不能在代码中访问，但会由JavaScript引擎处理。</p><p>上面利用的是函数上下文下的变量对象来说明变量对象储存了什么，但变量对象还存在于全局上下文中，接下来就分别来聊聊全局上下文中和函数上下文中的变量对象吧。</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>以浏览器中为例，全局对象为<code>window</code>。 全局上下文有一个特殊的地方，它的变量对象，就是<code>window</code>全局对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以浏览器中为例，全局对象为window</span></span><br><span class="line"><span class="comment">// 全局上下文创建阶段</span></span><br><span class="line"><span class="comment">// VO 为变量对象（Variable Object）的缩写</span></span><br><span class="line">windowEC = &#123;</span><br><span class="line">    VO: Window,</span><br><span class="line">    scopeChain: &#123;&#125;,</span><br><span class="line">    <span class="keyword">this</span>: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在上面已经提到了，变量对象存储了执行上下文中的变量和函数声明，但在函数上下文中，还多了一个<code>arguments(函数参数列表)</code>, 一个伪数组对象。</p><p>这时变量对象的<strong>创建阶段</strong>会包括：</p><ol><li><strong>创建<code>arguments</code>对象</strong>。检查当前上下文中的参数，建立该对象下的属性与属性值。</li><li><strong>检查当前上下文的函数声明，也就是使用function关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li><li><strong>检查当前上下文中的变量声明</strong>（<code>var</code> 声明的变量），默认为 <code>undefined</code>；如果变量名称跟已经声明的形式参数或函数相同，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过变量声明，原属性值不会被修改。</li></ol><p><img src="/images/variableobject-1.jpg" alt></p><p>对于第3点中的“跳过”一词想必大家会有一丝疑问？底下例子中既然按照上面的规则，变量声明的<code>foo</code>遇到函数声明的<code>foo</code>会跳过，可是为什么最后<code>foo</code>的输出结果仍然是被覆盖了？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am function foo'</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>理由其实很简单，因为上面的三条规则仅仅适用于变量对象的<strong>创建过程</strong>，也就是执行上下文的创建过程。而<code>foo = 10</code>是在执行上下文的<strong>执行过程</strong>中运行的，输出结果自然会是10。对比下例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ƒ foo() &#123; console.log('I am function foo') &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am function foo'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>为啥又是不一样的结果呢？其实它的执行顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将所有函数声明放入变量对象中，函数声明变量提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am function foo'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过变量声明默认undefined的赋值</span></span><br><span class="line"><span class="comment">// var foo = undefined;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后开始执行阶段代码的执行</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ƒ foo() &#123; console.log('I am function foo') &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行上下文的执行过程中运行</span></span><br><span class="line">foo = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>根据上面的规则，理解变量提升就变得十分简单了，我们也可以看出，<strong><code>function</code>声明会比<code>var</code>声明优先级更高一点</strong>。为了帮助大家更好的理解变量对象，我们再结合一个简单的例子来进行探讨。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(foo());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果为：</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据上述的规则，理解变量提升后可以将执行顺序理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(foo());</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>这样是不是一目了然了呢？</p><p>当然还需要注意的是，函数未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象（VO）转变为了活动对象（AO），然后开始进行执行阶段的操作。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>当前进入执行阶段，变量对象（VO）激活成活动对象（AO），里面的属性都能被访问了，函数会顺序执行代码，改变变量对象的属性值，此阶段的执行上下文代码会分成两个阶段进行处理：</p><ol><li>进入执行上下文</li><li>执行代码</li></ol><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当进入执行上下文时，这时候还没有执行代码。让我们看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当进入带有参数10的<code>foo</code>函数上下文时，AO表现为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="literal">undefined</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">undefined</span>,</span><br><span class="line">    d: <span class="xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">reference</span> <span class="attr">to</span> <span class="attr">d</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    e: undefined,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><code>x</code> 是函数表达式，所以不在变量对象当中，<code>e</code> 变量引用的值也是函数表达式，所以变量 <code>e</code> 本身是声明，所以在变量对象当中。</p><h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4><p>这个阶段会按顺序执行代码，修改变量对象的属性值，紧接上面的例子，执行完成后AO如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="literal">undefined</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="number">10</span>,</span><br><span class="line">    d: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span> <span class="attr">declaration</span> <span class="attr">d</span>&gt;</span>,</span></span><br><span class="line">    e: &lt;reference to Function expression to _e&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简短地总结一下：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 <code>Arguments</code> 对象</li><li>在进入执行上下文时会依次给变量对象<strong>添加形参</strong>、<strong>函数声明</strong>、<strong>变量声明</strong>等初始的属性值</li><li>函数未进入执行阶段之前，变量对象中的属性都不能访问</li><li>在执行代码阶段，会再次修改变量对象的属性值，并赋予该有的属性值</li></ol><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇&lt;a href=&quot;https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/&quot;&gt;《JavaScript系列之执行上下文和执行栈》&lt;/a&gt;，通过对变量对象(Variable Object)的介绍对执行上下文有一个更深一步的了解。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="变量对象" scheme="https://luozongmin.com/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之执行上下文和执行栈</title>
    <link href="https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <id>https://luozongmin.com/2019/06/13/JavaScript系列之执行上下文和执行栈/</id>
    <published>2019-06-13T05:15:17.714Z</published>
    <updated>2019-06-30T04:48:08.435Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想成为一名优秀的JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。<a id="more"></a></p><p>执行上下文和执行栈是JavaScript的难点之一，所以本人尽量用通俗易懂的方式来阐述这些概念。</p><h3 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h3><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。执行上下文（可执行代码段）总共有三种类型：</p><ul><li><strong>全局执行上下文（全局代码）</strong>：不在任何函数中的代码都位于全局执行上下文中，只有一个，浏览器中的全局对象就是 <code>window</code> 对象，<code>this</code> 指向这个全局对象。</li><li><strong>函数执行上下文（函数体）</strong>：只有调用函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创-建，它都会按照特定的顺序执行一系列步骤。</li><li><strong><code>Eval</code> 函数执行上下文（eval代码）</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</li></ul><p>执行上下文又包括三个生命周期阶段：<strong>创建阶段→执行阶段→回收阶段</strong>，本文重点介绍创建阶段。</p><p><strong>1.创建阶段</strong></p><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li><strong>创建变量对象(Variable object，VO)</strong>：首先初始化函数的参数<code>arguments</code>，提升函数声明和变量声明。后文会详细说明。</li><li><strong>创建作用域链（Scope Chain）</strong>：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。后文会详细说明。</li><li><strong>确定this指向</strong>：包括多种情况，后文会详细说明。</li></ul><p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p><p>另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出<code>this</code> 、 <code>arguments</code>和函数的参数。</p><p><strong>2.执行阶段</strong></p><p>进入执行上下文、执行代码</p><p><strong>3.回收阶段</strong></p><p>执行完毕后执行上下文出栈并等待被垃圾回收</p><p><img src="/images/scopechain-1.jpg" alt></p><h3 id="执行上下文栈（Execution-Context-Stack）"><a href="#执行上下文栈（Execution-Context-Stack）" class="headerlink" title="执行上下文栈（Execution Context Stack）"></a>执行上下文栈（Execution Context Stack）</h3><p>假如我们写的函数多了，每次调用函数时都创建一个新的执行上下文，如何管理创建的那么多执行上下文呢？</p><p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，具有 LIFO（后进先出）的栈结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个<strong>新的函数</strong>执行上下文并Push到当前执行栈的顶部，浏览器的JS执行引擎总是访问栈顶的执行上下文。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的<strong>下一个</strong>执行上下文，最终移回到<strong>全局</strong>执行上下文，全局上下文只有唯一的一个，它在浏览器关闭时Pop出。</p><p>看到目前为止，是否觉得这两个概念还是有点晦涩难懂呢？那…接下来通过几小段代码和图解来详细介绍并理解吧。</p><h3 id="执行上下文是如何执行的呢？"><a href="#执行上下文是如何执行的呢？" class="headerlink" title="执行上下文是如何执行的呢？"></a>执行上下文是如何执行的呢？</h3><p>让我们先来看一下这段简单代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>这段代码背后执行的逻辑是这样的：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，这时候会一并建立<code>this</code>、<code>global object</code> (<code>window</code>)，在函数开始执行的过程中，<code>function a</code>和<code>b</code>由于JS提升机制的缘故会先被建立在内存中，接着才会开始逐行执行函数。</p><p><img src="/images/context-1.jpg" alt></p><p>接着，代码会执行到<code>a( )</code>这个部分，这时候，会建立<code>a</code>的执行上下文（execution context），并且被放置到执行栈（execution stack）中。在这个execution stack中，最上面的execution context会是正在被执行的<code>a( )</code>。如下图：</p><p><img src="/images/context-2.jpg" alt></p><p><code>function a</code> 的execution context建立后，便会开始执行<code>function a</code>中的内容。由于在<code>function a( )</code> 里面有去执行<code>function b</code> ，因此，在这个execution stack中，接下来最上面会变成<code>function b</code> 的execution context。如下图：</p><p><img src="/images/context-3.jpg" alt></p><p>当<code>function b</code> 执行完之后，会从execution stack中离开，继续逐行执行<code>function a</code>。当<code>function a</code> 执行完之后，一样会从execution stack中抽离，再回到Global Execution Context逐行执行。如下图：</p><p><img src="/images/context-4.jpg" alt></p><h3 id="不同执行上下文中的变量是不同的"><a href="#不同执行上下文中的变量是不同的" class="headerlink" title="不同执行上下文中的变量是不同的"></a>不同执行上下文中的变量是不同的</h3><p>在了解了一般的函数其运作背后的逻辑后，让我们来看一下这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">  b();</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>你可以想像，如果我们在不同的execution context中去把<code>myVar</code>这个变量打出来，会得到什么结果呢？结果如下：</p><p><img src="/images/context-5.jpg" alt></p><p>我们分别得到了1、<code>undefined</code>和2。为什么会这样呢？</p><p>让我们来看看这段代码背后执行的逻辑：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，由于变量提升的缘故，<code>myVar</code>、<code>function a</code>和<code>b</code>都会被建立并储存在内存中，接着便开始逐行执行函数。一开始会碰到<code>var myVar = 1</code>所以，最外层的<code>myVar</code>便被给值为1，接着执行到了<code>console.log(myVar)</code>，这是在global execution context执行的，于是得到了第一个1的结果：</p><p><img src="/images/context-6.jpg" alt></p><p>然后执行到了<code>a ( )</code>，于是建立了<code>a</code>的execution context，这时候由于逐行执行的关系，会先执行到<code>var myVar = 2</code>，但因为这是在function a的execution context中，所以并不会影响到global execution context的<code>myVar</code>：</p><p><img src="/images/context-7.jpg" alt></p><p>在执行完<code>function a</code>中的<code>var myVar = 2</code>后，继续逐行执行，于是执行到了<code>b ( )</code>，这时候，<code>function b</code>的execution function便被建立，而且会先去执行<code>function b</code>里面的内容：</p><p><img src="/images/context-8.jpg" alt></p><p><code>function b</code>的execution function建立后，会开始逐行执行<code>function b</code>里面的内容，于是读到了<code>var myVar</code>;，这时候在<code>function b</code>这个execution context中的<code>myVar</code>变量被建立，但是还没被赋值，所以会是<code>undefined</code>。和上面提到的一样，由于这个<code>myVar</code>是在<code>function b</code>中的execution context所建立，所以并不会影响到其他execution context的<code>myVar</code>，这时候执行到了<code>function b</code>的 execution context中的<code>console.log(myVar)</code>，于是得到了第二个看到的<code>undefined</code>：</p><p><img src="/images/context-9.jpg" alt></p><p>最后，<code>function b</code>执行完之后，会从execution stack中离开，继续回到<code>function a</code>中的<code>b( )</code>后逐行执行，也就是<code>console.log(myVar)</code>，这时候是在function a的execution context加以执行的，因此也就得到了结果中看到的第三个2了。</p><p>最后由于<code>b ( )</code> 后面已经没有内容，<code>function a</code>执行完毕，这时候，<code>function a</code>也会从execution stack中抽离。</p><p><img src="/images/context-10.jpg" alt></p><p>最后回到Global Execution Context，如果函数中的<code>a( )</code>后面还有内容的话，会继续进行逐行执行。</p><p>由上面的例子，我们可以知道，我们是在不同的execution context中分别去声明变量<code>myVar</code>的，<strong>因此在不同的execution context，变量彼此之间不会影响</strong>，所以虽然这三个变量都叫做<code>myVar</code>，但其实是三个不同的变量。</p><p>由于我们是在不同的execution context中去声明变量，所以这其实是位于三个不同execution context中的变量，所以即使我们是在执行完<code>a( )</code>后再去调用一次<code>myVar</code>，一样会得到” 1”的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">  b();</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(myVar);  <span class="comment">// 一样会得到"1"</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>最后需要注意的是，如果是在<code>function</code>里面直接使用<code>myVar</code>这个变量，而没有通过<code>var</code>重新声明它的话，就会得到不同的结果！因为在函数作用域内加 <code>var</code> 定义的变量是局部变量，不加 <code>var</code> 定义的就成了全局变量。在未声明新的变量的情况下，在该execution context中JavaScript 引擎找不到这个变量，它就会往它的外层去寻找，最后会得到，1 ,2 ,2 ,2 的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  myVar;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  myVar = <span class="number">2</span>;</span><br><span class="line">  b();</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想成为一名优秀的JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Execution Context" scheme="https://luozongmin.com/tags/Execution-Context/"/>
    
      <category term="Execution Context Stack" scheme="https://luozongmin.com/tags/Execution-Context-Stack/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中的函数构造式和prototype的建立</title>
    <link href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>https://luozongmin.com/2019/06/11/谈谈JavaScript中的函数构造式和prototype的建立/</id>
    <published>2019-06-11T14:03:26.471Z</published>
    <updated>2019-07-19T01:29:34.076Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/">《谈谈JavaScript中的function constructor和new关键字》</a>这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。<a id="more"></a></p><p>在JavaScript中的函数也是一种对象，其中包含一些属性像是该函数的名称（<code>Name</code>）和该函数的内容（<code>Code</code>），但其实<code>function</code>这里面还有一个属性，这个属性就是<code>prototype</code>，这个属性会以空对象的型式呈现。</p><p>除非你是把<code>function</code>当做<code>function constructor</code>来使用，否则这个属性就没有特别的用途；但如果你是把它当做<code>function constructor</code>，通过<code>new</code>这个关键字来执行这个<code>function</code>的话，它就有特别的意义了。</p><p><img src="/images/constructor-1.jpg" alt></p><p>要进入这个<code>function</code>的<code>prototype</code>属性只要直接通过 <code>.prototype</code> 就可以了。</p><p>然而，有一点很容易令人困惑的地方，我们会以为如果我使用 <code>.prototype</code> 时，就可以直接进入该函数的原型，但实际上并不是这样的！</p><p><strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个<code>function constructor</code>所建立出来的对象的<code>prototype</code></strong>，听起来有点混乱吧…没关系，让我们来看一些代码来帮助我们理解这一概念。</p><h3 id="说明函数中的prototype-属性"><a href="#说明函数中的prototype-属性" class="headerlink" title="说明函数中的prototype 属性"></a>说明函数中的prototype 属性</h3><p><strong>1.function 中的prototype 属性一开始是空对象</strong></p><p>我们先执行上篇文章最后所写的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>到Google Chrome的console视窗中，我们输入 <code>Person.prototype</code>得到的结果会得到一个空对象，如下图：</p><p><img src="/images/constructor-2.jpg" alt></p><p><strong>2.通过function constructor 所建立的对象会继承该function 中prototype 的内容</strong></p><p>接着，让我们在<code>Person.prototype</code>里面增加一个<code>getFullName</code>的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person . prototype . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>在上面代码的第6 - 8行中，我们为<code>Person.prototype</code>添加了一个函数，所以当我们在Google Chrome的console视窗中调用<code>Person.prototype</code>时，会多了这个函数在内：</p><p><img src="/images/constructor-3.jpg" alt></p><p>刚刚，我们有提到很重要的一句话，「<strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个function constructor所建立出来的对象的<code>prototype</code></strong>」。</p><p>这句话的意思其实是说<code>Person.prototype</code>并不是<code>Person.__proto__</code>，但是所有通过<code>Person</code>这个<code>function constructor</code>所建立的对象，在该实例对象的<code>__proto__</code>中，会包含有<code>Person.prototype</code>的内容。</p><p>也就是说，当我们使用<code>new</code>这个运算符来执行<code>function constructor</code>时，它会先建立一个空对象，同时将该构造函数中<code>prototype</code>这个属性的内容（<code>Person.prototype</code>），设置到该实例对象的<code>prototype</code>中，即 <code>person1.__proto__ === Person.prototype</code>的结果为<code>true</code>。</p><p>因此，当我们在Google Chrome的console中输入<code>person1.__proto__</code>时，我们就可以看到刚刚在<code>Person.prototype</code>所建立的函数<code>getFullName</code>已经继承在里面了：</p><p><img src="/images/constructor-4.jpg" alt></p><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>由于<code>Person.prototype</code>中的方法已经被继承到由<code>Person</code>这个<code>function constructor</code>所建立的实例对象<code>person1</code>中，所以这时侯，我们就可以顺利的使用 <code>person1.getFullName</code> 这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person . prototype . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1.getFullName() ) ;</span><br></pre></td></tr></table></figure><p>可以正确的执行<code>getFullName</code>这个函数并得到如下的结果：</p><p><img src="/images/constructor-5.png" alt></p><h3 id="通过function-constructor与Prototype-的实用处"><a href="#通过function-constructor与Prototype-的实用处" class="headerlink" title="通过function constructor与Prototype 的实用处"></a>通过function constructor与Prototype 的实用处</h3><p>通过这样的方法，我们可以让所有根据这个函数构造器（<code>function constructor</code>）所建立的对象都包含有某些我们想要使用的方法。如果我们有1000个对象是根据这个函数构造器所建立的，那么我们只需要使用 <code>.prototype</code>这样的方法，就可以让这1000个物件都可以使用到我们想要执行的某个<code>method</code>，这样减少了代码的复用。</p><p>有的人可能会好奇问，为什么我们不把<code>getFullName</code>这个方法直接写在函数构造式当中呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">  <span class="keyword">this</span> . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person . prototype . getFullName  =  function ( )  &#123; </span></span><br><span class="line"><span class="comment">  return  this . firstName +  ' '  +  this . lastName ; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意！我们不该把方法放在<code>function constructor</code> 中。</p></blockquote><p>把方法放在函数构造式中这么做虽然仍然可以正确执行并得到结果，但是这么做会有个问题，如果我们是把这个方法直接写在函数构造式中，那么每一个对象都会包含有这个方法，如果我们有1000 个对象根据这个函数构造式所建立，那么这1000 个对象都会包含这个方法在内，如此将会占据相当多的内存；但如果是建立在<code>prototype</code> 中，我们只会有一个这样的方法。</p><p>所以，为了性能上的考量，通常会把方法（<code>method</code>）放在构造函数的<code>prototype</code> 中，因为它们可以是通用的；把属性（<code>property</code>）放在构造函数当中，因为每一个对象可能都会有不同的属性内容，如此将能有效减少内存的问题。</p><p>最后，如果感觉当前缺少你要用的方法，可以自己通过这一方法去创建。</p><p>例如在json2.js源码中，为<code>Date</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code>方法添加一个<code>toJSON</code>的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype.toJSON !== <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Date</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isFinite</span>(<span class="keyword">this</span>.valueOf()) ?</span><br><span class="line">        <span class="keyword">this</span>.getUTCFullYear() + <span class="string">'-'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCMonth() + <span class="number">1</span>) + <span class="string">'-'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCDate()) + <span class="string">'T'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCHours()) + <span class="string">':'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCMinutes()) + <span class="string">':'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCSeconds()) + <span class="string">'Z'</span> : <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span>.prototype.toJSON = </span><br><span class="line">  <span class="built_in">Number</span>.prototype.toJSON = </span><br><span class="line">  <span class="built_in">Boolean</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueOf();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/&quot;&gt;《谈谈JavaScript中的function constructor和new关键字》&lt;/a&gt;这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="constructor" scheme="https://luozongmin.com/tags/constructor/"/>
    
      <category term="prototype" scheme="https://luozongmin.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中的函数构造式和new关键字</title>
    <link href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://luozongmin.com/2019/06/11/谈谈JavaScript中的函数构造式和new关键字/</id>
    <published>2019-06-11T09:52:41.612Z</published>
    <updated>2019-07-19T01:29:18.986Z</updated>
    
    <content type="html"><![CDATA[<p>您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？<a id="more"></a></p><p>大多数 Javascript 的新开发者不太想要使用new关键字，因为这会让代码写的像是 Java 并且在使用上会造成一点混乱；在这篇文章我会尽量尝试着去理清这些东西，并解释它是如何运作的。</p><h3 id="谈谈function-constructor"><a href="#谈谈function-constructor" class="headerlink" title="谈谈function constructor"></a>谈谈function constructor</h3><p><code>constructor</code> 翻为构造器但为了让您之后更好地理解，会直接使用 <code>constructor</code>；在 Javascript 中任何一个函数(<code>function</code>)都可以被当作 <code>constructor</code>；Javascript 并没有明确的区分两者，也就是说 <code>function</code> 可以被当作 <code>constructor</code> 或者当作一般函数调用。</p><p>而 <code>constructor</code> 的用法就是 <code>function</code> 搭配<code>new</code>关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>接着我们把<code>person</code>呼叫出来看，会得到如下的结果，<strong>通过<code>new</code>它会帮我们建立一个对象</strong>，然后里面有<code>Person</code>这个<code>function</code>里面的内容，并且变成了属性名称和属性值：</p><p><img src="/images/new-1.png" alt></p><h3 id="进一步来看new-让这个过程发生了什么"><a href="#进一步来看new-让这个过程发生了什么" class="headerlink" title="进一步来看new 让这个过程发生了什么"></a>进一步来看new 让这个过程发生了什么</h3><p>当使用<code>new</code>命令时，它后面的函数依次执行下面的4个步骤：</p><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li><li>如果函数没有return其他对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ol><p>也就是说，当我们使用<code>new</code>这个关键字时，实际上会先有一个空的对象被建立。</p><p>接着<code>People</code>这个构造函数会被执行，这个空对象的原型，指向了<code>People.prototype</code>。</p><p>我们知道当函数执行的时候，在<code>execution context</code>中会有<code>this</code>被建立，而<strong>当我们使用<code>new</code>的时候，函数里面的<code>this</code>会被指定成刚刚所建立的那个空对象</strong>。</p><p>所以当执行<code>People</code>这个<code>function</code>，执行到<code>this.firstName</code>和<code>this.lastName</code>时，因为<code>this</code>现在指称的是那个空对象，所以实际上是在帮这个空对象赋予属性名称和属性值。</p><p>在这样的过程中，<strong>只要这个构造函数<code>People</code> 没有指定<code>return</code>为其他对象，它就会直接返回给我们这个新建立的对象</strong>。</p><p>接着让我们通过一段代码来更清楚的了解这个执行的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="string">'这个函数有被执行'</span> ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>这时候在chrome 中呼叫出来的结果如下，说明了当我们使用<code>new</code> 在构造对象的时候<code>People</code> 这个<code>function</code> 确实有被执行：</p><p><img src="/images/new-2.png" alt></p><h3 id="通过new-会帮我们建立一个空的对象"><a href="#通过new-会帮我们建立一个空的对象" class="headerlink" title="通过new 会帮我们建立一个空的对象"></a>通过new 会帮我们建立一个空的对象</h3><p>现在我把我们上面的代码改成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span> (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="keyword">this</span> ) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="comment">// console.log(person);</span></span><br></pre></td></tr></table></figure><p>这时候代码返回的结果如下，表示的确在执行这段代码的过程中帮我们建立了一个新的空对象：</p><p><img src="/images/new-3.jpg" alt></p><h3 id="函数的最后若return其他对象，则原新对象内容会被覆盖"><a href="#函数的最后若return其他对象，则原新对象内容会被覆盖" class="headerlink" title="函数的最后若return其他对象，则原新对象内容会被覆盖"></a>函数的最后若return其他对象，则原新对象内容会被覆盖</h3><p>现在，让我们把原本的代码稍微做如下修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">  <span class="keyword">return</span>   &#123; <span class="string">"RETURN"</span> : <span class="string">"原本this的内容就不会被返回"</span> &#125; ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>构造函数的内部若<code>return</code>其他对象，<code>new</code>命令会返回<code>return</code>语句指定的对象，将原新对象内容覆盖掉；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。返回的结果如下：</p><p><img src="/images/new-4.png" alt></p><h3 id="手写一个new实现"><a href="#手写一个new实现" class="headerlink" title="手写一个new实现"></a>手写一个new实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line"><span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line"><span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line"><span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这个手写的new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内置函数new</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(...)</span><br><span class="line">                        </span><br><span class="line"><span class="comment">// 使用手写的new，即create</span></span><br><span class="line"><span class="keyword">var</span> person = create(Person, ...)</span><br></pre></td></tr></table></figure><p>代码原理解析：</p><ol><li>用<code>new Object()</code> 的方式新建了一个对象<code>obj</code></li><li>取出第一个参数，就是我们要传入的构造函数。此外因为 <code>shift</code> 会修改原数组，所以 <code>arguments</code> 会被去除第一个参数</li><li>将 <code>obj</code> 的原型指向构造函数，这样<code>obj</code>就可以访问到构造函数原型中的属性</li><li>使用 <code>apply</code>，改变构造函数 <code>this</code> 的指向到新建的对象，这样 <code>obj</code> 就可以访问到构造函数中的属性</li><li>返回 <code>obj</code></li></ol><h3 id="function-constructor-的实际应用"><a href="#function-constructor-的实际应用" class="headerlink" title="function constructor 的实际应用"></a>function constructor 的实际应用</h3><p>由上面的方法，我们可以通过<code>function</code>的方式来建立一个新的对象，如果我们想要<strong>建立出同属性名称但不同属性值的对象内容，我们可以把对象的属性值变成参数</strong>，如此就能通过此<code>function constructor</code>建立出许多不同的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>如此，我们就可以通过同一个构造函数建立出很多不同的对象：</p><p><img src="/images/new-5.png" alt></p><p>此外，我们会把根据<strong>构造器（<code>constructor</code>）所建立出来的对象称作是实例（<code>instance</code>）</strong>，这在之前的文章里也有提过。</p><h3 id="注意！如果我们忘了加上new关键字"><a href="#注意！如果我们忘了加上new关键字" class="headerlink" title="注意！如果我们忘了加上new关键字"></a>注意！如果我们忘了加上new关键字</h3><p>这里有一个地方我们需要非常留意，如果你在撰写代码的过程当中，忘记加上<code>new</code>这个关键字的话，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>如此，因为JavaScript不知道你是要执行这个函数，还是要根据这个<code>function</code>去建立<code>object</code>，因次最后会返回<code>undefined</code>的结果。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>其实构造函数（function constructor）就是普通的function，只是我们可以通过这个function 来建立对象。</li><li>通过在function 前面加上new 这个运算符，它会把函数中this 这个关键字建立成一个新的对象，然后如果你没有在该函数的内部指定返回出其它对象的话，它就会自动返回这个新的对象给你。</li></ul><p>那又是如何通过<code>function constructors</code> 来设定我们的原型（<code>prototype</code>）呢？让我们在下一篇文章来谈吧！</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="constructor" scheme="https://luozongmin.com/tags/constructor/"/>
    
      <category term="new" scheme="https://luozongmin.com/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之对象的继承</title>
    <link href="https://luozongmin.com/2019/06/10/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://luozongmin.com/2019/06/10/JavaScript系列之对象的继承/</id>
    <published>2019-06-10T09:04:17.179Z</published>
    <updated>2019-06-30T05:10:33.274Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的重点讲的是关于JavaScript中对象的继承，这是面向对象编程很重要的一个方面。A 对象继承自B 对象，就能直接拥有 B 对象的所有属性和方法，作用是避免了代码的复用，节省代码量。<a id="more"></a></p><p>而大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。传统上，JavaScript 语言的继承不通过 class（ES6 引入了 class 语法，基于 class 的继承不在这里介绍），而是通过“原型对象”（<code>prototype</code>）实现，因此，这里把“继承”着重拿出来讲，就为了体现这个不同。</p><h3 id="复习原型-原型链"><a href="#复习原型-原型链" class="headerlink" title="复习原型/原型链"></a>复习原型/原型链</h3><p>JavaScript的继承得靠原型/原型链来实现，当然原型/原型链不是这篇文章的重点，之前的文章也已经介绍过了，所以这里我们来复习一下即可。</p><p>其实原型的概念很简单，我觉得用以下简短的几句话就能概括完全了：</p><ul><li>所有对象都有一个属性 <code>__proto__</code> 指向一个对象，也就是原型</li><li>每个对象的原型都可以通过 <code>constructor</code> 找到构造函数，构造函数也可以通过 <code>prototype</code> 找到原型</li><li>所有函数都可以通过 <code>__proto__</code> 找到 <code>Function</code> 对象</li><li>所有对象都可以通过 <code>__proto__</code> 找到 <code>Object</code> 对象</li><li>对象之间通过 <code>__proto__</code> 连接起来，这样称之为原型链。当前对象上不存在的属性可以通过原型链一层层往上查找，直到顶层 <code>Object</code> 对象，顶层 <code>Object</code> 对象最终指向<code>null</code></li></ul><p>我觉得原型中最重要的内容其实就这些了，没必要看太多关于原型的文章，到头来只是会越来越糊涂，如果硬要推荐原型参阅资料的话，《JavaScript高级程序设计》这本书，当之无愧！</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过上面的介绍，我们知道JavaScript中的继承是通过原型/原型链来体现的，先看几行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">f1.a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Foo.prototype.a = <span class="number">100</span>;</span><br><span class="line">Foo.prototype.b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1.a);  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.b);  <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.c);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>以上代码中，<code>f1</code>是<code>Foo</code>函数通过<code>new</code>构造出来的对象，<code>f1.a</code>是<code>f1</code>对象的基本属性，而<code>f1.b</code>是从<code>Foo.prototype</code>继承得到的，因为<code>f1.__proto__</code>指向的是<code>Foo.prototype</code>。</p><p>这里有一个重要的规则：<strong>当访问一个对象的属性时，首先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链往上找，看是否在链上，有的话就能继承这一属性，如果没有，就返回<code>undefined</code>，这就是原型链</strong>，又复习一遍咯。</p><p>看图直观一些，这里还是采用反复用的原型/原型链经典图：</p><p><img src="/images/jicheng-1.jpg" alt></p><p>上图中，访问<code>f1.a</code>时，<code>f1</code>的基本属性中有<code>a</code>，则不会继续沿着<code>__proto__</code>找，直接读出基本属性<code>a</code>的值；而访问<code>f1.b</code>时，<code>f1</code>的基本属性中没有<code>b</code>，于是沿着<code>__proto__</code>找到了<code>Foo.prototype.b</code>。</p><p>那我们如何在实际应用中区分一个属性到底是基本属性还是在原型链中的公有属性呢？这里可以好好利用一下这个属性——<code>hasOwnProperty</code>，一下就能测出谁是基本属性，当在<code>for…in…</code>循环中，需要额外注意。</p><p><img src="/images/jicheng-2.jpg" alt></p><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性，所以上图中，右边的只打印出<code>a</code>一个值，因为<code>b</code>是在<code>Foo.prototype</code>上的，不属于自身属性。</p><p>那<code>f1</code>的这个<code>hasOwnProperty()</code>方法，<code>f1</code>自身没有，<code>Foo.prototype</code>中也没有，又是从何而来呢？</p><p>还是引用那张原型/原型链经典图，从图上来看，<code>hasOwnProperty()</code>方法是从<code>Object.prototype</code>中继承来的：</p><p><img src="/images/jicheng-3.jpg" alt></p><p>所以对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，因为自身没有这一属性，就会沿着原型链一直查找到<code>Object.prototype</code>上有这一属性，如果没找到则返回<code>undefined</code>。</p><p>由于所有的对象的原型链都会最终找到<code>Object.prototype</code>，因此所有的对象都会有<code>Object.prototype</code>中的方法，比如<code>toString</code>、<code>valueOf</code>等这些公有属性，这就是所谓的“继承”。</p><p>当然这只是一个例子，你可以自定义函数和对象来实现自己的继承，这一点后续文章会有专门介绍。</p><p>这里再说一个函数的例子来加深理解吧。</p><p>我们都知道每个函数都有<code>apply</code>，<code>call</code>方法，都有<code>length</code>，<code>arguments</code>，<code>caller</code>等属性。为什么每个函数都有？这肯定是“继承”来的。在介绍<code>instanceof</code><a href="https://luozongmin.com/2019/06/05/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/">这篇文章</a>中也提到，函数是由<code>Function</code>函数创建，都继承自<code>Function.prototype</code>中的方法。不信可以在Chrome中打印出：</p><p><img src="/images/jicheng-4.jpg" alt></p><p>直接可以看到了吧，有<code>call</code>、<code>length</code>等这些属性。</p><p>那怎么还有<code>hasOwnProperty</code>呢？上图中<code>hasOwnProperty</code>右边显示<code>Object</code>，代表<code>Function.prototype</code>继承自<code>Object.prototype</code>。有疑问可以再看看这张原型/原型链经典大图，<code>Function.prototype.__proto__</code>会指向<code>Object.prototype</code>。</p><p><img src="/images/jicheng-5.jpg" alt></p><p>最后还是那句话，当你完全搞懂上面这张图的时候，就是你掌握原型、原型链的时候了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的重点讲的是关于JavaScript中对象的继承，这是面向对象编程很重要的一个方面。A 对象继承自B 对象，就能直接拥有 B 对象的所有属性和方法，作用是避免了代码的复用，节省代码量。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="继承" scheme="https://luozongmin.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>从instanceof身上深入理解原型/原型链</title>
    <link href="https://luozongmin.com/2019/06/05/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://luozongmin.com/2019/06/05/从instanceof身上深入理解原型原型链/</id>
    <published>2019-06-05T09:32:59.787Z</published>
    <updated>2019-06-30T05:15:21.743Z</updated>
    
    <content type="html"><![CDATA[<p>今天将延续<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。<a id="more"></a></p><p>对于原始类型（primitive type）的值，即<code>string</code>/<code>number</code>/<code>boolean</code>，你可以通过<code>typeof</code>判断其类型，但是<code>typeof</code>在判断到合成类型（complex type）的值的时候，返回值只有<code>object</code>/<code>function</code>，你不知道它到底是一个<code>object</code>对象，还是数组，也不能判断出Object 下具体是什么细分的类型，比如 <code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code> 等。</p><p>官方对<code>instanceof</code>运算符的解释是返回一个布尔值，表示对象是否为某个构造函数的实例。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>f1</code>是构造函数<code>Foo</code>的实例，所以返回<code>true</code>，但是“f1 instanceof Object”为什么也是<code>true</code>呢？</p><p>至于为什么等会再解释，先把<code>instanceof</code>判断的规则告诉大家。根据以上代码看下图：</p><p><img src="/images/instanceof-1.jpg" alt>  </p><p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数，左边变量暂称为A，右边变量暂称为B。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。</p><p>通俗一点来讲，<code>instanceof</code>的判断规则是：<strong><code>instanceof</code>会检查整个原型链，将沿着A的<code>__proto__</code>这条线来一直找，同时沿着B的<code>prototype</code>这条线来一直找，直到能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code></strong>。即上图中的 <code>f1</code>–&gt;<code>__proto__</code> 和 <code>Foo</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Foo)</code>为<code>true</code>。</p><p>按照以上规则，重新来看看“ f1 instanceof Object ”这句代码为什么是<code>true</code>？ 根据上图很容易就能看出来， f1–&gt;<code>__proto__</code>–&gt;<code>__proto__</code> 和<code>Object</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Object)</code>为<code>true</code>。</p><p>通过上面的规则，可以很好地解释一些比较怪异的现象，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这些就是<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>所讲的看似很混乱的东西，现在知道为何了吧。</p><p>但还有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>后续会有专门文章介绍）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真。</p><p>说到这里，继续贴上这幅原型/原型链的经典图，是否现在看起来没那么复杂了呢。</p><p><img src="/images/jicheng-5.jpg" alt>  </p><p>如果<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>你看的比较仔细，再结合刚才介绍的<code>instanceof</code>的概念规则，相信能看懂上面这张图的内容了。</p><p>那么问题又出来了。<code>instanceof</code>这样设计，到底有什么用？到底<code>instanceof</code>想表达什么呢？</p><p>这就要重点讲讲继承了，即<code>instanceof</code>表示的就是一种继承关系，或者原型链的结构，请看后续文章介绍。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天将延续&lt;a href=&quot;https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/&quot;&gt;这篇文章&lt;/a&gt;，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>【译】12个编写干净且可扩展的JavaScript技巧</title>
    <link href="https://luozongmin.com/2019/06/04/%E3%80%90%E8%AF%91%E3%80%9112%E4%B8%AA%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/"/>
    <id>https://luozongmin.com/2019/06/04/【译】12个编写干净且可扩展的JavaScript技巧/</id>
    <published>2019-06-04T05:05:56.932Z</published>
    <updated>2019-06-04T05:26:15.531Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。<a id="more"></a> </p><p>现代Web应用程序严重依赖JavaScript，尤其是单页应用程序（SPA）。借助于React，AngularJS和Vue.js等新兴框架，Web应用程序主要使用JavaScript构建。</p><p>扩展这些应用程序有时候会比较棘手，通过简单的设置，您最终可能会遇到限制并迷失在混乱的海洋中。我想分享一些小技巧，这些技巧将帮助您以有效的方式编写干净的代码。</p><p>本文面向任何技能水平的JavaScript开发人员。 但是，至少具有JavaScript中级知识的开发人员将从这些技巧中获益最多。</p><blockquote><p>原文链接：<a href="https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/" target="_blank" rel="noopener">https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/</a></p></blockquote><h3 id="分隔您的代码"><a href="#分隔您的代码" class="headerlink" title="分隔您的代码"></a>分隔您的代码</h3><p>我建议保持代码库清洁和可读的最重要的事情是具有按主题分隔的特定逻辑块（通常是函数）。如果你编写一个函数，该函数应该默认只有一个目的，不应该一次做多个事情。</p><p>此外，您应避免引起副作用，这意味着在大多数情况下，您不应更改在函数外声明的任何内容。 您将数据接收到带参数的函数中；其他一切都不应该被访问。如果您希望从函数中获取某些内容，请返回新值。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当然，如果以类似的方式使用这些函数或执行类似的操作，您可以将多个函数分组到一个模块（and/or 的类中）。例如，如果要进行许多不同的计算，请将它们拆分为可以链接的独立步骤（函数）。但是，这些函数都可以在一个文件（模块）中声明。 以下是JavaScript中的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add,</span><br><span class="line">    subtract</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">'./calculations'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subtract(<span class="number">5</span>, add(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>如果您正在编写前端JavaScript，请务必使用默认导出作为最重要的项目，并为次要项目命名导出。</p><h3 id="多个参数优先于单个对象参数"><a href="#多个参数优先于单个对象参数" class="headerlink" title="多个参数优先于单个对象参数"></a>多个参数优先于单个对象参数</h3><p>声明一个函数时，您应该总是喜欢多个参数而不是一个期望对象的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayUser</span>(<span class="params">firstName, lastName, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>. She is <span class="subst">$&#123;age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>. She is <span class="subst">$&#123;user.age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这背后的原因是，当您查看函数声明的第一行时，您能确切知道需要传递给函数的内容。</p><p>尽管函数应该受到限制 - 只做一项工作 - 但是它可能会变得更大。在函数体中扫描需要传递的变量（嵌套在对象中）将花费更多时间。有时，使用整个对象并将其传递给函数似乎更容易，但为了扩展应用程序，此设置肯定会有所帮助。</p><p>在某种程度上，声明特定参数没有意义。对我来说，它超过四个或五个功能参数。如果你的函数变大，你应该转向使用对象参数。</p><p>这里的主要原因是参数需要以特定顺序传递。 如果您有可选参数，则需要传递undefined或null。 使用对象参数，您可以简单地传递整个对象，其中顺序和未定义的值无关紧要。</p><h3 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h3><p>解构是ES6引入的一个很好的工具。它允许您从对象中获取特定字段并立即将其分配给变量。 您可以将它用于任何类型的对象或模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EXAMPLE FOR MODULES</span></span><br><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">'./calculations'</span>)</span><br></pre></td></tr></table></figure><p>只导入您需要在文件中使用的函数而不是整个模块，然后从中访问特定的函数。 同样，当您确定您确实需要一个对象作为函数参数时，也可以使用destructuring。 这仍将为您提供函数内所需内容的概述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logCountry</span>(<span class="params">&#123;name, code, language, currency, population, continent&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">`The official language of <span class="subst">$&#123;name&#125;</span> `</span></span><br><span class="line">    <span class="keyword">if</span>(code) msg += <span class="string">`(<span class="subst">$&#123;code&#125;</span>) `</span></span><br><span class="line">    msg += <span class="string">`is <span class="subst">$&#123;language&#125;</span>. <span class="subst">$&#123;population&#125;</span> inhabitants pay in <span class="subst">$&#123;currency&#125;</span>.`</span></span><br><span class="line">    <span class="keyword">if</span>(contintent) msg += <span class="string">` The country is located in <span class="subst">$&#123;continent&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'Germany'</span>,</span><br><span class="line">    code: <span class="string">'DE'</span>,</span><br><span class="line">    language <span class="string">'german'</span>,</span><br><span class="line">    currency: <span class="string">'Euro'</span>,</span><br><span class="line">    population: <span class="string">'82 Million'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'China'</span>,</span><br><span class="line">    language <span class="string">'mandarin'</span>,</span><br><span class="line">    currency: <span class="string">'Renminbi'</span>,</span><br><span class="line">    population: <span class="string">'1.4 Billion'</span>,</span><br><span class="line">    continent: <span class="string">'Asia'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正如你所看到的，我仍然知道我需要传递什么给函数 - 即使它被包装在一个对象中。要解决了解所需内容的问题，请参阅下一个提示！（顺便说一句，这也适用于React功能组件。）</p><h3 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h3><p>解构的默认值甚至基本函数参数都非常有用。首先，它们为您提供了一个可以传递给函数的值的示例。其次，您可以指出哪些值是必需的，哪些值不是。使用前面的示例，该函数的完整设置如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logCountry</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    name = <span class="string">'United States'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    code, </span></span></span><br><span class="line"><span class="function"><span class="params">    language = <span class="string">'English'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    currency = <span class="string">'USD'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    population = <span class="string">'327 Million'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    continent,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">`The official language of <span class="subst">$&#123;name&#125;</span> `</span></span><br><span class="line">    <span class="keyword">if</span>(code) msg += <span class="string">`(<span class="subst">$&#123;code&#125;</span>) `</span></span><br><span class="line">    msg += <span class="string">`is <span class="subst">$&#123;language&#125;</span>. <span class="subst">$&#123;population&#125;</span> inhabitants pay in <span class="subst">$&#123;currency&#125;</span>.`</span></span><br><span class="line">    <span class="keyword">if</span>(contintent) msg += <span class="string">` The country is located in <span class="subst">$&#123;continent&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'Germany'</span>,</span><br><span class="line">    code: <span class="string">'DE'</span>,</span><br><span class="line">    language <span class="string">'german'</span>,</span><br><span class="line">    currency: <span class="string">'Euro'</span>,</span><br><span class="line">    population: <span class="string">'82 Million'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'China'</span>,</span><br><span class="line">    language <span class="string">'mandarin'</span>,</span><br><span class="line">    currency: <span class="string">'Renminbi'</span>,</span><br><span class="line">    population: <span class="string">'1.4 Billion'</span>,</span><br><span class="line">    continent: <span class="string">'Asia'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，有时您可能不想使用默认值，而是在未传递值时抛出错误。 然而，这通常是一个方便的技巧。</p><h3 id="数据稀缺性"><a href="#数据稀缺性" class="headerlink" title="数据稀缺性"></a>数据稀缺性</h3><p>前面的技巧引出了一个结论：最好不要传递您不需要的数据。同样，在设置函数时，这可能意味着更多的工作。但是，从长远来看，它肯定会为您提供更具可读性的代码库。确切地知道在特定位置使用哪些值是非常有价值的。</p><h3 id="行数和缩进限制"><a href="#行数和缩进限制" class="headerlink" title="行数和缩进限制"></a>行数和缩进限制</h3><p>我见过大文件 - 非常大的文件。实际上，超过3,000行代码。在这些文件中查找逻辑块是非常困难的。</p><p>因此，您应该将文件大小限制为一定数量的行。我倾向于将我的文件保存在100行代码之下。 有时候，很难分解文件，它们会增长到200-300行，在极少数情况下会增加到400行。</p><p>超过此临界值，意味着文件太杂乱，难以维护。随意创建新的模块和文件夹。您的项目应该看起来像一个森林，由树（模块部分）和分支（模块和模块文件组）组成。避免试图模仿阿尔卑斯山，在密闭区域堆积代码。</p><p>相比之下，你的实际文件应该看起来像Shire，这里和那里都有一些山丘（小水平的缩进），但一切都相对平坦。 尽量将压痕水平保持在四级以下。</p><p>也许为这些提示启用eslint规则是有帮助的！</p><h3 id="使用prettier"><a href="#使用prettier" class="headerlink" title="使用prettier"></a>使用prettier</h3><p>在团队中工作需要清晰的样式指南和格式。ESLint提供了一个巨大的规则集，您可以根据自己的需求进行自定义。还有 <code>eslint--fix</code>，它可以纠正一些错误，但不是全部。</p><p>相反，我建议使用<a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a>格式化代码。这样，开发人员不必担心代码格式化，而只需编写高质量的代码。 外观将一致并且格式自动化。</p><h3 id="使用有意义的变量名"><a href="#使用有意义的变量名" class="headerlink" title="使用有意义的变量名"></a>使用有意义的变量名</h3><p>理想情况下，应根据其内容命名变量。 以下是一些有助于您声明有意义的变量名称的指南。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数通常执行某种操作。为了解释这一点，人类使用动词 - 转换或显示，例如。在开头用动词命名函数是个好主意，例如<code>convertCurrency</code> 或 <code>displayUserName</code>。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>这些通常会包含一系列项目; 因此，将s附加到变量名称。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> students = [<span class="string">'Eddie'</span>, <span class="string">'Julia'</span>, <span class="string">'Nathan'</span>, <span class="string">'Theresa'</span>]</span><br></pre></td></tr></table></figure><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>简单地说就是尽量多接近于自然语言，这样好理解。你会问“这个人是教师吗？”→“是”或“否”。同样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isTeacher = <span class="literal">true</span> <span class="comment">// OR false</span></span><br></pre></td></tr></table></figure><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><p><code>forEach</code>, <code>map</code>, <code>reduce</code>, <code>filter</code>等是很好的原生JavaScript函数，用于处理数组和执行某些操作。 我看到很多人只是将<code>el</code> 或 <code>element</code>作为参数传递给回调函数。 虽然这很简单快捷，但您还应根据其值来命名。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cities = [<span class="string">'Berlin'</span>, <span class="string">'San Francisco'</span>, <span class="string">'Tel Aviv'</span>, <span class="string">'Seoul'</span>]</span><br><span class="line">cities.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">city</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>通常，您必须跟踪特定数据集和对象的ID。当嵌套id时，只需将其保留为id即可。在这里，我喜欢在将对象返回到前端之前将MongoDB <code>_id</code>映射到 <code>id</code>。从对象中提取<code>id</code>时，请预先添加对象的类型。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> studentId = student.id</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">id</span>: studentId &#125; = student <span class="comment">// destructuring with renaming</span></span><br></pre></td></tr></table></figure><p>该规则的一个例外是模型中的MongoDB引用。 在这里，只需在引用的模型之后命名字段即可。 这将在填充参考文档时保持清晰：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StudentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    teacher: &#123;</span><br><span class="line">        type: Schema.Types.ObjectId,</span><br><span class="line">        ref: <span class="string">'Teacher'</span>,</span><br><span class="line">        required: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="尽可能使用async-await"><a href="#尽可能使用async-await" class="headerlink" title="尽可能使用async / await"></a>尽可能使用async / await</h3><p>在可读性方面，回调是最糟糕的 - 特别是在嵌套时。Promises是一个很好的改进，但在我看来，async / await具有最好的可读性。即使对于初学者或来自其他语言的人来说，这也会有很大帮助。但是，请确保您了解其背后的概念，并且不要盲目地在任何地方使用它。</p><h3 id="模块导入顺序"><a href="#模块导入顺序" class="headerlink" title="模块导入顺序"></a>模块导入顺序</h3><p>正如我们在技巧1和2中看到的那样，将逻辑保持在正确的位置是可维护性的关键。 同样，导入不同模块的方式可以减少文件中的混淆。 我在导入不同模块时遵循一个简单的结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3rd party packages</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stores</span></span><br><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">'~/Store</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// reusable components</span></span><br><span class="line"><span class="string">import Button from '</span>~<span class="regexp">/components/</span>Button<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// utility functions</span></span><br><span class="line"><span class="string">import &#123; add, subtract &#125; from '</span>~<span class="regexp">/utils/</span>calculate<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// submodules</span></span><br><span class="line"><span class="string">import Intro from '</span>./Intro<span class="string">'</span></span><br><span class="line"><span class="string">import Selector from '</span>./Selector<span class="string">'</span></span><br></pre></td></tr></table></figure><p>我在这里使用了React组件作为示例，因为有更多类型的导入。 您应该能够根据您的具体用例进行调整。</p><h3 id="摆脱控制台"><a href="#摆脱控制台" class="headerlink" title="摆脱控制台"></a>摆脱控制台</h3><p><code>console.log</code> 是一种很好的调试方式 - 非常简单，快速，完成工作。显然，有更复杂的工具，但我认为每个开发人员仍然使用它。如果您忘记清理日志，您的控制台最终将陷入巨大的混乱。然后，您确实要在代码库中保留日志; 例如，警告和错误。</p><p>要解决此问题，您仍然可以使用<code>console.log</code> 进行调试，但对于持久日志，请使用<a href="https://www.npmjs.com/package/loglevel" target="_blank" rel="noopener">loglevel</a>或<a href="https://www.npmjs.com/package/winston" target="_blank" rel="noopener">winston</a>等库。此外，您可以使用ESLint警告控制台语句。这样你就可以轻松地全局查找<code>console...</code> 并删除这些语句。</p><p>遵循这些指导原则确实帮助我保持代码库的清洁和可扩展性。 你觉得还有什么提示特别有用的吗？请在评论中告诉我您在编码工作过程中值得推荐的内容，并请分享您用于帮助代码结构的任何其他提示！谢谢~</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="编程技巧" scheme="https://luozongmin.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>由一段代码引发的关于Object和Function的鸡和蛋问题的思考</title>
    <link href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://luozongmin.com/2019/06/01/由一段代码引发的关于Object和Function的鸡和蛋问题的思考/</id>
    <published>2019-06-01T10:06:56.785Z</published>
    <updated>2019-06-30T05:29:01.929Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。<a id="more"></a> </p><h3 id="鸡和蛋问题的由来"><a href="#鸡和蛋问题的由来" class="headerlink" title="鸡和蛋问题的由来"></a>鸡和蛋问题的由来</h3><p>首先<code>Object</code>和<code>Function</code>都是构造函数，而所有的构造函数都是<code>Function</code>的实例对象。 因此<code>Object</code>是<code>Function</code>的实例对象；而<code>Function.prototype</code>是<code>Object</code>的实例对象。所以这里就引伸出了一个有意思的鸡和蛋的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>那么<code>Object</code>和<code>Function</code>，谁是鸡谁是蛋呢？</p><p>接下来就来深入探究下上面这段代码所引起的鸡生蛋蛋生鸡问题，从下面这张原型/原型链经典图入手，在这个过程中深入了解 <code>Object.prototype</code>、<code>Function.prototype</code>、<code>function Object()</code> 、<code>function Function()</code> 之间的关系，这个过程可能有点烧脑，毕竟是JS的一大玄学嘛。</p><p><img src="/images/jidang-1.jpg" alt>  </p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>原型链的尽头就是<code>Object.prototype</code>（不考虑 <code>null</code> 的情况下）。<strong>所有对象均从</strong><code>Object.prototype</code><strong>继承toString() 等公共属性</strong>。</p><p><img src="/images/jidang-2.jpg" alt>   </p><p><code>Object.prototype</code> 表示 <code>Object</code> 的原型对象，实际上<code>Object.prototype</code> 并不是通过<code>Object</code>函数创建的，为什么呢？看如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'川普'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.__proto__ === Dog.prototype;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>实例对象的<code>__proto__</code>会指向构造函数的<code>prototype</code>，即<code>dog.__proto__</code>指向 <code>Dog.prototype</code>，但是<code>Object.prototype.__proto__</code>又是 <code>null</code>，所以 <code>Object.prototype</code> 并不是通过 <code>Object</code> 函数创建的，那它如何生成的？其实 <code>Object.prototype</code> 是浏览器底层根据 ECMAScript 规范创造的一个对象，所以在经典图里面只是看起来<code>Object.prototype</code> 是通过 <code>Object</code> 函数创建的，实际上并不是。</p><p><img src="/images/jidang-3.jpg" alt>  </p><h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p><code>Function.prototype</code>和<code>Function.__proto__</code>为<strong>同一对象</strong>。</p><p><img src="/images/jidang-4.jpg" alt>  </p><p>这也意味着：<strong><code>Object</code>/<code>Array</code>等等构造函数本质上和<code>Function</code>一样，均继承于<code>Function.prototype</code>，从经典图上来看都是通过<code>new Function</code>构造出来的</strong>。</p><p>当然，<code>Function.prototype</code> 对象是一个函数（对象），其<code>__proto__</code>属性指向 <code>Object.prototype</code>，即<code>Function.prototype</code>会直接继承root（<code>Object.prototype</code>）。</p><p><img src="/images/jidang-5.jpg" alt> </p><p>通过这点我们可以弄清<strong>继承的原型链</strong>：<code>Function|Object|Array...---&gt;Function.prototype---&gt;Object.prototype(root)</code>。如下图所示：</p><p><img src="/images/jidang-6.jpg" alt> </p><h3 id="function-Object"><a href="#function-Object" class="headerlink" title="function Object()"></a>function Object()</h3><p><code>Object</code> 作为构造函数时，其<code>__proto__</code>属性指向 <code>Function.prototype</code>，即:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从经典图来看：</p><p><img src="/images/jidang-7.jpg" alt>   </p><p>使用 <code>new Object()</code> 创建实例对象o1时，实例对象o1的 <code>__proto__</code>属性指向构造函数的 <code>prototype</code> 属性，对应上图就是 <code>Object.prototype</code>，即<code>o1.__proto__ === Object.prototype</code>结果为<code>true</code>。</p><p><code>Function.prototype</code>指向的对象，它的<code>__proto__</code>会指向<code>Object.prototype</code>，因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。</p><h3 id="function-Function"><a href="#function-Function" class="headerlink" title="function Function()"></a>function Function()</h3><p><code>Function</code>也是一个函数对象，也有<code>__proto__</code>属性，既然是函数，那么它一定是被<code>Function</code>创建，所以<code>Function</code>是被自身创建的，所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/images/jidang-8.jpg" alt>  </p><p>到这里就有点烧脑了吧，我们再看下鸡生蛋蛋生鸡问题。</p><h3 id="Function-amp-Object-鸡和蛋问题"><a href="#Function-amp-Object-鸡和蛋问题" class="headerlink" title="Function &amp; Object 鸡和蛋问题"></a>Function &amp; Object 鸡和蛋问题</h3><p>由上面可知，<code>Object</code>构造函数继承了<code>Function.prototype</code>，同时<code>Function</code>构造函数继承了<code>Object.prototype</code>，这里就产生了<strong>鸡和蛋</strong>的问题。为什么会出现这种问题呢？必须首先更深入一层去理解<code>Function.prototype</code>这个对象，因为它是导致<code>Function instanceof Object</code>和<code>Object instanceof Function</code>都为<code>true</code>的原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object instanceof Function 即</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function instanceof Object 即</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object instanceof Object 即 </span></span><br><span class="line"><span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function instanceof Function 即</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据JS规范，<code>Function.prototype</code>又是个不同于一般函数（对象）的函数（对象），其中：</p><ol><li><code>Function.prototype</code>像普通函数一样可以调用，但总是返回<code>undefined</code>。</li><li>普通函数实际上是<code>Function</code>的实例，即普通函数继承于<code>Function.prototype</code>。即<code>func.__proto__ === Function.prototype</code>。</li><li><code>Function.prototype</code>继承于<code>Object.prototype</code>，并且没有<code>prototype</code>这个属性。</li><li>所以，<code>Function.prototype</code>其实是个另类的函数，可以独立于/先于<code>Function</code>产生。</li></ol><p>而<code>Object</code>本身是个（构造）函数，是<code>Function</code>的实例，即<code>Object.__proto__</code>就是<code>Function.prototype</code>。</p><p><strong>总结：先有<code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code>继承<code>Object.prototype</code>而产生，最后，<code>Function</code>和<code>Object</code>和其它构造函数继承<code>Function.prototype</code>而产生</strong>。</p><p>看到这里估计也都看烦了，是不是还是有点混乱呀？乱也很正常。那这篇文章就先让它乱着，下一篇我们将请另一个老朋友来帮忙，把它彻底理清楚，这位老朋友就是——<code>instanceof</code>，那就且听请下回分解咯。</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Function" scheme="https://luozongmin.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>从原生JS实现jQuery的一个API中体会其设计思想</title>
    <link href="https://luozongmin.com/2019/05/31/%E4%BB%8E%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84%E4%B8%80%E4%B8%AAAPI%E4%B8%AD%E4%BD%93%E4%BC%9A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <id>https://luozongmin.com/2019/05/31/从原生JS实现jQuery的一个API中体会其设计思想/</id>
    <published>2019-05-31T14:16:34.767Z</published>
    <updated>2019-05-31T14:24:00.597Z</updated>
    
    <content type="html"><![CDATA[<p>根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？<a id="more"></a>读源代码又太繁琐，所以这里利用原生JS来实现jQuery中的addClass这个API，通过实现此过程来体会jQuery的设计思想，力求简单易懂。</p><h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">classes</span>)</span>&#123;&#125; <span class="comment">//可将所有输入的标签的class添加一个类</span></span><br></pre></td></tr></table></figure><h3 id="实现这个函数"><a href="#实现这个函数" class="headerlink" title="实现这个函数"></a>实现这个函数</h3><p>函数<code>addClass()</code>是输入一个类名，给选中的所有标签添加一个类，所以要用到<code>classList.add()</code>，具体实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">node, classes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">    allTag[i].classList.add(classes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在全局变量中创建一个对象，用来储存封装后的函数，这就是命名空间（名字前面统一加一个前缀）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = &#123;&#125;</span><br><span class="line">jQuery.addClass = addClass</span><br><span class="line"></span><br><span class="line">jQuery.addClass(<span class="string">'div'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>整理之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = &#123;&#125;</span><br><span class="line">jQuery.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">node, classes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">    allTag[i].classList.add(classes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.addClass(<span class="string">'div'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h3 id="将node放到前面"><a href="#将node放到前面" class="headerlink" title="将node放到前面"></a>将node放到前面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.addClass(classes)</span><br></pre></td></tr></table></figure><p>方法一：扩展 Node 接口，直接在 <code>Node.prototype</code> 上加函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：新的接口 <code>BetterNode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    element: node,</span><br><span class="line">    addClass: <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">        allTag[i].classList.add(classes)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node2 = jQuery(<span class="string">'div'</span>)</span><br><span class="line">node2.addClass(<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>第二种叫做「无侵入」。</p><h3 id="进一步完善"><a href="#进一步完善" class="headerlink" title="进一步完善"></a>进一步完善</h3><p>给个缩写并且使其可以是节点或者选择器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">      nodes[i]=temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeOrSelector <span class="keyword">instanceof</span> Node)&#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      <span class="number">0</span>:nodeOrSelector,</span><br><span class="line">      length:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class="line">      nodes[i].classList.add(classes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.$ = jQuery</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>)</span><br><span class="line">$div.addClass(<span class="string">'red'</span>) <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br></pre></td></tr></table></figure><h3 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h3><p>按照jQuery的设计思路封装一个ajax函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">url, method, body, success, fail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> request = XMLHttpResquest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                success.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                fail.call(<span class="literal">undefined</span>, request)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级改进一下满足promise规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    url,</span></span></span><br><span class="line"><span class="function"><span class="params">    method,</span></span></span><br><span class="line"><span class="function"><span class="params">    body,</span></span></span><br><span class="line"><span class="function"><span class="params">    headers</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> request = XMLHttpResquest()</span><br><span class="line">        request.open(method, url)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">            <span class="keyword">let</span> value = headers[key]</span><br><span class="line">            request.setRequestHeader(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    success.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                    fail.call(<span class="literal">undefined</span>, request)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.send(body)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="https://luozongmin.com/tags/jQuery/"/>
    
  </entry>
  
</feed>
