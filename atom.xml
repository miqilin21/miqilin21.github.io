<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米淇淋の个人博客</title>
  
  <subtitle>Stay hungry. Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luozongmin.com/"/>
  <updated>2019-04-27T07:50:27.949Z</updated>
  <id>https://luozongmin.com/</id>
  
  <author>
    <name>miqilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中任何值的prototype到最后都是Object</title>
    <link href="https://luozongmin.com/2019/04/27/JavaScript%E4%B8%AD%E4%BB%BB%E4%BD%95%E5%80%BC%E7%9A%84prototype%E5%88%B0%E6%9C%80%E5%90%8E%E9%83%BD%E6%98%AFObject/"/>
    <id>https://luozongmin.com/2019/04/27/JavaScript中任何值的prototype到最后都是Object/</id>
    <published>2019-04-27T07:32:00.664Z</published>
    <updated>2019-04-27T07:50:27.949Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记延伸上一篇所提到的<a href="https://luozongmin.com/2019/04/25/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型（prototype）</a>的概念，说明了在JavaScript当中，所有的类型（字符串、数值、Boolean值、函数、数组、对象）的prototype的最后都是object！  <a id="more"></a>   </p><p>什么意思呢？</p><p>假设我们现在分别建立对象、函数和数组，直接上代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object </span></span><br><span class="line"><span class="keyword">var</span> a =  &#123; </span><br><span class="line">  name : <span class="string">'miqilin'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function </span></span><br><span class="line"><span class="keyword">var</span>  b  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="string">'Hello'</span> ) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array </span></span><br><span class="line"><span class="keyword">var</span> c =  [ <span class="string">'A'</span> , <span class="string">'r'</span> , <span class="string">'r'</span> , <span class="string">'a'</span> , <span class="string">'y'</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string </span></span><br><span class="line"><span class="keyword">var</span> d =  <span class="string">'This is string'</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number </span></span><br><span class="line"><span class="keyword">var</span> e =  <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean </span></span><br><span class="line"><span class="keyword">var</span> f =  <span class="literal">true</span> ;</span><br></pre></td></tr></table></figure><p>接着，我们会在Google Chrome 的console 视窗来分别检验这些类型的<code>prototype</code>。  </p><h4 id="对象（object）"><a href="#对象（object）" class="headerlink" title="对象（object）"></a>对象（object）</h4><p>我们可以看到a这个对象本身的<code>prototype</code>也是一个对象，在下去就没了（<code>null</code>），也就是<strong>Object → Object → null的过程</strong>。 </p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc4066980328.jpg" alt>    </div></p><p>而<code>a.__proto__</code>就是对象的原型，打开来看会发现里面有许多内置的方法。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc406904ba62.jpg" alt>   </div></p><p>如果我在console中输入<code>a.</code>，则会出现对于对象而言内置的方法： </p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc406b6140d6.jpg" alt>   </div></p><p>由于<code>a.__proto__</code>仍然是一个对象，所以如果我输入<code>a.__proto__.</code>的话，会得到除了<code>name</code>一样对于对象可以使用的方法：</p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc406e69789c.jpg" alt>   </div></p><h4 id="函数（function）"><a href="#函数（function）" class="headerlink" title="函数（function）"></a>函数（function）</h4><p>接着我们来看看函数，根据上面同样的方法得出是<strong>function → function → object → null</strong>的过程，所以最后还是结束在<code>object</code>。 </p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc4073f301dc.jpg" alt>    </div></p><p>如果我们想要看函数有哪些内置的方法可以用，我们可以输入<code>b.</code>或<code>b.__proto__.</code>就可以看到了，这里我们就可以看到我们常用的<code>apply</code> , <code>bind</code> ,和<code>call</code>。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc4077450aff.jpg" alt>   </div></p><h4 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h4><p>对于数组的话则是<strong>array → array → object → null</strong>的过程。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc407ac2642f.jpg" alt>   </div></p><p>如果我们要看数组有哪些方法可以用，一样可以透过<code>c.</code>或<code>c.__proto__.</code>来检视： </p><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc407deef58b.jpg" alt>    </div></p><p>同样的方法也可以用来检视字符串、数字和Boolean值，有兴趣的通过chrome 来试试看吧！  </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇笔记延伸上一篇所提到的&lt;a href=&quot;https://luozongmin.com/2019/04/25/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/&quot;&gt;原型（prototype）&lt;/a&gt;的概念，说明了在JavaScript当中，所有的类型（字符串、数值、Boolean值、函数、数组、对象）的prototype的最后都是object！
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之原型与原型链</title>
    <link href="https://luozongmin.com/2019/04/25/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://luozongmin.com/2019/04/25/JavaScript系列之原型与原型链/</id>
    <published>2019-04-25T02:14:34.206Z</published>
    <updated>2019-04-27T00:30:06.515Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 也是一门面向对象的语言，ES6之前并没有引入类（class）的概念，像c++ 这种典型的面向对象语言都是通过类来创建实例对象，而JavaScript是直接通过构造函数来创建实例。<a id="more"></a>   </p><p>所以理解两种继承模式的差异是需要一定时间的，今天我们就来了解一下原型和原型链，在介绍原型和原型链之前，我们有必要先了解一下构造函数的知识。   </p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。  </p><p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。另外就是调用方式的不同，普通函数是直接调用，<strong>而构造函数需要使用new关键字来调用</strong>。我们先使用构造函数创建一个对象：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'阿黄'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog.name)     <span class="comment">// 阿黄</span></span><br></pre></td></tr></table></figure><p>上面例子中，Dog 就是一个构造函数，我们使用 new 创建了一个实例对象 dog。  </p><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p><strong>prototype</strong>  </p><p>每个函数都有一个特殊的属性叫作<code>原型（prototype）</code>，正如下面代码所展示的。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'阿黄'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype)</span><br></pre></td></tr></table></figure><p>那这个构造函数的 <code>prototype</code> 属性指向的是什么呢？是这个函数的原型吗？  </p><p>打开 chrome 浏览器的开发者工具，在 console 栏输入上面的代码，你可以看到 <code>Dog.prototype</code> 的值： </p><p><div align="center"><img src="https://i.loli.net/2019/04/25/5cc11936423fe.jpg" alt>    </div></p><p>其实，函数的 <code>prototype</code> 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型。   </p><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(<code>null</code>除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。  </p><p>让我们用一张图来表示构造函数和实例原型之间的关系：</p><p><div align="center"><img src="https://i.loli.net/2019/04/25/5cc1198c45bfe.jpg" alt>     </div></p><p>那么我们该怎么表示实例与实例原型，也就是 <code>person</code> 和 <code>Person.prototype</code> 之间的关系呢，接下来就应该讲到第二个属性：  </p><p><strong><strong>proto</strong></strong>  </p><p>这是每一个JavaScript对象(除了 <code>null</code> )都具有的一个属性，叫<code>__proto__</code>，这个属性会指向该对象的原型。  </p><p>为了证明这一点,我们可以在chrome中输入：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'阿黄'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(dog) === dog.__proto__)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ === Dog.prototype)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>于是我们更新下关系图： </p><p><div align="center"><img src="https://i.loli.net/2019/04/25/5cc119e192097.jpg" alt>    </div></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？  </p><p><strong>constructor</strong>  </p><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：<code>constructor</code>，每个原型都有一个 <code>constructor</code> 属性指向关联的构造函数。  </p><p>为了验证这一点，我们在chrome中输入：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'阿黄'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.constructor === Dog)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以再更新下关系图：  </p><p><div align="center"><img src="https://i.loli.net/2019/04/25/5cc11a331a130.jpg" alt>     </div></p><p>综上我们已经得出：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'阿黄'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ == Dog.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.constructor == Dog) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(dog) === Dog.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>在上文我们理解了原型，原型链肯定是与原型有关了，是一个个原型链接起来的么？我们先通过下面的图来观察一下。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/25/5cc11a7517605.jpg" alt>      </div></p><p>解析： </p><p><strong>obj.prop1</strong>：假设我们现在有一个对象，就称作<code>obj</code>，而这个对象包含一个属性<code>（property）</code>，我们称作<code>prop1</code>，现在我们可以使用<code>obj.prop1</code>来读取这个属性的值，就可以直接读取到<code>prop1</code>的属性值了。  </p><p><strong>obj.prop2</strong>：JavaScript中会有一些预设的属性和方法，所有的对象和函数都包含<code>prototype</code>这个属性，假设我们把<code>prototype</code>叫做<code>proto</code>，这时候如果我们使用<code>obj.prop2</code>的时候，JavaScript引擎会先在<code>obj</code>这个对象的属性里去寻找有没有叫作<code>prop2</code>的属性，<strong>如果它找不到，这时候它就会再进一步往该对象的<code>proto</code>里面去寻找</strong>。所以，虽然我们输入<code>obj.prop2</code>的时候会得到回传值，但实际上这不是<code>obj</code>里面直接的属性名称，而是在<code>obj</code>的<code>proto</code>里面找到的属性名称（即，<code>obj.proto.prop2</code>，但我们不需要这样打）。  </p><p><strong>obj.prop3</strong>：同样地，每一个对象里面都包含一个<code>prototype</code>，包括对象<code>proto</code>本身也不例外，所以，如果输入<code>obj.prop3</code>时，JavaScript会先在<code>obj</code>这个对象里去寻找有没有<code>prop3</code>这个属性名称，找不到时会再往<code>obj</code>的<code>proto</code>去寻找，<strong>如果还是找不到时，就再往<code>proto</code>这个对象里面的<code>proto</code>找下去</strong>，最后找到后回传属性值给我们（<code>obj.proto.proto.prop3</code>）。  </p><p>虽然乍看之下，<code>prop3</code>很像是在对象<code>obj</code>里面的属性，但实际上它是在<code>obj → prop → prop</code>的对象里面，而这样从对象本身往<code>proto</code>寻找下去的链我们就称作「原型链（prototype chain）」。这样一直往下找会找到什么时候呢？它会直到某个对象的原型为<code>null</code>为止（也就是不再有原型指向）。  </p><h4 id="举个例子来帮助理解原型链"><a href="#举个例子来帮助理解原型链" class="headerlink" title="举个例子来帮助理解原型链"></a>举个例子来帮助理解原型链</h4><p>让我们实际来看个例子帮助我们了解prototype chain这个概念，千万这个例子只是单纯为了用来说明prototype chain的概念，实际上千万不要使用这样的方式编程！ </p><p>首先，我们先建立一个对象<code>person</code> 和一个对象<code>john</code>：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person =  &#123; </span><br><span class="line">  firstName :  <span class="string">'Default'</span> , </span><br><span class="line">  lastName :  <span class="string">'Default'</span> , </span><br><span class="line">  getFullName :  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">  &#125; , </span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john =  &#123; </span><br><span class="line">  firstName :  <span class="string">'John'</span> , </span><br><span class="line">  lastName :  <span class="string">'Doe'</span> , </span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>接着，我们知道<strong>所有的对象里面都会包含原型（prototype）这个对象，在JavaScript中这个对象的名称为<strong>proto</strong></strong>。如同上述原型链（prototype chain）的概念，如果在原本的对象中找不到指定的属性名称或方法时，就会进一步到<code>__proto__</code>这里面来找。  </p><p>为了示范，我们来对<code>__proto__</code>做一些事： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//千万不要照着下面这样做，这么做只是为了示范 </span></span><br><span class="line">john . __proto__ = person ;</span><br></pre></td></tr></table></figure><p>如此，<code>john</code>这个对象就继承了<code>person</code>对象。在这种情况下，如果我们想要呼叫某个属性或方法，但在原本<code>john</code>这个对象中找不到这个属性名称或方法时，JavaScript引擎就会到<code>__proto__</code>里面去找，所以当接着执行如下的代码时，并不会报错： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span> . log ( john . getFullName ( ) )         <span class="comment">// John Doe;</span></span><br></pre></td></tr></table></figure><p>我们可以得到”John Doe”的结果。原本在<code>john</code>的这个对象中，是没有<code>getFullName()</code>这个方法的，但由于我让<code>__proto__</code>里面继承了<code>person</code>这个对象，所以当JavaScript引擎在<code>john</code>对象里面找不到<code>getFullName()</code>这个方法时，它便会到<code>__proto__</code>里面去找，最后它找到了，于是它回传”John Doe”的结果。  </p><p>如果我是执行：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span> . log ( john . firstName ) ;         <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>我们会得到的是John而不是’Default’，因为JavaScript引擎在寻找<code>john.firstName</code>这个属性时，在<code>john</code>这个对象里就可以找到了，因此它不会在往<code>__proto__</code>里面找。<strong>这也就是刚刚在上面所的原型链（prototype chain）的概念，一旦它在上层的部分找到该属性或方法时，就不会在往下层的prototype去寻找</strong>。  </p><p>在了解了prototype chain这样的概念后，让我们接着看下面这段代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jane = &#123; </span><br><span class="line">  firstName :  <span class="string">'Jane'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jane . __proto__ = person ; </span><br><span class="line"><span class="built_in">console</span> . log ( jane . getFullName ( ) ) ;</span><br></pre></td></tr></table></figure><p>现在，你可以理解到会输出什么结果吗？</p><p>答案是”Jane Default” 。</p><p>因为在<code>jane</code>这个对象里只有<code>firstName</code>这个属性，所以当JavaScript引擎要寻找<code>getFullName()</code>这个方法和<code>lastName</code>这个属性时，它都会去找<code>__proto__</code>里面，而这里面找到的就是一开始建立的<code>person</code>这个对象的内容。</p><p>全代码如下：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person =  &#123; </span><br><span class="line">  firstName : <span class="string">'Default'</span> , </span><br><span class="line">  lastName : <span class="string">'Default'</span> , </span><br><span class="line">  getFullName :  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john =  &#123; </span><br><span class="line">  firstName : <span class="string">'John'</span> , </span><br><span class="line">  lastName : <span class="string">'Doe'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//千万不要照着下面这样做，这么做只是为了示范 </span></span><br><span class="line">john . __proto__ = person ; </span><br><span class="line"><span class="built_in">console</span> . log ( john . getFullName ( ) ) ;     <span class="comment">// John Doe </span></span><br><span class="line"><span class="built_in">console</span> . log ( john . firstName ) ;         <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jane = &#123; </span><br><span class="line">  firstName :  <span class="string">'Jane'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jane . __proto__ = person ; </span><br><span class="line"><span class="built_in">console</span> . log ( jane . getFullName ( ) ) ;</span><br></pre></td></tr></table></figure><p>以上就是目前能总结的全部了，肯定还是有缺陷的地方，后续还会修改完善的。  </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 也是一门面向对象的语言，ES6之前并没有引入类（class）的概念，像c++ 这种典型的面向对象语言都是通过类来创建实例对象，而JavaScript是直接通过构造函数来创建实例。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之内存泄漏</title>
    <link href="https://luozongmin.com/2019/04/22/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://luozongmin.com/2019/04/22/JavaScript系列之内存泄漏/</id>
    <published>2019-04-22T08:41:35.478Z</published>
    <updated>2019-04-27T01:08:15.085Z</updated>
    
    <content type="html"><![CDATA[<p>在程序运行过程中不再用到的内存，没有及时释放，会出现内存泄漏（memory leak），会造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。<a id="more"></a>   </p><p>而内存泄漏是每个开发人员最终必须面对的问题。 即使使用内存管理语言，比如C语言有着<code>malloc()</code> 和 <code>free()</code> 这种低级内存管理语言也有可能出现泄露内存的情况。  </p><p>这很麻烦，所以为了编程中的负担，大多数语言提供了自动内存管理，这被称为”垃圾回收机制”（garbage collector）。   </p><h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p>现在各大浏览器通常采用的垃圾回收有两种方法：<strong>标记清除（mark and sweep）</strong>、<strong>引用计数(reference counting)</strong>。  </p><p><strong>1、标记清除</strong> </p><p>这是javascript中最常用的垃圾回收方式。  </p><p>工作原理：当变量进入执行环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。   </p><p>工作流程：  </p><ol><li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。</li><li>去掉环境中的变量以及被环境中的变量引用的变量的标记。</li><li>之后再被加上标记的变量将被视为准备删除的变量。</li><li>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。  </li></ol><p><strong>2、引用计数</strong>  </p><p>工作原理：跟踪记录每个值被引用的次数。   </p><p>工作流程：   </p><ol><li>将一个引用类型的值赋值给这个声明了的变量，这个引用类型值的引用次数就是1。</li><li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。</li><li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1</li><li>当引用次数变成0时，就表示这个值不再用到了。</li><li>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。   </li></ol><p>但如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，会导致内存泄漏。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello miqilin'</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>[1, 2, 3]</code>会占用内存，赋值给了变量<code>arr</code>，因此引用次数为1。尽管后面的一段代码没有用到<code>arr</code>，它还是会持续占用内存。  </p><p>如果增加一行代码，解除arr对<code>[1, 2, 3]</code>引用，这块内存就可以被垃圾回收机制释放了。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello miqilin'</span>);</span><br><span class="line">arr = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>arr</code>重置为<code>null</code>，就解除了对<code>[1, 2, 3]</code>的引用，引用次数变成了0，内存就可以释放出来了。  </p><p>因此，并不是说有了垃圾回收机制，程序员就无事一身轻了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。  </p><p>接下来，我将介绍四种常见的JavaScript 内存泄漏及如何避免。目前水平有限，借鉴了国外大牛的文章了解这几种内存泄漏，原文链接：<a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="noopener">https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec</a>  </p><h4 id="四种常见的-JavaScript-内存泄漏"><a href="#四种常见的-JavaScript-内存泄漏" class="headerlink" title="四种常见的 JavaScript 内存泄漏"></a>四种常见的 JavaScript 内存泄漏</h4><p><strong>1.意外的全局变量</strong> </p><p>未定义的变量会在全局对象创建一个新变量，对于在浏览器的情况下，全局对象是<code>window</code>。 看以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">     bar = <span class="string">"this is a hidden global variable"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>foo</code>内部使用<code>var</code>声明，实际上JS会把<code>bar</code>挂载在全局对象上，意外创建一个全局变量。等同于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">window</span>.bar = <span class="string">"this is an explicit global variable"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述情况下， 泄漏一个简单的字符串不会造成太大的伤害，但它肯定会更糟。 </p><p>另一种可以创建偶然全局变量的情况是<code>this</code>：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Foo called on its own, this points to the global object (window)</span></span><br><span class="line"><span class="comment">// rather than being undefined. </span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，使用严格模式避免意外的全局变量，此时上例中的<code>this</code>指向<code>undefined</code>。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 <code>null</code> 或者重新定义。   </p><p><strong>2.被遗忘的计时器或回调函数</strong> </p><p>在JavaScript中使用<code>setInterval</code>非常常见。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData(); </span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);     </span><br><span class="line">     <span class="keyword">if</span>(node) &#123;</span><br><span class="line">         <span class="comment">// Do stuff with node and someResource.</span></span><br><span class="line">         node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">     &#125; &#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面的代码表明，在节点<code>node</code>或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当<code>node</code>节点被移除后，<code>interval</code> 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">     element.innerHtml = <span class="string">'text'</span>; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, onClick); <span class="comment">// Do stuff </span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, onClick); </span><br><span class="line">element.parentNode.removeChild(element); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Now when element goes out of scope,</span></span><br><span class="line"><span class="comment">// both element and onClick will be collected even in old browsers that don't</span></span><br><span class="line"><span class="comment">// handle cycles well.</span></span><br></pre></td></tr></table></figure><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。其中IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 </p><p>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><p>诸如jQuery之类的框架和库在处理节点之前会删除侦听器（当使用它们的特定API时）。 这由库内部处理，并确保不会产生任何泄漏，即使在有问题的浏览器（如旧版Internet Explorer）下运行也是如此。  </p><p><strong>3.闭包</strong></p><p>JavaScript 开发的一个关键知识是闭包：这是一个内部函数，它可以访问外部（封闭）函数的变量。由于 JavaScript 运行时的实现细节，用下边这种方式可能会造成内存泄漏：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> originalThing = theThing;   </span><br><span class="line">   <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (originalThing)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"hi"</span>);   </span><br><span class="line">&#125;;   </span><br><span class="line">   theThing = &#123;</span><br><span class="line">     longStr: newArray(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">     someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(someMessage);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;; </span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>每次调用<code>replaceThing</code>，<code>theThing</code>得到一个包含一个大数组和一个新闭包（<code>someMethod</code>）的新对象。同时，变量<code>unused</code>是一个引用<code>originalThing</code>的闭包（先前的<code>replaceThing</code>又调用了<code>theThing</code>）。<code>someMethod</code>可以通过<code>theThing</code>使用，<code>someMethod</code>与<code>unused</code>分享闭包作用域，尽管<code>unused</code>从未使用，它引用的<code>originalThing</code>迫使它保留在内存中（防止被回收）。需要记住的是<strong>一旦一个闭包作用域被同一个父作用域的闭包所创建，那么这个作用域是共享的</strong>。</p><p>所有这些都可能导致严重的内存泄漏。当上面的代码片段一次又一次地运行时，你可以看到内存使用量的急剧增加。当垃圾收集器运行时，也不会减少。一个链接列表闭包被创建（在这种情况下 <code>theThing</code> 变量是根源），每一个闭包作用域对打数组进行间接引用。  </p><p>解决方法：</p><p>在 <code>replaceThing</code> 的最后添加 <code>originalThing = null</code> 。将所有联系都切断。</p><p><strong>4.脱离 DOM 的引用</strong>  </p><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。如果在将来某个时候您决定删除这些行，则需要使两个引用都无法访问，都清除掉。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">     button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">     image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</span><br><span class="line">     text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>) </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     image.src = <span class="string">'http://some.url/image'</span>;</span><br><span class="line">     button.click();</span><br><span class="line">     <span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">     <span class="comment">// Much more logic</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// The button is a direct child of body.</span></span><br><span class="line">     <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point, we still have a reference to #button in the global</span></span><br><span class="line">    <span class="comment">// elements dictionary. In other words, the button element is still in</span></span><br><span class="line">    <span class="comment">// memory and cannot be collected by the GC. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code>的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此<code>&lt;td&gt;</code>是表格的子节点，子元素与父元素是引用关系。由于<strong>代码保留了<code>&lt;td&gt;</code>的引用</strong>，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。  </p><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><p>在局部作用域中，等函数执行完毕，变量就没有存在的必要了，js垃圾回收机制很快做出判断并且回收，但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。  </p><p>我们在使用闭包的时候，就会造成严重的内存泄漏，因为闭包的原因，局部变量会一直保存在内存中，所以在使用闭包的时候，要多加小心。  </p><h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4><ul><li><a href="http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf" target="_blank" rel="noopener">http://www-bcf.usc.edu/~dkempe/CS104/08-29.pdf</a></li><li><a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156</a></li><li><a href="http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html" target="_blank" rel="noopener">http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html</a></li></ul><p>如果有别的关于内存泄漏好的资源，可以分享给我嘛谢谢了~   </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在程序运行过程中不再用到的内存，没有及时释放，会出现内存泄漏（memory leak），会造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="内存" scheme="https://luozongmin.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之内存空间</title>
    <link href="https://luozongmin.com/2019/04/22/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"/>
    <id>https://luozongmin.com/2019/04/22/JavaScript系列之内存空间/</id>
    <published>2019-04-22T05:43:00.038Z</published>
    <updated>2019-04-27T01:02:21.761Z</updated>
    
    <content type="html"><![CDATA[<p>对于很多没经验的前端开发来说，觉得JS反正有垃圾回收机制，很容易忽视内存空间的管理，这其实是一个大错误。</p><p>直到最近，看了阮一峰老师关于JS内存泄漏的文章，才发现自己以前写的代码，存在许多内存泄漏的问题，再者，因为忽略对内存空间的学习，导致后面很多进阶概念很模糊，比如闭包、作用域链，比如深拷贝与浅拷贝的区别等等。<a id="more"></a>  </p><p><em>这里先介绍内存空间，后续还会通过别的文章来介绍深浅拷贝和内存泄漏。</em>  </p><h4 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h4><p>JavaScript的内存生命周期:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 分配你所需要的内存</span><br><span class="line">2. 使用分配到的内存（读、写）</span><br><span class="line">3. 不需要时将其释放、归还</span><br></pre></td></tr></table></figure><p>为了便于理解，我们使用一个简单的例子来解释这个周期。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;  <span class="comment">// 在内存中给数值变量分配空间</span></span><br><span class="line">alert(a + <span class="number">90</span>);  <span class="comment">// 使用分配到的内存</span></span><br><span class="line">a = <span class="literal">null</span>; <span class="comment">// 使用完毕之后，释放内存空间</span></span><br></pre></td></tr></table></figure><p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，<strong>栈内存(stack)</strong>与<strong>堆内存(heap)</strong>。  </p><h4 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h4><p>栈(stack)是有序的，主要存放一些<strong>基本类型的变量和对象的地址</strong>，每个区块按照一定次序存放（后进先出），它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小也是确定的，并由系统自动分配和自动释放。   </p><p>因此，这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间，且寻址速度也更快。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/22/5cbd550ebf347.jpg" alt>    </div></p><p>堆(heap)是没有特别的顺序的，数据可以任意存放，多用于<strong>复杂数据类型（引用类型）</strong>分配空间，例如数组对象、object对象。   </p><p>其实这样说也不太准确，因为，引用类型数据的地址是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得想要访问对象的地址，然后，再通过地址指向找出堆中的所需数据。就好比书架上的书，虽然已经按顺序放好了，但我们只要知道书的名字，就可以对应的取下来。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/22/5cbd5542327bb.jpg" alt>     </div></p><h4 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h4><p>首先，我们来看一下代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始类型都放在栈（stack）里</span></span><br><span class="line"><span class="comment">//引用类型都放在堆（heap）里</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'lzm'</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = &#123; <span class="attr">n</span>: <span class="number">22</span> &#125;; <span class="comment">//地址假设为0x0012ff7f，不代表实际地址</span></span><br><span class="line"><span class="keyword">var</span> e = &#123; <span class="attr">n</span>: <span class="number">22</span> &#125;; <span class="comment">//重新开辟一段内存空间，地址假设为0x0012ff8c</span></span><br><span class="line"><span class="built_in">console</span>.log(e==d); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//地址假设为0x0012ff9d</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]; <span class="comment">//地址假设为0x0012ff6e</span></span><br></pre></td></tr></table></figure><p>为什么<code>console.log(e == d)</code>的结果为<code>false</code>？可以用下面的内存图解释：   </p><p><div align="center"><img src="https://i.loli.net/2019/04/22/5cbd55a383967.jpg" alt>    </div></p><p>变量a,b,c为基本数据类型，它们的值，直接存放在栈中，d,e,obj,arr为复合数据类型，他们的引用变量及地址存储在栈中，指向于存储在堆中的实际对象。我们是无法直接操纵堆中的数据的，也就是说我们无法直接操纵对象，我们只能通过栈中对对象的引用来操作对象，就像我们通过遥控机操作电视一样，区别在于这台电视本身并没有控制按钮。   </p><p>变量d,e虽然指向存在堆内存中对象内容的值是相等的，但是它们来自栈内存中变量地址不相同，导致<code>console.log(e == d)</code>的结果为<code>false</code>。   </p><p>这里就回到了最初的疑问，为什么原始类型值要放在栈中，而引用类型值要放在堆中，为什么要分开放置呢？单列一种内存岂不是更省事吗？那接下来，援引<a href="http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html" target="_blank" rel="noopener">这篇文章</a>里边的解释：   </p><p>记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题。堆比栈大，栈比堆的运算速度快,对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。所以简单数据类型的值直接存放在栈中。   </p><h4 id="比较抠细节的面试题"><a href="#比较抠细节的面试题" class="headerlink" title="比较抠细节的面试题"></a>比较抠细节的面试题</h4><p>下面的几道是关于内存空间的面试题，虽然不是特别的难，但比较扣细节你稍不注意就错了，我的建议还是老老实实画个内存图再自信的给出正确答案吧。   </p><p><strong>第一题：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> </span><br><span class="line"><span class="keyword">var</span> b = a </span><br><span class="line">b = <span class="number">2</span> </span><br><span class="line">请问 a 显示是几？</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://i.loli.net/2019/04/22/5cbd56687dc08.jpg" alt>     </div></p><p>上图中可以看出，答案为：1。在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值。<code>var b = a</code>执行之后，a与b虽然值都等于1，但是他们其实已经是相互独立互不影响的值了。 </p><p><strong>第二题：</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = &#123;<span class="attr">name</span>: <span class="string">'b'</span>&#125;</span><br><span class="line">请问现在 a.name 是多少？</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://i.loli.net/2019/04/22/5cbd56bd41245.jpg" alt>     </div></p><p>上图中可以看出，答案为：”a”。因为<code>b ={name:&#39;b&#39;}</code>后相当于重新在堆内存中分配内存给对象<code>{name:&#39;b&#39;}</code>，同时栈内存中变量b的指向地址也随之变化，变量a不受影响。   </p><p><strong>第三题：</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125; </span><br><span class="line"><span class="keyword">var</span> b = a </span><br><span class="line">b.name = <span class="string">'b'</span> </span><br><span class="line">请问现在 a.name 是多少？</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://i.loli.net/2019/04/22/5cbd570e6f668.jpg" alt>    </div></p><p>上图中可以看出，答案为：”b”。我们通过<code>var b = a</code>执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在堆内存中访问到的具体对象实际上是同一个，因此<code>b.name =&#39;b&#39;</code>使堆内存中对象的value值变化，<code>a.name</code>的值也随之变化。  </p><p><strong>第四题：</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125; </span><br><span class="line"><span class="keyword">var</span> b = a </span><br><span class="line">b = <span class="literal">null</span> </span><br><span class="line">请问现在 a 是什么？</span><br></pre></td></tr></table></figure><p><div align="center"><img src="https://i.loli.net/2019/04/27/5cc3a4be50af5.jpg" alt>    </div></p><p>上图中可以看出，答案为：{name: “a”}。因为<code>null</code>为基本类型，存在栈内存当中。因此栈内存中的变量b由之前指向对象的一个地址转变为<code>null</code>，变量a的地址还是指向原先的对象。  </p><p>最后来个图总结一下：</p><p><div align="center"><img src="https://i.loli.net/2019/04/22/5cbd7a4eae053.png" alt>  </div></p><p>以上都是通过内存图来解释关于内存空间的知识，如有不合理的地方，希望指正一下~后续还会增加内存泄漏以及深浅拷贝的文章，敬请期待！</p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于很多没经验的前端开发来说，觉得JS反正有垃圾回收机制，很容易忽视内存空间的管理，这其实是一个大错误。&lt;/p&gt;
&lt;p&gt;直到最近，看了阮一峰老师关于JS内存泄漏的文章，才发现自己以前写的代码，存在许多内存泄漏的问题，再者，因为忽略对内存空间的学习，导致后面很多进阶概念很模糊，比如闭包、作用域链，比如深拷贝与浅拷贝的区别等等。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="内存" scheme="https://luozongmin.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>学会如何学习（三）</title>
    <link href="https://luozongmin.com/2019/04/20/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://luozongmin.com/2019/04/20/学会如何学习（三）/</id>
    <published>2019-04-20T02:17:19.625Z</published>
    <updated>2019-04-20T02:25:29.923Z</updated>
    
    <content type="html"><![CDATA[<p>第三周的学习因为拖延稍微拖了那么几天，而这周的主题又刚好是拖延症与记忆的关系。想要高效地学习，就得学会如何运用和提高自己的记忆能力，而这个过程中，必须先克服拖延症。所以上完这节课，我是该好好改改拖延的老毛病了嘻嘻~ <a id="more"></a>    </p><h4 id="拖延症的形成"><a href="#拖延症的形成" class="headerlink" title="拖延症的形成"></a>拖延症的形成</h4><p>我们常在那些让人不太舒服的事情上拖延，这点大家或多或少都会有，那事实结果是，拖延是一个极其重要、影响广泛的坏习惯，生活的方方面面都会受到拖延的影响。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/20/5cba819ec761f.jpg" alt>     </div></p><p>这里要强调一下，很多人觉得能靠自己的意志力去战胜拖延症，其实这是适得其反的。人每天的意志力是有限的，调用意志力去克服一件困难的事，会大量消耗能量。为什么拖延症这么容易就产生，是因为它变成了习惯，习惯是不需要意志力去执行的，它能减少大脑的消耗。所以改变习惯，是改变拖延症的正确方法。   </p><h4 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h4><p>习惯可以分为四个阶段：  </p><p><div align="center"><img src="https://i.loli.net/2019/04/20/5cba81d442a89.jpg" alt>   </div></p><p>第一阶段是<strong>提示 (cue)</strong> ，是指引发你进行某种惯例的信息来源。比如朋友发来的一条微信信息，或是你看到了待办事项清单上的第一件事等等。   </p><p>第二个阶段就是<strong>惯例 (routine)</strong>，是指你对提示做出的惯性反应。比如看到微信信息就觉得要立马停下手头上的事情去回信息；看到待办的事情就想着当下去解决掉它。这里一个好的建议是，你可以通过关掉手机或者断网，或者远离其他占用碎片时间的消遣来隔离那些最具杀伤力的信号，就像你在进行番茄工作法那样。   </p><p>第三阶段是<strong>奖励 (reward)</strong>，是指你做完这个惯例之后得到的反馈，它会刺激你不断按照之前的惯例行事。任何一种习惯得以发展和延续都是因为它可以回报我们，它会立即给我们带来些许愉悦感。拖延是极易产生的习惯，因为你将关注点转向更令人愉悦的事情后，随之而来的奖励迅速而又简单。好习惯也是有奖励的，对于克服拖延症来说，想办法奖励好习惯非常重要，<strong>只有当大脑开始期待那个奖励，旧习惯才能得到重置，你才能养成新习惯</strong>。    </p><p>研究发现需要给奖励设定时间点。比如说，午休与朋友到快餐店吃饭，或是在下午5点结束主要的任务。这样小而实在的截止期限可以激励你很好地去工作。   </p><p>第四阶段是<strong>信念 (belief)</strong> 。改变拖延习惯最重要的一点就是“相信自己能够做到”的这个信念，就好比说必须要摒弃“自己不是学这块知识的料”这一习惯想法，而是要保持自己能够学好的信念并为之做出应有的努力。   </p><h4 id="应对生活和学习"><a href="#应对生活和学习" class="headerlink" title="应对生活和学习"></a>应对生活和学习</h4><p>要保持对学习目标的展望，一个很好的办法是每周写下本周关键任务列表，试着在前一晚写下第二日的任务，为什么要在前一晚呢？ 研究表明，这可以让你在潜意识下设法解决任务，从而找到完成方法。  </p><p>列下任务清单后，每天花一个或几个番茄钟的时间完成它们。如果可以短时间完成的任务，可以采用结果导向，如果不是则关注过程。你不必一定要设置25分钟的番茄钟，比如22分钟也是可行的。   </p><p>其实，<strong>当你能对一定时间内自己可以完成的工作量做出较准确的判断时，你将很快进步</strong>。计划好完成目标的时间是合理且最为重要的一点，计划你的休息时间和计划工作时间也同样重要，就是在努力学习之余保持健康休闲时间的人，其表现往往胜过那些一味努力学习的人，所以从现在开始，在努力工作学习之余试着挤出点休息时间吧！   </p><p>芭芭拉老师还建议在<strong>早晨尽量先开始最重要且最讨厌，最难的工作，至少做一个番茄时间，这证明了极其有效</strong>！有时会发生一些意料之外的事，我们当然需要对计划作出改变，但是请记住幸运法则——<strong>幸运女神会眷顾努力之人</strong>。良好的计划也是努力的一部分，关注学习目标，尽量避免因为偶发事件产生的不确定性。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/20/5cba826fd9320.jpg" alt>     </div></p><h4 id="提高记忆力"><a href="#提高记忆力" class="headerlink" title="提高记忆力"></a>提高记忆力</h4><p>改变了拖延症的坏习惯后，我们才能更好地利用记忆去学习。我们的大脑天生就擅长记忆不同的空间信息，如果你受邀参观一所陌生的房子 ，你会很快对这个房子有一个大致的概念。例如，整体的家具布局、房间位置、颜色的搭配。只需几分钟，你的大脑就能获取并存储数以千计的信息，甚至几周后，就算你面对是一堵白墙，也仍然能记起许多细节。这一系列空间信息，帮助你在脑中形成地图。如果能够<strong>充分发挥天生就很强大的视觉和空间记忆能力</strong>，你的记忆潜能就可以得到极大提高。   </p><p>评判一个人的记忆力好坏，主要看他的长期记忆的能力如何，每个人都可以通过集中注意力使某件事物进入你的临时工作记忆，但<strong>从工作记忆进入长期记忆则要满足两个条件。首先它要令人难忘，其次，信息需要复习和回顾</strong>。那如何让它难忘呢？比如记F=ma（力=质量x加速度）这个物理公式，老师把它想象成一只戴着飞行员眼镜的驴(a flying mule，英文首字母对应公式的简写)，躺在她老家厨房的水槽里，这样就完成了把抽象概念变成具体图像。这个比喻是不是很无厘头啊哈哈，所以说记忆大师们都是一些幻想家。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/20/5cba82b726fbe.jpg" alt>     </div></p><p>记忆宫殿（Mind Palace / Memory Palace）就是这么一个虚拟的，让你储存信息的技巧工具。你可以把熟悉的场景，比如你的家，作为一个放置记忆碎片的地方，然后把要记的抽象的东西，通过联想，组团，转化成具体图像，放在那个场景中的某个地方。而且这个图像不需要阐述你要记住的东西的意义，甚至它越是不合常理，越稀奇古怪，效果就越好。因为大脑通常会滤过习以为常的事物，而对令人惊讶的非典型性事件记忆犹新。   </p><p>比如购物清单上要买的牛奶、面包、鸡蛋，使用这个技巧你可以想象在你的家中，有一大瓶牛奶在前门，面包掉到了沙发上，裂了的鸡蛋从咖啡桌边缘滴落。也就是说，你可以想象自己穿过一个熟悉的地方，伴随着一些与要记忆的物体相关的难忘画面，这种记忆方式往往记得很牢。   </p><p>题外话，爱看港剧的朋友，相信对TVB剧《读心神探》中的记忆宫殿印象深刻。第三集中有一段对记忆方法的特写，我们一起来细究一下吧！第三集刚开始的时候讲的就是记忆人名头像。那么记忆人名第一步就是观察人物的长相特征，这个特征可以看人物穿的衣服，戴的装饰品，五官的长相特点，发型，声音的特色等等，找出特点以后第二步就是对人物的名字进行联想。比如有个人叫袁泉，而正好她戴了一对圆圆的耳环，那么就很容易联想到“圆圈”（利用名字的谐音记忆）；又比如有人叫邓超，那么你可以联想到这个和你初识时，眼睛“邓”的超大的痴痴的望着你，只要你这么一想，那么这个人物名字肯定就在你脑海里留下了深刻的印象，虽然有点点毛骨悚然哈哈。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/20/5cba82e86bc7c.jpg" alt>    </div></p><p>看完上面举得例子也许会有人会问你那些名字和特征都是你事先设想好的，所以才容易发现名字与特征之间的联系，但其实这些都是临时想到的真实案例，<strong>其实我们能够观察到的特征是有限的，但是人的想象是无限的</strong>，只要你的想法足够好那肯定能找到一个人物的特征与名字之间的完美契合点，这也是记忆法的精髓。   </p><p>最后，在这一周的课外采访中，受采访者是一名美国记忆比赛的冠军，他是“记忆宫殿”这个技巧的专家。他给大家的学习建议是——保持孩童般的想象力与好奇心，通过新奇的想象来帮助你记忆，让学习变得有趣和容易。大家从现在开始不妨试一试~   </p><p>下一节课我们会学习复兴式学习与潜力的关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三周的学习因为拖延稍微拖了那么几天，而这周的主题又刚好是拖延症与记忆的关系。想要高效地学习，就得学会如何运用和提高自己的记忆能力，而这个过程中，必须先克服拖延症。所以上完这节课，我是该好好改改拖延的老毛病了嘻嘻~
    
    </summary>
    
      <category term="学习之道" scheme="https://luozongmin.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="高效学习" scheme="https://luozongmin.com/tags/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法" scheme="https://luozongmin.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Undefined vs Null</title>
    <link href="https://luozongmin.com/2019/04/19/Undefined%20vs%20Null/"/>
    <id>https://luozongmin.com/2019/04/19/Undefined vs Null/</id>
    <published>2019-04-19T02:11:15.201Z</published>
    <updated>2019-04-22T10:10:41.046Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript中，将一个变量赋值为undefined或null，感觉没啥区别，都表示“无”；但在实际应用中，远非如此，这两个之间区别的不明确可能会导致一些问题。<a id="more"></a>  </p><p><em>在<a href="https://luozongmin.com/2019/04/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">这篇文章</a>中，我已经简略介绍了<code>undefined</code>和<code>null</code>的特性了。</em></p><p>本文将探讨JavaScript中<code>undefined</code>和<code>null</code>之间的相似和差异之处。  </p><h4 id="相似性"><a href="#相似性" class="headerlink" title="相似性"></a>相似性</h4><p>（1）<code>undefined</code>和<code>null</code>在if语句中，都会被自动转为<code>false</code>，加!转换为<code>true</code>，相等运算符对于两者比较是相等的。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'undefined is false'</span>);</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'null is false'</span>);</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（2）在JavaScript中，只有六个假值，<code>null</code>和<code>undefined</code>都包含在六个假值中。   </p><ul><li>false</li><li>0</li><li>‘’ (空字符串，’’和””一样)</li><li><strong>null</strong></li><li><strong>undefined</strong></li><li>NaN</li></ul><p>除了这六个值，JavaScript中的任何其他值都被认为是真值。  </p><p>（3）同样在JavaScript中，有六个原始值，<code>null</code>和<code>undefined</code>都包含在这六个原始值中。  </p><ul><li>Boolean</li><li><strong>Null</strong></li><li><strong>Undefined</strong></li><li>Number</li><li>String</li><li>Symbol</li></ul><p>既然<code>undefined</code>和<code>null</code>的含义与用法都比较相似，那为什么还要无端增加另外一个值，这不是增加混淆吗？   </p><h4 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h4><p>最近，在阅读阮一峰老师的博客文章时，才从历史因素里得到答案！  </p><p>1995年JavaScript诞生之初，像Java一样，只设置了<code>null</code>作为表示”无”的值。  </p><p>根据C语言的传统，<code>null</code>被设计成可以自动转为0。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> + <span class="literal">null</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>但是，JavaScript的设计者Brendan Eich，觉得这样做达不到自己的预想，其中有两个原因。   </p><p>首先，<code>null</code>像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。  </p><p>其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果<code>null</code>自动转为0，很不容易发现错误。  </p><p>因此，Brendan Eich又设计增加了一个<code>undefined</code>。  </p><h4 id="差异性"><a href="#差异性" class="headerlink" title="差异性"></a>差异性</h4><p><strong>（1）数据类型区别</strong>  </p><p><code>undefined</code>类型只有一个值，undefined；<code>null</code>类型只有一个值，null。  </p><p>也就是说<code>undefined</code>值和<code>null</code>值分别属于不同的数据类型，并且这两个数据类型都只有一个值，使用“typeof”运算符判断类型。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);   <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>第一行输出没毛病，正确打印出<code>undefined</code>类型；而第二行打印结果为<code>object</code>，难道<code>null</code>不是<code>null</code>类型？  </p><p>原因解释：这是JS一个设计失误，原本正确的结果应该是<code>null</code>，现在只能将错就错，或许以后哪个新版本会修正此问题。   </p><p><strong>（2）转为数值区别</strong>  </p><p>JavaScript的最初版本为了更好区分这两个值，是这样设定的：<code>null</code>是一个表示”无”的对象，转为数值时为0；<code>undefined</code>是一个表示”无”的<strong>原始值</strong>，转为数值时为<code>NaN</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1= <span class="number">5</span> + <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a1)  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2= <span class="number">5</span> + <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a2)  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>（3）null !== undefined</strong>   </p><p>如上所见，<code>null</code>和<code>undefined</code>不同，但有一些相似之处， 因此，ECMAScript规范规定<code>null</code>不严格等于<code>undefined</code>。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> !== <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但是，上面也提到了，<code>null</code>松散相等于<code>undefined</code>（相比===的相等程度更低）。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在JavaScript中，==适用松散相等，意味着我们在将它们转换为通用类型后比较两个值。   </p><p>只要记住<code>null==undefined</code>会返回<code>true</code>，因为它们是类似的值；但<code>null===undefined</code>会返回<code>false</code>，因为它们是不同类型的值。后续也会增加==与===区别的文章，敬请期待。  </p><h4 id="实际用法"><a href="#实际用法" class="headerlink" title="实际用法"></a>实际用法</h4><p>但是，上面的区分，在实践中都不常用。实际上，<code>null</code>和<code>undefined</code>被视为几乎同义的，只有一些细小的差别。  </p><p><strong>null表示一个变量被人为的设置为空对象，而不是原始状态，即该处不应该有值。</strong>一般会在以下 2 种场景中出现：</p><p>（1） 利用document.getElementById(‘XXX’) 寻找一个不存在的元素，将返回null。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="built_in">document</span>.getElementById(<span class="string">'notExistElement'</span>))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（2） 作为对象原型链的终点。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)  <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><strong>undefined表示一个变量自然的、最原始的状态值，就是此处应该有一个值，但是还没有定义。</strong>一般会在以下 4 种场景中出现：  </p><p>（1）声明了一个变量，但没有赋值，就等于<code>undefined</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>（2) 函数定义了形参，但没有传递实参，该参数等于<code>undefined</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义了形参 a </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(a); <span class="comment">// undefined </span></span><br><span class="line">&#125;  </span><br><span class="line">f(); <span class="comment">//未传递实参</span></span><br></pre></td></tr></table></figure><p>（3）访问对象上不存在的属性，该属性的值为<code>undefined</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">a.p <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>（4）函数没有返回值时，默认返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = f()</span><br><span class="line">a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 <code>undefined</code>，当需要<strong>释放一个对象</strong>时，直接赋值为 <code>null</code> 即可。 </p><p>最后引用玉伯大大对null和undefined的解释：  </p><p>值类型的“虚无”用<code>undefined</code>，引用类型的“虚无”，用<code>null</code>。   </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JavaScript中，将一个变量赋值为undefined或null，感觉没啥区别，都表示“无”；但在实际应用中，远非如此，这两个之间区别的不明确可能会导致一些问题。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之类型转换</title>
    <link href="https://luozongmin.com/2019/04/18/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://luozongmin.com/2019/04/18/JavaScript系列之类型转换/</id>
    <published>2019-04-18T09:17:22.626Z</published>
    <updated>2019-04-22T10:09:46.603Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 是一种<strong>弱类型</strong>或者说是一门<strong>动态</strong>语言，这意味着你不用提前声明变量的类型，而是在程序运行过程中，运算符会自动将值转换为正确的类型，但也有一些情况需要强制类型转换。<a id="more"></a>    </p><p>以下我将介绍将各种类型的值，分别转换成<strong>数字</strong>、<strong>字符串</strong>或者<strong>布尔值</strong>（基于ES5规范）。   </p><h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h4><p><strong>（1）Number()</strong>   </p><p>使用Number函数，可以将任意类型的值转化成数值。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">123</span>)  <span class="comment">// 123  转换后为原值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'123'</span>)  <span class="comment">// 123  转换为相应的数值，前提能被解析为数值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'123abc'</span>)   <span class="comment">// NaN  如果不能被解析为数值，则返回 NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">5</span>]) <span class="comment">// 5  //包含单个数值的数组将返回数字</span></span><br></pre></td></tr></table></figure><p><strong>（2）ParseInt()</strong>   </p><p><code>parseInt</code>函数可用于将字符串转为整数。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>)  <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'   123'</span>)  <span class="comment">// 123  如果字符串头部有空格，空格会被自动去除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>)  <span class="comment">// 1  如果参数不是字符串，则会先转为字符串再转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8a'</span>)  <span class="comment">//  8  如果遇到不能转为数字的字符，就不再进行下去，返回可转的部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>)  <span class="comment">// NaN  如果第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+1'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">10</span>) <span class="comment">// 1000  第二个参数（2到36之间），表示被解析的值的进制</span></span><br></pre></td></tr></table></figure><p>如上，<code>Number()</code>函数会整体将目标字符串转为数值，只要有一个字符无法转成数值，目标就会被转为<code>NaN</code>，这点要比<code>parseInt()</code>函数严格很多。   </p><p>这里要注意一点，就是转换’011’时看起来01结构是8进制，实际上JS经过升级，后面加逗号8才是转为8进制或其他进制。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'011'</span>)  <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'011'</span> , <span class="number">8</span>)  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p><strong>（3）ParseFloat()</strong><br><code>parseFloat</code>函数用于将一个字符串转为浮点数。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14'</span>)  <span class="comment">//  3.14</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14more'</span>) <span class="comment">// 3.14  如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'AAA'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN  如果参数不是字符串或空，亦或字符串的第一个字符不能转化为浮点数，则返回NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中，尤其注意的是，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。  </p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'1.23A'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1.23A'</span>) <span class="comment">// 1.23</span></span><br></pre></td></tr></table></figure><p><strong>（4）字符串减0</strong>   </p><p>字符串数字后直接减一个0，可将字符串转为数值。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span> - <span class="number">0</span>  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">'123'</span> - <span class="number">0</span>  <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">'1.23'</span> - <span class="number">0</span>  <span class="comment">// 1.23</span></span><br><span class="line"></span><br><span class="line"><span class="string">'12A'</span> - <span class="number">0</span>  <span class="comment">// NaN  字符串里不是数字，则返回NaN</span></span><br><span class="line"><span class="string">'null'</span> - <span class="number">0</span>  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串减0操作既有<code>parseInt</code>、也有<code>parseFloat</code>的功能。   </p><p>还比较省代码数量，在实际应用中会比较常见。   </p><p><strong>（5）字符串前加+</strong>   </p><p>字符串数字前加一个+，可将字符串转为数字。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">'1'</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">+ <span class="string">'1.23'</span> <span class="comment">// 1.23</span></span><br><span class="line"></span><br><span class="line">+ <span class="string">'.1'</span> <span class="comment">// 0.1</span></span><br><span class="line"></span><br><span class="line">+ <span class="string">'-1'</span> <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">+ <span class="string">'12A'</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串前加+操作也有<code>parseInt</code>和<code>parseFloat</code>的功能。  </p><h4 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h4><p><strong>（1）toString()</strong>   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.toString()  <span class="comment">// "123"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span></span><br><span class="line">a.toString()  <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span></span><br><span class="line">a.toString()  <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line">a.toString()  <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a.toString()  <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure><p>上面代码中，注意一点<code>null</code>、<code>undefined</code>用<code>toString()</code>转为字符串是不行的，而且<code>toString()</code>方法占的字节较多，那么有别的解决方法吗？   </p><p><strong>（2）加’’(双引号)</strong>   </p><p>当然有，更常用的转为字符串方法为：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="number">1</span> + <span class="string">''</span>  <span class="comment">// "1" </span></span><br><span class="line"><span class="string">''</span> + <span class="number">1</span>  <span class="comment">// "1" </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">''</span> <span class="comment">// "true"</span></span><br><span class="line"><span class="string">''</span> + <span class="literal">true</span> <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">''</span>  <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">''</span>  <span class="comment">// "null"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj + <span class="string">''</span>  <span class="comment">// "[object Object]"</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + <span class="string">''</span>  <span class="comment">// "1,2,3"  数组，返回该数组的字符串形式</span></span><br></pre></td></tr></table></figure><p>相比<code>toString()</code>方法，这种方法更为常用，且和前后加’’的顺序无关。   </p><p><strong>（3）String()</strong>   </p><p><code>String</code>函数可以将任意类型的值转化成字符串。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>) <span class="comment">// "123"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>) <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>) <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">// "null"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// "1,2,3"  数组，返回该数组的字符串形式</span></span><br></pre></td></tr></table></figure><h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p><strong>（1）Boolean()</strong>  </p><p><code>Boolean</code>函数可以将任意类型的值转为布尔值。   </p><p>它的转换规则比较简单：除了以下五个<code>falsy</code>值的转换结果为<code>false</code>，其余的值全部为<code>true</code>。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false 包括+0、-0</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">// false 和""一样都为空字符串，这里当成同一种</span></span><br></pre></td></tr></table></figure><p>所以的话，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>Boolean()</code>操作对于’’和’ ‘（中间有空格）的结果是不一样的：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'  '</span>)  <span class="comment">// true 因为中间有空格，代表有空格键输入，不算真正意义上的无内容</span></span><br></pre></td></tr></table></figure><p><strong>（2）类型值前加！！</strong>   </p><p>任何数据类型值前面加两个！！，都可以将其转为布尔类型。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">// false </span></span><br><span class="line">!!<span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">''</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>从<code>Boolean()</code>九个字符变为！！两个字符，省了代码量；转换规则也与<code>Boolean</code>函数一致，故老手多用此类方法。  </p><p>目前总结的就这么多啦，如有一些遗漏或有误的地方，欢迎大家指正~</p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 是一种&lt;strong&gt;弱类型&lt;/strong&gt;或者说是一门&lt;strong&gt;动态&lt;/strong&gt;语言，这意味着你不用提前声明变量的类型，而是在程序运行过程中，运算符会自动将值转换为正确的类型，但也有一些情况需要强制类型转换。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="数据类型" scheme="https://luozongmin.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>一些好用的工具、网站</title>
    <link href="https://luozongmin.com/2019/04/16/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99/"/>
    <id>https://luozongmin.com/2019/04/16/一些好用的工具、网站/</id>
    <published>2019-04-16T01:51:32.816Z</published>
    <updated>2019-04-22T10:11:18.489Z</updated>
    
    <content type="html"><![CDATA[<p>这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。<a id="more"></a>    </p><h4 id="Evernote：一款神奇的笔记"><a href="#Evernote：一款神奇的笔记" class="headerlink" title="Evernote：一款神奇的笔记"></a>Evernote：一款神奇的笔记</h4><p>✔如果一款工具能满足你对笔记的所有需求的话，那就是Evernote了，写笔记，列清单，时间管理，录音，工作同步，手机和电脑端都可下载…   </p><p>✔如果你还没用过，推荐你现在关闭答案去应用市场下载一个，相信我你都会爱上它的。</p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb537135a898.jpg" alt></div></p><h4 id="免费人工智能PPT制作平台：beautiful-ai"><a href="#免费人工智能PPT制作平台：beautiful-ai" class="headerlink" title="免费人工智能PPT制作平台：beautiful.ai"></a>免费人工智能PPT制作平台：<a href="https://www.beautiful.ai/" target="_blank" rel="noopener">beautiful.ai</a></h4><p>✔这个国外的黑科技网站，网站提供很多超赞的板式，我们将文字放进去，AI智能帮助我们制作PPT。真的让我这个一做PPT就头疼的人，感到开心！   </p><p>✔没广告还免费！   </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb5375d20554.jpg" alt></div></p><h4 id="录制GIF工具-：GifCam"><a href="#录制GIF工具-：GifCam" class="headerlink" title="录制GIF工具 ：GifCam"></a>录制GIF工具 ：GifCam</h4><p>✔录制动图对许多人来说也算是必备的东西了。   </p><p>✔窗口化录屏，也可以直接设置全屏幕录制，录制完毕后直接保存为 GIF 图片，软件大小不超过 2M，简直太方便太良心了~    </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb5378fbccb4.jpg" alt></div></p><h4 id="截图-贴图神器：Snipaste"><a href="#截图-贴图神器：Snipaste" class="headerlink" title="截图/贴图神器：Snipaste"></a>截图/贴图神器：Snipaste</h4><p>✔它在我心中绝对可以堪称神器了！令人惊叹不仅仅是它的强大截图功能，而是它的贴图功能也实在是太好用了！   </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb53dd9da54a.jpg" alt></div></p><h4 id="设计网址导航网站：牛大拿"><a href="#设计网址导航网站：牛大拿" class="headerlink" title="设计网址导航网站：牛大拿"></a>设计网址导航网站：<a href="http://www.niudana.com/" target="_blank" rel="noopener">牛大拿</a></h4><p>✔精选国内外优秀的UI设计网站,设计参考文章与免费的UI设计素材与资源，每日更新Dribbble精选内容、Behance精选内容、站酷精选内容、UI中国…   </p><p>✔一定也有设计师不知道这个网站滴。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb538b51f68d.jpg" alt></div></p><h4 id="国外设计师常用网站：Dribbble"><a href="#国外设计师常用网站：Dribbble" class="headerlink" title="国外设计师常用网站：Dribbble"></a>国外设计师常用网站：<a href="https://dribbble.com/" target="_blank" rel="noopener">Dribbble</a></h4><p>✔通过 Dribbble，你可以浏览许多创意设计，它们出自世界各地的个人设计师、设计团队以及设计公司。   </p><p>✔这些作品并不仅限于网页或手机 app 设计，还有图片设计、品牌设计、动画、插图、平面艺术等等。    </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb538fcec96e.jpg" alt></div></p><h4 id="国内设计师常用网站：花瓣网"><a href="#国内设计师常用网站：花瓣网" class="headerlink" title="国内设计师常用网站：花瓣网"></a>国内设计师常用网站：花瓣网</h4><p>✔花瓣网算是一个国内比较好的素材采集网，平时想要找的各种类型的图片素材在花瓣都能采集到，比如平面、漫画、摄影、UI等等。    </p><p>✔而且花瓣的素材普遍都很有设计感和时尚感，很适合年轻一代做设计。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb53952ed83f.jpg" alt> </div></p><h4 id="设计师和开发常用网站：iconfont-cn"><a href="#设计师和开发常用网站：iconfont-cn" class="headerlink" title="设计师和开发常用网站：iconfont.cn"></a>设计师和开发常用网站：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont.cn</a></h4><p>✔阿里巴巴旗下的免费icon百科网站，可免费下载矢量源文件，选择时可以打包所有你感兴趣的放在购物车，Download时还可以选择颜色和大小,很贴心有木有！同时支持下载开发用代码。   </p><p>✔比如搜索关键词“love”看到的结果：   </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb539a32bc89.jpg" alt></div></p><h4 id="壁纸天堂：Wallhaven"><a href="#壁纸天堂：Wallhaven" class="headerlink" title="壁纸天堂：Wallhaven"></a>壁纸天堂：<a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">Wallhaven</a></h4><p>✔图片量大而且还高清，分类清晰(人物/风景/动画)。   </p><p>✔相比一些图库不全，广告遍地，收费下载的壁纸网站，免费下载的wallhaven简直就是业界良心。</p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb53a3e79f0f.jpg" alt></div></p><h4 id="在线制作流程图网站：ProcessOn"><a href="#在线制作流程图网站：ProcessOn" class="headerlink" title="在线制作流程图网站：ProcessOn"></a>在线制作流程图网站：<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a></h4><p>✔ProcessOn在线支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 </p><p>✔轻松绘制，基本上是0难度上手。</p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb53b1642966.jpg" alt></div></p><h4 id="在线生成图片链接网站：SM-MS"><a href="#在线生成图片链接网站：SM-MS" class="headerlink" title="在线生成图片链接网站：SM.MS"></a>在线生成图片链接网站：<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a></h4><p>✔SM.MS图床网站只需上传一张本地的图片，点击生成链接即可，操作简单快捷。</p><p>✔永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb53bb13118e.jpg" alt></div></p><h4 id="Listary：电脑文件秒搜-路径直达"><a href="#Listary：电脑文件秒搜-路径直达" class="headerlink" title="Listary：电脑文件秒搜+路径直达"></a>Listary：电脑文件秒搜+路径直达</h4><p>✔软件体积非常小，全局本地搜索的便捷工具，设置热键后，能在任何环境下调出窗口搜索文件，如我设置的是’Win+F’，想要找某文件时按下Win+F调出小长条搜索框就能进行实时搜索，非常便捷。    </p><p>✔相信你用了后会觉得它很高效的。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb53c4ee1e21.jpg" alt></div></p><h4 id="v9porn"><a href="#v9porn" class="headerlink" title="v9porn"></a><a href="https://github.com/techGay/v9porn" target="_blank" rel="noopener">v9porn</a></h4><p>✔看到上面的标题，想必大多数人都知道了吧嘿嘿嘿</p><p>✔那这个项目就不多介绍了，自行体会，体验好的话就默默点个赞哦   </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb53cb594df1.jpg" alt>  </div></p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。
    
    </summary>
    
      <category term="tools" scheme="https://luozongmin.com/categories/tools/"/>
    
    
      <category term="工具" scheme="https://luozongmin.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之类型判断</title>
    <link href="https://luozongmin.com/2019/04/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>https://luozongmin.com/2019/04/13/JavaScript系列之类型判断/</id>
    <published>2019-04-13T04:52:19.699Z</published>
    <updated>2019-04-22T10:09:36.111Z</updated>
    
    <content type="html"><![CDATA[<p>类型判断在 web 开发中较为常见，简单的有判断数字还是字符串，判断是数组还是对象稍微复杂一些，再复杂一点的有判断日期、正则、错误类型，再再复杂一点还有比如判断 plainObject、空对象、Window 对象等等。<a id="more"></a>     </p><p>通过本文，我将尝试概述Javascript中类型判断的几种方法（<strong>基于ES5的规范</strong>）。</p><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>typeof判断类型方法算是我们最最常用的了，直接上代码：   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">3</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"abc"</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><p>以上这些类型都比较正常，直到：   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>这显然是一个错误。 这可能会在以后的ECMAScript哪个版本中修复，返回值将为“<code>null</code>”。   </p><p>除此之外 <code>Object</code> 下还有很多细分的类型，比如 <code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code> 等。如果用 <code>typeof</code> 去检测这些类型，举其中几个例子：   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = []</span><br><span class="line"><span class="keyword">var</span> array2 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> array1); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> array2); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> date); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> error); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>因此，<code>typeof</code>非常善于区分不同类型的原始值，并区分它们和对象，但在区分不同类型的对象（包括数组和<code>null</code>）时完全没用，那这该怎么区分？有没有更好的解决方法呢？</p><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><p>JS作为一门愈加成熟的语言，解决方法当然有！嘿嘿~这就是<code>Object.prototype.toString</code>！  </p><p>那 <code>Object.protototype.toString</code>看起来是一长串字母，看起来比较复杂诶~为了讲清楚，在<strong>toString</strong>方法被调用时,是会执行下面的操作步骤的：  </p><ol><li>如果<code>this</code>的值为<code>undefined</code>,则返回”[<code>object Undefined</code>]”.</li><li>如果this的值为<code>null</code>,则返回”[<code>object Null</code>]”.</li><li>让O成为调用<code>ToObject(this)</code>的结果.</li><li>让class成为O的内部属性<code>[[Class]]</code>的值.</li><li>最后返回由 <code>&quot;[object &quot;</code>和 <code>class</code> 和 <code>&quot;]&quot;</code> 三个部分组成的字符串.    </li></ol><p>通过规范，我们至少了解了调用 <code>Object.prototype.toString</code> 最终会返回一个由 <code>&quot;[object &quot;</code> 和 <code>class</code> 和 <code>&quot;]&quot;</code> 组成的字符串，而 <code>class</code> 是要判断的对象的内部属性。</p><p>看这些规范还是一知半解的状态吧，直接上代码直观一点：   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">3</span>)) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)) <span class="comment">// [object Null]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(date)) <span class="comment">// [object Date]</span></span><br></pre></td></tr></table></figure><p>我们可以看到这个 class 值其实就是识别对象类型的关键！    </p><p>因此我们可以用 <code>Object.prototype.toString</code> 方法识别出更多类型！那到底能识别多少种类型呢？那还是看代码数个数吧~嘿嘿    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;          <span class="comment">// [object Number]</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'123'</span>;      <span class="comment">// [object String]</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;      <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="keyword">var</span> unde = <span class="literal">undefined</span>;     <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="keyword">var</span> nul = <span class="literal">null</span>;          <span class="comment">// [object Null]</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;         <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">var</span> array = [];   <span class="comment">// [object Array]</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();   <span class="comment">// [object Date]</span></span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;          <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// [object Function]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTypes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>[i]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkTypes(number, string, bool, unde, nul, obj, array, date, error, reg, func)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出</span></span><br><span class="line">[object <span class="built_in">Number</span>]</span><br><span class="line">[object <span class="built_in">String</span>]</span><br><span class="line">[object <span class="built_in">Boolean</span>]</span><br><span class="line">[object Undefined]</span><br><span class="line">[object Null]</span><br><span class="line">[object <span class="built_in">Object</span>]</span><br><span class="line">[object <span class="built_in">Array</span>]</span><br><span class="line">[object <span class="built_in">Date</span>]</span><br><span class="line">[object <span class="built_in">Error</span>]</span><br><span class="line">[object <span class="built_in">RegExp</span>]</span><br><span class="line">[object <span class="built_in">Function</span>]</span><br></pre></td></tr></table></figure><p>除了以上 11 种之外，还有3种：   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>)); <span class="comment">// [object Math]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>)); <span class="comment">// [object JSON]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>)); </span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// [object Arguments]</span></span><br></pre></td></tr></table></figure><p>这里看我们至少可以识别14 种类型，而[[class]] 属性数量至少有 12 个。</p><h4 id="写个类库"><a href="#写个类库" class="headerlink" title="写个类库"></a>写个类库</h4><p>利用<code>Object.prototype.toString</code>判断类型的方法来写个类库吧，此类库来自(Axis.js)[//github.com/toddmotto/axis]:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否使用了模块</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    <span class="comment">// 使用AMD模块</span></span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用CMD模块</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有使用模块，放在全局下</span></span><br><span class="line">    root.axis = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">var</span> exports = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将字符串转为数组</span></span><br><span class="line">  <span class="keyword">var</span> types = <span class="string">'Array Object String Date RegExp Function Boolean Number Null Undefined'</span>.split(<span class="string">' '</span>);</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 遍历types，为exports对象添加isArray、isObject...等方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = types.length; i--;) &#123;</span><br><span class="line">    exports[<span class="string">'is'</span> + types[i]] = (<span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// type.call(elem)将type方法里的this指针指向elem</span></span><br><span class="line">        <span class="keyword">return</span> type.call(elem) === self;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(types[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用方法也比较简单，直接上代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axis.isArray([]); <span class="comment">// true</span></span><br><span class="line">axis.isObject(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line">axis.isString(<span class="string">''</span>); <span class="comment">// true</span></span><br><span class="line">axis.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// true</span></span><br><span class="line">axis.isRegExp(<span class="regexp">/test/i</span>); <span class="comment">// true</span></span><br><span class="line">axis.isFunction(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// true</span></span><br><span class="line">axis.isBoolean(<span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line">axis.isNumber(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">axis.isNull(<span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line">axis.isUndefined(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>考虑到实际情况下并不会检测 <code>Math</code> 和 <code>JSON</code>，而且上面这种方法也检测不了这两种类型，所以去掉这两个类型的检测。同时也不能识别自定义对象类型。</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>当 <code>typeof</code> 也有无解的时候，那么我们是否还有其他好的方法来判断一个变量是自定义对象类型呢？  </p><p>我们知道，javascript 的所有对象都有一个 <code>constructor</code> 属性，这个属性可以帮我们判断 object 数据类型，直接上代码：   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alert(1.constructor); //报错 数字常量无 constructor 属性   </span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;   </span><br><span class="line"><span class="built_in">console</span>.log(num.constructor == <span class="built_in">Number</span>); <span class="comment">//true   </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"miqilin"</span>.constructor == <span class="built_in">String</span>); <span class="comment">//true   </span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"miqilin"</span>;   </span><br><span class="line"><span class="built_in">console</span>.log(str.constructor == <span class="built_in">String</span>); <span class="comment">//true   </span></span><br><span class="line"><span class="keyword">var</span> obj= <span class="literal">null</span>;   </span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor); <span class="comment">//报错，null 没有 constructor 属性   </span></span><br><span class="line"><span class="keyword">var</span> none = <span class="literal">undefined</span>;   </span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor); <span class="comment">//报错，undefined 没有 constructor 属性</span></span><br></pre></td></tr></table></figure><p>可以看出，数字型常量，<code>null</code> 和 <code>undefined</code> 都没有 <code>constructor</code> 属性。  </p><p>之前以为到这就全部分析完了，看了多篇外文才知道原来还有可挖掘的东西，来看下面的代码：   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">&#125;   </span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();   </span><br><span class="line">Cat.prototype.CatchMouse = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   </span><br><span class="line"><span class="comment">//do some thing   </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Cat();   </span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor == Cat); <span class="comment">//false ？？因为 Cat.prototype不在obj的原型链上   </span></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor == Animal); <span class="comment">//true 理解</span></span><br></pre></td></tr></table></figure><p>原来对于<strong>原型链继承</strong>的情况，<code>constuctor</code> 也不怎么好用了。那怎么办呢？  </p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>嘿嘿~原来还有一种方法可以解决这种困境，那就是 <code>instanceof</code>。<code>instanceof</code> 运算符会告诉您对象是否是某种类型的实例， 这里所谓的“类型”其实就是构造函数。直接上代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">&#125;   </span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();   </span><br><span class="line">Cat.prototype.CatchMouse = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   </span><br><span class="line"><span class="comment">//do some thing   </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Cat();   </span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Cat); <span class="comment">//true 毫无疑问   </span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Animal); <span class="comment">//true 可以理解</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> 适用于所有原生类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">/abc/ <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是 <code>instanceof</code> 不适用于原始类型：字符串，数字，布尔值：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">'abc'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>所以这里<code>constructor</code>又有点优势了，可以适用于原始类型<code>number</code>，<code>string</code>和<code>boolean</code>的判断（<code>constructor</code>小节有例子）。    </p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>虽然检查任何一种特定类型真的不是那么难，但你可能不得不在此过程中做出很多选择，势必会引起一些混乱。因此，了解所有不同的选项会有所帮助，以下是对四种方法可识别类型的简单概括：</p><p><strong>typeof：</strong></p><ul><li>可以是标准类型（<code>Null</code> 除外）</li><li>不可识别具体的对象类型（<code>Function</code> 除外）</li></ul><p><strong>Object.prototype.toString：</strong></p><ul><li>可是识别标准类型及内置对象类型（例如，<code>Object</code>, <code>Date</code>, <code>Array</code>）</li><li>不能识别自定义对象类型</li></ul><p><strong>constructor：</strong></p><ul><li>可以识别标准类型（<code>Undefined</code>/<code>Null</code> 除外）</li><li>可识别内置对象类型</li><li>可识别自定义对象类型</li></ul><p><strong>instanceof：</strong></p><ul><li>不可判别原始类型</li><li>可判别内置对象类型</li><li>可判别自定义对象类型</li></ul><p>类型转换的<strong>图形化</strong>表示（其中红色单元格表示该判断方式不支持的类型）：  </p><p><div align="center"><img src="https://i.loli.net/2019/04/16/5cb55ff78a7cb.png" alt>  </div></p><p>还有更复杂的判断比如 <code>plainObject</code>、空对象、<code>Window</code>对象、类数组对象等，还未涉及，后续也会增加。 敬请关注！  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型判断在 web 开发中较为常见，简单的有判断数字还是字符串，判断是数组还是对象稍微复杂一些，再复杂一点的有判断日期、正则、错误类型，再再复杂一点还有比如判断 plainObject、空对象、Window 对象等等。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="数据类型" scheme="https://luozongmin.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之数据类型</title>
    <link href="https://luozongmin.com/2019/04/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://luozongmin.com/2019/04/12/JavaScript系列之数据类型/</id>
    <published>2019-04-12T05:43:04.131Z</published>
    <updated>2019-04-22T10:10:27.437Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript提供了不同的数据类型来保存不同类型的值，主要有两种类型的数据类型：原始类型和引用类型。<a id="more"></a>    </p><h4 id="原始类型（值类型）"><a href="#原始类型（值类型）" class="headerlink" title="原始类型（值类型）"></a>原始类型（值类型）</h4><ul><li>Undefined <code>undefined</code></li><li>Null <code>null</code></li><li>Boolean <code>true</code></li><li>String <code>&#39;hello&#39;</code></li><li>Number <code>123</code></li><li>Symbol(这里先不做介绍)  </li></ul><h4 id="引用类型（对象类型）"><a href="#引用类型（对象类型）" class="headerlink" title="引用类型（对象类型）"></a>引用类型（对象类型）</h4><ul><li>Object：由以上几种基本类型组成，而且对象里面还可以包含对象   </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">&lt;!-- 原始类型变量的包装类型如下 --&gt;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> obj0 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>如<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">MDN</a>所讲，JavaScript 是一种<strong>弱类型</strong>或者说是一门<strong>动态</strong>语言。这意味着你不用提前声明变量的类型，而是在程序运行过程中，类型会被自动确定。  </p><p>当然，原始类型和引用类型会有一些<strong>区别</strong>：  </p><p>原始类型的值是直接储存在栈（Stack）内存中的，而引用类型的数据是把 Heap内存地址存在 Stack 里，所以对已引用类型的复制其实只是复制了相同的地址而非实际的变量值。   </p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>为整型直接量，浮点型直接量，十六进制直接量（0x-)，八进制直接量（0-）等 出现场合：  </p><ul><li><code>1024</code></li><li><code>3.14</code></li><li><code>1.2e5</code></li><li><code>0x10</code></li><li><code>0o377</code></li></ul><p>除以上常规数字外，还有所谓的“特殊数值”，它们也属于这种数据类型：<code>Infinity</code>，<code>-Infinity</code>和<code>NaN</code>。  </p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>JavaScript中的字符串必须用引号括起来，有3种类型的引号 出现场合：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello, world!"</span>;  <span class="comment">//双引号</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello, world!'</span>; <span class="comment">//单引号</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">`Hello, world!`</span>;  <span class="comment">//反引号</span></span><br></pre></td></tr></table></figure></p><p>双引号和单引号是“简单”引号，它们在JavaScript中没有区别，但由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。   </p><p>反引号是“扩展功能”的引用，允许我们通过将变量和表达式包装在$ {…}中来将它们嵌入到字符串中，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"miqilin"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// embed a variable</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span> ); <span class="comment">// Hello, miqilin!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// embed an expression</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">`the result is <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span> ); <span class="comment">// the result is 3</span></span><br></pre></td></tr></table></figure></p><p>加反引号后计算<code>$ {...}</code>内的表达式，结果会成为字符串的一部分。 我们可以在其中放置任何东西：像名称这样的变量或像1 + 2这样的算术表达式或更复杂的东西。   </p><p>但请注意，这只能在反引号中完成。 其他形式没有这种嵌入功能！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="string">"the result is $&#123;1 + 2&#125;"</span> ); <span class="comment">// the result is $&#123;1 + 2&#125; (双引号不生效)</span></span><br></pre></td></tr></table></figure></p><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>布尔类型只有两个值：<code>true</code> 和 <code>false</code> 出现场合：   </p><ul><li>条件语句导致的系统执行的隐式类型转换 <code>if(隐式转换){}</code></li><li>字面量或变量定义 <code>var bool = true;</code></li><li>也出现在比较的结果 ：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isGreater = <span class="number">4</span> &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( isGreater ); <span class="comment">// true (the comparison result is "yes")</span></span><br></pre></td></tr></table></figure><h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>null 出现场合：</p><ul><li>获取不存在的对象 <code>document.getElementById(&#39;not-exist-element&#39;)</code>  </li></ul><p>在JavaScript中，<code>null</code>不是“对不存在的对象的引用”或者像其他语言中的“空指针”。它只是一个特殊值，代表“无”，“空”或“未知值”。</p><h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p>undefined的含义是“未赋值” 出现场合：</p><ul><li>变量声明了，但没赋值 <code>var obj;</code></li><li>获取对象不存在的属性 <code>var obj = {x: 0}; obj.y;</code></li><li>无返回值函数的执行结果 <code>function f(){}; var obj = f();</code></li><li>调用函数时，应该提供的参数没有提供 <code>function f(i){console.log(i)}; f();</code></li><li><code>void(expression)</code></li></ul><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，老实说，语法效果几乎没区别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但也有一丝区别，区别是这样的：<code>null</code>是一个表示“空”的对象，转为数值时为0；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>属性集合 出现场合：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"miqilin"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sound = <span class="string">"wow"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但请注意，我们还没有提到过<code>Array</code>，<code>Date</code>，甚至是函数，因为正式地说，它们都是对象类型。</p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript提供了不同的数据类型来保存不同类型的值，主要有两种类型的数据类型：原始类型和引用类型。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="数据类型" scheme="https://luozongmin.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>学会如何学习（二）</title>
    <link href="https://luozongmin.com/2019/04/09/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://luozongmin.com/2019/04/09/学会如何学习（二）/</id>
    <published>2019-04-09T02:49:42.728Z</published>
    <updated>2019-04-20T01:55:52.722Z</updated>
    
    <content type="html"><![CDATA[<p>第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。<a id="more"></a>   </p><h3 id="Part1-组块"><a href="#Part1-组块" class="headerlink" title="Part1 组块"></a>Part1 组块</h3><h4 id="什么是组块"><a href="#什么是组块" class="headerlink" title="什么是组块"></a>什么是组块</h4><p>什么是组块 (chunk) ？对于绝大多数人来说这是一个全新的概念，看上去并没有什么意义，就像一堆乱糟糟的拼图。从神经科学的角度来看，<strong>组块就是通过应用或意义连接在一起的信息碎片</strong>。而在不加理解或不关注上下文的情况下，单纯的死记硬背并不能帮助你理解其内涵和你所学概念之间的关联，那么这个概念拼图就没有可以拼合的边缘，无法关联到其他的拼图碎片上。</p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac22ac47cf5.jpg" alt>      </div></p><p>当你全神贯注于某件事上，就好像你的脑子里有一只章鱼。这只注意力的章鱼会在必要时把它的触须穿过工作记忆的四个插槽，从而帮助你把分布于大脑不同区域里的信息联系起来。    </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac22dc53456.jpg" alt>      </div></p><p>这和发散模式下的随机连接不同，创建组块的过程中，它需要集中<strong>注意力</strong>将大脑的不同部分连接起来，专注模式下将不同的想法联系在一起。但在你很紧张时，你的注意力章鱼会失去一些连接能力，这也是为什么在你生气、紧张、害怕的时候，大脑似乎不能专注工作。    </p><p>在任何领域获得专业知识的第一步都是先创建出概念组块。这种根据意义将信息碎片拼接起来的思维跃进，可以运用于所有人类能够掌握的领域，如运动、音乐、舞蹈等。<strong>最重要的是专注的训练和重复可以建立强的记忆痕迹，从而帮助你创建组块</strong>。专业的培养都是一小步一小步的，这个过程中，小的组块可以形成更大的组块。随着你对学习材料的理解越来越深入，所有的专业知识都只是更有创造性的见解的铺路石。    </p><p>但仅仅通过练习和重复来创建组块，并不能使你得心应手并有创造力地运用它们。组块化可以让大脑工作得更有效，一旦你把某个想法、概念或动作组块化后，你就不再需要记住有关的全部细节，你只需要知道最主要的那个概念就行了，也就是只需要记住组块。这就像清晨起床穿衣服，你只需要一个简单的想法——“我要穿衣服”， 但细想你会发现这个简单想法的组块所包含的活动是非常复杂的。   </p><h4 id="怎样形成组块"><a href="#怎样形成组块" class="headerlink" title="怎样形成组块"></a>怎样形成组块</h4><p>如果你是吉他初学者，你想学习弹奏一首有难度的吉他曲，你脑中关于这首曲子的神经表征可被看作是一个巨大的组块。首先你会听这首曲子、看别人弹奏这首曲子，还要从持琴姿势学起。和大多数技能一样，你通常需要将曲子的每一小部分转化为一个小的神经组块，再将这些小组块组合起来形成大组块。经过一段时间的练习，当你掌握了很多乐段之后，你就能流利地弹奏一个乐段了。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac2344dcd4d.jpg" alt>  </div></p><p>对于数学和科学的相关学科来说，关上书本检测自己，能够帮你检验那些你以为已经明白了的问题，并且加快你的学习速度。<strong>当你能独自完成某件事时，你才是真正掌握了它</strong>。许多事情都是这个道理，就像你只是看别人画画，并不代表你也能画出来，仅仅听别人唱歌并不能使你拥有同样的唱功和洪亮的嗓音。某件事如果你只是在看，或者就算理解了如何去做，也不代表你能真正做到。只有在你自己实际操作和完全掌握的情况下才能建立起神经模型。  </p><p><strong>组块化的第一步：就是对你想要组块化的信息全神贯注</strong>。如果你正开着电视，或是每隔几分钟就检查、回复手机上的消息，这些都会增加你建立组块的难度，因为你的大脑并没有完全投入到新信息的组块化中去。   </p><p><strong>组块化的第二步：要求你对建立组块的对象有基本的了解</strong>。无论是理解概念性的知识，还是寻找故事中不同情节间的关联，通常我们都可以自然而然地领会所学内容的大意。  </p><p><strong>组块化的第三步：是获取背景知识</strong>。不断重复和练习解决相关的或不相关的问题，这样你不仅知道如何使用组块，还明白应该什么时候使用。这样做能帮你认识新建立的组块是如何融入整体知识框架的。   </p><p>最后<strong>第四步，练习能帮你拓宽组块连接的神经网络，并确保它们不仅牢固，还能通过不同途径访问</strong>。正如下图所示，学习由两部分组成，自上而下的认识以及由下至上的组块化。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac23c964e96.jpg" alt>    </div></p><p>在由下至上组块化的过程中，练习和重复能够帮助你建立和强化每一个组块，这样你就可以在需要它的时候使用它。当自上而下的方法能够让你清楚地看到你正在学习什么以及它适用于哪里。就完全掌握知识而言，这两个过程都非常重要。而背景认识就是这两个过程的交汇处，背景认识意味着学会在特定的时候使用正确的方法。   </p><p>通常在真正的阅读之前，快速浏览书中某一章的图片以及小标题，能够帮助你知晓大意。听那些有严谨层次结构的课程，可以帮你弄清楚应在哪里建立组块以及如何把不同组块联系起来。一旦完成了这些，再了解具体的信息，那么就算遗漏了一些让你疑惑的部分，你依然可以理解主要部分。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac23f275bac.jpg" alt>   </div></p><p><strong>总的来说，最好在精神高度集中的时候建立组块，理解基本的含义后，通过练习来真正掌握知识，并对情境有个大致了解，是建立组块的基本步骤</strong>。快把“组块”融入到你正在使用的学习中去吧！  </p><h4 id="能力错觉"><a href="#能力错觉" class="headerlink" title="能力错觉"></a>能力错觉</h4><p>这一小节来介绍一些让学习走上正轨的基本理念。   </p><p><strong>1.回顾的重要性</strong>   </p><p>学习书本或资料时，最常见方法之一就是反复阅读。不过心理学家Jeffrey Karpicke证明，这种方法的成效远不及另一种简单技巧——回顾。也就是阅读材料后，移开视线，看看你能回忆起多少内容。    </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac2450e87cc.jpg" alt>    </div></p><p>Karpicke发表在《科学》杂志上的研究提供了可靠证据。先让学生们学一篇科技文章，然后通过尽力回忆其中信息来巩固练习；接着，让他们重读并再次回想。结果相同时间内仅用回顾法练习的学生较使用其他学习方法的学生而言，对材料的掌握更为全面深入。其他学习方法包括反复阅读资料，或者绘制可以加强学习材料之间联系的思维导图。学生通过正式考试或非正式自测都证明了回顾法有助于学习。这给了我们一个重要提示，<strong>即在回顾知识时，我们并非机械地复述，而是在通过回顾这个过程加深理解</strong>。这也有助于我们形成知识组块，就好像回忆过程帮助我们在神经上嵌入了“钩子”，以便我们串联起前后知识。    </p><p>比起被动重复阅读，回顾——<strong>即在心里检索关键概念</strong>——可以使你的学习更加专注高效，只有隔上一定时间后再重读才会有效果，因为这样，重读就更像是间隔重复练习。    </p><p><strong>2.能力的错觉</strong>   </p><p>你该明白你才是要解决问题和掌握概念的人，如果你看到某个习题答案后告诉自己，“哦，我明白他们为什么这么做了！” 那么这个答案并不真正属于你，因为你没有真正把这些概念嵌入自己潜在的神经回路中去。这是一种学习中最为常见的自欺欺人式错觉。如果你想要很好地掌握材料以在考试中取得好成绩，并从中创新，就必须让这些知识在你脑海里生根发芽。    </p><p>另一个类似情况就是做笔记和注释。做笔记时高亮和下划线必须要谨慎，否则不仅没有效果还容易产生误导。在空白处写笔记总结关键概念也被证明是一种很更好的办法。   </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac249e69cf8.jpg" alt>   </div></p><p>Karpicke的研究还发现，学生们喜欢重读笔记或课本的原因是，当他们面前打开着课本、笔记或谷歌时，会误以为这些知识同样在他们的脑海里，然而事实却并非如此。因为看书比回顾做起来简单，学生们会陷入一种自欺欺人的错觉。事实上，这种学习方式效率很低。    </p><p><strong>3.自测与犯错</strong>   </p><p>能力的错觉提醒我们，在学习资料上花太多时间并不能保证你真的懂了。而<strong>自测是一种极其有用的办法，来确保你是真的学会了，而不是自欺欺人的错觉</strong>。从某种意义上来说，这就是回忆在发挥作用。  </p><p>让你发现自己是否真的掌握一个概念，犯错实际上是件好事。因为你之后就会想要避免重复犯错，所以实际考试前，在自测中犯的错是很有价值的，因为它们能让你一点点弥补思维漏洞。<strong>犯错可以纠正思考方向，让你学得更好、做得更好</strong>。</p><p><strong>4.多场合回顾</strong>   </p><p>回顾是一种有效工具，而<strong>在常规学习场所以外回顾知识则会帮助你加深对知识的理解</strong>。通过在不同物理环境下回顾和思考知识，你会脱离对给定场所的依赖，这会帮助你避免由于考试与学习场所的不同而产生的问题。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac24ff6465a.jpg" alt>   </div></p><h3 id="Part2-看到全局"><a href="#Part2-看到全局" class="headerlink" title="Part2 看到全局"></a>Part2 看到全局</h3><h4 id="是什么激励了你？"><a href="#是什么激励了你？" class="headerlink" title="是什么激励了你？"></a>是什么激励了你？</h4><p>你会发现当学的东西并非自己真正喜欢的东西时，学习是非常困难的；而学习自己真正感兴趣的东西的时候，一切都变得非常简单，那这是为什么呢?   </p><p>你的大脑有一套神经递质的广泛投射系统，它加载的不是经验本身的内容，而是信息的重要性以及对未来的价值。神经递质是可以影响神经元如何回应其他神经元的化学物质。今天我们将要谈谈它们其中的三种，<strong>乙酰胆碱、多巴胺和血清素</strong>。  </p><p><strong>乙酰胆碱影响专注学习和集中注意力</strong>。当你注意力高度集中的时候，这些乙酰胆碱神经元就会广泛地投射出来，并且激活环路来控制突触可塑性，从而形成新的长期记忆。   </p><p><strong>多巴胺信号与意料之外的奖励相关</strong>。当接受到一个毫无预期的奖励时，这些神经元将分泌出多巴胺，多巴胺的信号将广泛投射，这会对学习产生强有力的影响；同时也会影响决策，甚至是感官输入的价值所在，它控制着我们的动力。比如番茄工作法中的设置奖励就是给自己的多巴胺神经元加油。  </p><p><strong>血清素影响社会生活和冒险行为</strong>。它可以有力地影响你的社交生活。在猴子部落中的雄性首领有着最高的血清素分泌水平，而位列最末的公猴，其血清素水平则最低。血清素也与风险行为有着紧密的联系，在那些血清素低的猴子身上往往能观察到更多的冒险行为。服刑犯人中，因暴力犯罪而入狱的是社会中血清素分泌活动最低的群体之一。  </p><p><strong>情绪也可以强烈地影响你的学习</strong>。你自己应该深有体会，情绪曾一度被认为与认知互不影响，然而近期研究显示，情绪、感觉以及注意力互相交织，并与学习和记忆力互相影响。    </p><p>对于成功的学习来说，情绪及神经递质系统比感知和动作要反应迟缓，但却同等重要。   </p><h4 id="组块库的价值"><a href="#组块库的价值" class="headerlink" title="组块库的价值"></a>组块库的价值</h4><p>将新的组块和原有组块结合起来的能力，体现在很多历史的创新变革中。比如比尔·盖茨与其他工业领袖会留出长达一周的阅读周期，以便在一段时间内掌握多种不同想法，把新鲜想法留在头脑中，与未忘记的想法进行自我交流，可以形成<strong>创新性思维</strong>。</p><p>你的组块库越大，运用越熟练，无论学什么科目，你都将能够更轻易地解决问题。组块化并非创新灵活度所需要的全部，但是它是重要的一环。组块还可以帮助你理解新概念。这是因为当你理解一个组块时，你会发现这一组块能以令人惊讶的方式与相似的组块联系起来。不仅在同一领域中如此，在截然不同的领域中也是这样。这就是所谓的<strong>知识迁移</strong>(transfer)。 </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac25c17f568.jpg" alt>    </div></p><p>你建立每一个组块，它就为你补上知识拼图的一块，但如果你不训练变大的组块，它们就会保持模糊的状态，你要学习的东西拼到一起就会更为困难。<strong>建立组块库就是在训练你的大脑，不仅要认出一个特定的概念，还要识别概念的类别，以便你能够自如地知晓如何快速处理你遇到的问题</strong>。你将开始看到一些为你简化解决方法的模式，并很快发现不同的解决方法就潜藏在你的记忆边缘。   </p><p>有两种途径解决问题，一是顺序性地，一步步推理；二是通过整体性的直觉。顺序性思维涉及到专注模式；而直觉通常需要创造性的发散模式来联系不同的想法。大多数较难的问题和概念都是通过直觉来理解的，因为新的想法和你熟悉的领域相去甚远。发散模式是半随机地进行连接，这意味着它们带来的解决方法，应该由专注模式进行小心验证。直觉性的理解不是永远正确的，你大概会想无论你在学什么，仅在单一的部分或章节里就有那么多问题和概念，根本没法全学会。这时<strong>机遇定律</strong>就发挥作用了，幸运女神会眷顾努力之人。<strong>专注于你正在学习的单元，你会发现一旦你把第一个问题或概念放进组块库，不论那是什么，第二个概念的进入就会容易一些，然后第三个概念也就更容易，这并不都那么简单，但会越来越容易</strong>。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac2603ba53d.jpg" alt>    </div></p><h4 id="过度学习、思维定势、交替学习"><a href="#过度学习、思维定势、交替学习" class="headerlink" title="过度学习、思维定势、交替学习"></a>过度学习、思维定势、交替学习</h4><p>当你在学习一个新单词、一种新概念或新的问题解法时，你需要在同一学习阶段内反复练习。一定的练习是必要且有用的，但在完全掌握此阶段的所有内容后继续学习训练，就是所谓的过度学习。过度学习在有些场合是有意义的，比如对网球发球、钢琴协奏曲演奏可能非常重要，它能在紧张的时候，帮助其行为自动化。但仍要警惕在单一学习阶段的重复性过度识记，研究表明，<strong>这可能会对宝贵的学习时间造成浪费</strong>。  </p><p>一旦你在某一阶段学会了一个基本概念，在这段时间不断地巩固它，并不能加强你所期许的长期记忆联系。<strong>学完一段时间之后再复习是更好更有用的，这可以加强并深化你的组块化神经模式</strong>。但请注意，重复你已经掌握的东西非常容易，而这可能会造成能力错觉，让你误以为自己已掌握了所有材料，但其实你只掌握了简单的部分。所以，<strong>你应该均衡学习，把精力集中在你认为困难的部分。专注于学习的困难部分称为刻意训练 (deliberate practice) ，这种刻意训练 (deliberate practice) 通常是好学生与优秀学生的差别所在</strong>。   </p><p>这些与<strong>思维定势</strong>(Einstellung) 的概念有关。一个已经形成并加强的神经模式可能阻碍你发现更棒的解决方案。思维定势在这张弹珠脑图里就表现为，你最初的想法向大脑上方移动，而解法的思维模式则位于下方。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/09/5cac267877a30.jpg" alt="思维定势想法（橙）与解决方法（黑）"> </div></p><p>密集的专注模式以及先前构造的思维模式，会形成惯性，阻止你走向一个可能发现解决方法的新区域。你可以把思维定势想像为一个路障，而它是你最初的想法所造成的，这种错误的方式在运动和科学学科中就很容易发生。因为有时你最初”发生什么”或”该去做什么”的直觉是有误导性的，<strong>在学习新事物时，你必须摒弃错误的旧思想和方法</strong>。  </p><p>学生学习时会犯的一项重大失误是，在学会游泳前就跳入水中。换句话说，他们盲目地开始做作业，不看书、不上课、不看在线课程，或甚至不与熟识此方面的人交谈。这种学习方法只会失败。就像在放任思想在一个专注模式的弹珠器里跳来跳去，而完全不考虑解法到底在哪里。在学习和生活中，理解如何得到真正的解决方法很重要。掌握一门新学科不仅要学习基础组块，更要学会如何选择和应用不同的组块。<strong>最佳的学习方法是，在需要不同技术和策略的问题中来回切换、练习，这就是所谓的交替学习</strong>。  </p><p>交替学习非常重要，你需要让自己的大脑习惯这种思想，即仅仅知道如何使用特定的概念、方法或解题技巧是不够的，你也需要知道何时去使用 ，要贯彻交替学习的思想。这样你才能脱离只会练习和重复，而开始学会独立思考。当你在一个学科内交替学习，你就开始在这个学科内发展创造力了。当你在多个不同学科间交替学习，你就能更容易地在不同领域的组块间创造联系，这能进一步提高你的创造性。当然，在不同领域间发展固定知识组块需要时间，所以有时需要取舍。成为几个领域的专家，意味着你可以将一个领域的新思想引入另一个领域，但这也可能意味着，你在某个领域的专业知识 并不如专攻一个领域的人那么深厚。反过来，如果你只专研一个学科，你可能对它有很深刻的理解，但也变得只习惯某种思考方式，这种根深蒂固的思考模式，让你很难把握新思想。  </p><p>科学哲学家Thomas Kuhn发现，科学中大部分的方式转变都是由年轻人，或者之前学习其他学科的人所提出的。他们不那么容易陷于思维定势，不会被先前的专业训练阻碍思想。有句老话说道，科学会随着每个葬礼的进行而进步，因为葬礼意味着根深蒂固的旧思想的流逝。  </p><p>最后我转帖一个别人在元学习课程里用拼图的理念去学编程的文章，作为一个实例参考:  </p><p><a href="https://www.jianshu.com/p/385551d15a67" target="_blank" rel="noopener">元学习课心得和实践（一）——八小时搞定《JavaScript DOM》</a></p><p>下一节课我们会学习怎样应对拖延症，以及拖延症和记忆的关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。
    
    </summary>
    
      <category term="学习之道" scheme="https://luozongmin.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="高效学习" scheme="https://luozongmin.com/tags/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法" scheme="https://luozongmin.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客中遇到的一些&quot;事&quot;</title>
    <link href="https://luozongmin.com/2019/04/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E2%80%9C%E4%BA%8B%E2%80%9D/"/>
    <id>https://luozongmin.com/2019/04/03/Hexo搭建博客中遇到的一些“事”/</id>
    <published>2019-04-03T13:19:59.655Z</published>
    <updated>2019-04-22T10:18:20.513Z</updated>
    
    <content type="html"><![CDATA[<p>我写的这篇<a href="https://luozongmin.com/2019/03/21/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">文章</a>已经详细讲解了怎样利用hexo搭建GitHub个人博客，自从入了hexo搭建博客的坑后，发现hexo真的是巨TM好用， 配置好以后对我最大的方便就是想改就改，想删就删，一条 $ hexo g -d 命令搞定了事，支持 Markdown ，还支持非备案域名绑定，开心！    </p><p>搭建过程中也并非一切顺利，稍微不注意就出现bug，接下来罗列了几条我搭建过程中所遇到的一些“事”及解决办法。<a id="more"></a>   </p><h4 id="仓库的名字"><a href="#仓库的名字" class="headerlink" title="仓库的名字"></a>仓库的名字</h4><p>仓库的名字的正确格式应该是<code>github用户名.github.io</code>，比如说，如果你的github用户名是test，那么你就应该新建<code>test.github.io</code>的仓库（必须是你的github用户名，这里再强调一遍，其它名称无效，之前因为没仔细看，随便起了个名字，果断报错）。    </p><h4 id="首页文章内容部分展示"><a href="#首页文章内容部分展示" class="headerlink" title="首页文章内容部分展示"></a>首页文章内容部分展示</h4><p>我用的是next主题，默认会把所有文章内容都展示出来，这可不简洁美观。所以查了一下，有一个小技巧，就是在你觉得要展示在首页的Mrakdown文件内容文字后面添加<code>&lt;!--more--&gt;</code>即可。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: HTML、CSS、JS中unicode字符的处理 </span><br><span class="line">---</span><br><span class="line"># 前言</span><br><span class="line">使用github pages服务搭建博客的好处有：</span><br><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br></pre></td></tr></table></figure></p><p><div align="center"><img src="https://i.loli.net/2019/04/03/5ca4b489d8f30.jpg" alt>   </div></p><h4 id="GitHub-Pages绑定域名后每次hexo-d都会失效"><a href="#GitHub-Pages绑定域名后每次hexo-d都会失效" class="headerlink" title="GitHub Pages绑定域名后每次hexo d都会失效"></a>GitHub Pages绑定域名后每次hexo d都会失效</h4><p>在GitHub Pages绑定域名之后，发现每次<code>hexo d</code>后，域名网址都会报错404，又要重新部署，就有点太麻烦了。  </p><p><div align="center"><img src="https://i.loli.net/2019/04/03/5ca4b4ba9b38c.jpg" alt>   </div></p><p>搞了很久还是不行，后面在网上和群里问出，到这里域名绑定并没有结束，还差关键一步：    </p><p>具体就是在Hexo目录里的source文件下添加一个名为<code>CNAME</code>的文件，注意<strong>这个文件是没有后缀的，千万不要设置成.txt文本文件</strong>，文件的内容就是域名，格式如：   </p><pre><code>luozongmin.com</code></pre><p>添加后重新部署文件到github，这个时候再试，应该就成功了。   </p><h4 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h4><p>添加一个分类页面，并在菜单中显示页面链接。应先新建一个页面，命名为 categories ，命令如下：    </p><pre><code class="bash">$ hexo new page categories </code></pre><p><strong>注意！！！</strong>categories中千万别加””(双引号)，不然会导致部署完后网站中不显示具体分类：    </p><p><div align="center"><img src="https://i.loli.net/2019/04/03/5ca4b5516f9a6.jpg" alt>      </div></p><p>之后在编辑刚新建的页面中，将页面的类型设置为<code>categories</code>； 最后编辑主题的<code>_config.yml</code>，将<code>menu</code>中的<code>categories: /categories</code>注释去掉即可。    </p><h4 id="Busuanzi-统计浏览量失效"><a href="#Busuanzi-统计浏览量失效" class="headerlink" title="Busuanzi 统计浏览量失效"></a>Busuanzi 统计浏览量失效</h4><p>由于busuanzi(不蒜子)的网址更新，导致了使用Hexo Next主题时统计浏览量时失效。   </p><p>解决方法:    </p><p>到hexo的themes文件夹下, 进入\themes\next\layout_third-party\analytics   </p><p>打开: busuanzi-counter.swig    </p><p>将src=“<a href="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”" target="_blank" rel="noopener">https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js”</a>    </p><p>修改为src=“<a href="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”" target="_blank" rel="noopener">https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js”</a>    </p><p>即可。    </p><p>不蒜子官网:<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a>  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我写的这篇&lt;a href=&quot;https://luozongmin.com/2019/03/21/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;文章&lt;/a&gt;已经详细讲解了怎样利用hexo搭建GitHub个人博客，自从入了hexo搭建博客的坑后，发现hexo真的是巨TM好用， 配置好以后对我最大的方便就是想改就改，想删就删，一条 $ hexo g -d 命令搞定了事，支持 Markdown ，还支持非备案域名绑定，开心！    &lt;/p&gt;
&lt;p&gt;搭建过程中也并非一切顺利，稍微不注意就出现bug，接下来罗列了几条我搭建过程中所遇到的一些“事”及解决办法。
    
    </summary>
    
      <category term="tools" scheme="https://luozongmin.com/categories/tools/"/>
    
    
      <category term="Hexo" scheme="https://luozongmin.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>学会如何学习（一）</title>
    <link href="https://luozongmin.com/2019/03/30/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://luozongmin.com/2019/03/30/学会如何学习（一）/</id>
    <published>2019-03-30T12:22:29.431Z</published>
    <updated>2019-04-09T05:12:41.410Z</updated>
    
    <content type="html"><![CDATA[<p>我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？<a id="more"></a>    </p><p>无意中在<a href="http://link.zhihu.com/?target=https%3A//www.coursera.org/learn/ruhe-xuexi" target="_blank" rel="noopener">Coursera</a>上发现了一门神奇适用的课程，叫做“Learning How to Learn”， 旨在利用科学知识以及授课者切身经验教会你学会如何学习，学习这门课我才开始恍然大悟，原来学习应该这样学习，算是初步悟到如何学习的真谛了。下面我将讨论我从第一周课堂中学到的经验教训。    </p><h4 id="利用专注与发散思维"><a href="#利用专注与发散思维" class="headerlink" title="利用专注与发散思维"></a>利用专注与发散思维</h4><p>研究发现，人有两种完全不同的思考模式，专注模式（focused mode）和发散模式（diffuse mode）。就目前神经学家所知，专注模式与发散模式只能单独存在，你不能同时使用两种模式。而发散思维是你试图了解新事物时应该采取的思维模式。</p><p>课程讲述萨尔瓦多·达利 (20世纪著名的超现实主义画家)有时会坐在椅子上，放空自己的大脑，并常常会漫无目的地思考一下之前的工作。这样他就能把脑海中那些在发散模式下得到的的联想和点子及时地收集起来，然后带着这些在发散模式下得到的新想法回到专注模式里去。    </p><p><div align="center"><img src="https://i.loli.net/2019/03/30/5c9f60be3dcad.jpg" alt>   </div></p><p>这个例子目的是告诉我们：当你处于长期专注的学习模式时，可以通过小睡或做一些运动，然后过渡到发散模式，有助于你的大脑建立必要的神经连接，在你的长时间记忆中建立持久的知识块。还要强调的是，当你学习一些新的东西，尤其是比较难的东西的时候，你的大脑需要有在两种学习模式之间来回转换的能力，这能帮助你更高效地学习。想要锻炼你的神经，你需要每天做一点练习，逐步建立起支撑你思考的神经骨架，这就是关键所在。</p><h4 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h4><p>每个人或多或少有拖延的毛病，只不过有些人比较严重。当你面对一件你极度不情愿做的事情时，就好像激活了大脑中与疼痛相关的区域。 </p><p>所以拖延的过程大概如下图：首先，某件事可能会让你产生轻微的不安；为了消除这种不适感，你会转而去做一些更让人愉悦的事情，这么做的结果就是你觉得更开心了，但这只是暂时的，后续文章会更深入地去了解拖延症。</p><p><div align="center"><img src="https://i.loli.net/2019/03/30/5c9f61601836b.jpg" alt="拖延的过程">    </div></p><h4 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h4><p>课程告诉我们一个小巧方便的意志力工具，这个小工具叫做番茄工作法 (Pomodoro)。这个小技巧所需的只有一个计时器（手机上搜索“番茄ToDo”APP，电脑端也有许多类似的软件，可以自行选择），具体的实行过程是这样的：    </p><ol><li>首先需要把计时器设定25分钟，屏蔽所有会打扰你的事物；</li><li>在25分钟内，集中精力专注你所要专注的事；</li><li>最后还有一件很重要的事情是，当你前两步之后要给自己一点小小的奖励。比如：上几分钟网、喝杯咖啡或者简单地做一下运动，来使你的大脑可以愉悦的放松一会儿。<br><div align="center"><img src="https://i.loli.net/2019/03/30/5c9f61a5eb73a.jpg" alt="番茄工作法">   </div></li></ol><p>实行后你会发现番茄工作法的使用效果非常明显，这就像是你的大脑在健身房做完一次25分钟的高强度训练，然后进行休息放松一样。当你无法专注的时候不妨试一试！</p><h4 id="记忆与练习"><a href="#记忆与练习" class="headerlink" title="记忆与练习"></a>记忆与练习</h4><p>当我们回忆数学方程组时，我们使用的是长期记忆。当我们尝试结合脑海中的想法来帮助我们理解某一概念或解决某一问题时，我们使用的是工作记忆。工作记忆和长期记忆是两种主要的记忆系统，工作记忆是大脑在即时且有意识地处理信息时所涉及的那部分记忆。    </p><ul><li>长期记忆就像一个储存仓库，不同的长期记忆储存在大脑的不同区域。研究表明，当你首次尝试将一段短期记忆转入长期记忆中时，你需要多次回顾以增加需要时找到相关信息的几率。</li><li>当你遇到新事物时，你通常会运用工作记忆来处理它，如果你想将这个信息转移到长期记忆里，就需要间隔重复的练习来促进这一过程。</li><li>不断重复你尝试记忆的内容，但重复的过程必须间隔开来。如果你尝试在一个晚上重复记忆20次相同的内容，记忆效果还比不上在几天内重复同样的次数这种方法。    </li></ul><p>练习在数学和科学中学到的思想和概念是很重要的，通过反复实践练习可以帮助你提高和增强学习过程中生成的神经连接，越是抽象的东西越要注重练习。</p><ul><li>学习的时候如果一心一意地专注学习，时间一长学习效果反而不好，需要休息一下或者至少稍稍将注意力转移到其他地方。在这段看似放松的时间里，你大脑的发散模式就有机会在后台帮你完成对概念的理解。如果你不这么做，而是进行填鸭式学习，你的知识库看起来将会像杂乱不堪，基础不牢靠的泥堆。</li><li>如果你有拖延问题，就需要使用番茄工作法帮助你注意力集中一段时间，并适当休息。这会帮你行动起来，并开始建立你需要的神经模式，使你能更有成效地学习更具挑战性的内容！</li></ul><h4 id="睡眠的重要性"><a href="#睡眠的重要性" class="headerlink" title="睡眠的重要性"></a>睡眠的重要性</h4><p>你怎么也不会想到，当你绝对清醒时你的大脑会产生一些有毒的物质，那大脑如何除掉这些有毒物质呢？原来当人们睡觉时，大脑细胞会收缩，从而增加脑内细胞之间的距离。这就像疏通了一条溪流，液体会在细胞空隙间流过，冲走有毒的物质。所以，睡觉这件事有时候看起来像是浪费时间，实际上是大脑保持清洁和健康的一种方式。   </p><p><div align="center"><img src="https://i.loli.net/2019/03/30/5c9f62212f2e6.jpg" alt="睡觉时大脑清除毒素">    </div></p><p>睡眠不足意味着少量代谢毒素残留在你的大脑之中，而这些有毒物质会让你思维混乱，不仅会让你发挥失常，还会导致头疼、抑郁症、糖尿病、心脏类疾病，甚至寿命缩短，这绝不是在吓你，可以参考一下睡眠不足的危害。   </p><p>睡眠对人们解决困难问题和理解所学知识的能力有显著影响，大脑会将你学习和思考过的想法、概念进行整理，清除掉一些不太重要的部分；同时增强你需要或想要记住的区域的记忆。在睡梦中，大脑还会将你努力学习到的东西在神经中枢一遍遍排演以增强加深记忆力！</p><p>如果你在打盹或睡觉之前，复习一遍所学东西，那你将有更大可能性梦到它。如果你更进一步，告诉自己你想要梦到这些内容，你梦到它的几率也会大大提高。梦见你所学的知识，本质上能够增强你的理解能力，在一定程度上可以将你的记忆整合成更易被掌握的组块信息。   </p><p>现在是时候去打个盹儿了！   </p><h4 id="采访特伦斯·谢诺沃斯基-Terrence-Sejnowski-博士的学习方法"><a href="#采访特伦斯·谢诺沃斯基-Terrence-Sejnowski-博士的学习方法" class="headerlink" title="采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法"></a>采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法</h4><p>1、当你遇到完全陌生的事物时你是如何更容易学习的？    </p><p>答：单刀直入地实践，因为实践出真知，且大量的阅读作用甚微，同时最好有专家的指点。 </p><p>2、你是如何让自己在一场枯燥的讲座中保持专注的？</p><p>答：没有简单的方法是可以让你对不感兴趣的东西一直保持参与度的，但是有一个小技巧，就是用提问来“伏击”演讲者，这种打断通常会带出更有趣的讨论；比起被动的听，积极参与会让你学到更多。</p><p>3、你是如何进入发散思维模式，并从中获益的呢？</p><p>答：慢跑或户外锻炼是让思维跳出常规想法的绝佳方法，而且这时极其可能迸发灵感。奔跑中，事物从你身边略过，你会开始思考发生的一些事情，然后意识之外的想法涌上表面，接着通常就会出现有用的新想法。但是，这些转瞬即逝的点子过后很容易忘记，我会随身携带一本小本子及时记下来。</p><p>4、你会同时进行多项任务吗？</p><p>答：生活中有大量任务不断地“轰炸”，我们一刻也离不开多线程工作，如果做不到统筹兼顾，日子将会很难熬。但我们不能真正地同时做两件事，容易混淆且效率低下。同时处理多个任务实际是一种切换任务的能力。你可能要花很多时间才能完成这样的切换，切换任务并回到当时中断的地方开始工作，这是高效完成任务的方法之一。</p><p>5、神经科学方面的知识有运用到学习上的例子吗？</p><p>答：别把自己关在房间里，充足的空间、能激励你的人、很多可以积极参与的事件，以及运动和锻炼都大有助益，它们会增加新神经元的数量并促进神经元的生长。</p><p>6、你有关于高效地集中注意力、学习和创新的技巧吗？</p><p>答：处于富有创新氛围的环境中，是一种提升自身创造力的方法。当你和别人交流、阐述观点，你就会有更好的想法，这一过程通常有助于创新。</p><p>7、给大家的建议?</p><p>1） 聪明的人并不一定会成功，有很多聪明的人并不成功，而那些富有激情并且坚持努力的人容易达到，是因为人生中的成功多半来自于激情和努力，往往成功的人的身上都具有这样的品质。</p><p>2）每天我们周围都有值得发现去重新理解的东西，我们必须要用不同的视角来看待这些普通的东西，这很重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？
    
    </summary>
    
      <category term="学习之道" scheme="https://luozongmin.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="高效学习" scheme="https://luozongmin.com/tags/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法" scheme="https://luozongmin.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Git命令拓展</title>
    <link href="https://luozongmin.com/2019/03/29/Git%E5%91%BD%E4%BB%A4%E6%8B%93%E5%B1%95/"/>
    <id>https://luozongmin.com/2019/03/29/Git命令拓展/</id>
    <published>2019-03-29T10:35:09.244Z</published>
    <updated>2019-03-29T10:52:30.598Z</updated>
    
    <content type="html"><![CDATA[<p>本文的内容基本上是从廖雪峰及阮一峰老师的Git 教程中总结出来的，方便自己以后查阅相关命令。</p><p>一般来说，日常使用只需要记住下图6个命令即可。但是想往深度使用Git，恐怕还需要记住其余的几十个命令。<a id="more"></a></p><p><div align="center"><img src="https://i.loli.net/2019/03/29/5c9df63e8073b.jpg" alt></div></p><p>上图中几个专用名词的译名如下：    </p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：本地仓库</li><li>Remote：远程仓库</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list    //显示当前的Git配置</span><br><span class="line"></span><br><span class="line">$ git config -e [--global]    //编辑Git配置文件</span><br><span class="line"></span><br><span class="line">$ git config --global user.name <span class="string">"miqilin21"</span></span><br><span class="line">$ git config --global user.email miqilin21@example.com   //设置你的仓库用户名及邮箱，用于标识提交者</span><br></pre></td></tr></table></figure><h4 id="新建Git代码库"><a href="#新建Git代码库" class="headerlink" title="新建Git代码库"></a>新建Git代码库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init    //在当前目录新建一个Git代码库</span><br><span class="line"></span><br><span class="line">$ git init [project-name]   //新建一个目录，将其初始化为Git代码库</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> [url]    //下载一个项目和它的整个代码历史</span><br></pre></td></tr></table></figure><h4 id="添加-删除文件"><a href="#添加-删除文件" class="headerlink" title="添加/删除文件"></a>添加/删除文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git add [file1] [file2] ...    //添加一个或多个文件到暂存区</span><br><span class="line"></span><br><span class="line">$ git add [dir]    //添加指定目录到暂存区，包括子目录</span><br><span class="line"></span><br><span class="line">$ git add    //添加当前目录的所有文件到暂存区</span><br><span class="line"></span><br><span class="line">$ git rm [file1] [file2] ..    //删除工作区文件，并放入暂存区</span><br><span class="line"></span><br><span class="line">$ git rm --cached [file]    //停止追踪指定文件，但该文件会保留在工作区</span><br></pre></td></tr></table></figure><h4 id="本地文件提交"><a href="#本地文件提交" class="headerlink" title="本地文件提交"></a>本地文件提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Commit message"</span>    //提交暂存区到仓库区</span><br><span class="line"></span><br><span class="line">$ git commit -a    //提交工作区自上次commit之后更改的所有文件，直接到仓库区</span><br><span class="line"></span><br><span class="line">$ git commit -v    //提交时显示所有diff信息</span><br><span class="line"></span><br><span class="line">$ git commit --amend -m <span class="string">"Latest commit message"</span>    //使用一次新的commit，替代上一次提交；如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br></pre></td></tr></table></figure><h4 id="同步远程仓库"><a href="#同步远程仓库" class="headerlink" title="同步远程仓库"></a>同步远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote]    //下载远程仓库的所有变动</span><br><span class="line"></span><br><span class="line">$ git remote -v    //显示所有远程仓库</span><br><span class="line"></span><br><span class="line">$ git remote show [remote]    //显示某个远程仓库的信息</span><br><span class="line"></span><br><span class="line">$ git remote add [shortname] [url]    //增加一个新的远程仓库，并命名</span><br><span class="line"></span><br><span class="line">$ git pull [remote] [branch]    //同步远程仓库的变化，并与本地分支合并</span><br><span class="line"></span><br><span class="line">$ git push [remote] [branch]    //上传本地指定分支到远程仓库</span><br><span class="line"></span><br><span class="line">$ git push [remote] --force     //强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line"></span><br><span class="line">$ git push [remote] --all    //推送所有分支到远程仓库</span><br></pre></td></tr></table></figure><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout [file]    //恢复暂存区的指定文件到工作区</span><br><span class="line"></span><br><span class="line">$ git checkout [commit] [file]    //恢复某个commit过的文件到暂存区和工作区</span><br><span class="line"></span><br><span class="line">$ git checkout    //恢复暂存区的所有文件到工作区</span><br><span class="line"></span><br><span class="line">$ git reset [file]    //重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line"></span><br><span class="line">$ git reset --hard    //重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line"></span><br><span class="line">$ git reset --hard [commit]    //重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line"></span><br><span class="line">$ git revert [commit]    //新建一个commit，用来撤销指定commit；后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line"></span><br><span class="line">$ git stash    //将工作区现场保存起来，等以后恢复后继续工作。通常用于处理更为着急的任务时，例如：bug</span><br><span class="line"></span><br><span class="line">$ git stash list    //查看保存的工作现场</span><br><span class="line"></span><br><span class="line">$ git stash apply    //恢复工作现场</span><br><span class="line"></span><br><span class="line">$ git stash drop    //删除stash内容</span><br><span class="line"></span><br><span class="line">$ git stash pop    //恢复的同时直接删除stash内容</span><br></pre></td></tr></table></figure><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git branch    //列出所有本地分支</span><br><span class="line"></span><br><span class="line">$ git branch -r    //列出所有远程分支</span><br><span class="line"></span><br><span class="line">$ git branch -a    //列出所有本地分支和远程分支</span><br><span class="line"></span><br><span class="line">$ git branch [branch-name]    //新建一个分支，但依然停留在当前分支</span><br><span class="line"></span><br><span class="line">$ git branch [branch] [commit]    //新建一个分支，指向指定commit</span><br><span class="line"></span><br><span class="line">$ git checkout -b [branch]    //新建一个分支，并切换到该分支</span><br><span class="line"></span><br><span class="line">$ git checkout [branch-name]    //切换到指定分支，并更新工作区</span><br><span class="line"></span><br><span class="line">$ git merge [branch]    //合并指定分支到当前分支</span><br><span class="line"></span><br><span class="line">$ git push origin [branch-name]    //将分支推送到远程仓库</span><br><span class="line"></span><br><span class="line">$ git push --all origin    //将所有分支推送到远程仓库</span><br><span class="line"></span><br><span class="line">$ git branch -d [branch-name]    //删除分支</span><br><span class="line"></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git push origin :[branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]     //删除远程分支</span><br></pre></td></tr></table></figure><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git tag    //列出所有tag</span><br><span class="line"></span><br><span class="line">$ git tag [tag]    //新建一个tag在当前commit</span><br><span class="line"></span><br><span class="line">$ git tag [tag] [commit]    //新建一个tag在指定commit</span><br><span class="line"></span><br><span class="line">$ git tag -d [tag]    //删除本地tag</span><br><span class="line"></span><br><span class="line">$ git push origin :refs/tags/[tagName]    //删除远程tag</span><br><span class="line"></span><br><span class="line">$ git show [tag]    //查看tag信息</span><br><span class="line"></span><br><span class="line">$ git push [remote] [tag]    //提交指定tag</span><br><span class="line"></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line">$ git push --tags origin    //提交所有tag</span><br></pre></td></tr></table></figure><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git status    //显示有变更的文件</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span>    //显示当前分支的版本历史</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span>    //显示commit历史，以及每次commit发生变更的文件</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]    //搜索提交历史，根据关键词</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]    //显示某个文件的版本历史，包括文件改名</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]    //显示指定文件相关的每一次diff</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline    //显示过去5次提交</span><br><span class="line"></span><br><span class="line">$ git shortlog -sn    //显示所有提交过的用户，按提交次数排序</span><br><span class="line"></span><br><span class="line">$ git blame [file]    //显示指定文件是什么人在什么时间修改过</span><br><span class="line"></span><br><span class="line">$ git diff    //显示暂存区和工作区的差异</span><br><span class="line"></span><br><span class="line">$ git diff --cached [file]    //显示暂存区和上一个commit的差异</span><br><span class="line"></span><br><span class="line">$ git diff HEAD    //显示工作区与当前分支最新commit之间的差异</span><br><span class="line"></span><br><span class="line">$ git diff [first-branch]...[second-branch]    //显示两次提交之间的差异</span><br><span class="line"></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span>    //显示今天你写了多少行代码</span><br><span class="line"></span><br><span class="line">$ git show [commit]    //显示某次提交的元数据和内容变化</span><br><span class="line"></span><br><span class="line">$ git show --name-only [commit]    //显示某次提交发生变化的文件</span><br><span class="line"></span><br><span class="line">$ git show [commit]:[filename]     //显示某次提交时，某个文件的内容</span><br><span class="line"></span><br><span class="line">$ git reflog    //显示当前分支的最近几次提交</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的内容基本上是从廖雪峰及阮一峰老师的Git 教程中总结出来的，方便自己以后查阅相关命令。&lt;/p&gt;
&lt;p&gt;一般来说，日常使用只需要记住下图6个命令即可。但是想往深度使用Git，恐怕还需要记住其余的几十个命令。
    
    </summary>
    
      <category term="tools" scheme="https://luozongmin.com/categories/tools/"/>
    
    
      <category term="Git" scheme="https://luozongmin.com/tags/Git/"/>
    
      <category term="GitHub" scheme="https://luozongmin.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+GitHub搭建个人博客</title>
    <link href="https://luozongmin.com/2019/03/21/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://luozongmin.com/2019/03/21/使用Hexo+GitHub搭建个人博客/</id>
    <published>2019-03-21T10:25:10.201Z</published>
    <updated>2019-04-22T10:11:08.347Z</updated>
    
    <content type="html"><![CDATA[<p>hexo是一个快速、简介且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多<a id="more"></a>，所以就用它啦~     </p><p>下面一步一步地说怎么用hexo+github搭建一个个人博客。</p><p><strong><em>说明：本文只针对Windows平台下的搭建过程，其他平台的请自行上网查阅</em></strong></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在搭建博客之前，需要安装node.js和git，具体操作请参考<a href="https://www.jianshu.com/p/0356308834ad" target="_blank" rel="noopener">这篇文章</a>，并同时申请Github账号，使用的开发工具为VScode。</p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>1、首先新建一个文件夹如myBlog，用于存放整个博客源文件。右击鼠标点击文件夹，选中Git Bash Here在<strong>Git命令行中打开</strong>。  </p><p>2、执行以下命令安装Hexo及生成第一篇博客文章：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli   //安装hexo</span><br><span class="line">$ hexo  init               //初始化hexo,这样myBlog就是整个博客的根目录，所有的页面都可以在里面进行增删改操作</span><br><span class="line">$ hexo generate            //生成静态页面</span><br><span class="line">$ hexo server              //启动本地服务器，进行博客文章预览</span><br></pre></td></tr></table></figure></p><p>Hexo会默认生成第一篇博客《Hello World》，在浏览器下打开localhost://4000你将会看到：</p><p><div align="center"><img src="https://i.loli.net/2019/03/21/5c9367e206fed.png" alt>    </div></p><p>myBlog源文件夹整体目录预览：</p><p><div align="center"><img src="https://i.loli.net/2019/03/21/5c936816aebad.jpg" alt>     </div></p><p>其中_config.yml和package.json为项目的配置文件，themes存放了我们博客的主题，source-&gt;_post为我们的博客目录，public为执行hexo generate后生成的静态页面。</p><h4 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h4><p>1、在你的Github中建立新的 repo，repo 名称必须是「你的用户名.<a href="http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。" target="_blank" rel="noopener">http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。</a>    </p><p><div align="center"><img src="https://i.loli.net/2019/03/21/5c93686920362.jpg" alt> </div></p><p>2、将myBlog目录中的_config.yml文件在VScode中打开，编辑网站配置：</p><ul><li>把第 6 行的 title 改成你想要的名字</li><li>把第 10 行的 author 改成你想取大名</li><li>把最后一行的 type 改成 <code>type: git</code></li><li>在最后一行后面新增一行，左边与 type 平齐，加上一行 <code>repo: 仓库地址</code> （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址最好以 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>: 开头）<br><div align="center"><img src="https://i.loli.net/2019/03/21/5c9368cb42ac7.jpg" alt>     </div></li></ul><p><div align="center"><img src="https://i.loli.net/2019/03/21/5c9368f2e97e0.png" alt>     </div></p><p>3、修改完成配置后在myBlog目录下执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save    //安装 git 部署插件</span><br><span class="line">$ hexo deploy                             //将本地博客代码部署到Github上</span><br></pre></td></tr></table></figure></p><p>4、进入「你的用户名.<a href="http://github.io」对应的" target="_blank" rel="noopener">http://github.io」对应的</a> repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接；最后用浏览器访问「预览链接/index.html」就应该看到了你的博客啦！</p><h4 id="添加新文章"><a href="#添加新文章" class="headerlink" title="添加新文章"></a>添加新文章</h4><p>1、打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就相当于在本地添加了新文章</p><p>2、利用来VScode编辑新文章</p><p>3、<code>hexo generate</code></p><p>4、<code>hexo deploy</code></p><p>5、去看你的博客，应该能看到这篇新文章啦！</p><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>1、<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a> 上面有主题合集</p><p>2、随便找一个主题，进入主题的 GitHub 首页，比如我找的是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p>3、复制它的 SSH 地址或 HTTPS 地址，假设地址为 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:iissnan/hexo-theme-next.git</p><p>4、<code>cd themes</code></p><p>5、<code>git clone git@github.com:iissnan/hexo-theme-next.git</code></p><p>6、<code>cd ..</code></p><p>7、将 _config.yml 的第 75 行改为 <code>theme: hexo-theme-next</code>，保存</p><p>8、<code>hexo generate</code></p><p>9、<code>hexo deploy</code></p><p>10、等一分钟，然后刷新你的博客页面，你会看到一个新的外观，如果不喜欢这个主题，就回到第 1 步，重选一个主题。  </p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>1、最好进入一个安全的目录创建源文件夹，在根目录瞎搞；</p><p>2、_config.yml中的缩进和空格一定严格按照文件的默认格式来，不然会报错；</p><p>3、想要删除博客的话，直接删除source-&gt;_posts-&gt;对应的博客文章，然后再次执行hexo generate、hexo deploy即可；</p><p>4、在_config.yml中修改language为zh-CN，即可将博客中英文转换为中文；</p><p>5、常用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span>      //新建文章 </span><br><span class="line">hexo new page <span class="string">"pageName"</span> //新建页面 </span><br><span class="line">hexo clean              //清除缓存文件db.json和已生成的静态文件 public,网站显示异常时可以执行这条命令试试。</span><br><span class="line">hexo generate           //生成静态文件 </span><br><span class="line">hexo deploy             //部署到Giihub </span><br><span class="line">hexo server             //启动本地服务器 </span><br><span class="line">hexo <span class="built_in">help</span>               //查询帮助</span><br></pre></td></tr></table></figure></p><p>6、md文件需要用到<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown语法</a>。  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo是一个快速、简介且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多
    
    </summary>
    
      <category term="tools" scheme="https://luozongmin.com/categories/tools/"/>
    
    
      <category term="GitHub" scheme="https://luozongmin.com/tags/GitHub/"/>
    
      <category term="Hexo" scheme="https://luozongmin.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记—三栏布局</title>
    <link href="https://luozongmin.com/2019/03/20/CSS%E5%B8%83%E5%B1%80%E2%80%94%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <id>https://luozongmin.com/2019/03/20/CSS布局—三栏布局/</id>
    <published>2019-03-20T09:29:47.959Z</published>
    <updated>2019-03-30T12:57:06.998Z</updated>
    
    <content type="html"><![CDATA[<p>三栏布局的页面可分为左中右三部分，然后对中间那部分做自适应的一种布局方式。三栏布局在前端页面的开发中十分常见，那么怎么样的才算是三栏布局呢？<a id="more"></a> 比如苏宁易购的首页：  </p><p><div align="center"><img src="https://i.loli.net/2019/03/20/5c92088c027e4.jpg" alt>    </div></p><p>上图的布局就是一个常见的三栏布局：即左边商品导航和右边导航为固定宽度，中间内容随浏览器宽度变化自适应。  </p><p>下面详细介绍了一些经典及新兴的三栏布局方式，且所有方式显示的效果如下图：    </p><p><div align="center"><img src="https://i.loli.net/2019/03/20/5c9208d10c306.jpg" alt> </div></p><h4 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.container &#123;</span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.left &#123;</span></span><br><span class="line"><span class="undefined">    position: absolute;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    left: 0;</span></span><br><span class="line"><span class="undefined">    top: 0;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">        .middle &#123;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    margin: 0 160px;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.right &#123;</span></span><br><span class="line"><span class="undefined">    position: absolute;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">            right: 0;</span></span><br><span class="line"><span class="undefined">    top: 0;</span></span><br><span class="line"><span class="undefined">            background-color: yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绝对定位布局是一个比较古老和容易想到的方式，其特点就是简单实用，而且也不容易出问题，缺点就是，容器脱离了文档流，后代元素也脱离了文档流，当高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。   </p><h4 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.left &#123;</span></span><br><span class="line"><span class="undefined">    float: left;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">        .middle &#123;</span></span><br><span class="line"><span class="undefined">    margin: 0 160px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">&#125;  </span></span><br><span class="line"><span class="undefined">.right &#123;</span></span><br><span class="line"><span class="undefined">    float: right;</span></span><br><span class="line"><span class="undefined">            width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>float布局也是一种较为简单且容易想到的方式，原理是左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应，缺点就是中间部分最后加载，内容较多时会影响体验。   </p><h4 id="BFC-三栏布局"><a href="#BFC-三栏布局" class="headerlink" title="BFC 三栏布局"></a>BFC 三栏布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.left &#123;</span></span><br><span class="line"><span class="undefined">    float: left;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    margin-right: 10px;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.middle &#123;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">        .right &#123;</span></span><br><span class="line"><span class="undefined">    float: right;</span></span><br><span class="line"><span class="undefined">            width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    margin-left: 10px;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>BFC有一特性：BFC的区域不会与外部浮动元素重叠，这里利用了这一特性，实现了两栏自适应布局。缺点和方法二类似，为了解决这个问题，引出下面要介绍的双飞翼布局。  </p><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        .content &#123;</span></span><br><span class="line"><span class="undefined">      float: left;</span></span><br><span class="line"><span class="undefined">      width: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        .left &#123;</span></span><br><span class="line"><span class="undefined">    float: left;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    margin-left: -100%;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">        .middle &#123;</span></span><br><span class="line"><span class="undefined">      height: 200px;</span></span><br><span class="line"><span class="undefined">      margin-left: 160px;</span></span><br><span class="line"><span class="undefined">      margin-right: 160px;</span></span><br><span class="line"><span class="undefined">      background-color: green;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">.right &#123;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    float: right;</span></span><br><span class="line"><span class="undefined">    margin-left: -200px;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>双飞翼布局是在中间栏的 div 中再嵌套一个 div，内容写在嵌套的 div 里，然后对嵌套的 div 设置 margin-left 和 margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是 100% 宽度，只不过中间栏的内容通过 margin 的值显示在中间。    </p><p>中间内容可以优先加载，但其HTML 代码结构稍微复杂点。   </p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.container &#123;</span></span><br><span class="line"><span class="undefined">    margin-left: 160px;</span></span><br><span class="line"><span class="undefined">    margin-right: 160px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.middle &#123;</span></span><br><span class="line"><span class="undefined">    float: left;</span></span><br><span class="line"><span class="undefined">    width: 100%;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.left &#123;</span></span><br><span class="line"><span class="undefined">    float: left;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    margin-left: -100%;</span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">    left: -160px;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.right &#123;</span></span><br><span class="line"><span class="undefined">    float: left;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    margin-left: -210px;</span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">    right: -220px;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>圣杯布局的核心是左、中、右三栏都通过float进行浮动，然后通过margin负值进行调整。跟双飞翼布局比较像，但还是有一些区别，相对于双飞翼布局来说，其HTML 结构相对简单，但是css语法就稍微复杂，也是优先加载中间内容。</p><p>还有注意一点是：中间内容要放在最上面，保证其先渲染。   </p><h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.container &#123;</span></span><br><span class="line"><span class="undefined">            display: flex;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.middle &#123;</span></span><br><span class="line"><span class="undefined">            flex-grow: 1;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.left &#123;</span></span><br><span class="line"><span class="undefined">    order: -1;</span></span><br><span class="line"><span class="undefined">    flex: 0 1 150px;</span></span><br><span class="line"><span class="undefined">    margin-right: 10px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.right &#123;</span></span><br><span class="line"><span class="undefined">    flex: 0 1 150px;</span></span><br><span class="line"><span class="undefined">            margin-left: 10px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Flex布局是由CSS3提供的一种较为新兴的、方便的三栏布局方式，简单实用，缺点是其兼容性差一点。    </p><h4 id="Table-布局"><a href="#Table-布局" class="headerlink" title="Table 布局"></a>Table 布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      .container &#123;</span></span><br><span class="line"><span class="undefined">    display: table;</span></span><br><span class="line"><span class="undefined">    width: 100%;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .left, .middle, .right &#123;</span></span><br><span class="line"><span class="undefined">    display: table-cell;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .left &#123;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .middle &#123;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .right &#123;</span></span><br><span class="line"><span class="undefined">    width: 150px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>算是一种比较老的布局方式，较为简单，但其缺点是：无法设置栏间距，缺乏点灵活性，如下图：   </p><p><div align="center"><img src="https://i.loli.net/2019/03/20/5c9209d3d7f87.jpg" alt> </div></p><h4 id="Grid-网格-布局"><a href="#Grid-网格-布局" class="headerlink" title="Grid(网格)布局"></a>Grid(网格)布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      .container &#123;</span></span><br><span class="line"><span class="undefined">    display: grid;</span></span><br><span class="line"><span class="undefined">    grid-template-columns: 160px auto 160px;</span></span><br><span class="line"><span class="undefined">            height: 200px;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .left &#123;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">            margin-right: 10px;      </span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .middle &#123;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .right &#123;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">            margin-left: 10px;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>网格布局作为一种比较新潮的实现方式，仅仅几条样式命令就能完成三栏布局，可见其布局之强大，但其兼容性比较差。    </p><p><strong>以上就是我自己总结及结合文档所列出的8种css实现前端三栏布局的方式，如还有其他方式，欢迎大家告诉我哦。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三栏布局的页面可分为左中右三部分，然后对中间那部分做自适应的一种布局方式。三栏布局在前端页面的开发中十分常见，那么怎么样的才算是三栏布局呢？
    
    </summary>
    
      <category term="CSS" scheme="https://luozongmin.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://luozongmin.com/tags/CSS/"/>
    
      <category term="布局" scheme="https://luozongmin.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记—左右布局</title>
    <link href="https://luozongmin.com/2019/03/20/CSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80/"/>
    <id>https://luozongmin.com/2019/03/20/CSS布局—左右布局/</id>
    <published>2019-03-20T09:19:55.204Z</published>
    <updated>2019-04-26T07:25:09.298Z</updated>
    
    <content type="html"><![CDATA[<p>css左右布局是实现前端页面设计的基础，大部分的布局方式都能分割成左右布局，因此理解左右布局，能使我们在初学css的时候更快理解其他复杂的布局方式。<a id="more"></a>  </p><p>下面是我罗列的几种css实现前端左右布局的方式：   </p><h4 id="position-absolute实现"><a href="#position-absolute实现" class="headerlink" title="position: absolute实现"></a>position: absolute实现</h4><p>在父级元素内设置两个子元素，绝对定位它们，然后使用百分比将它们分成左右两部分。 这里的好处是，有两个可以容纳自己内容的独立容器。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">section</span>&gt;</span><br><span class="line">  &lt;div class="left-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Left Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class="right-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Right Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt; /*以上为html代码*/</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ea68a2</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="table实现"><a href="#table实现" class="headerlink" title="table实现"></a>table实现</h4><p>table布局是页面布局中使用的最早的布局方式，随着前端技术的发展，table布局由于自身的局限性逐渐被div布局取代。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">section</span>&gt;</span><br><span class="line">  &lt;div class="left-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Left Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class="right-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Right Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ea68a2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="float实现"><a href="#float实现" class="headerlink" title="float实现"></a>float实现</h4><p>float属性是css中关于布局的一个关键属性，可以产生脱离文档流的布局现象，其left属性值使该区域向父级标签区域的左侧边界放置，right属性值使该区域块向父级标签的右侧边界放置，利用该属性可以实现左右布局。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">section</span>&gt;</span><br><span class="line">  &lt;div class="left-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Left Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class="right-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Right Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">section</span>, <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ea68a2</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于float对后面同级元素的影响，既可以采用margin进行影响的清除，还可以在受影响的元素上添加overflow：hidden来清除浮动对该区域块带来的影响。   </p><h4 id="Inline-Block实现"><a href="#Inline-Block实现" class="headerlink" title="Inline-Block实现"></a>Inline-Block实现</h4><p>display:inline-block属性是介于行内元素（display: inline）和块级元素（display: block）之间的属性，它既可以像行内元素一样水平布局，也可以像块级元素设置宽高属性，所以左右布局可以利用它这种属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="left-half"&gt;</span><br><span class="line">  &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">    &lt;h1&gt;Left Half&lt;/h1&gt;</span><br><span class="line">  &lt;/article&gt;</span><br><span class="line">&lt;/div&gt;&lt;div class="right-half"&gt;</span><br><span class="line">&lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">  &lt;h1&gt;Right Half&lt;/h1&gt;</span><br><span class="line">&lt;/article&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ea68a2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="flexbox实现"><a href="#flexbox实现" class="headerlink" title="flexbox实现"></a>flexbox实现</h4><p>css3中出现了弹性盒子flexbox布局，使用这种方法，可以将父级容器变成一个灵活的盒子，子容器占用相等的份额， 无需再设置宽高。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class="container"&gt;</span><br><span class="line">  &lt;div class="left-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Left Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class="right-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Right Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ea68a2</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="grid实现"><a href="#grid实现" class="headerlink" title="grid实现"></a>grid实现</h4><p>CSS Grid(网格) 布局技术就像是Flexbox和Table的混合体，你可以通过将 CSS 规则应用于父元素(成为 Grid Container 网格容器)和其子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid 布局。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class="container"&gt;</span><br><span class="line">  &lt;div class="left-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Left Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class="right-half"&gt;</span><br><span class="line">    &lt;<span class="selector-tag">article</span>&gt;</span><br><span class="line">      &lt;h1&gt;Right Half&lt;/h1&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/secion&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">section</span>, <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, -50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ea68a2</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-half</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为比较新兴的布局技术，相信在未来的前端发展中，Grid 布局技术会越来越受到广大开发者的青睐。    </p><p><strong>以上就是我自己总结及结合文档所列出的6种css实现前端左右布局的方式，如还有其他方式，欢迎大家告诉我。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css左右布局是实现前端页面设计的基础，大部分的布局方式都能分割成左右布局，因此理解左右布局，能使我们在初学css的时候更快理解其他复杂的布局方式。
    
    </summary>
    
      <category term="CSS" scheme="https://luozongmin.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://luozongmin.com/tags/CSS/"/>
    
      <category term="布局" scheme="https://luozongmin.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记—居中布局</title>
    <link href="https://luozongmin.com/2019/03/20/CSS%E5%B8%83%E5%B1%80%E2%80%94%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/"/>
    <id>https://luozongmin.com/2019/03/20/CSS布局—居中布局/</id>
    <published>2019-03-20T08:48:26.683Z</published>
    <updated>2019-03-30T13:00:42.766Z</updated>
    
    <content type="html"><![CDATA[<p>我们在网页布局的时候，经常会碰到需要居中的情况，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。   <a id="more"></a>  </p><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="元素宽高未知"><a href="#元素宽高未知" class="headerlink" title="元素宽高未知"></a>元素宽高未知</h4><p>当元素的宽高都未知的时候，可以利用以下两种方法将元素水平居中：     </p><p>①CSS3 transform：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②flexbox：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="居中元素为内联元素"><a href="#居中元素为内联元素" class="headerlink" title="居中元素为内联元素"></a>居中元素为内联元素</h4><p>常见的内联元素有：span, a, img, input, label 等等。   </p><p>您可以在块级父元素内水平居中内联元素，只需css中加以下核心语法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">   <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法适用于display 为 inline, inline-block, inline-table, inline-flex 类型的元素。    </p><h4 id="居中元素为块级元素"><a href="#居中元素为块级元素" class="headerlink" title="居中元素为块级元素"></a>居中元素为块级元素</h4><p>常见的块元素：div, h1~h6, table, p, ul, li 等等。     </p><p>①设置 margin：0 auto<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此方法只能进行水平的居中，对浮动元素或绝对定位元素是无效的。  </p><p>②转换为 inline-block 属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="居中元素为浮动元素"><a href="#居中元素为浮动元素" class="headerlink" title="居中元素为浮动元素"></a>居中元素为浮动元素</h4><p>加以下核心语法:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="居中元素为绝对定位元素"><a href="#居中元素为绝对定位元素" class="headerlink" title="居中元素为绝对定位元素"></a>居中元素为绝对定位元素</h4><p>①<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="元素宽高未知-1"><a href="#元素宽高未知-1" class="headerlink" title="元素宽高未知"></a>元素宽高未知</h4><p>当元素的宽高都未知的时候，也可以利用以下同样两种方法将元素垂直居中：  </p><p>①CSS3 transform：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②flexbox：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>适用于子元素为浮动、绝对定位、内联元素，均可垂直居中。   </p><p>其中flexbox 是 CSS3 新增的属性，设计初衷就是为了解决像垂直居中这样的常见布局问题，相信未来flexbox布局会越来越多应用。     </p><h4 id="元素宽高已知"><a href="#元素宽高已知" class="headerlink" title="元素宽高已知"></a>元素宽高已知</h4><p>①<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="居中元素为单行文本"><a href="#居中元素为单行文本" class="headerlink" title="居中元素为单行文本"></a>居中元素为单行文本</h4><p>①<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将文本的 line-height 属性值设为和文字父容器一样的高度，但适用于只有一行文字的情况。   </p><p>②<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.link</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时内联/文本元素可以垂直居中显示，只是因为它们上部和下部都有相等的padding。    </p><h4 id="居中元素为多行文本"><a href="#居中元素为多行文本" class="headerlink" title="居中元素为多行文本"></a>居中元素为多行文本</h4><p>①table：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②flexbox:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="元素宽高已知-1"><a href="#元素宽高已知-1" class="headerlink" title="元素宽高已知"></a>元素宽高已知</h4><p>①负边距居中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此方法灵活性差，不能自适应，且宽高不支持百分比尺寸和 min-/max- 属性。    </p><p>②绝对居中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    //absolute is ok</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">right</span>: 0;</span><br><span class="line">    <span class="selector-tag">bottom</span>: 0;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>元素的宽高支持百分比 % 属性值和 min-/max- 属性。     </p><p>③transform :<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>④table-cell:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法适用于子元素 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，前提需要知道父元素的宽高，且父元素的宽高不能设为百分比数。     </p><p>⑤font-size 结合 vertical-align：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">175.4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法前提条件是需给父元素设一个合适的 font-size 值，该值一般为其父元素的高度除以 1.14 得到的值，并且子元素必须是一个 display 为 inline, inline-block, inline-table, inline-flex 类型的元素，此外还需在子元素内加上 vertical-align: middle 属性。    </p><p>⑥文本内容：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="元素宽高未知-2"><a href="#元素宽高未知-2" class="headerlink" title="元素宽高未知"></a>元素宽高未知</h4><p>①transform :<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>transform方法中元素既可以加宽高，也可不加，用于水平垂直居中布局。    </p><p>②flexbox :<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>③grid:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="comment">/* thing to center */</span></span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法适用于只有一个元素的时候，作为非常新的布局方式，其兼容性也比较差。        </p><p><strong>上面只是把所有方法的代码要点罗列了一下，能满足所有的居中布局方案，如你还有其他好方法，欢迎交流指正哦。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在网页布局的时候，经常会碰到需要居中的情况，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。
    
    </summary>
    
      <category term="CSS" scheme="https://luozongmin.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://luozongmin.com/tags/CSS/"/>
    
      <category term="布局" scheme="https://luozongmin.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>如何快速搭建静态资源服务器</title>
    <link href="https://luozongmin.com/2019/03/19/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://luozongmin.com/2019/03/19/如何快速搭建静态资源服务器/</id>
    <published>2019-03-19T11:12:23.652Z</published>
    <updated>2019-04-22T10:10:56.402Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。<a id="more"></a>以前的时候，都是使用php的本地环境，也算比较方便，但是自从学了nodejs，发现创建http-server更方便。  </p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90cf7be5b77.jpg" alt>  </div></p><h3 id="本文的目的"><a href="#本文的目的" class="headerlink" title="本文的目的"></a>本文的目的</h3><p>在这篇文章中，我将向您展示如何使用NodeJS创建一个非常简单的HTTP服务器。您可以通过http访问目录中的静态资源，如HTML，Javascript，CSS等，比如：  </p><ul><li><a href="http://localhost:8080/hello.html" target="_blank" rel="noopener">http://localhost:8080/hello.html</a></li><li><a href="http://localhost:8080/abc.js" target="_blank" rel="noopener">http://localhost:8080/abc.js</a>   </li></ul><p>而不是通过默认的file:///来访问  </p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90cff553452.jpg" alt>    </div></p><p>那问题是为什么只有需要一个HTTP才能访问静态资源呢？ </p><p>是因为HTML文件含有Javascript文件时，如果通过默认的file://地址来访问此文件的话，浏览器会阻止本地Javascript文件的一些操作，此时就需要安装HTTP-Server来解决这个问题。  </p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90d02a2727a.jpg" alt>    </div></p><p>报错信息：  </p><ul><li>Failed to load file:///E:/webexamples/reactjs/hello-reactjs/person.jsx:</li><li>Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.   </li></ul><h3 id="创建HTTP-Server"><a href="#创建HTTP-Server" class="headerlink" title="创建HTTP-Server"></a>创建HTTP-Server</h3><p>首先，确保已在计算机上安装NodeJS和npm； 否则，请按照以下说明进行安装：  </p><ul><li>在Windows上安装NodeJS</li><li><p>打开 Git Bash或其他命令行工具，依次输入以下命令，按回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br><span class="line">npm config <span class="built_in">set</span> loglevel http</span><br><span class="line">npm config <span class="built_in">set</span> progress <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>npm 的配置被存储在 ~/.npmrc，你可以随时改。    </p></li></ul><p>①接下来第一步，先创建一个空目录：</p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90d0fa98ae6.jpg" alt>     </div></p><p>②利用命令行工具进入这个目录，这里用的是Git Bash。右击鼠标，点击Git Bash here，即可用Git Bash打开这个目录：</p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90d1315673b.jpg" alt>    </div></p><p>③运行以下命令安装http-server：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g http-server</span><br></pre></td></tr></table></figure></p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90d15f2e704.jpg" alt>    </div></p><p>④启动HTTP-Server，输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http-server -c-1</span><br></pre></td></tr></table></figure></p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90d19972e2d.jpg" alt>    </div></p><p>到此您的HTTP服务器就已经启动了，它正在端口8080上监听，您可以通过访问以下链接进行检查，3个地址在电脑端打开的是同一份东西：</p><ul><li><a href="http://192.168.1.116:8080/" target="_blank" rel="noopener">http://192.168.1.116:8080/</a> （只有这个地址能在手机中预览）</li><li>127.0.0.1:8080/ （2和3性质是一样的）</li><li>localhost:8080/ （较为常用）    </li></ul><p>⑤在该目录中创建一个HTML文件，您可以通过此HTTP地址访问它：</p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90d1fc84445.jpg" alt>   </div></p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90d22068577.jpg" alt>    </div></p><p>⑥这里Windows 用户需要注意了，如果你发现你修改了源代码，页面却无法更新，说明http-server 的缓存还未消除，那么可以这样做：  </p><ol><li>打开 Chrome 开发者工具</li><li>点击 Network</li><li>勾选 Disable Cache    </li></ol><p>这样缓存就不存在了~  </p><h3 id="其他命令安装HTTP-Server"><a href="#其他命令安装HTTP-Server" class="headerlink" title="其他命令安装HTTP-Server"></a>其他命令安装HTTP-Server</h3><p>这里就不仔细介绍步骤了，因为大部分操作和结果与第2步是一样的，直接上命令： </p><p><strong>第一种方法：</strong><br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i startserver -g</span><br></pre></td></tr></table></figure></p><p>快速开启：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ startserver</span><br></pre></td></tr></table></figure></p><p><strong>第二种方法：</strong><br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g live-server</span><br></pre></td></tr></table></figure></p><p>快速开启：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ live-server</span><br></pre></td></tr></table></figure></p><p>如果看到其他有意思的方法，后续还会增加的！   </p><p><strong>以上就是我在近期收集到的一些方法资料，不一定全面，如有错误欢迎指正哦。</strong>  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。
    
    </summary>
    
      <category term="前端相关" scheme="https://luozongmin.com/categories/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Node.js" scheme="https://luozongmin.com/tags/Node-js/"/>
    
      <category term="http-server" scheme="https://luozongmin.com/tags/http-server/"/>
    
  </entry>
  
  <entry>
    <title>HTML常用标签</title>
    <link href="https://luozongmin.com/2019/03/19/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <id>https://luozongmin.com/2019/03/19/HTML常用标签/</id>
    <published>2019-03-19T10:00:07.195Z</published>
    <updated>2019-04-12T06:31:18.603Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 是用来描述网页的一种语言，通过添加各种标签，达到在浏览器中展示期望的效果。    <a id="more"></a> </p><ul><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)    </li></ul><ul><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)    </li></ul><ul><li>标记语言是一套标记标签 (markup tag)    </li></ul><ul><li>HTML 使用标记标签来描述网页    </li></ul><p>浏览器不会显示 HTML 标签(HTML tag)，而是使用标签来解释页面的内容：     </p><ul><li>HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code>  </li></ul><ul><li>HTML 标签通常是成对出现的，比如 <code>&lt;p&gt;</code> 和 <code>&lt;/p&gt;</code>  </li></ul><ul><li>标签对中的第一个标签是开始标签，第二个标签是结束标签     </li></ul><ul><li>开始和结束标签也被称为开放标签和闭合标签     </li></ul><p>⭐越多代表我觉得此标签越重要</p><h4 id="标题标签-⭐⭐⭐"><a href="#标题标签-⭐⭐⭐" class="headerlink" title="标题标签 ⭐⭐⭐"></a>标题标签 ⭐⭐⭐</h4><p>HTML提供了6个等级的标题(head)，即：h1、h2、h3、h4、h5和h6，h1是最高级的标题。其基本语法是：<code>&lt;hn&gt; 标题信息 &lt;/hn&gt;</code>     </p><p>注意：h1因为重要，尽量少用，一般都是给logo用，或者页面中最重要标题信息，其他5个级别标题在一个页面中都可以出现多次，h1只能出现一次。    </p><h4 id="段落标签-⭐⭐⭐"><a href="#段落标签-⭐⭐⭐" class="headerlink" title="段落标签 ⭐⭐⭐"></a>段落标签 ⭐⭐⭐</h4><p>在网页中要想把文字内容有条理地显示，离不开段落标签（paragraph）,它是网页中文章内容的基本组成部分。其基本语法是：<code>&lt;p&gt; 文本内容 &lt;/p&gt;</code>    </p><p>注意：段落标签是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 </p><h4 id="水平线标签-⭐⭐"><a href="#水平线标签-⭐⭐" class="headerlink" title="水平线标签 ⭐⭐"></a>水平线标签 ⭐⭐</h4><p>在网页中经常看到一些水平线将段落与段落间隔开，层次分明。这些水平线可以通过插入图片来实现，也可以简单地通过<code>&lt;hr/&gt;</code> 标签(horizontal)来完成。其基本语法是：<code>&lt;hr /&gt;是单标签</code>    </p><h4 id="换行标签-⭐⭐⭐"><a href="#换行标签-⭐⭐⭐" class="headerlink" title="换行标签 ⭐⭐⭐"></a>换行标签 ⭐⭐⭐</h4><p>在HTML中，一个段落的文字会从左往右按顺序排列，直到浏览器窗口的右端，然后会自动换行，如果希望某段文字强制进行换行，就需要使用换行标签(break)。其基本语法是：<code>&lt;br /&gt;</code>   </p><p>注意：除了少数应用（比如诗歌的分行），应该尽量避免使用这个标签，因为它并没有特别的语义含义，而且分行的视觉效果完全可以通过p标签、列表标签和CSS命令达到。   </p><h4 id="div-span标签-⭐⭐⭐⭐"><a href="#div-span标签-⭐⭐⭐⭐" class="headerlink" title="div span标签 ⭐⭐⭐⭐"></a>div span标签 ⭐⭐⭐⭐</h4><p>div 和 span是没有语义的，是现在网页布局用到的最主要的2个盒子，比如css+div的结合就可以基本上满足页面布局需要。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 这是头部 <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     <span class="tag">&lt;<span class="name">span</span>&gt;</span> 今日行情 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="文本格式化标签-⭐⭐"><a href="#文本格式化标签-⭐⭐" class="headerlink" title="文本格式化标签 ⭐⭐"></a>文本格式化标签 ⭐⭐</h4><p>在网页中，有时要为某些文字设置加粗、加斜或加下划线的效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。其基本语法是：    </p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90bfc2f3084.jpg" alt>    </div></p><p>注意：b i s u 只有使用，没有强调的意思，strong em del ins的语义更强烈。    </p><h4 id="图像标签img-⭐⭐⭐⭐"><a href="#图像标签img-⭐⭐⭐⭐" class="headerlink" title="图像标签img ⭐⭐⭐⭐"></a>图像标签img ⭐⭐⭐⭐</h4><p>要想在网页中显示图像就需要使用图像标签，下图详细介绍了图像标签<code>&lt;img /&gt;</code> 以及与其相关的一些属性。其基本语法是：    </p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90c0095c9d2.jpg" alt>    </div></p><ol><li>基本图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot;/&gt;</code></li><li>带有alt的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; alt=&quot;这是我吴彦祖的照片&quot;/&gt;</code></li><li>带有title的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot;/&gt;</code></li><li>带有宽度的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; /&gt;</code></li><li>带有边框的图像插入方式：<br><code>&lt;img src=&quot;wo.jpg&quot; title=&quot;吴彦祖&quot; width=&quot;300&quot; border=&quot;10&quot; /&gt;</code></li></ol><h4 id="链接标签-⭐⭐⭐⭐"><a href="#链接标签-⭐⭐⭐⭐" class="headerlink" title="链接标签 ⭐⭐⭐⭐"></a>链接标签 ⭐⭐⭐⭐</h4><p>在HTML中创建超链接比较简单，只需用链接标签(anchor)环绕需要被链接的对象即可。其基本语法是：<br><code>&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;</code>   </p><p>href：Hypertext Reference的缩写，意思是超文本引用，用于指定链接目标的url地址。    </p><p>target：用于指定链接页面的打开方式，其取值有self(新链接页面覆盖原页面，为默认值)、blank(在新窗口打开)、_parent(载入父级窗口，与iframe结合用得到)、_top(载入顶级窗口，与iframe结合用得到)，注意：     </p><ol><li>外部链接：需要添加 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>  </li><li>内部链接：直接链接内部页面名称即可，如<a href="index.html">首页</a>；还有可以通过创建锚点链接，能够快速定位到内部页面的目标内容：①.使用<a href="#id名">链接文本</a> ②.使用相应的id名标注跳转到目标的位置 </li><li>如果没有确定的链接目标时，通常将href属性定义为”#”(即href=”#”)，表示该链接暂时为一个空链接。</li><li>不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。   </li><li>当然也可以利用base标签来设置整体链接的打开状态，如网易这样设置让页面所有链接按新窗口打开：<br><div align="center"><img src="https://i.loli.net/2019/03/19/5c90c0b1d3922.jpg" alt>     </div></li></ol><h4 id="特殊字符标签-⭐"><a href="#特殊字符标签-⭐" class="headerlink" title="特殊字符标签 ⭐"></a>特殊字符标签 ⭐</h4><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90c0ed6b519.jpg" alt>    </div></p><h4 id="无序列表ul-⭐⭐⭐⭐"><a href="#无序列表ul-⭐⭐⭐⭐" class="headerlink" title="无序列表ul ⭐⭐⭐⭐"></a>无序列表ul ⭐⭐⭐⭐</h4><p>无序列表(unordered list)的各个列表项之间没有顺序级别之分，是并列的。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>注意：     </p><ul><li><code>&lt;ul&gt;&lt;/ul&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ul&gt;&lt;/ul&gt;</code>标签内输入其他标签或者文字的做法是不被允许的。  </li><li><code>&lt;li&gt;</code>与<code>&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。   </li><li>无序列表会自带样式属性，但还是让css来做！   </li></ul><h4 id="有序列表ol-⭐⭐"><a href="#有序列表ol-⭐⭐" class="headerlink" title="有序列表ol ⭐⭐"></a>有序列表ol ⭐⭐</h4><p>有序列表(ordered list)即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   ...... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>所有特性基本和ul一致，且自带顺序。   </p><h4 id="定义列表-⭐"><a href="#定义列表-⭐" class="headerlink" title="定义列表 ⭐"></a>定义列表 ⭐</h4><p>定义列表(definition list)常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span>    </span><br><span class="line">  ......  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span>     </span><br><span class="line">  ...... </span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="表格table-⭐⭐"><a href="#表格table-⭐⭐" class="headerlink" title="表格table ⭐⭐"></a>表格table ⭐⭐</h4><p>表格还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面的语法中包含三对HTML标签，分别为<code>&lt;table&gt;&lt;/table&gt;</code>、<code>&lt;tr&gt;&lt;/tr&gt;</code>、<code>&lt;td&gt;&lt;/td&gt;</code>，他们是创建表格的基本标签，缺一不可，下面对他们进行具体解释：    </p><ul><li>table用于定义一个表格。  </li><li>tr用于定义表格中的一行，必须嵌套在table标签中，且只能嵌套<code>&lt;td&gt;&lt;/td&gt;</code>，在table中包含几对tr，就有几行表格。   </li><li>td /td：用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中，一对<code>&lt;tr&gt;&lt;/tr&gt;</code>中包含几对<code>&lt;td&gt;&lt;/td&gt;</code>，就表示该行中有多少”列”（或多少个单元格），但表格只有行tr和单元格td，行里面装单元格，没有列的概念；<code>&lt;td&gt;&lt;/td&gt;</code>标签像一个容器，可以容纳所有的元素。   </li></ul><h4 id="表单标签-⭐⭐"><a href="#表单标签-⭐⭐" class="headerlink" title="表单标签 ⭐⭐"></a>表单标签 ⭐⭐</h4><p>表单的目的是为了收集用户信息，在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。   </p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90c203c38cb.jpg" alt>    </div></p><p>表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 </p><p>提示信息：一个表单中通常还需要包含一些说明性的文字，作用是提示用户进行填写和操作。    </p><p>表单域：相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过它定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。    </p><h4 id="input控件-⭐⭐⭐⭐"><a href="#input控件-⭐⭐⭐⭐" class="headerlink" title="input控件 ⭐⭐⭐⭐"></a>input控件 ⭐⭐⭐⭐</h4><p><code>&lt;input /&gt;</code>标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。其常见属性如下所示：    </p><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90c254eb627.jpg" alt>    </div></p><p>text语法:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区<span class="tag">&lt;/<span class="name">td</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"北京"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>    //value为默认值</span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>password语法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>radio单选按钮语法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">     男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line">     女<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line">     人妖<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="label标签-⭐⭐"><a href="#label标签-⭐⭐" class="headerlink" title="label标签 ⭐⭐"></a>label标签 ⭐⭐</h4><p>label标签为input元素定义标注，其中for属性规定了label与哪个表单元素绑定。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span>Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">id</span>=<span class="string">"male"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>点击Male会直接跳到右边的文本框内，label通过for和id建立联系快速找到。当然也可以简化成这种形式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span>Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="textarea文件域-⭐⭐"><a href="#textarea文件域-⭐⭐" class="headerlink" title="textarea文件域 ⭐⭐"></a>textarea文件域 ⭐⭐</h4><p>text 文本框只能写一行文本，如果需要输入大量的信息，就需要用到textarea标签，可以轻松地创建多行文本输入框。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"每行的字符数"</span> <span class="attr">rows</span>=<span class="string">"显示的行数"</span>&gt;</span></span><br><span class="line">   文本内容   </span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>但是textarea的宽和高通常是通过css来控制的,cols和rows几乎不用。    </p><h4 id="下拉菜单-⭐⭐"><a href="#下拉菜单-⭐⭐" class="headerlink" title="下拉菜单 ⭐⭐"></a>下拉菜单 ⭐⭐</h4><p>使用select标签定义下拉菜单的基本语法如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>注意：  </p><ul><li><code>&lt;select&gt;&lt;/select&gt;</code>中至少应包含一对<code>&lt;option&gt;&lt;/option&gt;</code>。</li><li>在option中定义selected=”selected”时，当前项即为默认选中项。    </li></ul><h4 id="表单域-⭐⭐"><a href="#表单域-⭐⭐" class="headerlink" title="表单域 ⭐⭐"></a>表单域 ⭐⭐</h4><p>在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"url地址"</span> <span class="attr">method</span>=<span class="string">"提交方式"</span> <span class="attr">name</span>=<span class="string">"表单名称"</span>&gt;</span>    </span><br><span class="line">    各种表单控件   </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>常见属性：   </p><ul><li>Action：在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接受并处理表单数据的服务器程序的url地址。   </li><li>method：用于设置表单数据的提交方式，其取值为get或post。   </li><li>name：用于指定表单的名称，以区分同一个页面中的多个表单。<br>注意：每个表单都应该有自己的表单域。    </li></ul><h4 id="HTML5常用新标签-⭐⭐⭐"><a href="#HTML5常用新标签-⭐⭐⭐" class="headerlink" title="HTML5常用新标签 ⭐⭐⭐"></a>HTML5常用新标签 ⭐⭐⭐</h4><ul><li>header：定义文档的页眉</li></ul><ul><li>nav：定义导航链接的部分</li></ul><ul><li>footer：定义文档或节的页脚</li></ul><ul><li>article：标签规定独立的自包含内容</li></ul><ul><li>section：定义文档中的节（section、区段）</li></ul><ul><li>aside：定义其所处内容之外的内容（侧边）</li></ul><ul><li>datalist：标签定义选项列表，与input元素配合使用</li></ul><ul><li>fieldset：可将表单内的相关元素分组，打包，与legend搭配使用</li></ul><h4 id="HTML5新增的input-type属性"><a href="#HTML5新增的input-type属性" class="headerlink" title="HTML5新增的input type属性"></a>HTML5新增的input type属性</h4><p><div align="center"><img src="https://i.loli.net/2019/03/19/5c90c43d5be31.jpg" alt>     </div></p><h4 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h4><ul><li>embed：标签定义嵌入的内容</li></ul><ul><li>audio：播放音频</li></ul><ul><li>video：播放视频   </li></ul><h4 id="多媒体embed-⭐⭐"><a href="#多媒体embed-⭐⭐" class="headerlink" title="多媒体embed ⭐⭐"></a>多媒体embed ⭐⭐</h4><p>embed可以用来插入各种多媒体（较大的），格式可以是Wav、AIFF、AU、MP3等。其中url为音频或视频文件的路径，可以是相对路径或绝对路径。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">'http://player.youku.com/player.php/sid/XMzk4MDUzNTA1Mg==/v.swf'</span> <span class="attr">allowFullScreen</span>=<span class="string">'true'</span> </span></span><br><span class="line"><span class="tag"><span class="attr">quality</span>=<span class="string">'high'</span> <span class="attr">width</span>=<span class="string">'480'</span> <span class="attr">height</span>=<span class="string">'400'</span> <span class="attr">align</span>=<span class="string">'middle'</span> <span class="attr">allowScriptAccess</span>=<span class="string">'always'</span> <span class="attr">type</span>=<span class="string">'applicati</span></span></span><br><span class="line"><span class="tag"><span class="string">on/x-shockwave-flash'</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="多媒体audio-⭐⭐"><a href="#多媒体audio-⭐⭐" class="headerlink" title="多媒体audio ⭐⭐"></a>多媒体audio ⭐⭐</h4><p>HTML5通过<code>&lt;audio&gt;</code>标签来解决音频播放的问题。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"./music/See You Again.mp3"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span> //通过src指定音频文件路径即可</span><br></pre></td></tr></table></figure></p><p>并且可以通过添加属性来更友好控制音频的播放，如：   </p><ul><li>autoplay 自动播放  </li></ul><ul><li>controls 是否显示默认播放组件  </li></ul><ul><li>loop 循环播放 ，loop=2就是循环2次 ，loop或者loop=“-1”无限循环   </li></ul><h4 id="多媒体video-⭐⭐"><a href="#多媒体video-⭐⭐" class="headerlink" title="多媒体video ⭐⭐"></a>多媒体video ⭐⭐</h4><p>同音频播放一样，<code>&lt;video&gt;</code>（通常插入较小的视频）使用也相当简单。其基本语法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"./video/movie.mp4"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span> //通过src指定视频文件路径</span><br></pre></td></tr></table></figure></p><p>同样，通过附加属性可以更友好的控制视频的播放：  </p><ul><li>autoplay 自动播放</li></ul><ul><li>controls 是否显示默认播放组件</li></ul><ul><li>loop 循环播放 </li></ul><ul><li>width 设置播放窗口的宽度 </li></ul><ul><li>height 设置播放窗口的高度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML 是用来描述网页的一种语言，通过添加各种标签，达到在浏览器中展示期望的效果。
    
    </summary>
    
      <category term="HTML" scheme="https://luozongmin.com/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://luozongmin.com/tags/HTML/"/>
    
      <category term="标签" scheme="https://luozongmin.com/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
</feed>
