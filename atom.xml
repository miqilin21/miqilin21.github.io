<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>miqilin&#39;s blog</title>
  
  <subtitle>Stay hungry. Stay young.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luozongmin.com/"/>
  <updated>2019-10-26T09:08:44.207Z</updated>
  <id>https://luozongmin.com/</id>
  
  <author>
    <name>miqilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过DOM API 查找节点</title>
    <link href="https://luozongmin.com/2019/10/18/%E9%80%9A%E8%BF%87DOM%20API%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9/"/>
    <id>https://luozongmin.com/2019/10/18/通过DOM API 查找节点/</id>
    <published>2019-10-18T02:23:49.431Z</published>
    <updated>2019-10-26T09:08:44.207Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇的分享当中，我们简单介绍了BOM 与DOM，也了解到JavaScript 是怎么通过它们提供的方法来与浏览器进行沟通。<a id="more"></a></p><p>当一个网页被载入到浏览器时，浏览器会首先分析这个HTML 文档，然后会依照这份HTML 的内容解析成DOM (Document Object Model，即文件对象模型)。</p><p>而DOM 是W3C 制定的一个规范，它是独立于平台与语言的标准。换言之，只要遵守这样的规范，不管是什么平台或者是什么语言开发，都可以通过DOM 提供的API 来操作DOM 的内容、结构与样式。</p><p>所以说，DOM 是网页的根本，懂得<strong>控制DOM就可以控制整个网页，做出良好的互动体验</strong>。</p><p>那么在今天的分享中，我们就继续来介绍DOM API 查找节点的方法吧。</p><h3 id="前言-script标签放哪里有区别吗？"><a href="#前言-script标签放哪里有区别吗？" class="headerlink" title="前言:script标签放哪里有区别吗？"></a>前言:script标签放哪里有区别吗？</h3><p>针对<code>&lt;script&gt;</code>标签放哪里，这个题目其实没有标准答案，一般你会看到有两种版本：</p><ul><li>放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间</li><li>放在<code>&lt;/body&gt;</code>之前</li></ul><p>还有人会说为什么放在<code>&lt;head&gt; ... &lt;/head&gt;</code>里面的JavaScript没有作用？我觉得这说的有出入，这里我们简单来讲一下问题所在。</p><p>那么我们来试试上一篇介绍过的，先以<code>document.querySelector</code>取得<code>id=&quot;hello&quot;</code>的节点，然后通过<code>textContent</code>来修改内容。</p><p>先来试试把<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>之前。在jsbin里面马上执行看看，看起来似乎很ok呢！</p><p><img src="/images/domapi/1.jpg" srcset="/img/loading.gif" alt>    </p><p>接着，我们试着把<code>&lt;script&gt;</code>标签移到<code>&lt;head&gt; ... &lt;/head&gt;</code>之间：</p><p><img src="/images/domapi/2.jpg" srcset="/img/loading.gif" alt>    </p><p>咦？怎么什么都没有呢？而且也没有错误信息，JavaScript真的如大家说的一样，很垃圾吗？</p><p><img src="/images/domapi/3.jpg" srcset="/img/loading.gif" alt>   </p><p>冷静一下，容我解释一下。</p><p>前面说过，当一个网页被载入到浏览器时，浏览器会先分析这个HTML 文档，由上而下依序来读取解析：</p><p><img src="/images/domapi/4.jpg" srcset="/img/loading.gif" alt>   </p><p>所以上面jsbin例子中，当浏览器在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间遇到<code>&lt;script&gt;</code>标签时，就会暂停解析网页，并且<strong>立即</strong>执行<code>&lt;script&gt;</code>里的内容，直到script执行完毕后再继续解析网页。</p><p>当<code>&lt;head&gt; ... &lt;/head&gt;</code>里的<code>&lt;script&gt;</code>想要尝试去寻找<code>&lt;div id=&quot;hello&quot;&gt;</code>这个标签，但因为还没解析到网页本体，所以也无从取得。</p><p>不是浏览器坏掉，也不是JavaScript太渣，而是因为我们<strong>不理解浏览器执行的原理所造成的误会</strong>。</p><p>这里是浏览器加载一个有 <code>&lt;script&gt;</code> 标签的网站所发生的事情:</p><ol><li>拉取 HTML 页面</li><li>开始解析 HTML</li><li>解析到 <code>&lt;script&gt;</code> 标签之后准备获取 script 文件.</li><li>浏览器获取script文件。同时，html 解析中断并且<strong>阻断</strong>页面上其他html的解析。</li><li>一段时间后，script下载完成并且<strong>执行</strong>。</li><li>继续解析HTML文档的其他部分（解析script之后的html代码）</li></ol><p>第4步导致了很不好的用户体验，直到script文件全部下载完成之前HTML都不能得到解析。</p><p>那么，当我们把<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>结束之前，由于DOM已经解析完成，所以<code>document.querySelector</code>就可以顺利取得<code>id=&quot;hello&quot;</code>的节点，并且把<code>&#39;HELLO&#39;</code>的字串放在网页里啦！</p><p>这样说起来，<code>&lt;script&gt;</code>标签是不是就不适合放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间呢？</p><p>也不能这么说，这点认真要讲的话之后或许可以用一整篇来说明这个。</p><h3 id="DOM-节点的选取"><a href="#DOM-节点的选取" class="headerlink" title="DOM 节点的选取"></a>DOM 节点的选取</h3><p><img src="/images/domapi/5.jpg" srcset="/img/loading.gif" alt>  </p><p>上一篇文章说过，<code>document对象</code>是DOM tree的根节点，所以当我们要存取HTML时，都从<code>document</code>对象开始。而DOM的节点类型除了<strong>HTML元素节点</strong>(element nodes)外，还有<strong>文字节点</strong>(text nodes)、<strong>注释节点</strong>(comment nodes)等。</p><p>而常见的DOM 选取方法有下列这些：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的值，找到 DOM 中 id 为 'xxx' 的元素。</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 class 名称，返回所有符合条件的节点集合</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的节点集合</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'xxx'</span>); </span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure><h3 id="DOM-节点的类型"><a href="#DOM-节点的类型" class="headerlink" title="DOM 节点的类型"></a>DOM 节点的类型</h3><p>DOM 常用的节点类型有下面几种：</p><p><img src="/images/domapi/6.jpg" srcset="/img/loading.gif" alt>  </p><p>可以通过节点类型常数或是对应数值来判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType === Node.DOCUMENT_NODE;   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">document</span>.nodeType === <span class="number">9</span>;   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>其他不常用或是已经废弃的部分可以参考：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType" target="_blank" rel="noopener">MDN Node.nodeType</a>一节。</p><h3 id="DOM-节点间的查找遍历-Traversing"><a href="#DOM-节点间的查找遍历-Traversing" class="headerlink" title="DOM 节点间的查找遍历(Traversing)"></a>DOM 节点间的查找遍历(Traversing)</h3><p>由于DOM 节点有分层的概念，于是节点与节点之间的关系，我们大致上可以分成以下两种：</p><ul><li><strong>父子关系</strong>：除了<code>document</code>之外，每一个节点都会有个上层的节点，我们通常称之为「父节点」 (Parent node)，而相对地，从属于自己下层的节点，就会称为「子节点」 (Child node)。</li><li><strong>兄弟关系</strong>：有同一个「父节点」的节点，那么他们彼此之间就是「兄弟节点」(Siblings node)。</li></ul><p>而隔层的节点基本上没有直接关系。</p><p><img src="/images/domapi/7.jpg" srcset="/img/loading.gif" alt>  </p><p>上图中水平方向的邻层节点为父子关系，垂直方向的同层节点为兄弟关系。</p><p><strong>Node.childNodes</strong></p><p>所有的DOM节点对象都有<code>childNodes</code>属性，且此种属性无法修改。  </p><p>我们可以通过<code>Node.hasChildNodes()</code>来检查某个DOM节点是否有子节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'#hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 node 內有子元素</span></span><br><span class="line"><span class="keyword">if</span>( node.hasChildNodes() ) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以通过 node.childNodes[n] (n 为数字索引) 取得对应的节点</span></span><br><span class="line">    <span class="comment">// 注意，NodeList 对象內容为即时更新的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; node.childNodes[i].length; i++) &#123;</span><br><span class="line">       <span class="comment">// ...     </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node.childNodes</code>返回的可能会有这几种：</p><ul><li>HTML 元素节点(element nodes)</li><li>文字节点(text nodes)，包含空格</li><li>注释节点(comment nodes)</li></ul><p><strong>Node.firstChild</strong></p><p><code>Node.firstChild</code>可以取得<code>Node</code>节点的<strong>第一个</strong>子节点，如果没有子节点则返回<code>null</code>。</p><p>要注意的是，子节点包括空白节点，如下面例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// tagName 属性可以取得 node 的标签名称</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.firstChild.tagName);      <span class="comment">// undefined</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为取得的是<code>&lt;p&gt;</code>与第一个<code>&lt;span&gt;</code>中间的换行字元，所以<code>p.firstChild.tagName</code>会得到<code>undefined</code>。所以改成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// tagName 属性可以取得 node 的标签名称</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.firstChild.tagName);      <span class="comment">// "SPAN"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把中间的换行与空白移除，就会得到预期中的<code>&quot;SPAN&quot;</code>了。</p><p><strong>Node.lastChild</strong></p><p><code>Node.lastChild</code>可以取得<code>Node</code>节点的最后一个子节点，如果没有子节点则返回<code>null</code>。</p><p>与<code>Node.firstChild</code>一样的是，子节点也包括空白节点，所以像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// textContent 属性可以取得节点内的文字内容</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.lastChild.textContent);      <span class="comment">// "" (换行字元)</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到的会是一个换行字元的空字符串。</p><p>移除节点之间多余的空白后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="javascript">  <span class="comment">// textContent 属性可以取得节点内的文字内容</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.lastChild.textContent);      <span class="comment">// "span 3"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出的就会是正确的”span 3” 啦。</p><p><strong>Node.parentNode</strong></p><p>那么相较于Child系列，<code>parentNode</code>就单纯一些。</p><p>通过<code>Node.parentNode</code>可以用来取得父元素，返回值可能会是一个元素节点(Element node)、根节点(Document node)或DocumentFragment节点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'span'</span>);   </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el.parentNode.nodeName );    <span class="comment">// "P"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Node.previousSibling</strong></p><p>看完了DOM父与子之后，接着来看看兄弟节点。</p><p>通过<code>Node.previousSibling</code>可以取得同层之间的前一个节点，如果node已经是第一个节点且前面无节点，则返回<code>null</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'span'</span>);   </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el.previousSibling );    <span class="comment">// null</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// document.querySelectorAll 会取得所有符合条件的集合，</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 而 document.querySelectorAll('span')[2] 指的是「第三个」符合条件的元素。</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span'</span>)[<span class="number">2</span>];   </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el2.previousSibling.textContent );    <span class="comment">// "span 2"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Node.nextSibling</strong></p><p>与<code>Node.previousSibling</code>类似，通过<code>Node.nextSibling</code>可以取得同层之间的下一个节点，如果node已经是最后一个节点，则返回<code>null</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// document.querySelector 会取得第一个符合条件的元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'span'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el.nextSibling.textContent );    <span class="comment">// "span 2"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>document.getElementsBy*与document.querySelector/ document.querySelectorAll的差异</strong></p><p>今天分享了很多关于DOM的选取以及查找遍历的方式，其中，像是<code>document.getElementById</code>以及<code>document.querySelector</code>因为取得的一定只会有一个元素/节点，所以不会有<code>index</code>与<code>length</code>属性。</p><p>而<code>document.getElementsBy**</code>(注意，这里有个s)以及<code>document.querySelectorAll</code>则分别返回HTMLCollection与NodeList。</p><p>这两者其实是有点差别的，HTMLCollection只收集HTML element 节点，而NodeList除了HTML element 节点，也包含文字节点、属性节点等。当然两者也有类似的地方，虽然不能使用数组的method，但这两种都可以用数组索引的方式来存取内容，也就是伪数组。</p><p>另一个需要注意的地方是，HTMLCollection/NodeList在大部分情况下是<strong>即时更新</strong>的，但通过<code>document.querySelector</code>/<code>document.querySelectorAll</code>取得的NodeList是<strong>静态</strong>的。</p><p>啥意思呢？举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> outerDiv = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 所有的 &lt;div&gt; 标签</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> allDivs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 2</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 清空 <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span> 下的节点   </span></span><br><span class="line"><span class="javascript">  outerDiv.innerHTML = <span class="string">''</span>;    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 因为清空了<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span> 下的节点，所以只剩下 outer</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 1</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果改成<code>document.querySelector</code>的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> outerDiv = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 所有的 &lt;div&gt; 标签</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> allDivs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 2</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 清空 <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span> 下的节点   </span></span><br><span class="line"><span class="javascript">  outerDiv.innerHTML = <span class="string">''</span>;    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// document.querySelector 返回的是静态的 NodeList，不受 outerDiv 更新影响</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 2</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么以上就是今天所要介绍的内容啦。</p><p>在后续的文章会再继续说明DOM API新增/删除/修改节点的部分，欢迎持续关注。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇的分享当中，我们简单介绍了BOM 与DOM，也了解到JavaScript 是怎么通过它们提供的方法来与浏览器进行沟通。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://luozongmin.com/tags/DOM/"/>
    
      <category term="API" scheme="https://luozongmin.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>贵州黔东南之行</title>
    <link href="https://luozongmin.com/2019/10/18/%E8%B4%B5%E5%B7%9E%E9%BB%94%E4%B8%9C%E5%8D%97%E4%B9%8B%E8%A1%8C/"/>
    <id>https://luozongmin.com/2019/10/18/贵州黔东南之行/</id>
    <published>2019-10-18T02:23:49.368Z</published>
    <updated>2019-09-27T05:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。<a id="more"></a></p><h4 id="镇远古镇"><a href="#镇远古镇" class="headerlink" title="镇远古镇"></a>镇远古镇</h4><p>第一站来到镇远古镇，路上听导游说这里还是一位皇帝的故乡呢！哈哈~当然不是古代的皇帝啦，其实是延禧攻略里面皇帝扮演者聂远的故乡啦😜。</p><p>我们到古城的时间也接近傍晚了，吃完晚饭散步在古城河边，天空中飘着乌云，真有一种“天青色等烟雨”的既视感了。</p><p><img src="/images/guizhou/1.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/2.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/3.jpg" srcset="/img/loading.gif" alt></p><p>河边坐落了许多充满文艺的小店和清吧。</p><p><img src="/images/guizhou/4.jpg" srcset="/img/loading.gif" alt></p><p>晚上的镇远古镇，虽说夜景和去过的其它几个古镇有些相似，但镇远独特之处在于宁静，有一种与世无争的感觉。</p><p><img src="/images/guizhou/5.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/6.jpg" srcset="/img/loading.gif" alt></p><p>在镇远古镇悠悠闲闲的一天里，给我最大的感受还是来自于它的静，很静，很舒服。</p><h4 id="西江千户苗寨"><a href="#西江千户苗寨" class="headerlink" title="西江千户苗寨"></a>西江千户苗寨</h4><p>第二站到达的西江千户苗寨，号称世界上最大的苗寨，一眼望去全是木质结构的屋子，层层叠叠错落有致。</p><p><img src="/images/guizhou/7.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/8.jpg" srcset="/img/loading.gif" alt></p><p>在苗寨里面瞎逛的途中遇到了当地苗族朋友的游行表演。</p><p><img src="/images/guizhou/9.jpg" srcset="/img/loading.gif" alt></p><p>来千户苗寨当然不能错过来自苗族朋友的热情，热情之一就是宴席上的“高山流水”，其实就是灌客人们喝甜甜的米酒，自知酒量不行，仪式开始之前就躲得远远的了哈哈，同桌几个男的就被灌了😄。</p><p><img src="/images/guizhou/10.jpg" srcset="/img/loading.gif" alt></p><p>因为苗寨难得遇到断电，“幸运地”被我们给遇上了，晚上只好回州府凯里住了，晚饭刚好感受了侗族形式的“高山流水”以及侗族的歌舞表演，表演倒是没啥好看的，不过有几个侗族小姐姐还是比较好看的~哈哈不知道她能不能看到，看到的话感觉会被打屎哦😥~</p><p><img src="/images/guizhou/11.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/12.jpg" srcset="/img/loading.gif" alt></p><h4 id="高要梯田"><a href="#高要梯田" class="headerlink" title="高要梯田"></a>高要梯田</h4><p>第三站抵达高要梯田，高要的梯田虽没有像广西龙胜、云南元阳被外界所熟知，但其美景完全不逊于前者，可惜不是金秋时节来，不然景色应该会更美。</p><p><img src="/images/guizhou/13.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/guizhou/14.jpg" srcset="/img/loading.gif" alt></p><p>总体来说，此次贵州之行还是很轻松的，可惜的是没时间去到黄果树，希望下次再带她一起来哦~嘻嘻🤭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。
    
    </summary>
    
      <category term="游记" scheme="https://luozongmin.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="贵州" scheme="https://luozongmin.com/tags/%E8%B4%B5%E5%B7%9E/"/>
    
      <category term="游记" scheme="https://luozongmin.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中的函数构造式和prototype的建立</title>
    <link href="https://luozongmin.com/2019/10/18/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>https://luozongmin.com/2019/10/18/谈谈JavaScript中的函数构造式和prototype的建立/</id>
    <published>2019-10-18T02:23:49.353Z</published>
    <updated>2019-09-27T05:37:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/">《谈谈JavaScript中的function constructor和new关键字》</a>这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。<a id="more"></a></p><p>在JavaScript中的函数也是一种对象，其中包含一些属性像是该函数的名称（<code>Name</code>）和该函数的内容（<code>Code</code>），但其实<code>function</code>这里面还有一个属性，这个属性就是<code>prototype</code>，这个属性会以空对象的型式呈现。</p><p>除非你是把<code>function</code>当做<code>function constructor</code>来使用，否则这个属性就没有特别的用途；但如果你是把它当做<code>function constructor</code>，通过<code>new</code>这个关键字来执行这个<code>function</code>的话，它就有特别的意义了。</p><p><img src="/images/constructor/1.jpg" srcset="/img/loading.gif" alt></p><p>要进入这个<code>function</code>的<code>prototype</code>属性只要直接通过 <code>.prototype</code> 就可以了。</p><p>然而，有一点很容易令人困惑的地方，我们会以为如果我使用 <code>.prototype</code> 时，就可以直接进入该函数的原型，但实际上并不是这样的！</p><p><strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个<code>function constructor</code>所建立出来的对象的<code>prototype</code></strong>，听起来有点混乱吧…没关系，让我们来看一些代码来帮助我们理解这一概念。</p><h3 id="说明函数中的prototype-属性"><a href="#说明函数中的prototype-属性" class="headerlink" title="说明函数中的prototype 属性"></a>说明函数中的prototype 属性</h3><p><strong>1.function 中的prototype 属性一开始是空对象</strong></p><p>我们先执行上篇文章最后所写的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>到Google Chrome的console视窗中，我们输入 <code>Person.prototype</code>得到的结果会得到一个空对象，如下图：</p><p><img src="/images/constructor/2.jpg" srcset="/img/loading.gif" alt></p><p><strong>2.通过function constructor 所建立的对象会继承该function 中prototype 的内容</strong></p><p>接着，让我们在<code>Person.prototype</code>里面增加一个<code>getFullName</code>的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person . prototype . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>在上面代码的第6 - 8行中，我们为<code>Person.prototype</code>添加了一个函数，所以当我们在Google Chrome的console视窗中调用<code>Person.prototype</code>时，会多了这个函数在内：</p><p><img src="/images/constructor/3.jpg" srcset="/img/loading.gif" alt></p><p>刚刚，我们有提到很重要的一句话，「<strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个function constructor所建立出来的对象的<code>prototype</code></strong>」。</p><p>这句话的意思其实是说<code>Person.prototype</code>并不是<code>Person.__proto__</code>，但是所有通过<code>Person</code>这个<code>function constructor</code>所建立的对象，在该实例对象的<code>__proto__</code>中，会包含有<code>Person.prototype</code>的内容。</p><p>也就是说，当我们使用<code>new</code>这个运算符来执行<code>function constructor</code>时，它会先建立一个空对象，同时将该构造函数中<code>prototype</code>这个属性的内容（<code>Person.prototype</code>），设置到该实例对象的<code>prototype</code>中，即 <code>person1.__proto__ === Person.prototype</code>的结果为<code>true</code>。</p><p>因此，当我们在Google Chrome的console中输入<code>person1.__proto__</code>时，我们就可以看到刚刚在<code>Person.prototype</code>所建立的函数<code>getFullName</code>已经继承在里面了：</p><p><img src="/images/constructor/4.jpg" srcset="/img/loading.gif" alt></p><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>由于<code>Person.prototype</code>中的方法已经被继承到由<code>Person</code>这个<code>function constructor</code>所建立的实例对象<code>person1</code>中，所以这时侯，我们就可以顺利的使用 <code>person1.getFullName</code> 这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person . prototype . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1.getFullName() ) ;</span><br></pre></td></tr></table></figure><p>可以正确的执行<code>getFullName</code>这个函数并得到如下的结果：</p><p><img src="/images/constructor/5.png" srcset="/img/loading.gif" alt></p><h3 id="通过function-constructor与Prototype-的实用处"><a href="#通过function-constructor与Prototype-的实用处" class="headerlink" title="通过function constructor与Prototype 的实用处"></a>通过function constructor与Prototype 的实用处</h3><p>通过这样的方法，我们可以让所有根据这个函数构造器（<code>function constructor</code>）所建立的对象都包含有某些我们想要使用的方法。如果我们有1000个对象是根据这个函数构造器所建立的，那么我们只需要使用 <code>.prototype</code>这样的方法，就可以让这1000个物件都可以使用到我们想要执行的某个<code>method</code>，这样减少了代码的复用。</p><p>有的人可能会好奇问，为什么我们不把<code>getFullName</code>这个方法直接写在函数构造式当中呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">  <span class="keyword">this</span> . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person . prototype . getFullName  =  function ( )  &#123; </span></span><br><span class="line"><span class="comment">  return  this . firstName +  ' '  +  this . lastName ; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意！我们不该把方法放在<code>function constructor</code> 中。</p></blockquote><p>把方法放在函数构造式中这么做虽然仍然可以正确执行并得到结果，但是这么做会有个问题，如果我们是把这个方法直接写在函数构造式中，那么每一个对象都会包含有这个方法，如果我们有1000 个对象根据这个函数构造式所建立，那么这1000 个对象都会包含这个方法在内，如此将会占据相当多的内存；但如果是建立在<code>prototype</code> 中，我们只会有一个这样的方法。</p><p>所以，为了性能上的考量，通常会把方法（<code>method</code>）放在构造函数的<code>prototype</code> 中，因为它们可以是通用的；把属性（<code>property</code>）放在构造函数当中，因为每一个对象可能都会有不同的属性内容，如此将能有效减少内存的问题。</p><p>最后，如果感觉当前缺少你要用的方法，可以自己通过这一方法去创建。</p><p>例如在json2.js源码中，为<code>Date</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code>方法添加一个<code>toJSON</code>的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype.toJSON !== <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Date</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isFinite</span>(<span class="keyword">this</span>.valueOf()) ?</span><br><span class="line">        <span class="keyword">this</span>.getUTCFullYear() + <span class="string">'-'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCMonth() + <span class="number">1</span>) + <span class="string">'-'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCDate()) + <span class="string">'T'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCHours()) + <span class="string">':'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCMinutes()) + <span class="string">':'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCSeconds()) + <span class="string">'Z'</span> : <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span>.prototype.toJSON = </span><br><span class="line">  <span class="built_in">Number</span>.prototype.toJSON = </span><br><span class="line">  <span class="built_in">Boolean</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueOf();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/&quot;&gt;《谈谈JavaScript中的function constructor和new关键字》&lt;/a&gt;这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="constructor" scheme="https://luozongmin.com/tags/constructor/"/>
    
      <category term="prototype" scheme="https://luozongmin.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中的函数构造式和new关键字</title>
    <link href="https://luozongmin.com/2019/10/18/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://luozongmin.com/2019/10/18/谈谈JavaScript中的函数构造式和new关键字/</id>
    <published>2019-10-18T02:23:49.321Z</published>
    <updated>2019-09-27T05:38:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？<a id="more"></a></p><p>大多数 Javascript 的新开发者不太想要使用new关键字，因为这会让代码写的像是 Java 并且在使用上会造成一点混乱；在这篇文章我会尽量尝试着去理清这些东西，并解释它是如何运作的。</p><h3 id="谈谈function-constructor"><a href="#谈谈function-constructor" class="headerlink" title="谈谈function constructor"></a>谈谈function constructor</h3><p><code>constructor</code> 翻为构造器但为了让您之后更好地理解，会直接使用 <code>constructor</code>；在 Javascript 中任何一个函数(<code>function</code>)都可以被当作 <code>constructor</code>；Javascript 并没有明确的区分两者，也就是说 <code>function</code> 可以被当作 <code>constructor</code> 或者当作一般函数调用。</p><p>而 <code>constructor</code> 的用法就是 <code>function</code> 搭配<code>new</code>关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>接着我们把<code>person</code>呼叫出来看，会得到如下的结果，<strong>通过<code>new</code>它会帮我们建立一个对象</strong>，然后里面有<code>Person</code>这个<code>function</code>里面的内容，并且变成了属性名称和属性值：</p><p><img src="/images/new/1.png" srcset="/img/loading.gif" alt></p><h3 id="进一步来看new-让这个过程发生了什么"><a href="#进一步来看new-让这个过程发生了什么" class="headerlink" title="进一步来看new 让这个过程发生了什么"></a>进一步来看new 让这个过程发生了什么</h3><p>当使用<code>new</code>命令时，它后面的函数依次执行下面的4个步骤：</p><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li><li>如果函数没有return其他对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ol><p>也就是说，当我们使用<code>new</code>这个关键字时，实际上会先有一个空的对象被建立。</p><p>接着<code>People</code>这个构造函数会被执行，这个空对象的原型，指向了<code>People.prototype</code>。</p><p>我们知道当函数执行的时候，在<code>execution context</code>中会有<code>this</code>被建立，而<strong>当我们使用<code>new</code>的时候，函数里面的<code>this</code>会被指定成刚刚所建立的那个空对象</strong>。</p><p>所以当执行<code>People</code>这个<code>function</code>，执行到<code>this.firstName</code>和<code>this.lastName</code>时，因为<code>this</code>现在指称的是那个空对象，所以实际上是在帮这个空对象赋予属性名称和属性值。</p><p>在这样的过程中，<strong>只要这个构造函数<code>People</code> 没有指定<code>return</code>为其他对象，它就会直接返回给我们这个新建立的对象</strong>。</p><p>接着让我们通过一段代码来更清楚的了解这个执行的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="string">'这个函数有被执行'</span> ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>这时候在chrome 中呼叫出来的结果如下，说明了当我们使用<code>new</code> 在构造对象的时候<code>People</code> 这个<code>function</code> 确实有被执行：</p><p><img src="/images/new/2.png" srcset="/img/loading.gif" alt></p><h3 id="通过new-会帮我们建立一个空的对象"><a href="#通过new-会帮我们建立一个空的对象" class="headerlink" title="通过new 会帮我们建立一个空的对象"></a>通过new 会帮我们建立一个空的对象</h3><p>现在我把我们上面的代码改成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span> (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="keyword">this</span> ) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="comment">// console.log(person);</span></span><br></pre></td></tr></table></figure><p>这时候代码返回的结果如下，表示的确在执行这段代码的过程中帮我们建立了一个新的空对象：</p><p><img src="/images/new/3.jpg" srcset="/img/loading.gif" alt></p><h3 id="函数的最后若return其他对象，则原新对象内容会被覆盖"><a href="#函数的最后若return其他对象，则原新对象内容会被覆盖" class="headerlink" title="函数的最后若return其他对象，则原新对象内容会被覆盖"></a>函数的最后若return其他对象，则原新对象内容会被覆盖</h3><p>现在，让我们把原本的代码稍微做如下修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">  <span class="keyword">return</span>   &#123; <span class="string">"RETURN"</span> : <span class="string">"原本this的内容就不会被返回"</span> &#125; ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>构造函数的内部若<code>return</code>其他对象，<code>new</code>命令会返回<code>return</code>语句指定的对象，将原新对象内容覆盖掉；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。返回的结果如下：</p><p><img src="/images/new/4.png" srcset="/img/loading.gif" alt></p><h3 id="手写一个new实现"><a href="#手写一个new实现" class="headerlink" title="手写一个new实现"></a>手写一个new实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line"><span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line"><span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line"><span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这个手写的new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内置函数new</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(...)</span><br><span class="line">                        </span><br><span class="line"><span class="comment">// 使用手写的new，即create</span></span><br><span class="line"><span class="keyword">var</span> person = create(Person, ...)</span><br></pre></td></tr></table></figure><p>代码原理解析：</p><ol><li>用<code>new Object()</code> 的方式新建了一个对象<code>obj</code></li><li>取出第一个参数，就是我们要传入的构造函数。此外因为 <code>shift</code> 会修改原数组，所以 <code>arguments</code> 会被去除第一个参数</li><li>将 <code>obj</code> 的原型指向构造函数，这样<code>obj</code>就可以访问到构造函数原型中的属性</li><li>使用 <code>apply</code>，改变构造函数 <code>this</code> 的指向到新建的对象，这样 <code>obj</code> 就可以访问到构造函数中的属性</li><li>返回 <code>obj</code></li></ol><h3 id="function-constructor-的实际应用"><a href="#function-constructor-的实际应用" class="headerlink" title="function constructor 的实际应用"></a>function constructor 的实际应用</h3><p>由上面的方法，我们可以通过<code>function</code>的方式来建立一个新的对象，如果我们想要<strong>建立出同属性名称但不同属性值的对象内容，我们可以把对象的属性值变成参数</strong>，如此就能通过此<code>function constructor</code>建立出许多不同的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>如此，我们就可以通过同一个构造函数建立出很多不同的对象：</p><p><img src="/images/new/5.png" srcset="/img/loading.gif" alt></p><p>此外，我们会把根据<strong>构造器（<code>constructor</code>）所建立出来的对象称作是实例（<code>instance</code>）</strong>，这在之前的文章里也有提过。</p><h3 id="注意！如果我们忘了加上new关键字"><a href="#注意！如果我们忘了加上new关键字" class="headerlink" title="注意！如果我们忘了加上new关键字"></a>注意！如果我们忘了加上new关键字</h3><p>这里有一个地方我们需要非常留意，如果你在撰写代码的过程当中，忘记加上<code>new</code>这个关键字的话，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>如此，因为JavaScript不知道你是要执行这个函数，还是要根据这个<code>function</code>去建立<code>object</code>，因次最后会返回<code>undefined</code>的结果。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>其实构造函数（function constructor）就是普通的function，只是我们可以通过这个function 来建立对象。</li><li>通过在function 前面加上new 这个运算符，它会把函数中this 这个关键字建立成一个新的对象，然后如果你没有在该函数的内部指定返回出其它对象的话，它就会自动返回这个新的对象给你。</li></ul><p>那又是如何通过<code>function constructors</code> 来设定我们的原型（<code>prototype</code>）呢？让我们在下一篇文章来谈吧！</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="constructor" scheme="https://luozongmin.com/tags/constructor/"/>
    
      <category term="new" scheme="https://luozongmin.com/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中创建对象(Object)</title>
    <link href="https://luozongmin.com/2019/10/18/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%BB%BA%E7%AB%8B(Object)/"/>
    <id>https://luozongmin.com/2019/10/18/谈谈JavaScript中对象建立(Object)/</id>
    <published>2019-10-18T02:23:49.306Z</published>
    <updated>2019-09-27T06:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中我将会着重说明如何创建和调用JavaScript里的对象（Object）。<a id="more"></a>   </p><h4 id="对象（Object）是什么？"><a href="#对象（Object）是什么？" class="headerlink" title="对象（Object）是什么？"></a>对象（Object）是什么？</h4><p>在开始介绍如何创建对象前，我们要知道对象是什么。<strong>对象（<code>Object</code>）</strong>简单地来说，就是一堆「名称- 值」的配对（key - value pairs）。至于可以放入哪些值呢？  </p><p>第一种是原生的值（<code>primitive</code>），像是布尔值（<code>Boolean</code>）、数值（<code>Number</code>）或是字符串（<code>String</code>），而在对象当中，我们把这类的值称为属性（<code>Property</code>）。  </p><p>第二种可以放入的值是对象（<code>Object</code>），也就是在一个对象里面再嵌入一个对象，这种以对象为值的情况我们也把它称作属性（<code>Property</code>）。  </p><p>第三种放入的值可以是函数（<code>function</code>），在对象的情况下，我们会把这种函数称做方法（<code>method</code>）。在对象中的每一个<code>Property</code>或是<code>Method</code>都会占据电脑当中一个记忆体的位置，在需要使用到的时候，把它们调取出来。  </p><p>接下来我将介绍三种创建JavaScript里的对象及如何调用的方法：  </p><h4 id="方法一：使用"><a href="#方法一：使用" class="headerlink" title="方法一：使用 [ ]"></a>方法一：使用 [ ]</h4><p><strong>创建对象</strong>  </p><p>创建对象的第一个方法是使用<code>[ ]</code>，<code>[ ]</code>在JavaScript中被称做Computed Member Access：  </p><p><img src="/images/object/2.jpg" srcset="/img/loading.gif" alt>    </p><p>让我们看一下底下的例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person[<span class="string">"firstname"</span>] = <span class="string">"Jay"</span>;</span><br><span class="line">person[<span class="string">"lastname"</span>] = <span class="string">"Chou"</span>;</span><br></pre></td></tr></table></figure><p>这是利用<code>[ ]</code>创建对象的方法，首先我们创建一个对象，叫做<code>person</code>，接着开始给它「名称-值」配对，例如，<code>firstname</code>是属性的名称，<code>Jay</code>则是它的值；<code>lastname</code>也是属性名称，<code>Chou</code>则是它的值。通过这种方法，我们就可以创建对象里面的各种「名称-值」配对。  </p><p><strong>调用对象</strong>   </p><p>紧接上面的例子，我们也同样可以利用<code>[ ]</code>来调用已经建立好的对象，<code>[ ]</code>里面如果放的是字符串而不是变量，注意要记得加上引号’像是这样：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用对象</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"firstname"</span>]);  <span class="comment">// Jay</span></span><br></pre></td></tr></table></figure><p>另外，如果是通过<code>[ ]</code>来调用对象的话，还有一个特别的地方，就是<code>[ ]</code>内可以放变量，像是这样（当<code>[ ]</code>里面放的是变量时不用加引号<code>&quot;</code>），一样可以调用到对象的值，这个是用种方法二（<code>.</code>）做不到的：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用对象</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="string">"lastname"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[id]);  <span class="comment">// Chou</span></span><br></pre></td></tr></table></figure><h4 id="方法二：使用点符号"><a href="#方法二：使用点符号" class="headerlink" title="方法二：使用点符号 ."></a>方法二：使用点符号 .</h4><p><strong>创建对象</strong>  </p><p>第二种创建对象的方法是使用英文的句点 <code>.</code>，在JavaScript中被称做Member Access，创建的方法如下：我们在刚刚创建的<code>person</code>这个对象里面，再创建一个对象属性，名称为<code>address</code>。其实，我觉得可以把.翻译成中文的「的」，所以这里的意思就是，在<code>person</code>的里面创建一个名称为<code>address</code>的对象；在<code>person</code>的<code>address</code>的<code>country</code>，创建一个值为<code>&quot;China&quot;</code>，以此类推…。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">person.address = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.address.country = <span class="string">"China"</span>;</span><br><span class="line">person.address.city = <span class="string">"Hangzhou"</span>;</span><br><span class="line">person.address.location = <span class="string">"Xihu"</span>;</span><br></pre></td></tr></table></figure><p><strong>调用对象</strong>  </p><p>同样的方法也可以用来调用出该对象的值：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用对象</span></span><br><span class="line"><span class="built_in">console</span>.log(person.address);  <span class="comment">//&#123;country: "China", city: "Hangzhou", location: "Xihu"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.address.country);  <span class="comment">// China</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"address"</span>][<span class="string">"location"</span>]);  <span class="comment">// Xihu</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，<code>.</code> 和<code>[ ]</code>是可以交替使用的。  </p><h4 id="方法三：使用"><a href="#方法三：使用" class="headerlink" title="方法三：使用{ }"></a>方法三：使用{ }</h4><p><strong>创建对象</strong>  </p><p>其实还有在创建对象上有更快的做法，我们可以直接使用<code>{ }</code>，我们可以把上面的代码，改成这样：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    firstname: <span class="string">"Jay"</span>,</span><br><span class="line">    lastname: <span class="string">"Chou"</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        country: <span class="string">"China"</span>,</span><br><span class="line">        city: <span class="string">"Hangzhou"</span>,</span><br><span class="line">        location: <span class="string">"Xihu"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，可以得到与方法二一模一样的结果，调用方法也一致。  </p><p><strong>搭配函数使用对象</strong>  </p><p>在我们创建好对象后，我们可以搭配函数(<code>function</code>)来使用对象，例如，我先把刚刚创建的对象<code>person</code>，改成叫做<code>jaychou</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jaychou = &#123;</span><br><span class="line">    firstname: <span class="string">"Jay"</span>,</span><br><span class="line">    lastname: <span class="string">"Chou"</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        country: <span class="string">"China"</span>,</span><br><span class="line">        city: <span class="string">"Hangzhou"</span>,</span><br><span class="line">        location: <span class="string">"Xihu"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建一个名称为<code>SayHI</code>的函数，并且带入我们的对象：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SayHI</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"HI"</span> + people.lastname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SayHI(jaychou);  <span class="comment">// HI Chou</span></span><br></pre></td></tr></table></figure><p><strong>直接在函数参数的地方创建对象</strong>  </p><p>我们也可以直接在调用函数的同时创建对象，像是这样子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SayHI(&#123;<span class="attr">firstname</span>: <span class="string">"Jony"</span>, <span class="attr">lastname</span>: <span class="string">"J"</span>&#125;);  <span class="comment">// HI J</span></span><br></pre></td></tr></table></figure><p>一开始看到这样的写法可能会觉得很奇怪，但其实这种方式和我们直接在函数的参数里面输入字符串或数值是一样的意思，只是这里是创建一个对象。我们把这种直接在函数的参数中创建对象的方法称做”creating object on the fly”（即动态创建对象）。  </p><h4 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h4><p>其实使用<code>new Object</code>不是创建对象最好的方式，这点会在之后的文章再作说明。另外，虽然使用<code>[ ]</code>和<code>.</code>都可以拿来创建对象和调用对象，但还是建议尽量使用点符号.作为创建对象和调用对象的方法，这样比较干净简洁，在debug的时候也比较容易。  </p><p>还有不论你使用的是<code>new Object</code>、”<code>.</code>“、或者直接用”<code>{ }</code>“来创建对象，其实在JavaScript转译之后，本质上做的都是同样的事。它都会将这个对象建立在内存中，并创建该对象的属性（<code>property</code>）和方法（<code>method</code>）在内存中。   </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中我将会着重说明如何创建和调用JavaScript里的对象（Object）。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="对象" scheme="https://luozongmin.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Object" scheme="https://luozongmin.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>谈谈浏览器里的JavaScript</title>
    <link href="https://luozongmin.com/2019/10/18/%E8%81%8A%E4%B8%80%E8%81%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%9A%84JavaScript/"/>
    <id>https://luozongmin.com/2019/10/18/聊一聊浏览器里的JavaScript/</id>
    <published>2019-10-18T02:23:49.274Z</published>
    <updated>2019-09-27T05:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在许多的网页前端教学或是文章书籍当中，你可能常常听到这样的说法：「HTML、CSS 与JavaScript 是网页前端三大要素」<a id="more"></a>，其中： </p><ul><li>HTML 负责资料与结构</li><li>CSS 负责样式与呈现</li><li>JavaScript 负责行为与互动</li></ul><p><img src="/images/dom/1.jpg" srcset="/img/loading.gif" alt>   </p><p>那么，如果你跟我在学JavaScript的时候也有一样的疑问：<strong>变量、类型、对象、流程控制、函数</strong>…表面上看似基础都学会了，但…  </p><p><strong>我还是不知道怎么通过JavaScript在网页上输出”Hello World!”啊！</strong>   </p><p><img src="/images/dom/2.png" srcset="/img/loading.gif" alt>   </p><p>那么相信看完今天的分享，我保证你一定可以通过JavaScript 在网页上输出”Hello World!” (嘻嘻)  </p><h3 id="浏览器里的JavaScript"><a href="#浏览器里的JavaScript" class="headerlink" title="浏览器里的JavaScript"></a>浏览器里的JavaScript</h3><p>严格来说，JavaScript (或者说ECMAScript 标准) 并没有提供网页的操作方法。  </p><p>事实上，前端开发者在网页的操作方法都是由JavaScript的执行平台，也就是<strong>浏览器</strong>提供的。这些操作方法基本上会分别由这两种对象所拥有：BOM与DOM。  </p><p>所以广泛来说，在浏览器上的JavaScript 实际上包含了以下三部分：  </p><ul><li><strong>JavaScript核心</strong> (以ECMAScript标准为基础)</li><li><strong>BOM</strong> (Browser Object Model，浏览器对象模型)</li><li><strong>DOM</strong> (Document Object Model，文件对象模型)  </li></ul><p>由于BOM与DOM是由浏览器执行环境所提供；所以换句话说，在node环境下的JavaScript就不会有这两个部分。  </p><p>前端开发者就是可以通过JavaScript 去调用BOM 与DOM 提供的API，进一步通过它们去控制浏览器的行为与网页的内容。  </p><p>那么接下来就来具体介绍一下BOM与DOM吧。  </p><h3 id="BOM-是什么"><a href="#BOM-是什么" class="headerlink" title="BOM 是什么?"></a>BOM 是什么?</h3><p><strong>BOM</strong>(<strong>Browser Object Model</strong>，浏览器对象模型)，是浏览器所有功能的核心，与网页的内容无关。  </p><p>在早期没有制定标准规范的时候，各家浏览器厂商几乎在自家浏览器上都有各自的功能，非常混乱。直到后来W3C 把各家浏览器都有的部分，以及确定已经(或未来会) 加入的功能，统一集合起来纳入了HTML5 的标准中，这也就是我们现在看到的BOM API。  </p><p>BOM 有时也有人非正式地称它为Level 0 DOM。因为它在DOM level 1 标准前就已存在，而不是真的有文件去规范这些，所以Level 0 DOM与BOM两者实际上指的是同一个东西。</p><h3 id="BOM的核心window对象"><a href="#BOM的核心window对象" class="headerlink" title="BOM的核心window对象"></a>BOM的核心window对象</h3><p><img src="/images/dom/3.jpg" srcset="/img/loading.gif" alt>   </p><p>从上图可以看出BOM的核心是<code>window</code>对象。 </p><p>而<code>window</code>对象提供的属性主要为<code>document</code>、<code>location</code>、<code>navigator</code>、<code>screen</code>、<code>history</code>以及<code>frames</code>。  </p><p>在浏览器里的<code>window</code>对象会扮演着两种角色：  </p><ul><li>ECMAScript 标准里的<strong>全局对象</strong> (Global Object)</li><li>JavaScript 用来与浏览器沟通的窗口</li></ul><p>凡是<strong>在全局作用域内声明的变量、对象、函数等，都会自动变成全局对象的属性</strong>。通常这样的变量，我们会称它们叫做<strong>全局变量</strong>，可以通过window.xxx的方式取得它们。比如：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>除此之外，在全局作用域内声明的全局变量还有一个特性，就是无法使用<code>delete</code>关键字来移除： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.a);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>但若是直接通过指定<code>window</code>对象的属性则可以：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.a);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>现在我们已经知道了全局对象是怎么回事了，那么<code>window</code>对象扮演的另一个角色，<strong>用来与浏览器沟通的窗口</strong>又是什么意思呢？  </p><h3 id="浏览器内建的对话框"><a href="#浏览器内建的对话框" class="headerlink" title="浏览器内建的对话框"></a>浏览器内建的对话框</h3><p>先来个最常见的例子：alert()警告对话框：  </p><p><img src="/images/dom/4.jpg" srcset="/img/loading.gif" alt>   </p><p>(alert on Chrome)</p><p>我想不管是不是刚接触JavaScript的朋友，对<code>alert</code>应该都不陌生，<code>alert</code>的完整语法其实是这样：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">"message"</span>);</span><br></pre></td></tr></table></figure><p>如同我们所熟知的全局变量一样，<code>window</code>对象下的成员，<code>window</code>是可以省略不打的。  </p><p>一行代码就可以生成一个对话框，很神奇吧？  </p><p>而这就是浏览器环境的BOM提供给JavaScript控制的功能之一。  </p><p>类似的对话框还有用来提供<strong>确定/取消</strong>的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm" target="_blank" rel="noopener">window.confirm()</a>，以及开放式问答的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt" target="_blank" rel="noopener">window.prompt()</a>对话框。  </p><p>当然BOM 提供的API 很多，包含开启/关闭视窗，改变视窗大小，计时器与取得网址等等。这些在之后的文章当中还会再细说。  </p><h3 id="DOM-是什么"><a href="#DOM-是什么" class="headerlink" title="DOM 是什么?"></a>DOM 是什么?</h3><p><strong>DOM</strong>(<strong>Document Object Model</strong>，文件对象模型)，是一个将HTML文件以树状的结构来表示的模型，而组合起来的树状图，我们称之为DOM Tree。 </p><p>简单来说，我们把HTML每个节点的关系连接起来倒着看，就好像是一棵树一样。假设我们有一个基本的HTML如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;米淇淋的个人博客&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;这是主题&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;这是一个&lt;i&gt;简单&lt;/i</span>&gt;的段落&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/domapi-5.jpg" srcset="/img/loading.gif" alt>  </p><p>在最根部的地方，就是<code>document</code>，就是BOM图中<code>window</code>下面的那个。</p><p>往下可以延伸出一个个的HTML 标签，一个节点就是一个标签，往下又可以再延伸出文本节点与属性的节点。</p><p>而DOM API 就是定义了让JavaScript 可以存取、改变HTML 结构、样式和内容的方法，甚至是对节点绑定的事件。</p><p>JavaScript 就是通过DOM 提供的API 来对HTML 做存取与操作。 </p><h3 id="DOM-与-BOM-的区别"><a href="#DOM-与-BOM-的区别" class="headerlink" title="DOM 与 BOM 的区别"></a>DOM 与 BOM 的区别</h3><p>前面介绍BOM时，我们已经知道DOM的<code>document</code>其实也就是<code>window</code>对象的子对象之一。 </p><p>而 DOM 与 BOM 最大的区别在于：</p><ul><li>BOM: JavaScript 与<strong>浏览器</strong>沟通的窗口，不涉及网页内容。</li><li>DOM: JavaScript 用来控制<strong>网页</strong>的节点与内容的标准。</li></ul><p>BOM完全依赖于浏览器厂商实作本身无标准规范，而DOM有着W3C 所制定的标准来规范。</p><p>想要通过DOM API 取得节点，JavaScript 可以这样写： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的值，找到 DOM 中 id 为 'xxx' 的元素。</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 class 名称，返回所有符合条件的 NodeList 对象。</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的 NodeList。</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'xxx'</span>); </span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure><p>而透过DOM API选取出来的节点，我们可以通过操作<code>textContent</code>属性来变更它的文字。</p><p>假设有一个HTML 节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"greet"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再来我们就可以先通过<code>document.querySelector()</code>方法来取得节点，然后修改<code>textContent</code>属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'#greet'</span>).textContent = <span class="string">'Hello World!'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/fuhurapivu/embed?html,js,output" target="_blank" rel="noopener">JS Bin on jsbin.com</a></p><p>看到这里，恭喜你已经可以通过JavaScript 在网页上输出”Hello World!” 啦！</p><p>在后续的内容中，我们会继续来介绍各种操作网页的DOM/BOM API。</p><p>毕竟对前端工程师来说，搞懂<strong>怎么与浏览器打交道、怎么操作网页内容</strong>，就是做好WebUI最重要的基础。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在许多的网页前端教学或是文章书籍当中，你可能常常听到这样的说法：「HTML、CSS 与JavaScript 是网页前端三大要素」
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://luozongmin.com/tags/DOM/"/>
    
      <category term="BOM" scheme="https://luozongmin.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>由一段代码引发的关于Object和Function的鸡和蛋问题的思考</title>
    <link href="https://luozongmin.com/2019/10/18/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://luozongmin.com/2019/10/18/由一段代码引发的关于Object和Function的鸡和蛋问题的思考/</id>
    <published>2019-10-18T02:23:49.259Z</published>
    <updated>2019-09-27T05:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。<a id="more"></a> </p><h3 id="鸡和蛋问题的由来"><a href="#鸡和蛋问题的由来" class="headerlink" title="鸡和蛋问题的由来"></a>鸡和蛋问题的由来</h3><p>首先<code>Object</code>和<code>Function</code>都是构造函数，而所有的构造函数都是<code>Function</code>的实例对象。 因此<code>Object</code>是<code>Function</code>的实例对象；而<code>Function.prototype</code>是<code>Object</code>的实例对象。所以这里就引伸出了一个有意思的鸡和蛋的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>那么<code>Object</code>和<code>Function</code>，谁是鸡谁是蛋呢？</p><p>接下来就来深入探究下上面这段代码所引起的鸡生蛋蛋生鸡问题，从下面这张原型/原型链经典图入手，在这个过程中深入了解 <code>Object.prototype</code>、<code>Function.prototype</code>、<code>function Object()</code> 、<code>function Function()</code> 之间的关系，这个过程可能有点烧脑，毕竟是JS的一大玄学嘛。</p><p><img src="/images/egg/1.jpg" srcset="/img/loading.gif" alt>  </p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>原型链的尽头就是<code>Object.prototype</code>（不考虑 <code>null</code> 的情况下）。<strong>所有对象均从</strong><code>Object.prototype</code><strong>继承toString() 等公共属性</strong>。</p><p><img src="/images/egg/2.jpg" srcset="/img/loading.gif" alt>   </p><p><code>Object.prototype</code> 表示 <code>Object</code> 的原型对象，实际上<code>Object.prototype</code> 并不是通过<code>Object</code>函数创建的，为什么呢？看如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'川普'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.__proto__ === Dog.prototype;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>实例对象的<code>__proto__</code>会指向构造函数的<code>prototype</code>，即<code>dog.__proto__</code>指向 <code>Dog.prototype</code>，但是<code>Object.prototype.__proto__</code>又是 <code>null</code>，所以 <code>Object.prototype</code> 并不是通过 <code>Object</code> 函数创建的，那它如何生成的？其实 <code>Object.prototype</code> 是浏览器底层根据 ECMAScript 规范创造的一个对象，所以在经典图里面只是看起来<code>Object.prototype</code> 是通过 <code>Object</code> 函数创建的，实际上并不是。</p><p><img src="/images/egg/3.jpg" srcset="/img/loading.gif" alt>  </p><h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p><code>Function.prototype</code>和<code>Function.__proto__</code>为<strong>同一对象</strong>。</p><p><img src="/images/egg/4.jpg" srcset="/img/loading.gif" alt>  </p><p>这也意味着：<strong><code>Object</code>/<code>Array</code>等等构造函数本质上和<code>Function</code>一样，均继承于<code>Function.prototype</code>，从经典图上来看都是通过<code>new Function</code>构造出来的</strong>。</p><p>当然，<code>Function.prototype</code> 对象是一个函数（对象），其<code>__proto__</code>属性指向 <code>Object.prototype</code>，即<code>Function.prototype</code>会直接继承root（<code>Object.prototype</code>）。</p><p><img src="/images/egg/5.jpg" srcset="/img/loading.gif" alt> </p><p>通过这点我们可以弄清<strong>继承的原型链</strong>：<code>Function|Object|Array...---&gt;Function.prototype---&gt;Object.prototype(root)</code>。如下图所示：</p><p><img src="/images/egg/6.jpg" srcset="/img/loading.gif" alt> </p><h3 id="function-Object"><a href="#function-Object" class="headerlink" title="function Object()"></a>function Object()</h3><p><code>Object</code> 作为构造函数时，其<code>__proto__</code>属性指向 <code>Function.prototype</code>，即:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从经典图来看：</p><p><img src="/images/egg/7.jpg" srcset="/img/loading.gif" alt>   </p><p>使用 <code>new Object()</code> 创建实例对象o1时，实例对象o1的 <code>__proto__</code>属性指向构造函数的 <code>prototype</code> 属性，对应上图就是 <code>Object.prototype</code>，即<code>o1.__proto__ === Object.prototype</code>结果为<code>true</code>。</p><p><code>Function.prototype</code>指向的对象，它的<code>__proto__</code>会指向<code>Object.prototype</code>，因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。</p><h3 id="function-Function"><a href="#function-Function" class="headerlink" title="function Function()"></a>function Function()</h3><p><code>Function</code>也是一个函数对象，也有<code>__proto__</code>属性，既然是函数，那么它一定是被<code>Function</code>创建，所以<code>Function</code>是被自身创建的，所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/images/egg/8.jpg" srcset="/img/loading.gif" alt>  </p><p>到这里就有点烧脑了吧，我们再看下鸡生蛋蛋生鸡问题。</p><h3 id="Function-amp-Object-鸡和蛋问题"><a href="#Function-amp-Object-鸡和蛋问题" class="headerlink" title="Function &amp; Object 鸡和蛋问题"></a>Function &amp; Object 鸡和蛋问题</h3><p>由上面可知，<code>Object</code>构造函数继承了<code>Function.prototype</code>，同时<code>Function</code>构造函数继承了<code>Object.prototype</code>，这里就产生了<strong>鸡和蛋</strong>的问题。为什么会出现这种问题呢？必须首先更深入一层去理解<code>Function.prototype</code>这个对象，因为它是导致<code>Function instanceof Object</code>和<code>Object instanceof Function</code>都为<code>true</code>的原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object instanceof Function 即</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function instanceof Object 即</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object instanceof Object 即 </span></span><br><span class="line"><span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function instanceof Function 即</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据JS规范，<code>Function.prototype</code>又是个不同于一般函数（对象）的函数（对象），其中：</p><ol><li><code>Function.prototype</code>像普通函数一样可以调用，但总是返回<code>undefined</code>。</li><li>普通函数实际上是<code>Function</code>的实例，即普通函数继承于<code>Function.prototype</code>。即<code>func.__proto__ === Function.prototype</code>。</li><li><code>Function.prototype</code>继承于<code>Object.prototype</code>，并且没有<code>prototype</code>这个属性。</li><li>所以，<code>Function.prototype</code>其实是个另类的函数，可以独立于/先于<code>Function</code>产生。</li></ol><p>而<code>Object</code>本身是个（构造）函数，是<code>Function</code>的实例，即<code>Object.__proto__</code>就是<code>Function.prototype</code>。</p><p><strong>总结：先有<code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code>继承<code>Object.prototype</code>而产生，最后，<code>Function</code>和<code>Object</code>和其它构造函数继承<code>Function.prototype</code>而产生</strong>。</p><p>看到这里估计也都看烦了，是不是还是有点混乱呀？乱也很正常。那这篇文章就先让它乱着，下一篇我们将请另一个老朋友来帮忙，把它彻底理清楚，这位老朋友就是——<code>instanceof</code>，那就且听请下回分解咯。</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Function" scheme="https://luozongmin.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数组常见遍历方法</title>
    <link href="https://luozongmin.com/2019/10/18/%E6%B5%85%E8%B0%88%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <id>https://luozongmin.com/2019/10/18/浅谈数组常见遍历方法/</id>
    <published>2019-10-18T02:23:49.228Z</published>
    <updated>2019-09-27T06:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍数组常见的遍历方法：forEach、map、filter、find、every、some、reduce，它们都有个共同点：不会改变原始数组。<a id="more"></a>   </p><p><img src="/images/array/1.png" srcset="/img/loading.gif" alt>   </p><p>接下来都是使用底下的基础数组来实现一些方法：  </p><ul><li>累加</li><li>比大小</li><li>分别运算</li><li>查找特定值等  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'马云'</span>,</span><br><span class="line">    money: <span class="number">2000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'马化腾'</span>,</span><br><span class="line">    money: <span class="number">1800</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'李彦宏'</span>,</span><br><span class="line">    money: <span class="number">1500</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'我'</span>,</span><br><span class="line">    money: <span class="literal">Infinity</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="forEach：遍历数组"><a href="#forEach：遍历数组" class="headerlink" title="forEach：遍历数组"></a>forEach：遍历数组</h3><p>forEach与另外几种方法有些许不同，就是除了forEach以外的几个方法都会返回值，如果在等号的左方放一个变量，那么此变量返回值将会是<code>undefined</code>(没有返回任何值)。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forEachLoop = people.forEach( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span> .log(item, index, array); <span class="comment">//（对象,索引,全部数组）</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(forEachLoop); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>其它的方法都会返回一个值或数组，以此来说就会传回原本的数组值。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapLoop = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapLoop); <span class="comment">//与原本数组资料相同</span></span><br></pre></td></tr></table></figure><h3 id="map：一一映射另一个数组"><a href="#map：一一映射另一个数组" class="headerlink" title="map：一一映射另一个数组"></a>map：一一映射另一个数组</h3><p>map会return返回的对象、值，作用上是用来处理数组返回新值产生一个新数组，要特别注意返回的值数量与原始数组长度相同，所以如果不给return，默认返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有给return 也会产生undefined</span></span><br><span class="line"><span class="keyword">var</span> mapEmpty = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapEmpty);     <span class="comment">// [undefined, undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> everyoneAdd = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line">  item.money = item.money + <span class="number">500</span> ; <span class="comment">//每个money + 500</span></span><br><span class="line">  <span class="keyword">return</span> item;              <span class="comment">//返回对象</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(everyoneAdd);   <span class="comment">// 返回每个处理后的数值，不过记得这是传参考特性，会影响到原始的对象</span></span><br><span class="line"><span class="comment">// &#123;name: "马云", money: 2500&#125;</span></span><br><span class="line"><span class="comment">// &#123;name: "马化腾", money: 2300&#125;</span></span><br><span class="line"><span class="comment">// &#123;name: "李彦宏", money: 2000&#125;</span></span><br><span class="line"><span class="comment">// &#123;name: "我", money: Infinity&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapMoneyThan1500 = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 错误示范，长度不符合时</span></span><br><span class="line"> <span class="keyword">if</span> (item.money &gt; <span class="number">1500</span> ) &#123;</span><br><span class="line"> <span class="keyword">return</span> item;               <span class="comment">//取得大于1500</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapMoneyThan1500);</span><br><span class="line"><span class="comment">// [&#123;name: "马云", money: 2000&#125;, &#123;name: "马化腾", money: 1800&#125;, undefined, &#123;name: "我", money: Infinity&#125; ]</span></span><br></pre></td></tr></table></figure><h3 id="filter：过滤掉数组中符合条件的元素"><a href="#filter：过滤掉数组中符合条件的元素" class="headerlink" title="filter：过滤掉数组中符合条件的元素"></a>filter：过滤掉数组中符合条件的元素</h3><p>filter() 检测数值元素，并返回符合条件所有元素的数组。 filter() 不会改变原始数组。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">var</span> filterEmpty = people.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(filterEmpty);    <span class="comment">// 没有给条件，会是一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterMoneyThan1500 = people.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1500</span>;       <span class="comment">// 取得大于1500</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(filterMoneyThan1500); <span class="comment">// 马云，马化腾，我 这三个对象</span></span><br></pre></td></tr></table></figure><h3 id="find：返回符合条件的数组的第一个元素的值"><a href="#find：返回符合条件的数组的第一个元素的值" class="headerlink" title="find：返回符合条件的数组的第一个元素的值"></a>find：返回符合条件的数组的第一个元素的值</h3><p>find是用来查找数组中符合条件的对象，且<strong>仅能有一个</strong>，当返回的<code>true</code>数量超过两个以上时，那会以第一个为优先，通常会用来查找特定 id。如果没有符合条件的对象，则返回<code>undefined</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findEmpty = people.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(findEmpty);          <span class="comment">// 没有条件，会是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findMoneyThan1500 = people.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1500</span>;      <span class="comment">// 取得大于1500</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(findMoneyThan1500);  <span class="comment">// 虽然满足条件的有3个，但只会返回 '马云' 这一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findMe = people.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.name === <span class="string">'我'</span>;    <span class="comment">// 找到我</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(findMe);            <span class="comment">// 我 这一对象</span></span><br></pre></td></tr></table></figure><h3 id="every：验证数组中是否每个元素都满足指定的条件"><a href="#every：验证数组中是否每个元素都满足指定的条件" class="headerlink" title="every：验证数组中是否每个元素都满足指定的条件"></a>every：验证数组中是否每个元素都满足指定的条件</h3><p>验证全部的结果，当全部的值都为 <code>true</code> 时，则最终会得到 <code>true</code>；只要其中之一为 <code>false</code>，则返回 <code>false</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ans = people.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1800</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans); <span class="comment">// false: 只要有部分不符合，则为 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans2 = people.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">500</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans2); <span class="comment">// true: 大家钱都超过 500</span></span><br></pre></td></tr></table></figure><h3 id="some：验证数组中是否有元素满足指定的条件"><a href="#some：验证数组中是否有元素满足指定的条件" class="headerlink" title="some：验证数组中是否有元素满足指定的条件"></a>some：验证数组中是否有元素满足指定的条件</h3><p>与前者类似，但只要部分为 <code>true</code>，则返回 <code>true</code>；全部为 <code>false</code> 时返回值才会为 <code>false</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ans = people.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1800</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans); <span class="comment">// true: 只要有部分符合，则为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans2 = people.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &lt; <span class="number">500</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans2); <span class="comment">// false: 大家钱都不少于 500</span></span><br></pre></td></tr></table></figure><h3 id="reduce：将数组合成一个值"><a href="#reduce：将数组合成一个值" class="headerlink" title="reduce：将数组合成一个值"></a>reduce：将数组合成一个值</h3><p>reduce是其中最为特殊的，首先他返回的参数与之前的不同，它会接收到前一个返回的值供下一个对象使用，很适合用在累加与对比上，返回的可以是数字也可以是数组。</p><ul><li>accumulator: 前一个参数，如果是第一个数组的话，值是以另外传入或初始化的值</li><li>currentValue: 当前值</li><li>currentIndex: 当前索引</li><li>array: 全部数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceEmpty = people.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(reduceEmpty);                 <span class="comment">// 沒有条件，会是 undefined</span></span><br></pre></td></tr></table></figure><p>可以通过与前一个相加的方式，累加数组中所有的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">people.pop(); <span class="comment">// 我的钱深不可测，先移除掉</span></span><br><span class="line"><span class="keyword">var</span> reducePlus = people.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 分別是前一个返回值, 当前值, 当前索引值</span></span><br><span class="line">  <span class="built_in">console</span>.log(accumulator, currentValue, currentIndex);</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue.money;  <span class="comment">// 与前一个值相加</span></span><br><span class="line">&#125;, <span class="number">0</span>);                                      <span class="comment">// 传入初始化值为 0</span></span><br><span class="line"><span class="built_in">console</span>.log(reducePlus);                    <span class="comment">// 总和为 5300</span></span><br></pre></td></tr></table></figure><p>也可以相互对比，取出最高的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceBestOne = people.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reduce'</span>, accumulator, currentValue, currentIndex)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(accumulator, currentValue.money); <span class="comment">// 与前一个值比较哪个更大</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reduceBestOne);                  <span class="comment">// 最大值为 2000</span></span><br></pre></td></tr></table></figure><p>reduce功能很强大，其余几种遍历方法可以用reduce方法来代替，这里只列出map被reduce代替的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map方法</span></span><br><span class="line"><span class="keyword">var</span> mapMoneyDouble = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> item.money*<span class="number">2</span>;               <span class="comment">//钱翻倍</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapMoneyDouble); <span class="comment">// 4000, 3600, 3000, Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce方法实现同样的功能</span></span><br><span class="line"><span class="keyword">var</span> reduceMoneyDouble = people.reduce( <span class="function"><span class="keyword">function</span> (<span class="params"> accumulator, currentValue, currentIndex, array </span>) </span>&#123;             <span class="comment">//钱翻倍</span></span><br><span class="line">  accumulator.push(currentValue.money*<span class="number">2</span>);                <span class="comment">//钱翻倍</span></span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;,[]);</span><br><span class="line"><span class="built_in">console</span> .log(reduceMoneyDouble); <span class="comment">// 4000, 3600, 3000, Infinity</span></span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍数组常见的遍历方法：forEach、map、filter、find、every、some、reduce，它们都有个共同点：不会改变原始数组。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="数组" scheme="https://luozongmin.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>学会如何学习（二）</title>
    <link href="https://luozongmin.com/2019/10/18/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://luozongmin.com/2019/10/18/学会如何学习（二）/</id>
    <published>2019-10-18T02:23:49.196Z</published>
    <updated>2019-09-27T06:16:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。<a id="more"></a>   </p><h3 id="Part1-组块"><a href="#Part1-组块" class="headerlink" title="Part1 组块"></a>Part1 组块</h3><h4 id="什么是组块"><a href="#什么是组块" class="headerlink" title="什么是组块"></a>什么是组块</h4><p>什么是组块 (chunk) ？对于绝大多数人来说这是一个全新的概念，看上去并没有什么意义，就像一堆乱糟糟的拼图。从神经科学的角度来看，<strong>组块就是通过应用或意义连接在一起的信息碎片</strong>。而在不加理解或不关注上下文的情况下，单纯的死记硬背并不能帮助你理解其内涵和你所学概念之间的关联，那么这个概念拼图就没有可以拼合的边缘，无法关联到其他的拼图碎片上。<br><img src="/images/learn2/1.jpg" srcset="/img/loading.gif" alt>      </p><p>当你全神贯注于某件事上，就好像你的脑子里有一只章鱼。这只注意力的章鱼会在必要时把它的触须穿过工作记忆的四个插槽，从而帮助你把分布于大脑不同区域里的信息联系起来。<br><img src="/images/learn2/2.jpg" srcset="/img/loading.gif" alt>      </p><p>这和发散模式下的随机连接不同，创建组块的过程中，它需要集中<strong>注意力</strong>将大脑的不同部分连接起来，专注模式下将不同的想法联系在一起。但在你很紧张时，你的注意力章鱼会失去一些连接能力，这也是为什么在你生气、紧张、害怕的时候，大脑似乎不能专注工作。    </p><p>在任何领域获得专业知识的第一步都是先创建出概念组块。这种根据意义将信息碎片拼接起来的思维跃进，可以运用于所有人类能够掌握的领域，如运动、音乐、舞蹈等。<strong>最重要的是专注的训练和重复可以建立强的记忆痕迹，从而帮助你创建组块</strong>。专业的培养都是一小步一小步的，这个过程中，小的组块可以形成更大的组块。随着你对学习材料的理解越来越深入，所有的专业知识都只是更有创造性的见解的铺路石。    </p><p>但仅仅通过练习和重复来创建组块，并不能使你得心应手并有创造力地运用它们。组块化可以让大脑工作得更有效，一旦你把某个想法、概念或动作组块化后，你就不再需要记住有关的全部细节，你只需要知道最主要的那个概念就行了，也就是只需要记住组块。这就像清晨起床穿衣服，你只需要一个简单的想法——“我要穿衣服”， 但细想你会发现这个简单想法的组块所包含的活动是非常复杂的。   </p><h4 id="怎样形成组块"><a href="#怎样形成组块" class="headerlink" title="怎样形成组块"></a>怎样形成组块</h4><p>如果你是吉他初学者，你想学习弹奏一首有难度的吉他曲，你脑中关于这首曲子的神经表征可被看作是一个巨大的组块。首先你会听这首曲子、看别人弹奏这首曲子，还要从持琴姿势学起。和大多数技能一样，你通常需要将曲子的每一小部分转化为一个小的神经组块，再将这些小组块组合起来形成大组块。经过一段时间的练习，当你掌握了很多乐段之后，你就能流利地弹奏一个乐段了。<br><img src="/images/learn2/3.jpg" srcset="/img/loading.gif" alt>  </p><p>对于数学和科学的相关学科来说，关上书本检测自己，能够帮你检验那些你以为已经明白了的问题，并且加快你的学习速度。<strong>当你能独自完成某件事时，你才是真正掌握了它</strong>。许多事情都是这个道理，就像你只是看别人画画，并不代表你也能画出来，仅仅听别人唱歌并不能使你拥有同样的唱功和洪亮的嗓音。某件事如果你只是在看，或者就算理解了如何去做，也不代表你能真正做到。只有在你自己实际操作和完全掌握的情况下才能建立起神经模型。  </p><p><strong>组块化的第一步：就是对你想要组块化的信息全神贯注</strong>。如果你正开着电视，或是每隔几分钟就检查、回复手机上的消息，这些都会增加你建立组块的难度，因为你的大脑并没有完全投入到新信息的组块化中去。   </p><p><strong>组块化的第二步：要求你对建立组块的对象有基本的了解</strong>。无论是理解概念性的知识，还是寻找故事中不同情节间的关联，通常我们都可以自然而然地领会所学内容的大意。  </p><p><strong>组块化的第三步：是获取背景知识</strong>。不断重复和练习解决相关的或不相关的问题，这样你不仅知道如何使用组块，还明白应该什么时候使用。这样做能帮你认识新建立的组块是如何融入整体知识框架的。   </p><p>最后<strong>第四步，练习能帮你拓宽组块连接的神经网络，并确保它们不仅牢固，还能通过不同途径访问</strong>。正如下图所示，学习由两部分组成，自上而下的认识以及由下至上的组块化。<br><img src="/images/learn2/4.jpg" srcset="/img/loading.gif" alt>    </p><p>在由下至上组块化的过程中，练习和重复能够帮助你建立和强化每一个组块，这样你就可以在需要它的时候使用它。当自上而下的方法能够让你清楚地看到你正在学习什么以及它适用于哪里。就完全掌握知识而言，这两个过程都非常重要。而背景认识就是这两个过程的交汇处，背景认识意味着学会在特定的时候使用正确的方法。   </p><p>通常在真正的阅读之前，快速浏览书中某一章的图片以及小标题，能够帮助你知晓大意。听那些有严谨层次结构的课程，可以帮你弄清楚应在哪里建立组块以及如何把不同组块联系起来。一旦完成了这些，再了解具体的信息，那么就算遗漏了一些让你疑惑的部分，你依然可以理解主要部分。   </p><p><img src="/images/learn2/5.jpg" srcset="/img/loading.gif" alt>   </p><p><strong>总的来说，最好在精神高度集中的时候建立组块，理解基本的含义后，通过练习来真正掌握知识，并对情境有个大致了解，是建立组块的基本步骤</strong>。快把“组块”融入到你正在使用的学习中去吧！  </p><h4 id="能力错觉"><a href="#能力错觉" class="headerlink" title="能力错觉"></a>能力错觉</h4><p>这一小节来介绍一些让学习走上正轨的基本理念。   </p><p><strong>1.回顾的重要性</strong>   </p><p>学习书本或资料时，最常见方法之一就是反复阅读。不过心理学家Jeffrey Karpicke证明，这种方法的成效远不及另一种简单技巧——回顾。也就是阅读材料后，移开视线，看看你能回忆起多少内容。<br><img src="/images/learn2/6.jpg" srcset="/img/loading.gif" alt>    </p><p>Karpicke发表在《科学》杂志上的研究提供了可靠证据。先让学生们学一篇科技文章，然后通过尽力回忆其中信息来巩固练习；接着，让他们重读并再次回想。结果相同时间内仅用回顾法练习的学生较使用其他学习方法的学生而言，对材料的掌握更为全面深入。其他学习方法包括反复阅读资料，或者绘制可以加强学习材料之间联系的思维导图。学生通过正式考试或非正式自测都证明了回顾法有助于学习。这给了我们一个重要提示，<strong>即在回顾知识时，我们并非机械地复述，而是在通过回顾这个过程加深理解</strong>。这也有助于我们形成知识组块，就好像回忆过程帮助我们在神经上嵌入了“钩子”，以便我们串联起前后知识。    </p><p>比起被动重复阅读，回顾——<strong>即在心里检索关键概念</strong>——可以使你的学习更加专注高效，只有隔上一定时间后再重读才会有效果，因为这样，重读就更像是间隔重复练习。    </p><p><strong>2.能力的错觉</strong>   </p><p>你该明白你才是要解决问题和掌握概念的人，如果你看到某个习题答案后告诉自己，“哦，我明白他们为什么这么做了！” 那么这个答案并不真正属于你，因为你没有真正把这些概念嵌入自己潜在的神经回路中去。这是一种学习中最为常见的自欺欺人式错觉。如果你想要很好地掌握材料以在考试中取得好成绩，并从中创新，就必须让这些知识在你脑海里生根发芽。    </p><p>另一个类似情况就是做笔记和注释。做笔记时高亮和下划线必须要谨慎，否则不仅没有效果还容易产生误导。在空白处写笔记总结关键概念也被证明是一种很更好的办法。<br><img src="/images/learn2/7.jpg" srcset="/img/loading.gif" alt>   </p><p>Karpicke的研究还发现，学生们喜欢重读笔记或课本的原因是，当他们面前打开着课本、笔记或谷歌时，会误以为这些知识同样在他们的脑海里，然而事实却并非如此。因为看书比回顾做起来简单，学生们会陷入一种自欺欺人的错觉。事实上，这种学习方式效率很低。    </p><p><strong>3.自测与犯错</strong>   </p><p>能力的错觉提醒我们，在学习资料上花太多时间并不能保证你真的懂了。而<strong>自测是一种极其有用的办法，来确保你是真的学会了，而不是自欺欺人的错觉</strong>。从某种意义上来说，这就是回忆在发挥作用。  </p><p>让你发现自己是否真的掌握一个概念，犯错实际上是件好事。因为你之后就会想要避免重复犯错，所以实际考试前，在自测中犯的错是很有价值的，因为它们能让你一点点弥补思维漏洞。<strong>犯错可以纠正思考方向，让你学得更好、做得更好</strong>。</p><p><strong>4.多场合回顾</strong>   </p><p>回顾是一种有效工具，而<strong>在常规学习场所以外回顾知识则会帮助你加深对知识的理解</strong>。通过在不同物理环境下回顾和思考知识，你会脱离对给定场所的依赖，这会帮助你避免由于考试与学习场所的不同而产生的问题。<br><img src="/images/learn2/8.jpg" srcset="/img/loading.gif" alt>   </p><h3 id="Part2-看到全局"><a href="#Part2-看到全局" class="headerlink" title="Part2 看到全局"></a>Part2 看到全局</h3><h4 id="是什么激励了你？"><a href="#是什么激励了你？" class="headerlink" title="是什么激励了你？"></a>是什么激励了你？</h4><p>你会发现当学的东西并非自己真正喜欢的东西时，学习是非常困难的；而学习自己真正感兴趣的东西的时候，一切都变得非常简单，那这是为什么呢?   </p><p>你的大脑有一套神经递质的广泛投射系统，它加载的不是经验本身的内容，而是信息的重要性以及对未来的价值。神经递质是可以影响神经元如何回应其他神经元的化学物质。今天我们将要谈谈它们其中的三种，<strong>乙酰胆碱、多巴胺和血清素</strong>。  </p><p><strong>乙酰胆碱影响专注学习和集中注意力</strong>。当你注意力高度集中的时候，这些乙酰胆碱神经元就会广泛地投射出来，并且激活环路来控制突触可塑性，从而形成新的长期记忆。   </p><p><strong>多巴胺信号与意料之外的奖励相关</strong>。当接受到一个毫无预期的奖励时，这些神经元将分泌出多巴胺，多巴胺的信号将广泛投射，这会对学习产生强有力的影响；同时也会影响决策，甚至是感官输入的价值所在，它控制着我们的动力。比如番茄工作法中的设置奖励就是给自己的多巴胺神经元加油。  </p><p><strong>血清素影响社会生活和冒险行为</strong>。它可以有力地影响你的社交生活。在猴子部落中的雄性首领有着最高的血清素分泌水平，而位列最末的公猴，其血清素水平则最低。血清素也与风险行为有着紧密的联系，在那些血清素低的猴子身上往往能观察到更多的冒险行为。服刑犯人中，因暴力犯罪而入狱的是社会中血清素分泌活动最低的群体之一。  </p><p><strong>情绪也可以强烈地影响你的学习</strong>。你自己应该深有体会，情绪曾一度被认为与认知互不影响，然而近期研究显示，情绪、感觉以及注意力互相交织，并与学习和记忆力互相影响。    </p><p>对于成功的学习来说，情绪及神经递质系统比感知和动作要反应迟缓，但却同等重要。   </p><h4 id="组块库的价值"><a href="#组块库的价值" class="headerlink" title="组块库的价值"></a>组块库的价值</h4><p>将新的组块和原有组块结合起来的能力，体现在很多历史的创新变革中。比如比尔·盖茨与其他工业领袖会留出长达一周的阅读周期，以便在一段时间内掌握多种不同想法，把新鲜想法留在头脑中，与未忘记的想法进行自我交流，可以形成<strong>创新性思维</strong>。</p><p>你的组块库越大，运用越熟练，无论学什么科目，你都将能够更轻易地解决问题。组块化并非创新灵活度所需要的全部，但是它是重要的一环。组块还可以帮助你理解新概念。这是因为当你理解一个组块时，你会发现这一组块能以令人惊讶的方式与相似的组块联系起来。不仅在同一领域中如此，在截然不同的领域中也是这样。这就是所谓的<strong>知识迁移</strong>(transfer)。<br><img src="/images/learn2/9.jpg" srcset="/img/loading.gif" alt>    </p><p>你建立每一个组块，它就为你补上知识拼图的一块，但如果你不训练变大的组块，它们就会保持模糊的状态，你要学习的东西拼到一起就会更为困难。<strong>建立组块库就是在训练你的大脑，不仅要认出一个特定的概念，还要识别概念的类别，以便你能够自如地知晓如何快速处理你遇到的问题</strong>。你将开始看到一些为你简化解决方法的模式，并很快发现不同的解决方法就潜藏在你的记忆边缘。   </p><p>有两种途径解决问题，一是顺序性地，一步步推理；二是通过整体性的直觉。顺序性思维涉及到专注模式；而直觉通常需要创造性的发散模式来联系不同的想法。大多数较难的问题和概念都是通过直觉来理解的，因为新的想法和你熟悉的领域相去甚远。发散模式是半随机地进行连接，这意味着它们带来的解决方法，应该由专注模式进行小心验证。直觉性的理解不是永远正确的，你大概会想无论你在学什么，仅在单一的部分或章节里就有那么多问题和概念，根本没法全学会。这时<strong>机遇定律</strong>就发挥作用了，幸运女神会眷顾努力之人。<strong>专注于你正在学习的单元，你会发现一旦你把第一个问题或概念放进组块库，不论那是什么，第二个概念的进入就会容易一些，然后第三个概念也就更容易，这并不都那么简单，但会越来越容易</strong>。<br><img src="/images/learn2/10.jpg" srcset="/img/loading.gif" alt>    </p><h4 id="过度学习、思维定势、交替学习"><a href="#过度学习、思维定势、交替学习" class="headerlink" title="过度学习、思维定势、交替学习"></a>过度学习、思维定势、交替学习</h4><p>当你在学习一个新单词、一种新概念或新的问题解法时，你需要在同一学习阶段内反复练习。一定的练习是必要且有用的，但在完全掌握此阶段的所有内容后继续学习训练，就是所谓的过度学习。过度学习在有些场合是有意义的，比如对网球发球、钢琴协奏曲演奏可能非常重要，它能在紧张的时候，帮助其行为自动化。但仍要警惕在单一学习阶段的重复性过度识记，研究表明，<strong>这可能会对宝贵的学习时间造成浪费</strong>。  </p><p>一旦你在某一阶段学会了一个基本概念，在这段时间不断地巩固它，并不能加强你所期许的长期记忆联系。<strong>学完一段时间之后再复习是更好更有用的，这可以加强并深化你的组块化神经模式</strong>。但请注意，重复你已经掌握的东西非常容易，而这可能会造成能力错觉，让你误以为自己已掌握了所有材料，但其实你只掌握了简单的部分。所以，<strong>你应该均衡学习，把精力集中在你认为困难的部分。专注于学习的困难部分称为刻意训练 (deliberate practice) ，这种刻意训练 (deliberate practice) 通常是好学生与优秀学生的差别所在</strong>。   </p><p>这些与<strong>思维定势</strong>(Einstellung) 的概念有关。一个已经形成并加强的神经模式可能阻碍你发现更棒的解决方案。思维定势在这张弹珠脑图里就表现为，你最初的想法向大脑上方移动，而解法的思维模式则位于下方。<br><img src="/images/learn2/11.jpg" srcset="/img/loading.gif" alt> </p><p>密集的专注模式以及先前构造的思维模式，会形成惯性，阻止你走向一个可能发现解决方法的新区域。你可以把思维定势想像为一个路障，而它是你最初的想法所造成的，这种错误的方式在运动和科学学科中就很容易发生。因为有时你最初”发生什么”或”该去做什么”的直觉是有误导性的，<strong>在学习新事物时，你必须摒弃错误的旧思想和方法</strong>。  </p><p>学生学习时会犯的一项重大失误是，在学会游泳前就跳入水中。换句话说，他们盲目地开始做作业，不看书、不上课、不看在线课程，或甚至不与熟识此方面的人交谈。这种学习方法只会失败。就像在放任思想在一个专注模式的弹珠器里跳来跳去，而完全不考虑解法到底在哪里。在学习和生活中，理解如何得到真正的解决方法很重要。掌握一门新学科不仅要学习基础组块，更要学会如何选择和应用不同的组块。<strong>最佳的学习方法是，在需要不同技术和策略的问题中来回切换、练习，这就是所谓的交替学习</strong>。  </p><p>交替学习非常重要，你需要让自己的大脑习惯这种思想，即仅仅知道如何使用特定的概念、方法或解题技巧是不够的，你也需要知道何时去使用 ，要贯彻交替学习的思想。这样你才能脱离只会练习和重复，而开始学会独立思考。当你在一个学科内交替学习，你就开始在这个学科内发展创造力了。当你在多个不同学科间交替学习，你就能更容易地在不同领域的组块间创造联系，这能进一步提高你的创造性。当然，在不同领域间发展固定知识组块需要时间，所以有时需要取舍。成为几个领域的专家，意味着你可以将一个领域的新思想引入另一个领域，但这也可能意味着，你在某个领域的专业知识 并不如专攻一个领域的人那么深厚。反过来，如果你只专研一个学科，你可能对它有很深刻的理解，但也变得只习惯某种思考方式，这种根深蒂固的思考模式，让你很难把握新思想。  </p><p>科学哲学家Thomas Kuhn发现，科学中大部分的方式转变都是由年轻人，或者之前学习其他学科的人所提出的。他们不那么容易陷于思维定势，不会被先前的专业训练阻碍思想。有句老话说道，科学会随着每个葬礼的进行而进步，因为葬礼意味着根深蒂固的旧思想的流逝。  </p><p>最后我转帖一个别人在元学习课程里用拼图的理念去学编程的文章，作为一个实例参考:  </p><p><a href="https://www.jianshu.com/p/385551d15a67" target="_blank" rel="noopener">元学习课心得和实践（一）——八小时搞定《JavaScript DOM》</a></p><p>下一节课我们会学习怎样应对拖延症，以及拖延症和记忆的关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一节课讲的是关于学习的一些基本认知，以及现代科学对大脑的认识，为的是帮助学习者提高对学习的信心，摆脱“自己不是学习（那个领域）的料”等妄自菲薄的想法。第二周就是讲具体的学习套路了，其主要内容都是围绕“组块”这个概念来的。
    
    </summary>
    
      <category term="学习之道" scheme="https://luozongmin.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="高效学习" scheme="https://luozongmin.com/tags/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法" scheme="https://luozongmin.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学会如何学习（三）</title>
    <link href="https://luozongmin.com/2019/10/18/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://luozongmin.com/2019/10/18/学会如何学习（三）/</id>
    <published>2019-10-18T02:23:49.181Z</published>
    <updated>2019-09-27T06:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>第三周的学习因为拖延稍微拖了那么几天，而这周的主题又刚好是拖延症与记忆的关系。想要高效地学习，就得学会如何运用和提高自己的记忆能力，而这个过程中，必须先克服拖延症。所以上完这节课，我是该好好改改拖延的老毛病了嘻嘻~ <a id="more"></a>    </p><h4 id="拖延症的形成"><a href="#拖延症的形成" class="headerlink" title="拖延症的形成"></a>拖延症的形成</h4><p>我们常在那些让人不太舒服的事情上拖延，这点大家或多或少都会有，那事实结果是，拖延是一个极其重要、影响广泛的坏习惯，生活的方方面面都会受到拖延的影响。  </p><p><img src="/images/learn3/1.jpg" srcset="/img/loading.gif" alt>     </p><p>这里要强调一下，很多人觉得能靠自己的意志力去战胜拖延症，其实这是适得其反的。人每天的意志力是有限的，调用意志力去克服一件困难的事，会大量消耗能量。为什么拖延症这么容易就产生，是因为它变成了习惯，习惯是不需要意志力去执行的，它能减少大脑的消耗。所以改变习惯，是改变拖延症的正确方法。   </p><h4 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h4><p>习惯可以分为四个阶段：  </p><p><img src="/images/learn3/2.jpg" srcset="/img/loading.gif" alt>   </p><p>第一阶段是<strong>提示 (cue)</strong> ，是指引发你进行某种惯例的信息来源。比如朋友发来的一条微信信息，或是你看到了待办事项清单上的第一件事等等。   </p><p>第二个阶段就是<strong>惯例 (routine)</strong>，是指你对提示做出的惯性反应。比如看到微信信息就觉得要立马停下手头上的事情去回信息；看到待办的事情就想着当下去解决掉它。这里一个好的建议是，你可以通过关掉手机或者断网，或者远离其他占用碎片时间的消遣来隔离那些最具杀伤力的信号，就像你在进行番茄工作法那样。   </p><p>第三阶段是<strong>奖励 (reward)</strong>，是指你做完这个惯例之后得到的反馈，它会刺激你不断按照之前的惯例行事。任何一种习惯得以发展和延续都是因为它可以回报我们，它会立即给我们带来些许愉悦感。拖延是极易产生的习惯，因为你将关注点转向更令人愉悦的事情后，随之而来的奖励迅速而又简单。好习惯也是有奖励的，对于克服拖延症来说，想办法奖励好习惯非常重要，<strong>只有当大脑开始期待那个奖励，旧习惯才能得到重置，你才能养成新习惯</strong>。    </p><p>研究发现需要给奖励设定时间点。比如说，午休与朋友到快餐店吃饭，或是在下午5点结束主要的任务。这样小而实在的截止期限可以激励你很好地去工作。   </p><p>第四阶段是<strong>信念 (belief)</strong> 。改变拖延习惯最重要的一点就是“相信自己能够做到”的这个信念，就好比说必须要摒弃“自己不是学这块知识的料”这一习惯想法，而是要保持自己能够学好的信念并为之做出应有的努力。   </p><h4 id="应对生活和学习"><a href="#应对生活和学习" class="headerlink" title="应对生活和学习"></a>应对生活和学习</h4><p>要保持对学习目标的展望，一个很好的办法是每周写下本周关键任务列表，试着在前一晚写下第二日的任务，为什么要在前一晚呢？ 研究表明，这可以让你在潜意识下设法解决任务，从而找到完成方法。  </p><p>列下任务清单后，每天花一个或几个番茄钟的时间完成它们。如果可以短时间完成的任务，可以采用结果导向，如果不是则关注过程。你不必一定要设置25分钟的番茄钟，比如22分钟也是可行的。   </p><p>其实，<strong>当你能对一定时间内自己可以完成的工作量做出较准确的判断时，你将很快进步</strong>。计划好完成目标的时间是合理且最为重要的一点，计划你的休息时间和计划工作时间也同样重要，就是在努力学习之余保持健康休闲时间的人，其表现往往胜过那些一味努力学习的人，所以从现在开始，在努力工作学习之余试着挤出点休息时间吧！   </p><p>芭芭拉老师还建议在<strong>早晨尽量先开始最重要且最讨厌，最难的工作，至少做一个番茄时间，这证明了极其有效</strong>！有时会发生一些意料之外的事，我们当然需要对计划作出改变，但是请记住幸运法则——<strong>幸运女神会眷顾努力之人</strong>。良好的计划也是努力的一部分，关注学习目标，尽量避免因为偶发事件产生的不确定性。   </p><p><img src="/images/learn3/3.jpg" srcset="/img/loading.gif" alt>     </p><h4 id="提高记忆力"><a href="#提高记忆力" class="headerlink" title="提高记忆力"></a>提高记忆力</h4><p>改变了拖延症的坏习惯后，我们才能更好地利用记忆去学习。我们的大脑天生就擅长记忆不同的空间信息，如果你受邀参观一所陌生的房子 ，你会很快对这个房子有一个大致的概念。例如，整体的家具布局、房间位置、颜色的搭配。只需几分钟，你的大脑就能获取并存储数以千计的信息，甚至几周后，就算你面对是一堵白墙，也仍然能记起许多细节。这一系列空间信息，帮助你在脑中形成地图。如果能够<strong>充分发挥天生就很强大的视觉和空间记忆能力</strong>，你的记忆潜能就可以得到极大提高。   </p><p>评判一个人的记忆力好坏，主要看他的长期记忆的能力如何，每个人都可以通过集中注意力使某件事物进入你的临时工作记忆，但<strong>从工作记忆进入长期记忆则要满足两个条件。首先它要令人难忘，其次，信息需要复习和回顾</strong>。那如何让它难忘呢？比如记F=ma（力=质量x加速度）这个物理公式，老师把它想象成一只戴着飞行员眼镜的驴(a flying mule，英文首字母对应公式的简写)，躺在她老家厨房的水槽里，这样就完成了把抽象概念变成具体图像。这个比喻是不是很无厘头啊哈哈，所以说记忆大师们都是一些幻想家。   </p><p><img src="/images/learn3/4.jpg" srcset="/img/loading.gif" alt>     </p><p>记忆宫殿（Mind Palace / Memory Palace）就是这么一个虚拟的，让你储存信息的技巧工具。你可以把熟悉的场景，比如你的家，作为一个放置记忆碎片的地方，然后把要记的抽象的东西，通过联想，组团，转化成具体图像，放在那个场景中的某个地方。而且这个图像不需要阐述你要记住的东西的意义，甚至它越是不合常理，越稀奇古怪，效果就越好。因为大脑通常会滤过习以为常的事物，而对令人惊讶的非典型性事件记忆犹新。   </p><p>比如购物清单上要买的牛奶、面包、鸡蛋，使用这个技巧你可以想象在你的家中，有一大瓶牛奶在前门，面包掉到了沙发上，裂了的鸡蛋从咖啡桌边缘滴落。也就是说，你可以想象自己穿过一个熟悉的地方，伴随着一些与要记忆的物体相关的难忘画面，这种记忆方式往往记得很牢。   </p><p>题外话，爱看港剧的朋友，相信对TVB剧《读心神探》中的记忆宫殿印象深刻。第三集中有一段对记忆方法的特写，我们一起来细究一下吧！第三集刚开始的时候讲的就是记忆人名头像。那么记忆人名第一步就是观察人物的长相特征，这个特征可以看人物穿的衣服，戴的装饰品，五官的长相特点，发型，声音的特色等等，找出特点以后第二步就是对人物的名字进行联想。比如有个人叫袁泉，而正好她戴了一对圆圆的耳环，那么就很容易联想到“圆圈”（利用名字的谐音记忆）；又比如有人叫邓超，那么你可以联想到这个和你初识时，眼睛“邓”的超大的痴痴的望着你，只要你这么一想，那么这个人物名字肯定就在你脑海里留下了深刻的印象，虽然有点点毛骨悚然哈哈。   </p><p><img src="/images/learn3/5.jpg" srcset="/img/loading.gif" alt>    </p><p>看完上面举得例子也许会有人会问你那些名字和特征都是你事先设想好的，所以才容易发现名字与特征之间的联系，但其实这些都是临时想到的真实案例，<strong>其实我们能够观察到的特征是有限的，但是人的想象是无限的</strong>，只要你的想法足够好那肯定能找到一个人物的特征与名字之间的完美契合点，这也是记忆法的精髓。   </p><p>最后，在这一周的课外采访中，受采访者是一名美国记忆比赛的冠军，他是“记忆宫殿”这个技巧的专家。他给大家的学习建议是——保持孩童般的想象力与好奇心，通过新奇的想象来帮助你记忆，让学习变得有趣和容易。大家从现在开始不妨试一试~   </p><p>下一节课我们会学习复兴式学习与潜力的关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三周的学习因为拖延稍微拖了那么几天，而这周的主题又刚好是拖延症与记忆的关系。想要高效地学习，就得学会如何运用和提高自己的记忆能力，而这个过程中，必须先克服拖延症。所以上完这节课，我是该好好改改拖延的老毛病了嘻嘻~
    
    </summary>
    
      <category term="学习之道" scheme="https://luozongmin.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="高效学习" scheme="https://luozongmin.com/tags/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法" scheme="https://luozongmin.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学会如何学习（一）</title>
    <link href="https://luozongmin.com/2019/10/18/%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://luozongmin.com/2019/10/18/学会如何学习（一）/</id>
    <published>2019-10-18T02:23:49.165Z</published>
    <updated>2019-09-27T06:19:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？<a id="more"></a>    </p><p>无意中在<a href="http://link.zhihu.com/?target=https%3A//www.coursera.org/learn/ruhe-xuexi" target="_blank" rel="noopener">Coursera</a>上发现了一门神奇适用的课程，叫做“Learning How to Learn”， 旨在利用科学知识以及授课者切身经验教会你学会如何学习，学习这门课我才开始恍然大悟，原来学习应该这样学习，算是初步悟到如何学习的真谛了。下面我将讨论我从第一周课堂中学到的经验教训。    </p><h4 id="利用专注与发散思维"><a href="#利用专注与发散思维" class="headerlink" title="利用专注与发散思维"></a>利用专注与发散思维</h4><p>研究发现，人有两种完全不同的思考模式，专注模式（focused mode）和发散模式（diffuse mode）。就目前神经学家所知，专注模式与发散模式只能单独存在，你不能同时使用两种模式。而发散思维是你试图了解新事物时应该采取的思维模式。</p><p>课程讲述萨尔瓦多·达利 (20世纪著名的超现实主义画家)有时会坐在椅子上，放空自己的大脑，并常常会漫无目的地思考一下之前的工作。这样他就能把脑海中那些在发散模式下得到的的联想和点子及时地收集起来，然后带着这些在发散模式下得到的新想法回到专注模式里去。<br><img src="/images/learn1/1.jpg" srcset="/img/loading.gif" alt>   </p><p>这个例子目的是告诉我们：当你处于长期专注的学习模式时，可以通过小睡或做一些运动，然后过渡到发散模式，有助于你的大脑建立必要的神经连接，在你的长时间记忆中建立持久的知识块。还要强调的是，当你学习一些新的东西，尤其是比较难的东西的时候，你的大脑需要有在两种学习模式之间来回转换的能力，这能帮助你更高效地学习。想要锻炼你的神经，你需要每天做一点练习，逐步建立起支撑你思考的神经骨架，这就是关键所在。</p><h4 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h4><p>每个人或多或少有拖延的毛病，只不过有些人比较严重。当你面对一件你极度不情愿做的事情时，就好像激活了大脑中与疼痛相关的区域。 </p><p>所以拖延的过程大概如下图：首先，某件事可能会让你产生轻微的不安；为了消除这种不适感，你会转而去做一些更让人愉悦的事情，这么做的结果就是你觉得更开心了，但这只是暂时的，后续文章会更深入地去了解拖延症。</p><p><img src="/images/learn1/2.jpg" srcset="/img/loading.gif" alt>    </p><h4 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h4><p>课程告诉我们一个小巧方便的意志力工具，这个小工具叫做番茄工作法 (Pomodoro)。这个小技巧所需的只有一个计时器（手机上搜索“番茄ToDo”APP，电脑端也有许多类似的软件，可以自行选择），具体的实行过程是这样的：    </p><ol><li>首先需要把计时器设定25分钟，屏蔽所有会打扰你的事物；</li><li>在25分钟内，集中精力专注你所要专注的事；</li><li>最后还有一件很重要的事情是，当你前两步之后要给自己一点小小的奖励。比如：上几分钟网、喝杯咖啡或者简单地做一下运动，来使你的大脑可以愉悦的放松一会儿。<br><img src="/images/learn1/3.jpg" srcset="/img/loading.gif" alt>   </li></ol><p>实行后你会发现番茄工作法的使用效果非常明显，这就像是你的大脑在健身房做完一次25分钟的高强度训练，然后进行休息放松一样。当你无法专注的时候不妨试一试！</p><h4 id="记忆与练习"><a href="#记忆与练习" class="headerlink" title="记忆与练习"></a>记忆与练习</h4><p>当我们回忆数学方程组时，我们使用的是长期记忆。当我们尝试结合脑海中的想法来帮助我们理解某一概念或解决某一问题时，我们使用的是工作记忆。工作记忆和长期记忆是两种主要的记忆系统，工作记忆是大脑在即时且有意识地处理信息时所涉及的那部分记忆。    </p><ul><li>长期记忆就像一个储存仓库，不同的长期记忆储存在大脑的不同区域。研究表明，当你首次尝试将一段短期记忆转入长期记忆中时，你需要多次回顾以增加需要时找到相关信息的几率。</li><li>当你遇到新事物时，你通常会运用工作记忆来处理它，如果你想将这个信息转移到长期记忆里，就需要间隔重复的练习来促进这一过程。</li><li>不断重复你尝试记忆的内容，但重复的过程必须间隔开来。如果你尝试在一个晚上重复记忆20次相同的内容，记忆效果还比不上在几天内重复同样的次数这种方法。    </li></ul><p>练习在数学和科学中学到的思想和概念是很重要的，通过反复实践练习可以帮助你提高和增强学习过程中生成的神经连接，越是抽象的东西越要注重练习。</p><ul><li>学习的时候如果一心一意地专注学习，时间一长学习效果反而不好，需要休息一下或者至少稍稍将注意力转移到其他地方。在这段看似放松的时间里，你大脑的发散模式就有机会在后台帮你完成对概念的理解。如果你不这么做，而是进行填鸭式学习，你的知识库看起来将会像杂乱不堪，基础不牢靠的泥堆。</li><li>如果你有拖延问题，就需要使用番茄工作法帮助你注意力集中一段时间，并适当休息。这会帮你行动起来，并开始建立你需要的神经模式，使你能更有成效地学习更具挑战性的内容！</li></ul><h4 id="睡眠的重要性"><a href="#睡眠的重要性" class="headerlink" title="睡眠的重要性"></a>睡眠的重要性</h4><p>你怎么也不会想到，当你绝对清醒时你的大脑会产生一些有毒的物质，那大脑如何除掉这些有毒物质呢？原来当人们睡觉时，大脑细胞会收缩，从而增加脑内细胞之间的距离。这就像疏通了一条溪流，液体会在细胞空隙间流过，冲走有毒的物质。所以，睡觉这件事有时候看起来像是浪费时间，实际上是大脑保持清洁和健康的一种方式。<br><img src="/images/learn1/4.jpg" srcset="/img/loading.gif" alt>    </p><p>睡眠不足意味着少量代谢毒素残留在你的大脑之中，而这些有毒物质会让你思维混乱，不仅会让你发挥失常，还会导致头疼、抑郁症、糖尿病、心脏类疾病，甚至寿命缩短，这绝不是在吓你，可以参考一下睡眠不足的危害。   </p><p>睡眠对人们解决困难问题和理解所学知识的能力有显著影响，大脑会将你学习和思考过的想法、概念进行整理，清除掉一些不太重要的部分；同时增强你需要或想要记住的区域的记忆。在睡梦中，大脑还会将你努力学习到的东西在神经中枢一遍遍排演以增强加深记忆力！</p><p>如果你在打盹或睡觉之前，复习一遍所学东西，那你将有更大可能性梦到它。如果你更进一步，告诉自己你想要梦到这些内容，你梦到它的几率也会大大提高。梦见你所学的知识，本质上能够增强你的理解能力，在一定程度上可以将你的记忆整合成更易被掌握的组块信息。   </p><p>现在是时候去打个盹儿了！   </p><h4 id="采访特伦斯·谢诺沃斯基-Terrence-Sejnowski-博士的学习方法"><a href="#采访特伦斯·谢诺沃斯基-Terrence-Sejnowski-博士的学习方法" class="headerlink" title="采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法"></a>采访特伦斯·谢诺沃斯基 (Terrence Sejnowski) 博士的学习方法</h4><p>1、当你遇到完全陌生的事物时你是如何更容易学习的？    </p><p>答：单刀直入地实践，因为实践出真知，且大量的阅读作用甚微，同时最好有专家的指点。 </p><p>2、你是如何让自己在一场枯燥的讲座中保持专注的？</p><p>答：没有简单的方法是可以让你对不感兴趣的东西一直保持参与度的，但是有一个小技巧，就是用提问来“伏击”演讲者，这种打断通常会带出更有趣的讨论；比起被动的听，积极参与会让你学到更多。</p><p>3、你是如何进入发散思维模式，并从中获益的呢？</p><p>答：慢跑或户外锻炼是让思维跳出常规想法的绝佳方法，而且这时极其可能迸发灵感。奔跑中，事物从你身边略过，你会开始思考发生的一些事情，然后意识之外的想法涌上表面，接着通常就会出现有用的新想法。但是，这些转瞬即逝的点子过后很容易忘记，我会随身携带一本小本子及时记下来。</p><p>4、你会同时进行多项任务吗？</p><p>答：生活中有大量任务不断地“轰炸”，我们一刻也离不开多线程工作，如果做不到统筹兼顾，日子将会很难熬。但我们不能真正地同时做两件事，容易混淆且效率低下。同时处理多个任务实际是一种切换任务的能力。你可能要花很多时间才能完成这样的切换，切换任务并回到当时中断的地方开始工作，这是高效完成任务的方法之一。</p><p>5、神经科学方面的知识有运用到学习上的例子吗？</p><p>答：别把自己关在房间里，充足的空间、能激励你的人、很多可以积极参与的事件，以及运动和锻炼都大有助益，它们会增加新神经元的数量并促进神经元的生长。</p><p>6、你有关于高效地集中注意力、学习和创新的技巧吗？</p><p>答：处于富有创新氛围的环境中，是一种提升自身创造力的方法。当你和别人交流、阐述观点，你就会有更好的想法，这一过程通常有助于创新。</p><p>7、给大家的建议?</p><p>1） 聪明的人并不一定会成功，有很多聪明的人并不成功，而那些富有激情并且坚持努力的人容易达到，是因为人生中的成功多半来自于激情和努力，往往成功的人的身上都具有这样的品质。</p><p>2）每天我们周围都有值得发现去重新理解的东西，我们必须要用不同的视角来看待这些普通的东西，这很重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最近对前端开发有着强烈的热情，这促使我有不断学习的冲动，但这对于我来说是一个全新的领域，以我一贯用的那种填鸭式的方法学习是肯定行不通的。那么面对新知识，自己为什么总是学不好？那如何才能学好？
    
    </summary>
    
      <category term="学习之道" scheme="https://luozongmin.com/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="高效学习" scheme="https://luozongmin.com/tags/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法" scheme="https://luozongmin.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何快速搭建静态资源服务器</title>
    <link href="https://luozongmin.com/2019/10/18/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://luozongmin.com/2019/10/18/如何快速搭建静态资源服务器/</id>
    <published>2019-10-18T02:23:49.149Z</published>
    <updated>2019-09-27T06:24:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。<a id="more"></a>以前的时候，都是使用php的本地环境，也算比较方便，但是自从学了nodejs，发现创建http-server更方便。<br><img src="/images/http-server/1.jpg" srcset="/img/loading.gif" alt>  </p><h3 id="本文的目的"><a href="#本文的目的" class="headerlink" title="本文的目的"></a>本文的目的</h3><p>在这篇文章中，我将向您展示如何使用NodeJS创建一个非常简单的HTTP服务器。您可以通过http访问目录中的静态资源，如HTML，Javascript，CSS等，比如：  </p><ul><li><a href="http://localhost:8080/hello.html" target="_blank" rel="noopener">http://localhost:8080/hello.html</a></li><li><a href="http://localhost:8080/abc.js" target="_blank" rel="noopener">http://localhost:8080/abc.js</a>   </li></ul><p>而不是通过默认的file:///来访问<br><img src="/images/http-server/2.jpg" srcset="/img/loading.gif" alt>    </p><p>那问题是为什么只有需要一个HTTP才能访问静态资源呢？ </p><p>是因为HTML文件含有Javascript文件时，如果通过默认的file://地址来访问此文件的话，浏览器会阻止本地Javascript文件的一些操作，此时就需要安装HTTP-Server来解决这个问题。<br><img src="/images/http-server/3.jpg" srcset="/img/loading.gif" alt>    </p><p>报错信息：  </p><ul><li>Failed to load file:///E:/webexamples/reactjs/hello-reactjs/person.jsx:</li><li>Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.   </li></ul><h3 id="创建HTTP-Server"><a href="#创建HTTP-Server" class="headerlink" title="创建HTTP-Server"></a>创建HTTP-Server</h3><p>首先，确保已在计算机上安装NodeJS和npm； 否则，请按照以下说明进行安装：  </p><ul><li>在Windows上安装NodeJS</li><li><p>打开 Git Bash或其他命令行工具，依次输入以下命令，按回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br><span class="line">npm config <span class="built_in">set</span> loglevel http</span><br><span class="line">npm config <span class="built_in">set</span> progress <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>npm 的配置被存储在 ~/.npmrc，你可以随时改。    </p></li></ul><p>①接下来第一步，先创建一个空目录：<br><img src="/images/http-server/4.jpg" srcset="/img/loading.gif" alt>     </p><p>②利用命令行工具进入这个目录，这里用的是Git Bash。右击鼠标，点击Git Bash here，即可用Git Bash打开这个目录：<br><img src="/images/http-server/5.jpg" srcset="/img/loading.gif" alt>    </p><p>③运行以下命令安装http-server：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g http-server</span><br></pre></td></tr></table></figure></p><p>这将http-server全局安装，以便它可以从命令行运行。</p><p><img src="/images/http-server/6.jpg" srcset="/img/loading.gif" alt>    </p><p>④使用HTTP-Server，命令行进入当前文件夹，输入以下命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http-server</span><br></pre></td></tr></table></figure></p><p>若要禁用缓存，请使用如下命令运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server -c-1</span><br></pre></td></tr></table></figure></p><p><img src="/images/http-server/7.jpg" srcset="/img/loading.gif" alt>    </p><p>到此您的HTTP服务器就已经启动了，它正在端口8080上监听，您可以通过访问以下链接进行检查，3个地址在电脑端打开的是同一份东西：</p><ol><li><a href="http://192.168.1.116:8080/" target="_blank" rel="noopener">http://192.168.1.116:8080/</a> （只有这个地址能在手机中预览）</li><li><a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> （2和3性质是一样的）</li><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> （较为常用）    </li></ol><p>⑤在该目录中创建一个HTML文件，您可以通过此HTTP地址访问它：<br><img src="/images/http-server/8.jpg" srcset="/img/loading.gif" alt><br><img src="/images/http-server/9.jpg" srcset="/img/loading.gif" alt>    </p><p>⑥这里Windows 用户需要注意了，如果你发现你修改了源代码，页面却无法更新，说明 http-server 的缓存还未消除，那么可以这样做：  </p><ol><li>打开 Chrome 开发者工具</li><li>点击 Network</li><li>勾选 Disable Cache    </li></ol><p>这样缓存就不存在了~  </p><h3 id="其他命令安装HTTP-Server"><a href="#其他命令安装HTTP-Server" class="headerlink" title="其他命令安装HTTP-Server"></a>其他命令安装HTTP-Server</h3><p>这里就不仔细介绍步骤了，因为大部分操作和结果与第2步是一样的，直接上命令： </p><p><strong>第一种方法：</strong><br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i startserver -g</span><br></pre></td></tr></table></figure></p><p>快速开启：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ startserver</span><br></pre></td></tr></table></figure></p><p><strong>第二种方法：</strong><br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g live-server</span><br></pre></td></tr></table></figure></p><p>快速开启：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ live-server</span><br></pre></td></tr></table></figure></p><p>如果看到其他有意思的方法，后续还会增加的！   </p><p><strong>以上就是我在近期收集到的一些方法资料，不一定全面，如有错误欢迎指正哦。</strong>  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，很多时候需要在本地开启静态资源服务器来测试，所以就需要一个简单省事好用的http服务器。
    
    </summary>
    
      <category term="前端相关" scheme="https://luozongmin.com/categories/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Node.js" scheme="https://luozongmin.com/tags/Node-js/"/>
    
      <category term="http-server" scheme="https://luozongmin.com/tags/http-server/"/>
    
  </entry>
  
  <entry>
    <title>前端必备英语词汇，你了解多少呢？</title>
    <link href="https://luozongmin.com/2019/10/18/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%E5%91%A2/"/>
    <id>https://luozongmin.com/2019/10/18/前端必备英语词汇，你了解多少呢/</id>
    <published>2019-10-18T02:23:49.134Z</published>
    <updated>2019-10-12T07:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>掌握前端开发过程中常用的英语词汇还是非常有必要的，现整理出一些前端英语词汇，希望对从事前端的你有所帮助。<a id="more"></a></p><h2 id="前端常用英语词汇表"><a href="#前端常用英语词汇表" class="headerlink" title="前端常用英语词汇表"></a>前端常用英语词汇表</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>abstraction 抽象、抽象物、抽象性</p><p>access 存取、访问</p><p>account 账户</p><p>action 动作</p><p>activate 激活</p><p>adapter 适配器</p><p>address 地址</p><p>advanced 高级的</p><p>aggregation 聚合、聚集</p><p>algorithm 算法</p><p>alias 别名</p><p>align 排列、对齐</p><p>allocate 分配、配置</p><p>allocator 分配器、配置器</p><p>annotation 注解、评注</p><p>anonymous function 匿名函数</p><p>append 附加</p><p>application 应用、应用程序</p><p>architecture 架构、体系结构</p><p>argument 参数</p><p>array 数组</p><p>arrow 箭头</p><p>assert(ion) 断言</p><p>assign 赋值</p><p>assignment 赋值、分配</p><p>associated 相关的、相关联的</p><p>asynchronous 异步的</p><p>attribute 特性、属性</p><p>augmented 扩充</p><p>authentication 验证</p><p>authorization 授权</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>background 背景、后台（进程）</p><p>backup 备份</p><p>backup device 备份设备</p><p>backup file 备份文件</p><p>backward compatible 向后兼容、向下兼容</p><p>base class 基类</p><p>batch 批处理、批量</p><p>binary tree 二叉树</p><p>binding 绑定</p><p>block 块、区块、语句块</p><p>bound 边界</p><p>brace 花括弧、花括号</p><p>bracket 方括弧、方括号</p><p>buffer 缓冲区</p><p>bug 缺陷错误</p><p>build 编译</p><p>built-in 内建、内置</p><p>business 业务、商务</p><p>business logic 业务逻辑</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>cache 缓存</p><p>call 调用</p><p>callback 回调</p><p>case 分支</p><p>casting 转型、造型转换</p><p>catalog 目录</p><p>chain 链</p><p>character 字符</p><p>chunk 块</p><p>class 类</p><p>class declaration 类声明</p><p>class definition 类定义</p><p>class hierachy 类层次结构</p><p>classification 分类</p><p>clause 子句</p><p>cleanup 清理、清除</p><p>client 客户、客户端</p><p>clipboard 剪贴板</p><p>clone 克隆</p><p>closure 闭包</p><p>collection 集合</p><p>column 行</p><p>command-line 命令行</p><p>command-line interface, CLI 命令行界面</p><p>comment 注释</p><p>commit 提交</p><p>communication 通讯</p><p>compatible 兼容</p><p>compile 编译</p><p>compiler 编译器</p><p>complexity 复杂度</p><p>component 组件</p><p>compression 压缩</p><p>concept 概念</p><p>concrete 具体</p><p>concurrency 并发</p><p>configuration 配置、组态</p><p>connection 连接</p><p>console 控制台</p><p>constant 常量</p><p>construct 构件、成分、概念、构造</p><p>container 容器</p><p>context 环境、上下文</p><p>control 控件</p><p>copy 拷贝、复制</p><p>cover 覆盖、涵盖</p><p>create/creation 创建、生成</p><p>cube 多维数据集</p><p>currying 柯里化</p><p>cursor 光标</p><p>custom 定制</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>data 数据</p><p>data structure 数据结构</p><p>data type 数据类型</p><p>database 数据库</p><p>dataset 数据集</p><p>deallocate 归还</p><p>debug 调试</p><p>debugger 调试器</p><p>decay 退化</p><p>declaration 声明</p><p>deconstruction 解构</p><p>deduction 推导</p><p>default 缺省、默认值</p><p>defer 推迟</p><p>definition 定义</p><p>delegate/delegation 委托</p><p>deploy 部署</p><p>derived 派生</p><p>design pattern 设计模式</p><p>destructuring 解构</p><p>dialog 对话框</p><p>digest 摘要</p><p>digital 数字的</p><p>directory 目录</p><p>disk 盘</p><p>dispatch 调度、分派、派发</p><p>document 文档</p><p>driver 驱动</p><p>dump 转储</p><p>dynamic binding 动态绑定</p><p>dynamic scope 动态作用域</p><p>dynamic type 动态类型</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>efficiency 效率</p><p>encapsulation 封装</p><p>engine 引擎</p><p>entity 实体</p><p>enum(enumeration) 枚举</p><p>equal 相等</p><p>escape character 转义符</p><p>evaluate 评估</p><p>event 事件</p><p>event driven 事件驱动</p><p>evidence 证据</p><p>excaption 异常</p><p>exception handling 异常处理</p><p>exit 退出</p><p>expendable 可扩展的</p><p>explicit 显式</p><p>export 导出</p><p>extensibility 可扩展性</p><p>extent 范围、程度</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>feature 特征、特性、功能</p><p>fetch 提取</p><p>field 字段</p><p>file 文件</p><p>filter 筛选</p><p>finalization 终结</p><p>firewall 防火墙</p><p>flag 标记</p><p>flush 刷新</p><p>form 窗体</p><p>formal parameter 形参</p><p>forward 转发</p><p>forward declaration 前置声明</p><p>framework 框架</p><p>function 函数</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>GC(Garbage collection) 垃圾回收机制</p><p>generate 生成</p><p>generic 泛化的、一般的、通用的</p><p>genericity 泛型</p><p>global 全局的</p><p>global declaration 全局声明</p><p>grant 授权</p><p>group 组、群</p><p>graphical user interface, GUI 图形用户界面</p><p>GUID(Globally Unique Identifier) 全球唯一标识符</p><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>hack 破解</p><p>handle 处理器、处理程序</p><p>hash tables 哈希表</p><p>heap 堆</p><p>hyperlink 超链接</p><p>HyperText Markup Language, HTML 超文本标记语言</p><p>HyperText Transfer Protocol, HTTP 超文本传输协议</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>implement 实现</p><p>implicit 隐式</p><p>import 导入</p><p>indent 缩进</p><p>infinite loop 无线循环</p><p>inheritance 继承</p><p>initialize 初始化</p><p>inline 内联</p><p>instances 实例</p><p>integrate 集成</p><p>interacts 交互</p><p>interface 接口</p><p>interpret 解释</p><p>invoke 调用</p><p>iterate 迭代</p><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>justify 两端对齐</p><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>keywords 关键字</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>lexical 词法的</p><p>lexical scope 词法作用域</p><p>library 库</p><p>list 列表</p><p>literal 字面</p><p>load 加载</p><p>local 局部的</p><p>local variable 局部变量</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>macro 宏</p><p>memory 内存</p><p>memory leaks 内存泄漏</p><p>micro 微</p><p>middleware 中间件</p><p>model 模型</p><p>modifier 修饰符</p><p>module 模块</p><p>mutable 可变的</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>namespace 命名空间</p><p>native 本地的</p><p>nested 嵌套</p><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>object 对象</p><p>object-oriented 面向对象</p><p>object-oriented programming 面向对象编程</p><p>operating system, OS 操作系统</p><p>operation 操作、操作行为 </p><p>operator 运算子、操作符</p><p>optimization 优化</p><p>option 选项</p><p>ordinary 常规的</p><p>orthogonality 正交性</p><p>overflow 溢出</p><p>overload 重载</p><p>override 改写、覆写</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>package 包</p><p>palette 调色盘、组件盘、工具箱</p><p>parallel 平行、并行</p><p>parameter 参数</p><p>parent class 父类</p><p>parentheses 括号</p><p>parse 解析</p><p>parser 解析器</p><p>pass by address 传址、按址传递</p><p>pass by reference 传引用、按引用传递</p><p>pass by value 传值、按值传递</p><p>pattern 模式</p><p>performance 性能</p><p>pixel 像素</p><p>placeholder 占位符</p><p>pointer 指标、指针</p><p>polymorphism 多态</p><p>primitive type 原生类型</p><p>priority 优先级</p><p>procedure 过程</p><p>profile 评测</p><p>property 属性</p><p>protocol 协议</p><p>prototype 原型</p><p>pseudo code 伪码</p><h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><p>qualified 修饰的 </p><p>qualifier 修饰符</p><p>query 查询</p><p>queue 队列</p><p>quote 引用</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>radian 弧度</p><p>radio button 圆钮、单选按钮</p><p>random number 随机数</p><p>recursion 递归</p><p>refactor 重构 </p><p>reference 引用</p><p>register 寄存器</p><p>regular expression 正则表达式</p><p>represent 表现</p><p>request 请求</p><p>resolve 解析</p><p>resolution 解析度</p><p>routine 例程</p><p>routing 路由</p><h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><p>save 储存</p><p>scaffold 脚手架</p><p>scope 作用域</p><p>scripting language 脚本语言</p><p>semantics 语义</p><p>semicolon 分号</p><p>sequence 序列</p><p>server 服务器</p><p>stack 栈</p><p>statement 语句、陈述</p><p>static type 静态类型</p><p>status 状态</p><p>superclass 基类</p><p>superfluous 多余的</p><p>symbol 符号</p><p>syntax 语法</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>table 表格</p><p>tag 标签</p><p>target 目标</p><p>template 模版</p><p>thread 线程</p><p>throw 抛出</p><p>traverse 遍历</p><p>trigger 触发器</p><p>type 类型</p><h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><p>user interface, UI 用户界面</p><p>unqualfied 未修饰的</p><p>uptime 运行时间</p><p>Uniform Resource Locator, URL 统一资源定位符</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>validate 验证</p><p>variable 变量</p><p>view 视图</p><p>virtual machine    虚拟机    </p><p>virtual memory    虚内存</p><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><p>warning message 警告信息</p><p>wildcard 通配符</p><p>window 窗口</p><p>wrapper 包装器</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握前端开发过程中常用的英语词汇还是非常有必要的，现整理出一些前端英语词汇，希望对从事前端的你有所帮助。
    
    </summary>
    
      <category term="前端相关" scheme="https://luozongmin.com/categories/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="英语术语" scheme="https://luozongmin.com/tags/%E8%8B%B1%E8%AF%AD%E6%9C%AF%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【译】分享7个好用的JavaScript技巧</title>
    <link href="https://luozongmin.com/2019/10/18/%E5%88%86%E4%BA%AB7%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/"/>
    <id>https://luozongmin.com/2019/10/18/分享7个有用的JavaScript技巧/</id>
    <published>2019-10-18T02:23:49.118Z</published>
    <updated>2019-09-27T06:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>就像所有其他编程语言一样，JavaScript也有许多技巧可以完成简单和困难的任务。 一些技巧广为人知，而其他技巧则足以让你大吃一惊。 让我们来看看你今天就可以开始使用的七个JavaScript技巧吧！<a id="more"></a>   </p><p><img src="/images/skill/1.jpg" srcset="/img/loading.gif" alt>    </p><p>原文链接：<a href="https://davidwalsh.name/javascript-tricks#comments" target="_blank" rel="noopener">https://davidwalsh.name/javascript-tricks#comments</a>   </p><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p>数组去重可能比您想象的更容易：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j = [...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])]</span><br><span class="line">&gt;&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>很简单有木有！ </p><h4 id="过滤掉falsy值"><a href="#过滤掉falsy值" class="headerlink" title="过滤掉falsy值"></a>过滤掉falsy值</h4><p>是否需要从数组中过滤出falsy值（<code>0</code>，<code>undefined</code>，<code>null</code>，<code>false</code>等）？ 你可能不知道还有这个技巧：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="literal">undefined</span>,<span class="literal">null</span>,<span class="literal">false</span>,<span class="string">''</span>].filter(<span class="built_in">Boolean</span>);</span><br><span class="line">&gt;&gt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="创建空对象"><a href="#创建空对象" class="headerlink" title="创建空对象"></a>创建空对象</h4><p>您可以使用<code>{ }</code>创建一个看似空的对象，但该对象仍然具有<code>__proto__</code>和通常的<code>hasOwnProperty</code>以及其他对象方法。 但是，有一种方法可以创建一个纯粹的“字典”对象：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict.__proto__ === "undefined"</span></span><br><span class="line"><span class="comment">// No object properties exist until you add them</span></span><br></pre></td></tr></table></figure><p>这种方式创建的对象就很纯粹，没有任何属性和对象，非常干净。</p><h4 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h4><p>在JavaScript中合并多个对象的需求已经存在，尤其是当我们开始使用选项创建类和小部件时：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">'David Walsh'</span>, <span class="attr">gender</span>: <span class="string">'Male'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> tools = &#123; <span class="attr">computer</span>: <span class="string">'Mac'</span>, <span class="attr">editor</span>: <span class="string">'Atom'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> attributes = &#123; <span class="attr">handsomeness</span>: <span class="string">'Extreme'</span>, <span class="attr">hair</span>: <span class="string">'Brown'</span>, <span class="attr">eyes</span>: <span class="string">'Blue'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> summary = &#123;...person, ...tools, ...attributes&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Object &#123;</span></span><br><span class="line"><span class="comment">  "computer": "Mac",</span></span><br><span class="line"><span class="comment">  "editor": "Atom",</span></span><br><span class="line"><span class="comment">  "eyes": "Blue",</span></span><br><span class="line"><span class="comment">  "gender": "Male",</span></span><br><span class="line"><span class="comment">  "hair": "Brown",</span></span><br><span class="line"><span class="comment">  "handsomeness": "Extreme",</span></span><br><span class="line"><span class="comment">  "name": "David Walsh",</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这三个点<code>(...)</code>使任务变得更加容易！   </p><h4 id="Require函数参数"><a href="#Require函数参数" class="headerlink" title="Require函数参数"></a>Require函数参数</h4><p>能够为函数参数设置默认值是JavaScript的一个很棒的补充，但是请查看这个技巧，要求为给定的参数传递值：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRequired = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'param is required'</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function">(<span class="params">name = isRequired(</span>)) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will throw an error because no name is provided</span></span><br><span class="line">hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will also throw an error</span></span><br><span class="line">hello(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are good!</span></span><br><span class="line">hello(<span class="literal">null</span>);</span><br><span class="line">hello(<span class="string">'David'</span>);</span><br></pre></td></tr></table></figure><h4 id="解构添加别名"><a href="#解构添加别名" class="headerlink" title="解构添加别名"></a>解构添加别名</h4><p>解构是JavaScript的一个非常受欢迎的补充，但有时我们更喜欢用其他名称来引用这些属性，所以我们可以利用别名：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grabs obj.x as &#123; x &#125;</span></span><br><span class="line"><span class="keyword">const</span> &#123; x &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grabs obj.x as &#123; otherName &#125;</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">x</span>: otherName &#125; = obj;</span><br></pre></td></tr></table></figure><p>有助于避免与现有变量的命名冲突！   </p><h4 id="获取查询字符串参数"><a href="#获取查询字符串参数" class="headerlink" title="获取查询字符串参数"></a>获取查询字符串参数</h4><p>获取url里面的参数值或者追加查询字符串，在这之前，我们一般通过正则表达式来获取查询字符串值，然而现在有一个新的api，具体详情可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams" target="_blank" rel="noopener">这里</a>，可以让我们以很简单的方式去处理url。  </p><p>比如现在我们有这样一个url，”?post=1234&amp;action=edit”，我们可以利用下面的技巧来处理这个url。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming "?post=1234&amp;action=edit"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urlParams = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.has(<span class="string">'post'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.get(<span class="string">'action'</span>)); <span class="comment">// "edit"</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.getAll(<span class="string">'action'</span>)); <span class="comment">// ["edit"]</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.toString()); <span class="comment">// "?post=1234&amp;action=edit"</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.append(<span class="string">'active'</span>, <span class="string">'1'</span>)); <span class="comment">// "?post=1234&amp;action=edit&amp;active=1"</span></span><br></pre></td></tr></table></figure><p>比我们过去用的容易多了！   </p><p>多年来JavaScript已经发生了很大的变化，但是我最喜欢的JavaScript部分是我们所看到的语言改进的速度。 尽管JavaScript的动态不断变化，我们仍然需要采用一些不错的技巧; 将这些技巧保存在工具箱中，以便在需要时使用！   </p><p>那你最喜欢的JavaScript技巧是什么？   </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就像所有其他编程语言一样，JavaScript也有许多技巧可以完成简单和困难的任务。 一些技巧广为人知，而其他技巧则足以让你大吃一惊。 让我们来看看你今天就可以开始使用的七个JavaScript技巧吧！
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="编程技巧" scheme="https://luozongmin.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+GitHub搭建个人博客</title>
    <link href="https://luozongmin.com/2019/10/18/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://luozongmin.com/2019/10/18/使用Hexo+GitHub搭建个人博客/</id>
    <published>2019-10-18T02:23:49.103Z</published>
    <updated>2019-09-27T06:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo是一个快速、简介且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多<a id="more"></a>，所以就用它啦~     </p><p>下面一步一步地说怎么用hexo+github搭建一个个人博客。</p><p><strong><em>说明：本文只针对Windows平台下的搭建过程，其他平台的请自行上网查阅</em></strong></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在搭建博客之前，需要安装node.js和git，具体操作请参考<a href="https://www.jianshu.com/p/0356308834ad" target="_blank" rel="noopener">这篇文章</a>，并同时申请Github账号，使用的开发工具为VScode。</p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>1、首先新建一个文件夹如myBlog，用于存放整个博客源文件。右击鼠标点击文件夹，选中Git Bash Here在<strong>Git命令行中打开</strong>。  </p><p>2、执行以下命令安装Hexo及生成第一篇博客文章：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli   //安装hexo</span><br><span class="line">$ hexo  init               //初始化hexo,这样myBlog就是整个博客的根目录，所有的页面都可以在里面进行增删改操作</span><br><span class="line">$ hexo generate            //生成静态页面</span><br><span class="line">$ hexo server              //启动本地服务器，进行博客文章预览</span><br></pre></td></tr></table></figure></p><p>Hexo会默认生成第一篇博客《Hello World》，在浏览器下打开localhost://4000你将会看到：<br><img src="/images/hexogit/1.png" srcset="/img/loading.gif" alt>    </p><p>myBlog源文件夹整体目录预览：<br><img src="/images/hexogit/2.jpg" srcset="/img/loading.gif" alt>     </p><p>其中_config.yml和package.json为项目的配置文件，themes存放了我们博客的主题，source-&gt;_post为我们的博客目录，public为执行hexo generate后生成的静态页面。</p><h4 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h4><p>1、在你的Github中建立新的 repo，repo 名称必须是「你的用户名.<a href="http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。" target="_blank" rel="noopener">http://github.io」（注意你的户名是你的GitHub的用户名），此处我创建的仓库名为：http://miqilin21.github.io，然后与我们的博客建立关联。</a><br><img src="/images/hexogit/3.jpg" srcset="/img/loading.gif" alt> </p><p>2、将myBlog目录中的_config.yml文件在VScode中打开，编辑网站配置：</p><ul><li>把第 6 行的 title 改成你想要的名字</li><li>把第 10 行的 author 改成你想取大名</li><li>把最后一行的 type 改成 <code>type: git</code></li><li>在最后一行后面新增一行，左边与 type 平齐，加上一行 <code>repo: 仓库地址</code> （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址最好以 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>: 开头）<br><img src="/images/hexogit/4.jpg" srcset="/img/loading.gif" alt>     </li></ul><p><img src="/images/hexogit/5.png" srcset="/img/loading.gif" alt>     </p><p>3、修改完成配置后在myBlog目录下执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save    //安装 git 部署插件</span><br><span class="line">$ hexo deploy                             //将本地博客代码部署到Github上</span><br></pre></td></tr></table></figure></p><p>4、进入「你的用户名.<a href="http://github.io」对应的" target="_blank" rel="noopener">http://github.io」对应的</a> repo，打开 GitHub Pages 功能，如果已经打开了，你应该会看到一个预览链接；最后用浏览器访问「预览链接/index.html」就应该看到了你的博客啦！</p><h4 id="添加新文章"><a href="#添加新文章" class="headerlink" title="添加新文章"></a>添加新文章</h4><p>1、打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就相当于在本地添加了新文章</p><p>2、利用来VScode编辑新文章</p><p>3、<code>hexo generate</code></p><p>4、<code>hexo deploy</code></p><p>5、去看你的博客，应该能看到这篇新文章啦！</p><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>1、<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a> 上面有主题合集</p><p>2、随便找一个主题，进入主题的 GitHub 首页，比如我找的是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p>3、复制它的 SSH 地址或 HTTPS 地址，假设地址为 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:iissnan/hexo-theme-next.git</p><p>4、<code>cd themes</code></p><p>5、<code>git clone git@github.com:iissnan/hexo-theme-next.git</code></p><p>6、<code>cd ..</code></p><p>7、将 _config.yml 的第 75 行改为 <code>theme: hexo-theme-next</code>，保存</p><p>8、<code>hexo generate</code></p><p>9、<code>hexo deploy</code></p><p>10、等一分钟，然后刷新你的博客页面，你会看到一个新的外观，如果不喜欢这个主题，就回到第 1 步，重选一个主题。  </p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>1、最好进入一个安全的目录创建源文件夹，在根目录瞎搞；</p><p>2、_config.yml中的缩进和空格一定严格按照文件的默认格式来，不然会报错；</p><p>3、想要删除博客的话，直接删除source-&gt;_posts-&gt;对应的博客文章，然后再次执行hexo generate、hexo deploy即可；</p><p>4、在_config.yml中修改language为zh-CN，即可将博客中英文转换为中文；</p><p>5、常用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span>      //新建文章 </span><br><span class="line">hexo new page <span class="string">"pageName"</span> //新建页面 </span><br><span class="line">hexo clean              //清除缓存文件db.json和已生成的静态文件 public,网站显示异常时可以执行这条命令试试。</span><br><span class="line">hexo generate           //生成静态文件 </span><br><span class="line">hexo deploy             //部署到Giihub </span><br><span class="line">hexo server             //启动本地服务器 </span><br><span class="line">hexo <span class="built_in">help</span>               //查询帮助</span><br></pre></td></tr></table></figure></p><p>6、md文件需要用到<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown语法</a>。  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo是一个快速、简介且高效的博客框架，拥有一个简单的服务器（可以用来当简单的动态博客使用），也有生成器，生成的静态文件可以一键部署到Github Pages上，用起来比较方便，并且能使用的主题也很多
    
    </summary>
    
      <category term="tools" scheme="https://luozongmin.com/categories/tools/"/>
    
    
      <category term="GitHub" scheme="https://luozongmin.com/tags/GitHub/"/>
    
      <category term="Hexo" scheme="https://luozongmin.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>从原生JS实现jQuery的一个API中体会其设计思想</title>
    <link href="https://luozongmin.com/2019/10/18/%E4%BB%8E%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84%E4%B8%80%E4%B8%AAAPI%E4%B8%AD%E4%BD%93%E4%BC%9A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <id>https://luozongmin.com/2019/10/18/从原生JS实现jQuery的一个API中体会其设计思想/</id>
    <published>2019-10-18T02:23:49.087Z</published>
    <updated>2019-05-31T14:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？<a id="more"></a>读源代码又太繁琐，所以这里利用原生JS来实现jQuery中的addClass这个API，通过实现此过程来体会jQuery的设计思想，力求简单易懂。</p><h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">classes</span>)</span>&#123;&#125; <span class="comment">//可将所有输入的标签的class添加一个类</span></span><br></pre></td></tr></table></figure><h3 id="实现这个函数"><a href="#实现这个函数" class="headerlink" title="实现这个函数"></a>实现这个函数</h3><p>函数<code>addClass()</code>是输入一个类名，给选中的所有标签添加一个类，所以要用到<code>classList.add()</code>，具体实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">node, classes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">    allTag[i].classList.add(classes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在全局变量中创建一个对象，用来储存封装后的函数，这就是命名空间（名字前面统一加一个前缀）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = &#123;&#125;</span><br><span class="line">jQuery.addClass = addClass</span><br><span class="line"></span><br><span class="line">jQuery.addClass(<span class="string">'div'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>整理之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = &#123;&#125;</span><br><span class="line">jQuery.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">node, classes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">    allTag[i].classList.add(classes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.addClass(<span class="string">'div'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h3 id="将node放到前面"><a href="#将node放到前面" class="headerlink" title="将node放到前面"></a>将node放到前面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.addClass(classes)</span><br></pre></td></tr></table></figure><p>方法一：扩展 Node 接口，直接在 <code>Node.prototype</code> 上加函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：新的接口 <code>BetterNode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    element: node,</span><br><span class="line">    addClass: <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">        allTag[i].classList.add(classes)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node2 = jQuery(<span class="string">'div'</span>)</span><br><span class="line">node2.addClass(<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>第二种叫做「无侵入」。</p><h3 id="进一步完善"><a href="#进一步完善" class="headerlink" title="进一步完善"></a>进一步完善</h3><p>给个缩写并且使其可以是节点或者选择器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">      nodes[i]=temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeOrSelector <span class="keyword">instanceof</span> Node)&#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      <span class="number">0</span>:nodeOrSelector,</span><br><span class="line">      length:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class="line">      nodes[i].classList.add(classes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.$ = jQuery</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>)</span><br><span class="line">$div.addClass(<span class="string">'red'</span>) <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br></pre></td></tr></table></figure><h3 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h3><p>按照jQuery的设计思路封装一个ajax函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">url, method, body, success, fail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> request = XMLHttpResquest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                success.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                fail.call(<span class="literal">undefined</span>, request)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级改进一下满足promise规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    url,</span></span></span><br><span class="line"><span class="function"><span class="params">    method,</span></span></span><br><span class="line"><span class="function"><span class="params">    body,</span></span></span><br><span class="line"><span class="function"><span class="params">    headers</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> request = XMLHttpResquest()</span><br><span class="line">        request.open(method, url)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">            <span class="keyword">let</span> value = headers[key]</span><br><span class="line">            request.setRequestHeader(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    success.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                    fail.call(<span class="literal">undefined</span>, request)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.send(body)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="https://luozongmin.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>从instanceof身上深入理解原型/原型链</title>
    <link href="https://luozongmin.com/2019/10/18/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://luozongmin.com/2019/10/18/从instanceof身上深入理解原型原型链/</id>
    <published>2019-10-18T02:23:49.071Z</published>
    <updated>2019-09-27T05:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天将延续<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。<a id="more"></a></p><p>对于原始类型（primitive type）的值，即<code>string</code>/<code>number</code>/<code>boolean</code>，你可以通过<code>typeof</code>判断其类型，但是<code>typeof</code>在判断到合成类型（complex type）的值的时候，返回值只有<code>object</code>/<code>function</code>，你不知道它到底是一个<code>object</code>对象，还是数组，也不能判断出Object 下具体是什么细分的类型，比如 <code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code> 等。</p><p>官方对<code>instanceof</code>运算符的解释是返回一个布尔值，表示对象是否为某个构造函数的实例。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>f1</code>是构造函数<code>Foo</code>的实例，所以返回<code>true</code>，但是“f1 instanceof Object”为什么也是<code>true</code>呢？</p><p>至于为什么等会再解释，先把<code>instanceof</code>判断的规则告诉大家。根据以上代码看下图：</p><p><img src="/images/instanceof/1.jpg" srcset="/img/loading.gif" alt>  </p><p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数，左边变量暂称为A，右边变量暂称为B。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。</p><p>通俗一点来讲，<code>instanceof</code>的判断规则是：<strong><code>instanceof</code>会检查整个原型链，将沿着A的<code>__proto__</code>这条线来一直找，同时沿着B的<code>prototype</code>这条线来一直找，直到能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code></strong>。即上图中的 <code>f1</code>–&gt;<code>__proto__</code> 和 <code>Foo</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Foo)</code>为<code>true</code>。</p><p>按照以上规则，重新来看看“ f1 instanceof Object ”这句代码为什么是<code>true</code>？ 根据上图很容易就能看出来， f1–&gt;<code>__proto__</code>–&gt;<code>__proto__</code> 和<code>Object</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Object)</code>为<code>true</code>。</p><p>通过上面的规则，可以很好地解释一些比较怪异的现象，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这些就是<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>所讲的看似很混乱的东西，现在知道为何了吧。</p><p>但还有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>后续会有专门文章介绍）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真。</p><p>说到这里，继续贴上这幅原型/原型链的经典图，是否现在看起来没那么复杂了呢。</p><p><img src="/images/inherit/5.jpg" srcset="/img/loading.gif" alt>  </p><p>如果<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>你看的比较仔细，再结合刚才介绍的<code>instanceof</code>的概念规则，相信能看懂上面这张图的内容了。</p><p>那么问题又出来了。<code>instanceof</code>这样设计，到底有什么用？到底<code>instanceof</code>想表达什么呢？</p><p>这就要重点讲讲继承了，即<code>instanceof</code>表示的就是一种继承关系，或者原型链的结构，请看后续文章介绍。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天将延续&lt;a href=&quot;https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/&quot;&gt;这篇文章&lt;/a&gt;，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>一些好用的工具、网站</title>
    <link href="https://luozongmin.com/2019/10/18/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99/"/>
    <id>https://luozongmin.com/2019/10/18/一些好用的工具、网站/</id>
    <published>2019-10-18T02:23:49.056Z</published>
    <updated>2019-09-27T06:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。<a id="more"></a>    </p><h4 id="Evernote：一款神奇的笔记"><a href="#Evernote：一款神奇的笔记" class="headerlink" title="Evernote：一款神奇的笔记"></a>Evernote：一款神奇的笔记</h4><p>✔如果一款工具能满足你对笔记的所有需求的话，那就是Evernote了，写笔记，列清单，时间管理，录音，工作同步，手机和电脑端都可下载…   </p><p>✔如果你还没用过，推荐你现在关闭答案去应用市场下载一个，相信我你都会爱上它的。</p><p><img src="/images/tool/1.jpg" srcset="/img/loading.gif" alt></p><h4 id="免费人工智能PPT制作平台：beautiful-ai"><a href="#免费人工智能PPT制作平台：beautiful-ai" class="headerlink" title="免费人工智能PPT制作平台：beautiful.ai"></a>免费人工智能PPT制作平台：<a href="https://www.beautiful.ai/" target="_blank" rel="noopener">beautiful.ai</a></h4><p>✔这个国外的黑科技网站，网站提供很多超赞的板式，我们将文字放进去，AI智能帮助我们制作PPT。真的让我这个一做PPT就头疼的人，感到开心！   </p><p>✔没广告还免费！   </p><p><img src="/images/tool/2.jpg" srcset="/img/loading.gif" alt></p><h4 id="录制GIF工具-：GifCam"><a href="#录制GIF工具-：GifCam" class="headerlink" title="录制GIF工具 ：GifCam"></a>录制GIF工具 ：GifCam</h4><p>✔录制动图对许多人来说也算是必备的东西了。   </p><p>✔窗口化录屏，也可以直接设置全屏幕录制，录制完毕后直接保存为 GIF 图片，软件大小不超过 2M，简直太方便太良心了~    </p><p><img src="/images/tool/3.jpg" srcset="/img/loading.gif" alt></p><h4 id="截图-贴图神器：Snipaste"><a href="#截图-贴图神器：Snipaste" class="headerlink" title="截图/贴图神器：Snipaste"></a>截图/贴图神器：Snipaste</h4><p>✔它在我心中绝对可以堪称神器了！令人惊叹不仅仅是它的强大截图功能，而是它的贴图功能也实在是太好用了！   </p><p><img src="/images/tool/4.jpg" srcset="/img/loading.gif" alt></p><h4 id="设计网址导航网站：牛大拿"><a href="#设计网址导航网站：牛大拿" class="headerlink" title="设计网址导航网站：牛大拿"></a>设计网址导航网站：<a href="http://www.niudana.com/" target="_blank" rel="noopener">牛大拿</a></h4><p>✔精选国内外优秀的UI设计网站,设计参考文章与免费的UI设计素材与资源，每日更新Dribbble精选内容、Behance精选内容、站酷精选内容、UI中国…   </p><p>✔一定也有设计师不知道这个网站滴。   </p><p><img src="/images/tool/5.jpg" srcset="/img/loading.gif" alt></p><h4 id="国外设计师常用网站：Dribbble"><a href="#国外设计师常用网站：Dribbble" class="headerlink" title="国外设计师常用网站：Dribbble"></a>国外设计师常用网站：<a href="https://dribbble.com/" target="_blank" rel="noopener">Dribbble</a></h4><p>✔通过 Dribbble，你可以浏览许多创意设计，它们出自世界各地的个人设计师、设计团队以及设计公司。   </p><p>✔这些作品并不仅限于网页或手机 app 设计，还有图片设计、品牌设计、动画、插图、平面艺术等等。    </p><p><img src="/images/tool/6.jpg" srcset="/img/loading.gif" alt></p><h4 id="国内设计师常用网站：花瓣网"><a href="#国内设计师常用网站：花瓣网" class="headerlink" title="国内设计师常用网站：花瓣网"></a>国内设计师常用网站：花瓣网</h4><p>✔花瓣网算是一个国内比较好的素材采集网，平时想要找的各种类型的图片素材在花瓣都能采集到，比如平面、漫画、摄影、UI等等。    </p><p>✔而且花瓣的素材普遍都很有设计感和时尚感，很适合年轻一代做设计。   </p><p><img src="/images/tool/7.jpg" srcset="/img/loading.gif" alt> </p><h4 id="设计师和开发常用网站：iconfont-cn"><a href="#设计师和开发常用网站：iconfont-cn" class="headerlink" title="设计师和开发常用网站：iconfont.cn"></a>设计师和开发常用网站：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont.cn</a></h4><p>✔阿里巴巴旗下的免费icon百科网站，可免费下载矢量源文件，选择时可以打包所有你感兴趣的放在购物车，Download时还可以选择颜色和大小,很贴心有木有！同时支持下载开发用代码。   </p><p>✔比如搜索关键词“love”看到的结果：   </p><p><img src="/images/tool/8.jpg" srcset="/img/loading.gif" alt></p><h4 id="壁纸天堂：Wallhaven"><a href="#壁纸天堂：Wallhaven" class="headerlink" title="壁纸天堂：Wallhaven"></a>壁纸天堂：<a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">Wallhaven</a></h4><p>✔图片量大而且还高清，分类清晰(人物/风景/动画)。   </p><p>✔相比一些图库不全，广告遍地，收费下载的壁纸网站，免费下载的wallhaven简直就是业界良心。</p><p><img src="/images/tool/9.jpg" srcset="/img/loading.gif" alt></p><h4 id="在线制作流程图网站：ProcessOn"><a href="#在线制作流程图网站：ProcessOn" class="headerlink" title="在线制作流程图网站：ProcessOn"></a>在线制作流程图网站：<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a></h4><p>✔ProcessOn在线支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 </p><p>✔轻松绘制，基本上是0难度上手。</p><p><img src="/images/tool/10.jpg" srcset="/img/loading.gif" alt></p><h4 id="在线生成图片链接网站：SM-MS"><a href="#在线生成图片链接网站：SM-MS" class="headerlink" title="在线生成图片链接网站：SM.MS"></a>在线生成图片链接网站：<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a></h4><p>✔SM.MS图床网站只需上传一张本地的图片，点击生成链接即可，操作简单快捷。</p><p>✔永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式。   </p><p><img src="/images/tool/11.jpg" srcset="/img/loading.gif" alt></p><h4 id="Listary：电脑文件秒搜-路径直达"><a href="#Listary：电脑文件秒搜-路径直达" class="headerlink" title="Listary：电脑文件秒搜+路径直达"></a>Listary：电脑文件秒搜+路径直达</h4><p>✔软件体积非常小，全局本地搜索的便捷工具，设置热键后，能在任何环境下调出窗口搜索文件，如我设置的是’Win+F’，想要找某文件时按下Win+F调出小长条搜索框就能进行实时搜索，非常便捷。    </p><p>✔相信你用了后会觉得它很高效的。  </p><p><img src="/images/tool/12.jpg" srcset="/img/loading.gif" alt></p><h4 id="v9porn"><a href="#v9porn" class="headerlink" title="v9porn"></a><a href="https://github.com/techGay/v9porn" target="_blank" rel="noopener">v9porn</a></h4><p>✔看到上面的标题，想必大多数人都知道了吧嘿嘿嘿</p><p>✔那这个项目就不多介绍了，自行体会，体验好的话就默默点个赞哦   </p><p><img src="/images/tool/13.jpg" srcset="/img/loading.gif" alt>  </p><p>本人Github链接如下，欢迎各位Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下13款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。
    
    </summary>
    
      <category term="tools" scheme="https://luozongmin.com/categories/tools/"/>
    
    
      <category term="工具" scheme="https://luozongmin.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【译】谈谈“typeof null为object”这一bug的由来</title>
    <link href="https://luozongmin.com/2019/10/18/%E3%80%90%E8%AF%91%E3%80%91%E8%B0%88%E8%B0%88%E2%80%9Ctypeof%20null%E4%B8%BAobject%E2%80%9D%E8%BF%99%E4%B8%80bug%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>https://luozongmin.com/2019/10/18/【译】谈谈“typeof null为object”这一bug的由来/</id>
    <published>2019-10-18T02:23:49.040Z</published>
    <updated>2019-05-11T02:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多前端初级开发者也许并不深究typeof null为何为Object？想更深地了解这一bug的由来，可以参阅Dr. Axel Rauschmayer关于”typeof null”的历史这篇文章。<a id="more"></a>     </p><blockquote><p>原文链接：<a href="http://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">http://www.2ality.com/2013/10/typeof-null.html</a></p></blockquote><p>我看了下C语言关于<code>typeof</code>的规范，它对于<code>typeof null</code>为何结果是’<code>object</code>’有更好的解释。  </p><p>在JavaScript中，<code>typeof null</code>的结果是’<code>Object</code>‘，它错误地暗示<code>null</code>是一个对象，实际上它是一个原始值。我在<a href="https://luozongmin.com/2019/05/09/JS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86/">上一篇文章</a>也提到了这是JS的一大bug，不幸的是这并不能解决，因为这将破坏现有规范，接下来解释下这个bug的历史。  </p><p>“<code>typeof null</code>”的错误从JavaScripts第一个版本开始就已经存在了。在这个版本，值以32位为单位存储，由小型标签（1-3位）和值的实际数据组成。类型标签存储在单元的低位中。 其中有五种：   </p><ul><li>000: <code>object</code>. 数据是对象的引用。</li><li>1: <code>int</code>. 数据是31位有符号整数。</li><li>010: <code>double</code>. 数据是对双浮点数的引用。</li><li>100: <code>string</code>. 数据是对字符串的引用。</li><li>110: <code>boolean</code>. 数据是布尔值。</li></ul><p>也就是说，最低位是1，然后类型标签只有1位长，即<code>int</code>型。 或者最低位为0，那么类型标签的长度为3位，为其余4种类型提供了两个附加位。  </p><p>但有2个值是特殊的：  </p><ul><li><code>undefined</code>（JSVAL_VOID）是整数−2^30（整数范围之外的数字）。</li><li><code>null</code>(JSVAL_NULL) 为机器码NULL的空指针，或者说：为0的object类型标签。   </li></ul><p>现在应该明白为什么<code>typeof</code>认为<code>null</code>是一个对象：它检测一个他的类型标签并且返回”<code>object</code>”。 以下是<code>typeof</code>的引擎代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">JS_PUBLIC_API(JSType)</span><br><span class="line">   JS_TypeOfValue(JSContext *cx, jsval v)</span><br><span class="line">   &#123;</span><br><span class="line">       JSType type = JSTYPE_VOID;</span><br><span class="line">       JSObject *obj;</span><br><span class="line">       JSObjectOps *ops;</span><br><span class="line">       JSClass *clasp;</span><br><span class="line"></span><br><span class="line">       CHECK_REQUEST(cx);</span><br><span class="line">       <span class="keyword">if</span> (JSVAL_IS_VOID(v)) &#123;  <span class="comment">// (1)</span></span><br><span class="line">           type = JSTYPE_VOID;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_OBJECT(v)) &#123;  <span class="comment">// (2)</span></span><br><span class="line">           obj = JSVAL_TO_OBJECT(v);</span><br><span class="line">           <span class="keyword">if</span> (obj &amp;&amp;</span><br><span class="line">               (ops = obj-&gt;<span class="built_in">map</span>-&gt;ops,</span><br><span class="line">                ops == &amp;js_ObjectOps</span><br><span class="line">                ? (clasp = OBJ_GET_CLASS(cx, obj),</span><br><span class="line">                   clasp-&gt;call || clasp == &amp;js_FunctionClass) <span class="comment">// (3,4)</span></span><br><span class="line">                : ops-&gt;call != <span class="number">0</span>)) &#123;  <span class="comment">// (3)</span></span><br><span class="line">               type = JSTYPE_FUNCTION;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               type = JSTYPE_OBJECT;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_NUMBER(v)) &#123;</span><br><span class="line">           type = JSTYPE_NUMBER;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_STRING(v)) &#123;</span><br><span class="line">           type = JSTYPE_STRING;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_BOOLEAN(v)) &#123;</span><br><span class="line">           type = JSTYPE_BOOLEAN;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述代码执行的步骤如下：  </p><ul><li>（1）引擎首先检测值是否是<code>undefined</code>(VOID)，它通过<code>==</code>做了这样的比较：  </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSVAL_IS_VOID(v)  ((v) == JSVAL_VOID)</span></span><br></pre></td></tr></table></figure><ul><li><p>下一个（2）是检测该值是否具有<code>object type</code>。如果它可使用<code>call</code>被调用（3）或其存在内部属性<code>[[Class]]</code>标记为函数（4），则v是函数。 否则，它是一个对象。 这是由<code>typeof null</code>生成的结果。  </p></li><li><p>后续检查是针对<code>number</code>，<code>string</code>和<code>boolean</code>，甚至没有明确检查<code>null</code>。这可以由以下C语言宏执行。  </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSVAL_IS_NULL(v)  ((v) == JSVAL_NULL)`</span></span><br></pre></td></tr></table></figure><p>这看似是一个非常明显的bug，但不要忘记，第一个版本的JavaScript完成只用了极少的时间，具体可以看看<a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" target="_blank" rel="noopener">JavaScript的诞生</a>。   </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多前端初级开发者也许并不深究typeof null为何为Object？想更深地了解这一bug的由来，可以参阅Dr. Axel Rauschmayer关于”typeof null”的历史这篇文章。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【译】12个编写干净且可扩展的JavaScript技巧</title>
    <link href="https://luozongmin.com/2019/10/18/%E3%80%90%E8%AF%91%E3%80%9112%E4%B8%AA%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/"/>
    <id>https://luozongmin.com/2019/10/18/【译】12个编写干净且可扩展的JavaScript技巧/</id>
    <published>2019-10-18T02:23:49.009Z</published>
    <updated>2019-06-04T05:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。<a id="more"></a> </p><p>现代Web应用程序严重依赖JavaScript，尤其是单页应用程序（SPA）。借助于React，AngularJS和Vue.js等新兴框架，Web应用程序主要使用JavaScript构建。</p><p>扩展这些应用程序有时候会比较棘手，通过简单的设置，您最终可能会遇到限制并迷失在混乱的海洋中。我想分享一些小技巧，这些技巧将帮助您以有效的方式编写干净的代码。</p><p>本文面向任何技能水平的JavaScript开发人员。 但是，至少具有JavaScript中级知识的开发人员将从这些技巧中获益最多。</p><blockquote><p>原文链接：<a href="https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/" target="_blank" rel="noopener">https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/</a></p></blockquote><h3 id="分隔您的代码"><a href="#分隔您的代码" class="headerlink" title="分隔您的代码"></a>分隔您的代码</h3><p>我建议保持代码库清洁和可读的最重要的事情是具有按主题分隔的特定逻辑块（通常是函数）。如果你编写一个函数，该函数应该默认只有一个目的，不应该一次做多个事情。</p><p>此外，您应避免引起副作用，这意味着在大多数情况下，您不应更改在函数外声明的任何内容。 您将数据接收到带参数的函数中；其他一切都不应该被访问。如果您希望从函数中获取某些内容，请返回新值。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当然，如果以类似的方式使用这些函数或执行类似的操作，您可以将多个函数分组到一个模块（and/or 的类中）。例如，如果要进行许多不同的计算，请将它们拆分为可以链接的独立步骤（函数）。但是，这些函数都可以在一个文件（模块）中声明。 以下是JavaScript中的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add,</span><br><span class="line">    subtract</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">'./calculations'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subtract(<span class="number">5</span>, add(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>如果您正在编写前端JavaScript，请务必使用默认导出作为最重要的项目，并为次要项目命名导出。</p><h3 id="多个参数优先于单个对象参数"><a href="#多个参数优先于单个对象参数" class="headerlink" title="多个参数优先于单个对象参数"></a>多个参数优先于单个对象参数</h3><p>声明一个函数时，您应该总是喜欢多个参数而不是一个期望对象的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayUser</span>(<span class="params">firstName, lastName, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>. She is <span class="subst">$&#123;age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>. She is <span class="subst">$&#123;user.age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这背后的原因是，当您查看函数声明的第一行时，您能确切知道需要传递给函数的内容。</p><p>尽管函数应该受到限制 - 只做一项工作 - 但是它可能会变得更大。在函数体中扫描需要传递的变量（嵌套在对象中）将花费更多时间。有时，使用整个对象并将其传递给函数似乎更容易，但为了扩展应用程序，此设置肯定会有所帮助。</p><p>在某种程度上，声明特定参数没有意义。对我来说，它超过四个或五个功能参数。如果你的函数变大，你应该转向使用对象参数。</p><p>这里的主要原因是参数需要以特定顺序传递。 如果您有可选参数，则需要传递undefined或null。 使用对象参数，您可以简单地传递整个对象，其中顺序和未定义的值无关紧要。</p><h3 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h3><p>解构是ES6引入的一个很好的工具。它允许您从对象中获取特定字段并立即将其分配给变量。 您可以将它用于任何类型的对象或模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EXAMPLE FOR MODULES</span></span><br><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">'./calculations'</span>)</span><br></pre></td></tr></table></figure><p>只导入您需要在文件中使用的函数而不是整个模块，然后从中访问特定的函数。 同样，当您确定您确实需要一个对象作为函数参数时，也可以使用destructuring。 这仍将为您提供函数内所需内容的概述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logCountry</span>(<span class="params">&#123;name, code, language, currency, population, continent&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">`The official language of <span class="subst">$&#123;name&#125;</span> `</span></span><br><span class="line">    <span class="keyword">if</span>(code) msg += <span class="string">`(<span class="subst">$&#123;code&#125;</span>) `</span></span><br><span class="line">    msg += <span class="string">`is <span class="subst">$&#123;language&#125;</span>. <span class="subst">$&#123;population&#125;</span> inhabitants pay in <span class="subst">$&#123;currency&#125;</span>.`</span></span><br><span class="line">    <span class="keyword">if</span>(contintent) msg += <span class="string">` The country is located in <span class="subst">$&#123;continent&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'Germany'</span>,</span><br><span class="line">    code: <span class="string">'DE'</span>,</span><br><span class="line">    language <span class="string">'german'</span>,</span><br><span class="line">    currency: <span class="string">'Euro'</span>,</span><br><span class="line">    population: <span class="string">'82 Million'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'China'</span>,</span><br><span class="line">    language <span class="string">'mandarin'</span>,</span><br><span class="line">    currency: <span class="string">'Renminbi'</span>,</span><br><span class="line">    population: <span class="string">'1.4 Billion'</span>,</span><br><span class="line">    continent: <span class="string">'Asia'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正如你所看到的，我仍然知道我需要传递什么给函数 - 即使它被包装在一个对象中。要解决了解所需内容的问题，请参阅下一个提示！（顺便说一句，这也适用于React功能组件。）</p><h3 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h3><p>解构的默认值甚至基本函数参数都非常有用。首先，它们为您提供了一个可以传递给函数的值的示例。其次，您可以指出哪些值是必需的，哪些值不是。使用前面的示例，该函数的完整设置如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logCountry</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    name = <span class="string">'United States'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    code, </span></span></span><br><span class="line"><span class="function"><span class="params">    language = <span class="string">'English'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    currency = <span class="string">'USD'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    population = <span class="string">'327 Million'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    continent,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">`The official language of <span class="subst">$&#123;name&#125;</span> `</span></span><br><span class="line">    <span class="keyword">if</span>(code) msg += <span class="string">`(<span class="subst">$&#123;code&#125;</span>) `</span></span><br><span class="line">    msg += <span class="string">`is <span class="subst">$&#123;language&#125;</span>. <span class="subst">$&#123;population&#125;</span> inhabitants pay in <span class="subst">$&#123;currency&#125;</span>.`</span></span><br><span class="line">    <span class="keyword">if</span>(contintent) msg += <span class="string">` The country is located in <span class="subst">$&#123;continent&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'Germany'</span>,</span><br><span class="line">    code: <span class="string">'DE'</span>,</span><br><span class="line">    language <span class="string">'german'</span>,</span><br><span class="line">    currency: <span class="string">'Euro'</span>,</span><br><span class="line">    population: <span class="string">'82 Million'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'China'</span>,</span><br><span class="line">    language <span class="string">'mandarin'</span>,</span><br><span class="line">    currency: <span class="string">'Renminbi'</span>,</span><br><span class="line">    population: <span class="string">'1.4 Billion'</span>,</span><br><span class="line">    continent: <span class="string">'Asia'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，有时您可能不想使用默认值，而是在未传递值时抛出错误。 然而，这通常是一个方便的技巧。</p><h3 id="数据稀缺性"><a href="#数据稀缺性" class="headerlink" title="数据稀缺性"></a>数据稀缺性</h3><p>前面的技巧引出了一个结论：最好不要传递您不需要的数据。同样，在设置函数时，这可能意味着更多的工作。但是，从长远来看，它肯定会为您提供更具可读性的代码库。确切地知道在特定位置使用哪些值是非常有价值的。</p><h3 id="行数和缩进限制"><a href="#行数和缩进限制" class="headerlink" title="行数和缩进限制"></a>行数和缩进限制</h3><p>我见过大文件 - 非常大的文件。实际上，超过3,000行代码。在这些文件中查找逻辑块是非常困难的。</p><p>因此，您应该将文件大小限制为一定数量的行。我倾向于将我的文件保存在100行代码之下。 有时候，很难分解文件，它们会增长到200-300行，在极少数情况下会增加到400行。</p><p>超过此临界值，意味着文件太杂乱，难以维护。随意创建新的模块和文件夹。您的项目应该看起来像一个森林，由树（模块部分）和分支（模块和模块文件组）组成。避免试图模仿阿尔卑斯山，在密闭区域堆积代码。</p><p>相比之下，你的实际文件应该看起来像Shire，这里和那里都有一些山丘（小水平的缩进），但一切都相对平坦。 尽量将压痕水平保持在四级以下。</p><p>也许为这些提示启用eslint规则是有帮助的！</p><h3 id="使用prettier"><a href="#使用prettier" class="headerlink" title="使用prettier"></a>使用prettier</h3><p>在团队中工作需要清晰的样式指南和格式。ESLint提供了一个巨大的规则集，您可以根据自己的需求进行自定义。还有 <code>eslint--fix</code>，它可以纠正一些错误，但不是全部。</p><p>相反，我建议使用<a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a>格式化代码。这样，开发人员不必担心代码格式化，而只需编写高质量的代码。 外观将一致并且格式自动化。</p><h3 id="使用有意义的变量名"><a href="#使用有意义的变量名" class="headerlink" title="使用有意义的变量名"></a>使用有意义的变量名</h3><p>理想情况下，应根据其内容命名变量。 以下是一些有助于您声明有意义的变量名称的指南。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数通常执行某种操作。为了解释这一点，人类使用动词 - 转换或显示，例如。在开头用动词命名函数是个好主意，例如<code>convertCurrency</code> 或 <code>displayUserName</code>。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>这些通常会包含一系列项目; 因此，将s附加到变量名称。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> students = [<span class="string">'Eddie'</span>, <span class="string">'Julia'</span>, <span class="string">'Nathan'</span>, <span class="string">'Theresa'</span>]</span><br></pre></td></tr></table></figure><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>简单地说就是尽量多接近于自然语言，这样好理解。你会问“这个人是教师吗？”→“是”或“否”。同样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isTeacher = <span class="literal">true</span> <span class="comment">// OR false</span></span><br></pre></td></tr></table></figure><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><p><code>forEach</code>, <code>map</code>, <code>reduce</code>, <code>filter</code>等是很好的原生JavaScript函数，用于处理数组和执行某些操作。 我看到很多人只是将<code>el</code> 或 <code>element</code>作为参数传递给回调函数。 虽然这很简单快捷，但您还应根据其值来命名。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cities = [<span class="string">'Berlin'</span>, <span class="string">'San Francisco'</span>, <span class="string">'Tel Aviv'</span>, <span class="string">'Seoul'</span>]</span><br><span class="line">cities.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">city</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>通常，您必须跟踪特定数据集和对象的ID。当嵌套id时，只需将其保留为id即可。在这里，我喜欢在将对象返回到前端之前将MongoDB <code>_id</code>映射到 <code>id</code>。从对象中提取<code>id</code>时，请预先添加对象的类型。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> studentId = student.id</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">id</span>: studentId &#125; = student <span class="comment">// destructuring with renaming</span></span><br></pre></td></tr></table></figure><p>该规则的一个例外是模型中的MongoDB引用。 在这里，只需在引用的模型之后命名字段即可。 这将在填充参考文档时保持清晰：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StudentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    teacher: &#123;</span><br><span class="line">        type: Schema.Types.ObjectId,</span><br><span class="line">        ref: <span class="string">'Teacher'</span>,</span><br><span class="line">        required: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="尽可能使用async-await"><a href="#尽可能使用async-await" class="headerlink" title="尽可能使用async / await"></a>尽可能使用async / await</h3><p>在可读性方面，回调是最糟糕的 - 特别是在嵌套时。Promises是一个很好的改进，但在我看来，async / await具有最好的可读性。即使对于初学者或来自其他语言的人来说，这也会有很大帮助。但是，请确保您了解其背后的概念，并且不要盲目地在任何地方使用它。</p><h3 id="模块导入顺序"><a href="#模块导入顺序" class="headerlink" title="模块导入顺序"></a>模块导入顺序</h3><p>正如我们在技巧1和2中看到的那样，将逻辑保持在正确的位置是可维护性的关键。 同样，导入不同模块的方式可以减少文件中的混淆。 我在导入不同模块时遵循一个简单的结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3rd party packages</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stores</span></span><br><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">'~/Store</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// reusable components</span></span><br><span class="line"><span class="string">import Button from '</span>~<span class="regexp">/components/</span>Button<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// utility functions</span></span><br><span class="line"><span class="string">import &#123; add, subtract &#125; from '</span>~<span class="regexp">/utils/</span>calculate<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// submodules</span></span><br><span class="line"><span class="string">import Intro from '</span>./Intro<span class="string">'</span></span><br><span class="line"><span class="string">import Selector from '</span>./Selector<span class="string">'</span></span><br></pre></td></tr></table></figure><p>我在这里使用了React组件作为示例，因为有更多类型的导入。 您应该能够根据您的具体用例进行调整。</p><h3 id="摆脱控制台"><a href="#摆脱控制台" class="headerlink" title="摆脱控制台"></a>摆脱控制台</h3><p><code>console.log</code> 是一种很好的调试方式 - 非常简单，快速，完成工作。显然，有更复杂的工具，但我认为每个开发人员仍然使用它。如果您忘记清理日志，您的控制台最终将陷入巨大的混乱。然后，您确实要在代码库中保留日志; 例如，警告和错误。</p><p>要解决此问题，您仍然可以使用<code>console.log</code> 进行调试，但对于持久日志，请使用<a href="https://www.npmjs.com/package/loglevel" target="_blank" rel="noopener">loglevel</a>或<a href="https://www.npmjs.com/package/winston" target="_blank" rel="noopener">winston</a>等库。此外，您可以使用ESLint警告控制台语句。这样你就可以轻松地全局查找<code>console...</code> 并删除这些语句。</p><p>遵循这些指导原则确实帮助我保持代码库的清洁和可扩展性。 你觉得还有什么提示特别有用的吗？请在评论中告诉我您在编码工作过程中值得推荐的内容，并请分享您用于帮助代码结构的任何其他提示！谢谢~</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="编程技巧" scheme="https://luozongmin.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
