<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米淇淋の个人博客</title>
  
  <subtitle>Stay hungry. Stay young.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luozongmin.com/"/>
  <updated>2019-07-04T07:50:59.076Z</updated>
  <id>https://luozongmin.com/</id>
  
  <author>
    <name>米淇淋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flexbox 对你说爱不完</title>
    <link href="https://luozongmin.com/2019/07/04/CSS%20Flexbox%20%E5%AF%B9%E4%BD%A0%E8%AF%B4%E7%88%B1%E4%B8%8D%E5%AE%8C/"/>
    <id>https://luozongmin.com/2019/07/04/CSS Flexbox 对你说爱不完/</id>
    <published>2019-07-04T06:59:08.842Z</published>
    <updated>2019-07-04T07:50:59.076Z</updated>
    
    <content type="html"><![CDATA[<p>Flexbox 意为弹性布局，是一种新的CSS 3 布局方式，与传统布局方式(基于盒模型，依赖display属性 +position属性 +float属性)相比，flex布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。<a id="more"></a></p><p>废话就不多说了，下面我将尽可能地用简洁明了的言语来描述 Flex 布局。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/images/flex-1.jpg" alt> </p><p>使用了flex布局，则有flex容器（flex container），子元素为项目(flex item）。</p><p>在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，start和end表示对应轴的起始位置，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴。比如将Flexbox的方向设置为row，则主轴就是横轴，而交叉轴就是纵轴；反之设置成column，则主轴就是纵轴，而交叉轴就是横轴，这个下面会具体讲。</p><p>每个项目(flex item)占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。</p><p>这里还需要注意的是，不能直截了当地认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。</p><p>实际上，要实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    display: flex | inline-flex;       //可以有两种取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给div这类块元素设置<code>display: flex</code>或者给span这类行内元素设<code>display: inline-flex</code>，flex布局即创建！</p><p>而Flex布局相关属性正好分为两拨，一拨作用在flex容器上，还有一拨作用在flex子项上。</p><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 的属性将会失效。</strong></p><h3 id="Flex容器上的属性"><a href="#Flex容器上的属性" class="headerlink" title="Flex容器上的属性"></a>Flex容器上的属性</h3><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><p><strong>1. flex-direction: 决定主轴的方向(即项目的排列方向)</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>row</code>（默认）：主轴为水平方向，起点在左端</li></ul><p><img src="/images/flex-2.jpg" alt> </p><ul><li><code>row-reverse</code>：主轴为水平方向，起点在右端</li></ul><p><img src="/images/flex-3.jpg" alt> </p><ul><li><code>column</code>：主轴为垂直方向，起点在上沿</li></ul><p><img src="/images/flex-4.jpg" alt> </p><ul><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿</li></ul><p><img src="/images/flex-5.jpg" alt> </p><p><strong>2. flex-wrap: 决定容器内项目是否可换行</strong></p><p>默认情况下，项目都排在主轴线上，使用 <code>flex-wrap</code> 可实现项目的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>nowrap</code>（默认）：不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行</li></ul><p><img src="/images/flex-6.jpg" alt> </p><ul><li><code>wrap</code>：项目主轴总尺寸超出容器时换行，第一行在上方</li></ul><p><img src="/images/flex-7.jpg" alt></p><ul><li><code>wrap-reverse</code>：换行并反向，第一行在下方</li></ul><p><img src="/images/flex-8.jpg" alt></p><p><strong>3. flex-flow: flex-direction 和 flex-wrap 的复合简写形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为: row nowrap，这个属性其实没多大卵用，不就是两个属性的缩写嘛。</p><p><strong>4. justify-content：定义项目在主轴的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>flex-start</code>（默认）：左对齐</li></ul><p><img src="/images/flex-9.jpg" alt></p><ul><li><code>flex-end</code>：右对齐</li></ul><p><img src="/images/flex-10.jpg" alt></p><ul><li><code>center</code>：居中</li></ul><p><img src="/images/flex-11.jpg" alt></p><ul><li><code>space-between</code>：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙</li></ul><p><img src="/images/flex-12.jpg" alt></p><ul><li><code>space-around</code>：每个项目两侧的间隔相等，所以项目之间的间隔是项目与边缘的间隔的两倍</li></ul><p><img src="/images/flex-13.jpg" alt></p><p><strong>5. align-items: 定义项目在交叉轴上的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: stretch | flex-start | flex-end | center | baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>stretch</code>（默认）：如果项目未设置高度或设为<code>auto</code>，将占满整个容器的高度</li></ul><p><img src="/images/flex-14.jpg" alt></p><p>假设容器高度设置为 50px，而项目都没有设置高度或设为<code>auto</code>的情况下，则项目的高度也为 50px</p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li></ul><p><img src="/images/flex-15.jpg" alt></p><ul><li><code>flex-end</code>：交叉轴的终点对齐</li></ul><p><img src="/images/flex-16.jpg" alt></p><ul><li><code>center</code>：交叉轴的中点对齐</li></ul><p><img src="/images/flex-17.jpg" alt></p><ul><li><code>baseline</code>: 项目的第一行文字的基线对齐</li></ul><p><img src="/images/flex-18.jpg" alt></p><p>以文字的底部为主</p><p><strong>6. align-content: 定义多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: stretch | flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫项目只有一根轴线呢？其实可以这么理解：</p><p>当你 <code>flex-wrap</code> 设置为 <code>nowrap</code> 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p><p>当你 <code>flex-wrap</code> 设置为 <code>wrap</code> 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p><p>建立在主轴为水平方向时测试，即 <code>flex-direction: row</code>, <code>flex-wrap: wrap</code></p><ul><li><code>stretch</code>（默认）：轴线占满整个交叉轴</li></ul><p><img src="/images/flex-19.jpg" alt></p><ul><li><code>flex-start</code>：轴线全部与交叉轴上的起点对齐</li></ul><p><img src="/images/flex-20.jpg" alt></p><ul><li><code>flex-end</code>：轴线全部与交叉轴上的终点对齐</li></ul><p><img src="/images/flex-21.jpg" alt></p><ul><li><code>center</code>：轴线全部在交叉轴上的中间对齐</li></ul><p><img src="/images/flex-22.jpg" alt></p><ul><li><code>space-between</code>：轴线与交叉轴两端对齐，轴线之间的间隔平均分布</li></ul><p><img src="/images/flex-23.jpg" alt></p><ul><li><code>space-around</code>：每个轴线两侧的间隔都相等，所以轴线之间的间隔是轴线与边缘的间隔的两倍</li></ul><p><img src="/images/flex-24.jpg" alt></p><p>到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item（项目） 上的属性。</p><h3 id="Flex-项目上的属性"><a href="#Flex-项目上的属性" class="headerlink" title="Flex 项目上的属性"></a>Flex 项目上的属性</h3><p>item 项目上有六种属性可运用，它们分别是：</p><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><p><strong>1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/flex-25.jpg" alt></p><p><strong>2. flex-grow: 定义项目的放大比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为 0，即如果存在剩余空间，也不放大。</p><p>如果所有项目的 <code>flex-grow</code> 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code>flex-grow</code> 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p><strong>3. flex-shrink: 定义项目的缩小比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><img src="/images/flex-26.jpg" alt></p><p>如果所有项目的 <code>flex-shrink</code> 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code> 属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><p><strong>4. flex-basis: 定义了在分配容器剩余空间之前项目的默认大小。相当于对浏览器提前告知：浏览器兄弟，我要占据这么大的空间，提前帮我预留好</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：<code>auto</code>，即项目本来的大小, 这时候 item 项目的宽高取决于 <code>width</code> 或 <code>height</code> 的值。</p><p>当主轴为水平方向的时候，同时设置 <code>width</code> 和 <code>flex-basis</code>，会忽略 <code>width</code>。flex顾名思义就是弹性的意思，因此，实际上不建议对flex项目使用 <code>width</code> 属性，因为不够弹性。</p><p>当容器剩余空间不足的时候，flex子项目的实际宽度通常不是设置的 <code>flex-basis</code> 尺寸，因为flex布局剩余空间不足的时候默认会收缩，如果有3个子项目，则默认按1:1:1收缩。</p><p><strong>5. flex: flex-grow, flex-shrink 和 flex-basis的复合缩写</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值为<code>0 1 auto</code>。</p><p>有关快捷值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex: auto  //等同于flex:1 1 auto</span><br><span class="line">flex: none  //等同于flex:0 0 auto</span><br></pre></td></tr></table></figure><p><strong>6. align-self: 控制单独某一个项目的垂直对齐方式，与align-items属性语法区别不大</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一区别就是<code>align-self</code>多了个<code>auto</code>（默认值），表示继承自flex容器的<code>align-items</code>属性值，如果没有父元素，则等同于 <code>stretch</code>。</p><p>跟 <code>align-items</code> 其他属性值含义一样，只不过 <code>align-self</code> 是对单个项目生效的，而 <code>align-items</code> 则是对容器下的所有项目生效的。</p><h3 id="从垂直居中看出flex的强大"><a href="#从垂直居中看出flex的强大" class="headerlink" title="从垂直居中看出flex的强大"></a>从垂直居中看出flex的强大</h3><p>以往让元素垂直居中并不容易，直到CSS3的出现，使用绝对定位配合<code>translate</code>属性才让垂直居中变得简单，不过还有一个更爽的办法，那就是使用flex，让垂直居中变得异常简单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“wrapper”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">“div”</span>&gt;</span></span><br><span class="line">        flexbox 对你说爱不完</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>几行简单代码，即可让div垂直居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最重要的就是包裹元素的三个关键属性:</p><ul><li><code>display: flex</code> 将容器指定为flex布局，任何一个元素都可以指定</li><li><code>align-items: center</code> 沿交叉轴对齐项目，这里指的是垂直方向</li><li><code>justify-content: center</code> 设置主轴内容对齐方式</li></ul><h3 id="其他Flex知识点"><a href="#其他Flex知识点" class="headerlink" title="其他Flex知识点"></a>其他Flex知识点</h3><ul><li>在Flex布局中，再强调一遍flex子元素中设置<code>float</code>，<code>clear</code>以及<code>vertical-align</code>属性都是没有用的。</li><li>Flexbox布局最适合应用程序的组件和小规模布局（一维布局），而Grid布局则适用于更大规模的布局（二维布局），有关Grid布局的文章后面会补充。</li><li>已经9102年了，Flex老语法不用在管了，果断放弃，然后私有前缀也不用再加了，看到就烦。</li><li>如果想更好地理解Flex的工作原理，可以在此页面上尝试<a href="http://www.csstutorial.org/flex-both.html" target="_blank" rel="noopener">flex 布局编辑器</a>。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flexbox 意为弹性布局，是一种新的CSS 3 布局方式，与传统布局方式(基于盒模型，依赖display属性 +position属性 +float属性)相比，flex布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。
    
    </summary>
    
      <category term="CSS" scheme="https://luozongmin.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://luozongmin.com/tags/CSS/"/>
    
      <category term="布局" scheme="https://luozongmin.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之闭包</title>
    <link href="https://luozongmin.com/2019/07/02/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/"/>
    <id>https://luozongmin.com/2019/07/02/JavaScript系列之闭包(Closure)/</id>
    <published>2019-07-02T14:42:47.913Z</published>
    <updated>2019-07-03T00:44:14.998Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多初学者在学习JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。<a id="more"></a></p><p>在具体介绍闭包之前，为了更好的理解本文要介绍的内容，建议先去阅读前面的文章<a href="https://zhuanlan.zhihu.com/p/69142071" target="_blank" rel="noopener">《JavaScript系列之变量对象》</a>和<a href="https://zhuanlan.zhihu.com/p/69910449" target="_blank" rel="noopener">《JavaScript系列之作用域和作用域链》</a>，因为它们相互之间都是有关联的。</p><h3 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h3><p>首先，先来看看MDN 对闭包的定义：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是一个既不是函数的形参，也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>好，如果上面三行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 不过如果你是初学者的话，我想应该不会，如果仅用三言两语就把闭包讲通，那还能称为Javascript 语言的一个难点吗？</p><p>先来举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p><code>f1</code> 函数可以访问变量 <code>n</code>，但是 <code>n</code> 既不是 <code>f1</code> 函数的形参，也不是 <code>f1</code> 函数的局部变量，所以这种情况下的 <code>n</code> 就是自由变量。其实上面代码中就存在闭包了，即函数 <code>f1</code> + <code>f1</code> 函数访问的自由变量 <code>n</code> 就构成了一个<strong>闭包</strong>。</p><p>上面代码中，函数 <code>f1</code> 可以读取全局自由变量 <code>n</code>。但是，函数外部无法读取函数内部声明的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n)  <span class="comment">// Uncaught ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure><p>如果有时需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过改变形式才能实现。那就是在函数的内部，再定义一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = f1();</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们就可以在<code>f1</code>外部读取它的内部变量了。</p><p>所以<strong>闭包是一个可以从另一个函数的作用域访问变量的函数。这是通过在函数内创建函数来实现的。当然，外部函数无法访问内部范围</strong>。</p><p>在我们深入研究闭包之前，有必要先从不使用闭包的情况切入，了解为什么要用闭包。</p><h3 id="不使用闭包的情况"><a href="#不使用闭包的情况" class="headerlink" title="不使用闭包的情况"></a>不使用闭包的情况</h3><p>在JavaScript 中，全局变量的错用可能会使得我们的代码出现不可预期的错误。</p><p>假设我们现在要做一个计数的函数，一开始我们想要先写一个给狗的计数函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗的计数函数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(count + <span class="string">' dog(s)'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// 1 dog(s)</span></span><br><span class="line">countDogs()    <span class="comment">// 2 dog(s)</span></span><br><span class="line">countDogs()    <span class="comment">// 3 dog(s)</span></span><br></pre></td></tr></table></figure><p>接着继续写代码的其他部分，当写到后面时，我发现我也需要写猫的计数函数，于是我又开始写了猫的计数函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗的计数函数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(count + <span class="string">' dog(s)'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间的其它代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫的计数函数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countCats</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(count + <span class="string">' cat(s)'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countCats()    <span class="comment">// 1 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 2 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 3 cat(s)</span></span><br></pre></td></tr></table></figure><p>乍看之下好像没啥问题，当我执行<code>countDogs()</code>或<code>countCats()</code>，都会让<code>count</code>增加，然而问题在于当我在不注意的情况下把<code>count</code>这个变量建立在了全局作用域底下时，不论是执行<code>countDogs()</code>或是<code>countCats()</code>时，都是用到了全局的<code>count</code>变量，这使得当我执行下面的代码时，它没有办法分辨现在到底是在对狗计数还是对猫计数，进而导致把猫的数量和狗的数量交错计算的错误情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">countCats()    <span class="comment">// 1 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 2 cat(s)</span></span><br><span class="line">countCats()    <span class="comment">// 3 cat(s)</span></span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// 4 dog(s)，我希望是 1 dog(s)</span></span><br><span class="line">countDogs()    <span class="comment">// 5 dog(s)，我希望是 2 dog(s)</span></span><br><span class="line"></span><br><span class="line">countCats()    <span class="comment">// 6 cat(s)，我希望是 4 cat(s)</span></span><br></pre></td></tr></table></figure><h3 id="闭包让函数有私有变量"><a href="#闭包让函数有私有变量" class="headerlink" title="闭包让函数有私有变量"></a>闭包让函数有私有变量</h3><p>从上面的例子我们知道，如果错误的使用全局变量，很容易会出现一些莫名其妙的bug ，这时候我们就可以利用闭包（closure）的写法，让函数有自己私有变量，简单来说就是<code>countDogs</code>里面能有一个计算<code>dogs</code>的<code>count</code>变数；而<code>countCats</code>里面也能有一个计算<code>cats</code>的<code>count</code>变量，两者是不会互相干扰的。</p><p>为了达到这样的效果，我们就要利用闭包，让变量保留在该函数中而不会被外在环境干扰。</p><p>改成闭包的写法会像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countDogs = dogHouse()</span><br><span class="line">countDogs()    <span class="comment">// "1 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "2 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "3 dogs"</span></span><br></pre></td></tr></table></figure><p>这样我们就将专门计算狗的变量<code>count</code>闭包在<code>dogHouse</code>这个函数中，在<code>dogHouse</code>这个函数中里面的<code>countDogs()</code>才是我们真正执行计数的函数，而在<code>dogHouse</code>这个函数中存在<code>count</code>这个变量，由于JavaScript变量会被缩限在函数的执行上下文中，因此这个<code>count</code>的值只有在<code>dogHouse</code>里面才能被取用，在<code>dogHouse</code>函数外是取用不到这个值的。</p><p>接着因为我们要能够执行在<code>dogHouse</code>中真正核心<code>countDogs()</code>这个函数，因此我们会在最后把这个函数给return出来，好让我们可以在外面去调用到<code>dogHouse</code>里面的这个<code>countDogs()</code>函数。</p><p>最后当我们在使用闭包时，我们先把存在<code>dogHouse</code>里面的<code>countDogs</code>拿出来用，并一样命名为<code>countDogs</code>（这里变量名称可以自己取），因此当我执行全局中的<code>countDogs</code>时，实际上会执行的是<code>dogHouse</code>里面的<code>countDogs</code>函数。</p><p>上面这是闭包的基本写法：<strong>一个函数里面包了另一个函数，同时会 return 里面的函数让我们可以在外面使用到它</strong>。</p><p>我们可以把我们最一开始的代码都改成使用闭包的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countCats</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' cats'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countCats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countDogs = dogHouse()</span><br><span class="line"><span class="keyword">const</span> countCats = catHouse()</span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// "1 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "2 dogs"</span></span><br><span class="line">countDogs()    <span class="comment">// "3 dogs"</span></span><br><span class="line"></span><br><span class="line">countCats()    <span class="comment">// "1 cats"</span></span><br><span class="line">countCats()    <span class="comment">// "2 cats"</span></span><br><span class="line"></span><br><span class="line">countDogs()    <span class="comment">// "4 dogs"</span></span><br></pre></td></tr></table></figure><p>当我们正确地使用闭包时，虽然一样都是使用<code>count</code>来计数，但是是在不同执行环境内的<code>count</code>因此也不会相互干扰。</p><h3 id="进一步了解和使用闭包"><a href="#进一步了解和使用闭包" class="headerlink" title="进一步了解和使用闭包"></a>进一步了解和使用闭包</h3><p>另外，甚至在运用的是同一个<code>dogHouse</code> 时，变量间也都是独立的执行环境不会干扰，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然都是使用 dogHouse ，但是各是不同的执行环境</span></span><br><span class="line"><span class="comment">// 因此彼此的变量不会互相干扰</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> countGolden = dogHouse()</span><br><span class="line"><span class="keyword">var</span> countPug = dogHouse()</span><br><span class="line"><span class="keyword">var</span> countPuppy = dogHouse()</span><br><span class="line"></span><br><span class="line">countGolden()     <span class="comment">// 1 dogs</span></span><br><span class="line">countGolden()     <span class="comment">// 2 dogs</span></span><br><span class="line"></span><br><span class="line">countPug()        <span class="comment">// 1 dogs</span></span><br><span class="line">countPuppy()      <span class="comment">// 1 dogs</span></span><br><span class="line"></span><br><span class="line">countGolden()     <span class="comment">// 3 dogs</span></span><br><span class="line">countPug()        <span class="comment">// 2 dogs</span></span><br></pre></td></tr></table></figure><h3 id="将参数代入闭包中"><a href="#将参数代入闭包中" class="headerlink" title="将参数代入闭包中"></a>将参数代入闭包中</h3><p>但是这么做的话你可能觉得还不够清楚，因为都是叫做<code>dogs</code>，这时候我们一样可以把外面的变量通过函数的参数代入闭包中，像是下面这样，返回的结果就清楚多了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过函数的参数将值代入闭包中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样是使用 dogHouse 但是使用不同的参数</span></span><br><span class="line"><span class="keyword">var</span> countGolden = dogHouse(<span class="string">'Golden'</span>)</span><br><span class="line"><span class="keyword">var</span> countPug = dogHouse(<span class="string">'Pug'</span>)</span><br><span class="line"><span class="keyword">var</span> countPuppy = dogHouse(<span class="string">'Puppy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果看起来更清楚了</span></span><br><span class="line">countGolden()     <span class="comment">// 1 Golden</span></span><br><span class="line">countGolden()     <span class="comment">// 2 Golden</span></span><br><span class="line"></span><br><span class="line">countPug()        <span class="comment">// 1 Pug</span></span><br><span class="line">countPuppy()      <span class="comment">// 1 Puppy</span></span><br><span class="line"></span><br><span class="line">countGolden()     <span class="comment">// 3 Golden</span></span><br><span class="line">countPug()        <span class="comment">// 2 Pug</span></span><br></pre></td></tr></table></figure><p>为了进一步简化代码，我们可以在闭包中直接return一个函数出来，我们就可以不必为里面的函数命名了，而是用匿名函数的方式直接把它返回出来。</p><p>因此写法可以简化成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 把原本 countDogs 函数改成匿名函数直接放进来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' dogs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catHouse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 把原本 countCats 函数改成匿名函数直接放进来</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' cats'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们刚刚有提到，可以透过函数参数的方式把值代入闭包当中，因此实际上我们只需要一个counter ，在不同的时间点给它参数区分就好。这样子不管你是要记录哪一种动物都很方便了，而且代码也相当简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCounter</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(count + <span class="string">' '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dogCounter = createCounter(<span class="string">'dogs'</span>)</span><br><span class="line"><span class="keyword">const</span> catCounter = createCounter(<span class="string">'cats'</span>)</span><br><span class="line"><span class="keyword">const</span> pigCounter = createCounter(<span class="string">'pigs'</span>)</span><br><span class="line"></span><br><span class="line">dogCounter()     <span class="comment">// 1 dogs</span></span><br><span class="line">dogCounter()     <span class="comment">// 2 dogs</span></span><br><span class="line">catCounter()     <span class="comment">// 1 cats</span></span><br><span class="line">catCounter()     <span class="comment">// 2 cats</span></span><br><span class="line">pigCounter()     <span class="comment">// 1 pigs</span></span><br><span class="line">dogCounter()     <span class="comment">// 3 dogs</span></span><br><span class="line">catCounter()     <span class="comment">// 3 cats</span></span><br></pre></td></tr></table></figure><h3 id="闭包的实际应用"><a href="#闭包的实际应用" class="headerlink" title="闭包的实际应用"></a>闭包的实际应用</h3><p>我们要实现这样的一个需求：点击某个按钮，提示点击的是”第n个”按钮，此处我们先不用事件代理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">&lt;button&gt;测试<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button&gt;测试2&lt;/</span>button&gt;</span><br><span class="line">&lt;button&gt;测试<span class="number">3</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">   var buttons = document.getElementsByTagName('button')</span></span><br><span class="line"><span class="string">    for (var i = 0; i &lt; buttons.length; i++) &#123;</span></span><br><span class="line"><span class="string">      buttons[i].onclick = function () &#123;</span></span><br><span class="line"><span class="string">        console.log('第' + (i + 1) + '个')</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>这时候可能会预期点选不同的按钮时，会根据每个button 点击顺序的不同而得到不同的结果。但是实际执行后，你会发现返回的结果都是“第四个”。这是因为<code>i</code>是全局变量，执行到点击事件时，此时<code>i</code>的值为3。</p><p>如果要强制返回预期的结果，那该如何修改呢？最简单的是用<code>let</code>声明<code>i</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">    buttons[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'第'</span> + (i + <span class="number">1</span>) + <span class="string">'个'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，通过<code>let</code>可以帮我们把所定义的变量缩限在块级作用域中，也就是变量的作用域只有在<code>{ }</code>内，来避免 <code>i</code> 这个变量跑到全局变量被重复覆盖。</p><p>另外我们可以通过闭包的方式来修改:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        buttons[j].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'第'</span> + (j + <span class="number">1</span>) + <span class="string">'个'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希望看完这篇文章后，你能对于闭包有更清楚的认识。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多初学者在学习JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="闭包" scheme="https://luozongmin.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之this是什么</title>
    <link href="https://luozongmin.com/2019/07/01/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8Bthis%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://luozongmin.com/2019/07/01/JavaScript系列之this是什么/</id>
    <published>2019-07-01T06:45:02.144Z</published>
    <updated>2019-07-03T00:44:03.849Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://zhuanlan.zhihu.com/p/69910449" target="_blank" rel="noopener">《JavaScript系列之作用域和作用域链》</a>中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。<a id="more"></a></p><p>再来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain-1.jpg" alt></p><p>本章将专门介绍与执行上下文创建阶段直接相关的最后一个细节——<strong>this</strong>是什么？以及它的指向到底是什么。</p><h3 id="了解this"><a href="#了解this" class="headerlink" title="了解this"></a>了解this</h3><p>也许你在其他面向对象的编程语言曾经看过<code>this</code>，也知道它会指向某个构造器(constructor)所建立的对象。但事实上在JavaScript里面，<code>this</code>所代表的不仅仅是那个被建立的对象。</p><p>先来看看ECMAScript 标准规范对this 的定义：</p><blockquote><p>「The this keyword evaluates to the value of the ThisBinding of the current execution context.」<br>「this 这个关键字代表的值为当前执行上下文的ThisBinding。」</p></blockquote><p>然后再来看看MDN 对this 的定义：</p><blockquote><p>「In most cases, the value of this is determined by how a function is called.」<br>「在大多数的情况下，this 其值取决于函数的调用方式。」</p></blockquote><p>好，如果上面两行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 我想应该不会，至少我光看这两行还是不懂。</p><p>先来看个例子吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> people1.gender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people1 = &#123;</span><br><span class="line">    gender: <span class="string">'female'</span>,</span><br><span class="line">    getGender: getGender</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people2 = &#123;</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    getGender: getGender</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(people1.getGender());    <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(people2.getGender());    <span class="comment">// female</span></span><br></pre></td></tr></table></figure><p>what?怎么<code>people2</code>变性了呢，这不是我想要的结果啊，为什么呢？</p><p>因为<code>getGender()</code>返回(return)写死了<code>people1.gender</code>的关系，结果自然是’female’。</p><p>那么，如果我们把<code>getGender</code>稍改一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gender;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个时候，你应该会分别得到<code>female</code>与<code>male</code>两种结果。</p><p>所以回到前面讲的重点，从这个例子可以看出，即便<code>people1</code>与<code>people2</code>的<code>getGender</code>方法参照的都是同一个<code>getGender function</code>，但由于调用的对象不同，所以执行的结果也会不同。</p><p>现在我们知道了第一个重点，<strong><code>this</code>实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数的调用方式</strong>。如何的区分<code>this</code>呢？</p><h3 id="this到底是谁"><a href="#this到底是谁" class="headerlink" title="this到底是谁"></a>this到底是谁</h3><p>看完上面的例子，还是有点似懂非懂吧？那接下来我们来看看不同的调用方式对 <code>this</code> 值的影响。</p><h4 id="情况一：全局对象-amp-调用普通函数"><a href="#情况一：全局对象-amp-调用普通函数" class="headerlink" title="情况一：全局对象&amp;调用普通函数"></a>情况一：全局对象&amp;调用普通函数</h4><p>在全局环境中，<code>this</code> 指向全局对象，在浏览器中，它就是 <code>window</code> 对象。下面的示例中，无论是否是在严格模式下，<code>this</code> 都是指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x)               <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x === x)         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>)      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果普通函数是在全局环境中被调用，在非严格模式下，普通函数中 <code>this</code> 也指向全局对象；如果是在严格模式下，<code>this</code> 将会是 <code>undefined</code>。ES5 为了使 JavaScript 运行在更有限制性的环境而添加了严格模式，严格模式为了消除安全隐患，禁止了 <code>this</code> 关键字指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Window 全局对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>使用严格模式后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>     <span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);  <span class="comment">// 报错 "Cannot read property 'x' of undefined"，因为此时 this 是 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h4 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h4><p>我们知道，在对象里的值如果是原生值（primitive type；例如，字符串、数值、布尔值），我们会把这个新建立的东西称为「<strong>属性（property）</strong>」；如果对象里面的值是函数（function）的话，我们则会把这个新建立的东西称为「<strong>方法（method）</strong>」。</p><p>如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，<strong>函数中的<code>this</code>指向这个上一级对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">2</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()     </span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.fn()结果打印出;</span></span><br><span class="line"><span class="comment">// Object &#123;x: 2, fn: function&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = obj.fn</span><br><span class="line">a()   </span><br><span class="line"></span><br><span class="line"><span class="comment">// a()结果打印出:   </span></span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，直接运行 <code>obj.fn()</code> ，调用该函数的上一级对象是 <code>obj</code>，所以 <code>this</code> 指向 <code>obj</code>，得到 <code>this.x</code> 的值是 2；之后我们将 <code>fn</code> 方法首先赋值给变量 <code>a</code>，<code>a</code> 运行在全局环境中，所以此时 <code>this</code> 指向全局对象<code>Window</code>，得到 <code>this.x</code> 为 1。</p><p>我们再来看一个例子，如果函数被多个对象嵌套调用，this 会指向什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: &#123;</span><br><span class="line">    x: <span class="number">3</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;x: 3, fn: function&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y.fn();</span><br></pre></td></tr></table></figure><p>为什么结果不是 2 呢，因为在这种情况下记住一句话：<strong><code>this</code> 始终会指向直接调用函数的上一级对象</strong>，即 <code>y</code>，上面例子实际执行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = &#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;x: 3, fn: function&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y.fn();</span><br></pre></td></tr></table></figure><p>对象可以嵌套，函数也可以，如果函数嵌套，<code>this</code> 会有变化吗？我们通过下面代码来探讨一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    y: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line">        fn();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Window 全局对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y();</span><br></pre></td></tr></table></figure><p>在函数 <code>y</code> 中，<code>this</code> 指向了调用它的上一级对象 <code>obj</code>，这是没有问题的。但是在嵌套函数 <code>fn</code> 中，<code>this</code> 并不指向 <code>obj</code>。嵌套的函数不会从调用它的函数中继承 <code>this</code>，当嵌套函数作为函数调用时，其 <code>this</code> 值在非严格模式下指向全局对象，在严格模式是 <code>undefined</code>，所以上面例子实际执行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Window 全局对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    y: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y();</span><br></pre></td></tr></table></figure><h4 id="情况三：作为构造函数调用"><a href="#情况三：作为构造函数调用" class="headerlink" title="情况三：作为构造函数调用"></a>情况三：作为构造函数调用</h4><p>我们可以使用 <code>new</code> 关键字，通过构造函数生成一个实例对象。此时，<strong><code>this</code> 便指向这个新对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　  <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Fn &#123;x: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Fn();   <span class="comment">// obj和Fn(..)调用中的this进行绑定</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.x)   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用<code>new</code>来调用<code>Fn(..)</code>时，会构造一个新对象并把它（<code>obj</code>）绑定到<code>Fn(..)</code>调用中的<code>this</code>。还有值得一提的是，如果构造函数返回了非引用类型（<code>string</code>，<code>number</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>），<code>this</code> 仍然指向实例化的新对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x)      <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>因为<code>Fn()</code>返回(return)的是一个对象（引用类型），<code>this</code> 会指向这个return的对象。如果return的是一个非引用类型的值呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x)      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="情况四：call-和-apply-方法调用"><a href="#情况四：call-和-apply-方法调用" class="headerlink" title="情况四：call 和 apply 方法调用"></a>情况四：call 和 apply 方法调用</h4><p>如果你想改变 <code>this</code> 的指向，可以使用 <code>call</code> 或 <code>apply</code> 方法。<strong>它们的第一个参数都是指定函数运行时其中的<code>this</code>指向</strong>。如果第一个参数不传（参数为空）或者传 <code>null</code> 、<code>undefined</code>，默认 <code>this</code> 指向全局对象（非严格模式）或 <code>undefined</code>（严格模式）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj)</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">fn.apply(obj)     </span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">fn.call()         </span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">fn.apply(<span class="literal">null</span>)    </span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">fn.call(<span class="literal">undefined</span>)    </span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>使用 <code>call</code> 和 <code>apply</code> 时，如果给 <code>this</code> 传的不是对象，JavaScript 会使用相关构造函数将其转化为对象，比如传 <code>number</code> 类型，会进行<code>new Number()</code>操作，如传 <code>string</code> 类型，会进行<code>new String()</code>操作，如传 <code>boolean</code> 类型，会进行<code>new Boolean()</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(<span class="string">'love'</span>)      <span class="comment">// [object String]</span></span><br><span class="line">fn.apply(<span class="number">1</span>)          <span class="comment">// [object Number]</span></span><br><span class="line">fn.call(<span class="literal">true</span>)          <span class="comment">// [object Boolean]</span></span><br></pre></td></tr></table></figure><p><code>call</code> 和 <code>apply</code> 的区别在于，<code>call</code> 的第二个及后续参数是一个参数列表，<code>apply</code> 的第二个参数是数组。参数列表和参数数组都将作为函数的参数进行执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span>(<span class="params">y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sum.call(obj, <span class="number">3</span>, <span class="number">4</span>)       <span class="comment">// 9</span></span><br><span class="line">Sum.apply(obj, [<span class="number">3</span>, <span class="number">4</span>])    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h4 id="情况五：bind-方法调用"><a href="#情况五：bind-方法调用" class="headerlink" title="情况五：bind 方法调用"></a>情况五：bind 方法调用</h4><p>调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，新函数的 <code>this</code> <strong>会永久的指向 <code>bind</code> 传入的第一个参数</strong>，无论这个函数是如何被调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    x: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fn.bind(obj1);</span><br><span class="line"><span class="keyword">var</span> b = a.bind(obj2);</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">a.call(obj2);</span><br><span class="line"><span class="comment">// Object &#123;x: 2&#125;</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，虽然我们尝试给函数 <code>a</code> 重新指定 <code>this</code> 的指向，但是它依旧指向第一次 <code>bind</code> 传入的对象，即使是使用 <code>call</code> 或 <code>apply</code> 方法也不能改变这一事实，即永久的指向 <code>bind</code> 传入的第一次参数。</p><h4 id="情况六：箭头函数中this指向"><a href="#情况六：箭头函数中this指向" class="headerlink" title="情况六：箭头函数中this指向"></a>情况六：箭头函数中this指向</h4><p>值得一提的是，从ES6 开始新增了箭头函数，先来看看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">MDN 上对箭头函数的说明</a>：</p><blockquote><p>An arrow function expression has a shorter syntax than a function expression and does notbind its own <code>this</code>,<code>arguments</code>,<code>super</code>, or <code>new.target</code>. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors.</p></blockquote><p>这里已经清楚了说明了，箭头函数没有自己的<code>this</code>绑定。<strong>箭头函数中使用的<code>this</code>，其实是直接包含它的那个函数或函数表达式中的<code>this</code></strong>。在前面情况二中函数嵌套函数的例子中，被嵌套的函数不会继承上层函数的 <code>this</code>，如果使用箭头函数，会发生什么变化呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// true</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Object &#123;y: function&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y()</span><br></pre></td></tr></table></figure><p>和普通函数不一样，箭头函数中的 <code>this</code> 指向了 <code>obj</code>，这是因为它从上一层的函数中继承了 <code>this</code>，你可以理解为箭头函数修正了 <code>this</code> 的指向。所以<strong>箭头函数的<code>this</code>不是调用的时候决定的，而是在定义的时候处在的对象就是它的<code>this</code></strong>。</p><p>换句话说，箭头函数的<code>this</code>看外层的是否有函数，如果有，外层函数的<code>this</code>就是内部箭头函数的<code>this</code>，如果没有，则<code>this</code>是<code>Window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  y: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Window 全局对象 </span></span><br><span class="line">       </span><br><span class="line">      <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);   <span class="comment">// false</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>);           <span class="comment">// Window 全局对象 </span></span><br><span class="line">      &#125;</span><br><span class="line">      fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.y()</span><br></pre></td></tr></table></figure><p>上例中，虽然存在两个箭头函数，其实<code>this</code>取决于最外层的箭头函数，由于<code>obj</code>是个对象而非函数，所以<code>this</code>指向为<code>Window</code>全局对象。</p><p>同 bind 一样，箭头函数也很“顽固”，我们无法通过 <code>call</code> 和 <code>apply</code> 来改变 <code>this</code> 的指向，即传入的第一个参数被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call(obj)       </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br><span class="line"></span><br><span class="line">a.apply(obj)      </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Window 全局对象</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇文章介绍了 <code>this</code> 指向的几种情况，不同的运行环境和调用方式都会对 <code>this</code> 产生影响。总的来说，函数 <code>this</code> 的指向取决于当前调用该函数的对象，也就是执行时的对象。在这一节中，你需要掌握：</p><ul><li><code>this</code> 指向全局对象的情况；</li><li>严格模式和非严格模式下 <code>this</code> 的区别；</li><li>函数作为对象的方法调用时 <code>this</code> 指向的几种情况；</li><li>作为构造函数时 <code>this</code> 的指向，以及是否 <code>return</code> 的区别；</li><li>使用 <code>call</code> 和 <code>apply</code> 改变调用函数的对象；</li><li><code>bind</code> 创建的函数中 <code>this</code> 的指向；</li><li>箭头函数中的 <code>this</code> 指向。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69910449&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JavaScript系列之作用域和作用域链》&lt;/a&gt;中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="this" scheme="https://luozongmin.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>贵州黔东南之行</title>
    <link href="https://luozongmin.com/2019/06/30/%E8%B4%B5%E5%B7%9E%E9%BB%94%E4%B8%9C%E5%8D%97%E4%B9%8B%E8%A1%8C/"/>
    <id>https://luozongmin.com/2019/06/30/贵州黔东南之行/</id>
    <published>2019-06-30T08:30:31.565Z</published>
    <updated>2019-07-01T07:55:07.358Z</updated>
    
    <content type="html"><![CDATA[<p>2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。<a id="more"></a></p><h4 id="镇远古镇"><a href="#镇远古镇" class="headerlink" title="镇远古镇"></a>镇远古镇</h4><p>第一站来到镇远古镇，路上听导游说这里还是一位皇帝的故乡呢！哈哈~当然不是古代的皇帝啦，其实是延禧攻略里面皇帝扮演者聂远的故乡啦😜。</p><p>我们到古城的时间也接近傍晚了，吃完晚饭散步在古城河边，天空中飘着乌云，真有一种“天青色等烟雨”的既视感了。</p><p><img src="/images/zhengyuan-1.jpg" alt></p><p><img src="/images/zhengyuan-2.jpg" alt></p><p><img src="/images/zhengyuan-3.jpg" alt></p><p>河边坐落了许多充满文艺的小店和清吧。</p><p><img src="/images/zhengyuan-4.jpg" alt></p><p>晚上的镇远古镇，虽说夜景和去过的其它几个古镇有些相似，但镇远独特之处在于宁静，有一种与世无争的感觉。</p><p><img src="/images/zhengyuan-5.jpg" alt></p><p><img src="/images/zhengyuan-6.jpg" alt></p><p>在镇远古镇悠悠闲闲的一天里，给我最大的感受还是来自于它的静，很静，很舒服。</p><h4 id="西江千户苗寨"><a href="#西江千户苗寨" class="headerlink" title="西江千户苗寨"></a>西江千户苗寨</h4><p>第二站到达的西江千户苗寨，号称世界上最大的苗寨，一眼望去全是木质结构的屋子，层层叠叠错落有致。</p><p><img src="/images/miaozhai-1.jpg" alt></p><p><img src="/images/miaozhai-2.jpg" alt></p><p>在苗寨里面瞎逛的途中遇到了当地苗族朋友的游行表演。</p><p><img src="/images/miaozhai-3.jpg" alt></p><p>来千户苗寨当然不能错过来自苗族朋友的热情，热情之一就是宴席上的“高山流水”，其实就是灌客人们喝甜甜的米酒，自知酒量不行，仪式开始之前就躲得远远的了哈哈，同桌几个男的就被灌了😄。</p><p><img src="/images/miaozhai-4.jpg" alt></p><p>因为苗寨难得遇到断电，“幸运地”被我们给遇上了，晚上只好回州府凯里住了，晚饭刚好感受了侗族形式的“高山流水”以及侗族的歌舞表演，表演倒是没啥好看的，不过有几个侗族小姐姐还是比较好看的~哈哈不知道她能不能看到，看到的话感觉会被打屎哦😥~</p><p><img src="/images/dongzu-1.jpg" alt></p><p><img src="/images/dongzu-2.jpg" alt></p><h4 id="高要梯田"><a href="#高要梯田" class="headerlink" title="高要梯田"></a>高要梯田</h4><p>第三站抵达高要梯田，高要的梯田虽没有像广西龙胜、云南元阳被外界所熟知，但其美景完全不逊于前者，可惜不是金秋时节来，不然景色应该会更美。</p><p><img src="/images/titian-1.jpg" alt></p><p><img src="/images/titian-2.jpg" alt></p><p>总体来说，此次贵州之行还是很轻松的，可惜的是没时间去到黄果树，希望下次再带她一起来哦~嘻嘻🤭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年6月23日下午，第一次踏足贵州黔东南苗族侗族自治州，听名字就知道是一个少数民族很多的地方，此行的主要目的也是来体验一波当地的风土人情。
    
    </summary>
    
      <category term="游记" scheme="https://luozongmin.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="贵州" scheme="https://luozongmin.com/tags/%E8%B4%B5%E5%B7%9E/"/>
    
      <category term="游记" scheme="https://luozongmin.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之作用域和作用域链</title>
    <link href="https://luozongmin.com/2019/06/28/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>https://luozongmin.com/2019/06/28/JavaScript系列之作用域和作用域链/</id>
    <published>2019-06-28T11:53:24.965Z</published>
    <updated>2019-06-29T07:49:51.043Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://zhuanlan.zhihu.com/p/69142071" target="_blank" rel="noopener">《JavaScript系列之变量对象》</a>中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。<a id="more"></a></p><p>此外，我们也知道每次进入上下文时都会创建变量对象并填充初始值，并且值会在代码执行阶段进行更新，现在就对执行上下文做更深一步的了解。</p><p>先来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain-1.jpg" alt></p><p>本章将专门介绍与执行上下文创建阶段直接相关的另一个细节——<strong>作用域链</strong>。</p><h3 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h3><p>在介绍作用域链前，有必要先来了解一下被称为作用域(Scope)的特性，那什么是作用域呢？</p><p>作用域就是在运行时代码中不同部分中函数和变量的可访问性。可能这句话并不太好理解，我们先来看段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">"inner variable"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(inVariable); <span class="comment">// inner variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); </span><br><span class="line"><span class="built_in">console</span>.log(inVariable); <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以很直观地体会作用域的概念，变量<code>inVariable</code>在全局作用域没有声明，所以在全局作用域下直接取值会报错。所以我们可以这样理解：<strong>作用域就像一个地头蛇，我的地盘我做主，让属于自己域内的变量不会轻易外泄出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong>。这几句话总比前面那句好理解多了吧。</p><p>关于JavaScript 中的作用域类型，<strong>ES6 之前 JavaScript 并没有块级作用域，只有全局作用域和函数作用域</strong>。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现：</p><ul><li>全局作用域 — 变量可以随处访问</li><li>函数作用域— 变量可以在定义它们的函数的边界内访问</li><li>块级作用域—变量可以在定义它们的块中访问，块由 { 和 } 分隔</li></ul><h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> global = <span class="string">'global scoped'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> global = <span class="string">'function scoped'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(global); <span class="comment">// function scoped</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(global); <span class="comment">// global scoped</span></span><br></pre></td></tr></table></figure><p>从上面例子可以看出全局作用域和函数作用域的作用范围，即使全局变量在函数内部分配了不同的值，它也只保留在同一函数的边界内，互相并不影响，我们也不会因使用相同的变量名而出错。再来看个例子加深理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> global = <span class="string">'global scoped'</span></span><br><span class="line"><span class="keyword">const</span> anotherGlobal = <span class="string">'also global scoped'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> global = <span class="string">'function scoped'</span></span><br><span class="line">    <span class="built_in">console</span>.log(global) <span class="comment">// function scoped</span></span><br><span class="line">    <span class="keyword">const</span> scoped = <span class="string">'also function scoped'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(scoped); <span class="comment">// also function scoped</span></span><br><span class="line">        <span class="built_in">console</span>.log(anotherGlobal) <span class="comment">// also global scoped</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(global); <span class="comment">// global scoped</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherGlobal); <span class="comment">// also global scoped</span></span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line">inner(); <span class="comment">// Uncaught ReferenceError: inner is not defined</span></span><br></pre></td></tr></table></figure><p>在这里我们可以看到 <code>inner()</code> 函数可以访问在其父函数中声明的变量—<code>fn()</code>。每当我们需要函数内部的变量时，引擎将首先在当前函数作用域内查找它。如果它没有当前函数作用域内找到它，它将继续上升，向上一级查找，直到它找到全局作用域内的变量，如果找不到变量，我们将得到一个ReferenceError。格外注意<strong>函数内层作用域可以访问外层作用域的变量，反之则不行</strong>。</p><p>除了上面所讲的最外层函数外面定义的变量拥有全局作用域，全局作用域还有一种特殊的出现场合：就是<strong>所有末声明直接赋值的变量将自动声明为拥有全局作用域的变量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    variable = <span class="string">"undeclared variable"</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">"inner variable"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(variable); <span class="comment">// undeclared variable</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable); <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br></pre></td></tr></table></figure><p>全局作用域有个弊端：如果我们写了很多行 JavaScript 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中，这样就会污染全局命名空间，容易引起命名冲突。同时意外的全局变量还会引起内存泄漏，所以在编程时，尽量避免全局变量的使用，以便后期更快地调试。</p><p>还有值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 <code>if</code> 和 <code>switch</code> 条件语句或 <code>for</code> 和 <code>while</code> 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 'if' 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'miqilin'</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// miqilin</span></span><br></pre></td></tr></table></figure><p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致bug出现 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在ES6中，我们得到了两个新的变量声明关键字 - <code>let</code>和<code>const</code>。它们和<code>var</code>之间的主要区别在于，使用ES6关键字声明的变量是块作用域，这意味着它们仅在它们定义的代码块中可用。块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p><code>let</code> 声明的语法与 <code>var</code> 的语法一致。你基本上可以用 <code>let</code> 来代替 <code>var</code> 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li><strong>声明变量不会提升到代码块顶部</strong></li></ul><p><code>let</code>/<code>const</code>创建的变量不会像使用<code>var</code>声明的变量那样被提升到顶部，因此你需要手动将 <code>let</code>/<code>const</code> 声明放置到顶部，以便让变量在整个代码块内部可用。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosole.log(name); <span class="comment">// Uncaught ReferenceError: cosole is not defined</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">"miqilin"</span>;</span><br></pre></td></tr></table></figure><p>所以确保代码没有引用错误的一种方法是确保只使用<code>let</code>和<code>const</code>进行变量声明。</p><ul><li><strong>禁止重复声明</strong></li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符再进行 <code>let</code> 声明就会抛出错误。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'count' has already been declared</span></span><br></pre></td></tr></table></figure><p>上面例子中<code>count</code> 变量被前后声明了两次：第一次使用 <code>var</code> ，另一次使用 <code>let</code> 。因为 <code>let</code> 不能在同一作用域内重复声明一个已有标识符，此处的 <code>let</code> 声明就会抛出错误。但如果在嵌套的作用域内使用 <code>let</code> 声明一个同名的新变量，则不会抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>循环中的绑定块作用域的妙用</strong></li></ul><p>开发者可能最希望实现<code>for</code>循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为用<code>let</code>声明计数器<code>i</code>，只在<code>for</code>循环体内有效，所以在循环体外引用就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果换使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码正确运行，输出了 5 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><h3 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h3><p>上面用一大篇幅来讲解作用域，其实在里面就有涉及到作用域链的知识了。简单的来说，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做<strong>作用域链</strong>。看下面一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line">a(); <span class="comment">// 2</span></span><br><span class="line">b(); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><p>最后加以执行<code>a()</code>和<code>b()</code>，这时候我们会发现两件事：</p><p>1.执行<code>a()</code>会得到2的结果：之所以会有这样的结果，是因为当我们执行<code>function a</code>里面的<code>function b</code>时，因为在<code>function b</code>里面它找不到<code>myVar</code>这个变量，因此它开始往它的外层去搜寻，而这时候它的父级作用域是<code>function a</code>，在<code>function a</code>里面它便找到了<code>myVar = 2</code>，因此它就不再往外部环境 (<code>myVar = 1</code>)去找了，直接返回了2这样的结果。</p><p>2.<code>b()</code>会得到<code>b is not defined</code>的结果：之所以<code>b</code>会是<code>not defined</code>（记得是<code>not defined</code>不是<code>undefined</code>哦！)，是因为这时候在最外层的全局上下文（<code>global execution context</code>）中，找不到<code>function b</code>。</p><p>而从<code>b() --&gt; a() --&gt; global execution context</code>这样的链，就称为<strong>作用域链（Scope Chain）</strong>：</p><p><img src="/images/scopechain-2.jpg" alt></p><p>如果我们把<code>function a</code>里面对于<code>myVar</code>的声明拿掉的话，它才会继续往外层搜寻<code>myVar</code>，直到找到全局作用域中的声明<code>myVar = 1</code>，这时候才会返回1的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var myVar = 2;</span></span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line">a(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如果我们更进一步的把全局作用域中，对于<code>myVar</code>的声明也拿掉，那么现在在全局作用域中也找不到<code>myVar</code>这个变量了，也就是说，在这整个作用域链中都找不到<code>myVar</code>，因此可想而知，最后的结果是<code>not defined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var myVar = 2;</span></span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var myVar = 1;</span></span><br><span class="line">a(); <span class="comment">// Uncaught ReferenceError: myVar is not defined</span></span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69142071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JavaScript系列之变量对象》&lt;/a&gt;中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Scope" scheme="https://luozongmin.com/tags/Scope/"/>
    
      <category term="Scope Chain" scheme="https://luozongmin.com/tags/Scope-Chain/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之变量对象</title>
    <link href="https://luozongmin.com/2019/06/19/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://luozongmin.com/2019/06/19/JavaScript系列之变量对象/</id>
    <published>2019-06-19T11:15:13.526Z</published>
    <updated>2019-06-29T07:55:21.941Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇<a href="https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">《JavaScript系列之执行上下文和执行栈》</a>，通过对变量对象(Variable Object)的介绍对执行上下文有一个更深一步的了解。<a id="more"></a></p><p>上一篇文章也提到了，一个执行上下文的生命周期可以分为三个阶段：</p><p><img src="/images/scopechain-1.jpg" alt></p><p>详细了解执行上下文对于初学者来说极为重要，因为其中涉及到了变量对象，作用域链，this等很多JavaScript初学者没完全搞懂，且极为重要的概念，它关系到我们能不能真正理解JavaScript，真正理解也能更为轻松地胜任后续工作，在后面的文章中我们会一一详细介绍，这里我们先重点了解一下<strong>变量对象</strong>。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>变量对象（Variable Object）是一个与执行上下文相关的数据作用域，存储了在上下文中定义的<strong>变量</strong>和<strong>函数声明</strong>，先来看一段代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;     </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);   <span class="comment">// function b()&#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(c);   <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>foo（）</code>函数的变量对象包含<strong>变量<code>a</code></strong>和<strong>函数<code>b（）</code>的声明</strong>。这里要注意的一点是，函数表达式并不像函数声明一样包含在变量对象中，在示例中所看到的那样，访问c（）函数会导致引用错误。因为变量对象是抽象的和特殊的，它不能在代码中访问，但会由JavaScript引擎处理。</p><p>上面利用的是函数上下文下的变量对象来说明变量对象储存了什么，但变量对象还存在于全局上下文中，接下来就分别来聊聊全局上下文中和函数上下文中的变量对象吧。</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>以浏览器中为例，全局对象为<code>window</code>。 全局上下文有一个特殊的地方，它的变量对象，就是<code>window</code>全局对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以浏览器中为例，全局对象为window</span></span><br><span class="line"><span class="comment">// 全局上下文创建阶段</span></span><br><span class="line"><span class="comment">// VO 为变量对象（Variable Object）的缩写</span></span><br><span class="line">windowEC = &#123;</span><br><span class="line">    VO: Window,</span><br><span class="line">    scopeChain: &#123;&#125;,</span><br><span class="line">    <span class="keyword">this</span>: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在上面已经提到了，变量对象存储了执行上下文中的变量和函数声明，但在函数上下文中，还多了一个<code>arguments(函数参数列表)</code>, 一个伪数组对象。</p><p>这时变量对象的<strong>创建阶段</strong>会包括：</p><ol><li><strong>创建<code>arguments</code>对象</strong>。检查当前上下文中的参数，建立该对象下的属性与属性值。</li><li><strong>检查当前上下文的函数声明，也就是使用function关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li><li><strong>检查当前上下文中的变量声明</strong>（<code>var</code> 声明的变量），默认为 <code>undefined</code>；如果变量名称跟已经声明的形式参数或函数相同，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过变量声明，原属性值不会被修改。</li></ol><p><img src="/images/variableobject-1.jpg" alt></p><p>对于第3点中的“跳过”一词想必大家会有一丝疑问？底下例子中既然按照上面的规则，变量声明的<code>foo</code>遇到函数声明的<code>foo</code>会跳过，可是为什么最后<code>foo</code>的输出结果仍然是被覆盖了？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am function foo'</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>理由其实很简单，因为上面的三条规则仅仅适用于变量对象的<strong>创建过程</strong>，也就是执行上下文的创建过程。而<code>foo = 10</code>是在执行上下文的<strong>执行过程</strong>中运行的，输出结果自然会是10。对比下例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ƒ foo() &#123; console.log('I am function foo') &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am function foo'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>为啥又是不一样的结果呢？其实它的执行顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将所有函数声明放入变量对象中，函数声明变量提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am function foo'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过变量声明默认undefined的赋值</span></span><br><span class="line"><span class="comment">// var foo = undefined;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后开始执行阶段代码的执行</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ƒ foo() &#123; console.log('I am function foo') &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行上下文的执行过程中运行</span></span><br><span class="line">foo = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>根据上面的规则，理解变量提升就变得十分简单了，我们也可以看出，<strong><code>function</code>声明会比<code>var</code>声明优先级更高一点</strong>。为了帮助大家更好的理解变量对象，我们再结合一个简单的例子来进行探讨。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(foo());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果为：</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据上述的规则，理解变量提升后可以将执行顺序理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(foo());</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>这样是不是一目了然了呢？</p><p>当然还需要注意的是，函数未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象（VO）转变为了活动对象（AO），然后开始进行执行阶段的操作。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>当前进入执行阶段，变量对象（VO）激活成活动对象（AO），里面的属性都能被访问了，函数会顺序执行代码，改变变量对象的属性值，此阶段的执行上下文代码会分成两个阶段进行处理：</p><ol><li>进入执行上下文</li><li>执行代码</li></ol><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当进入执行上下文时，这时候还没有执行代码。让我们看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当进入带有参数10的<code>foo</code>函数上下文时，AO表现为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="literal">undefined</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">undefined</span>,</span><br><span class="line">    d: <span class="xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">reference</span> <span class="attr">to</span> <span class="attr">d</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    e: undefined,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><code>x</code> 是函数表达式，所以不在变量对象当中，<code>e</code> 变量引用的值也是函数表达式，所以变量 <code>e</code> 本身是声明，所以在变量对象当中。</p><h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4><p>这个阶段会按顺序执行代码，修改变量对象的属性值，紧接上面的例子，执行完成后AO如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="literal">undefined</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="number">10</span>,</span><br><span class="line">    d: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span> <span class="attr">declaration</span> <span class="attr">d</span>&gt;</span>,</span></span><br><span class="line">    e: &lt;reference to Function expression to _e&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简短地总结一下：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 <code>Arguments</code> 对象</li><li>在进入执行上下文时会依次给变量对象<strong>添加形参</strong>、<strong>函数声明</strong>、<strong>变量声明</strong>等初始的属性值</li><li>函数未进入执行阶段之前，变量对象中的属性都不能访问</li><li>在执行代码阶段，会再次修改变量对象的属性值，并赋予该有的属性值</li></ol><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇&lt;a href=&quot;https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/&quot;&gt;《JavaScript系列之执行上下文和执行栈》&lt;/a&gt;，通过对变量对象(Variable Object)的介绍对执行上下文有一个更深一步的了解。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="变量对象" scheme="https://luozongmin.com/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之执行上下文和执行栈</title>
    <link href="https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <id>https://luozongmin.com/2019/06/13/JavaScript系列之执行上下文和执行栈/</id>
    <published>2019-06-13T05:15:17.714Z</published>
    <updated>2019-06-30T04:48:08.435Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想成为一名优秀的JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。<a id="more"></a></p><p>执行上下文和执行栈是JavaScript的难点之一，所以本人尽量用通俗易懂的方式来阐述这些概念。</p><h3 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h3><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。执行上下文（可执行代码段）总共有三种类型：</p><ul><li><strong>全局执行上下文（全局代码）</strong>：不在任何函数中的代码都位于全局执行上下文中，只有一个，浏览器中的全局对象就是 <code>window</code> 对象，<code>this</code> 指向这个全局对象。</li><li><strong>函数执行上下文（函数体）</strong>：只有调用函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创-建，它都会按照特定的顺序执行一系列步骤。</li><li><strong><code>Eval</code> 函数执行上下文（eval代码）</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</li></ul><p>执行上下文又包括三个生命周期阶段：<strong>创建阶段→执行阶段→回收阶段</strong>，本文重点介绍创建阶段。</p><p><strong>1.创建阶段</strong></p><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li><strong>创建变量对象(Variable object，VO)</strong>：首先初始化函数的参数<code>arguments</code>，提升函数声明和变量声明。后文会详细说明。</li><li><strong>创建作用域链（Scope Chain）</strong>：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。后文会详细说明。</li><li><strong>确定this指向</strong>：包括多种情况，后文会详细说明。</li></ul><p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p><p>另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出<code>this</code> 、 <code>arguments</code>和函数的参数。</p><p><strong>2.执行阶段</strong></p><p>进入执行上下文、执行代码</p><p><strong>3.回收阶段</strong></p><p>执行完毕后执行上下文出栈并等待被垃圾回收</p><p><img src="/images/scopechain-1.jpg" alt></p><h3 id="执行上下文栈（Execution-Context-Stack）"><a href="#执行上下文栈（Execution-Context-Stack）" class="headerlink" title="执行上下文栈（Execution Context Stack）"></a>执行上下文栈（Execution Context Stack）</h3><p>假如我们写的函数多了，每次调用函数时都创建一个新的执行上下文，如何管理创建的那么多执行上下文呢？</p><p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，具有 LIFO（后进先出）的栈结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个<strong>新的函数</strong>执行上下文并Push到当前执行栈的顶部，浏览器的JS执行引擎总是访问栈顶的执行上下文。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的<strong>下一个</strong>执行上下文，最终移回到<strong>全局</strong>执行上下文，全局上下文只有唯一的一个，它在浏览器关闭时Pop出。</p><p>看到目前为止，是否觉得这两个概念还是有点晦涩难懂呢？那…接下来通过几小段代码和图解来详细介绍并理解吧。</p><h3 id="执行上下文是如何执行的呢？"><a href="#执行上下文是如何执行的呢？" class="headerlink" title="执行上下文是如何执行的呢？"></a>执行上下文是如何执行的呢？</h3><p>让我们先来看一下这段简单代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>这段代码背后执行的逻辑是这样的：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，这时候会一并建立<code>this</code>、<code>global object</code> (<code>window</code>)，在函数开始执行的过程中，<code>function a</code>和<code>b</code>由于JS提升机制的缘故会先被建立在内存中，接着才会开始逐行执行函数。</p><p><img src="/images/context-1.jpg" alt></p><p>接着，代码会执行到<code>a( )</code>这个部分，这时候，会建立<code>a</code>的执行上下文（execution context），并且被放置到执行栈（execution stack）中。在这个execution stack中，最上面的execution context会是正在被执行的<code>a( )</code>。如下图：</p><p><img src="/images/context-2.jpg" alt></p><p><code>function a</code> 的execution context建立后，便会开始执行<code>function a</code>中的内容。由于在<code>function a( )</code> 里面有去执行<code>function b</code> ，因此，在这个execution stack中，接下来最上面会变成<code>function b</code> 的execution context。如下图：</p><p><img src="/images/context-3.jpg" alt></p><p>当<code>function b</code> 执行完之后，会从execution stack中离开，继续逐行执行<code>function a</code>。当<code>function a</code> 执行完之后，一样会从execution stack中抽离，再回到Global Execution Context逐行执行。如下图：</p><p><img src="/images/context-4.jpg" alt></p><h3 id="不同执行上下文中的变量是不同的"><a href="#不同执行上下文中的变量是不同的" class="headerlink" title="不同执行上下文中的变量是不同的"></a>不同执行上下文中的变量是不同的</h3><p>在了解了一般的函数其运作背后的逻辑后，让我们来看一下这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">  b();</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>你可以想像，如果我们在不同的execution context中去把<code>myVar</code>这个变量打出来，会得到什么结果呢？结果如下：</p><p><img src="/images/context-5.jpg" alt></p><p>我们分别得到了1、<code>undefined</code>和2。为什么会这样呢？</p><p>让我们来看看这段代码背后执行的逻辑：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，由于变量提升的缘故，<code>myVar</code>、<code>function a</code>和<code>b</code>都会被建立并储存在内存中，接着便开始逐行执行函数。一开始会碰到<code>var myVar = 1</code>所以，最外层的<code>myVar</code>便被给值为1，接着执行到了<code>console.log(myVar)</code>，这是在global execution context执行的，于是得到了第一个1的结果：</p><p><img src="/images/context-6.jpg" alt></p><p>然后执行到了<code>a ( )</code>，于是建立了<code>a</code>的execution context，这时候由于逐行执行的关系，会先执行到<code>var myVar = 2</code>，但因为这是在function a的execution context中，所以并不会影响到global execution context的<code>myVar</code>：</p><p><img src="/images/context-7.jpg" alt></p><p>在执行完<code>function a</code>中的<code>var myVar = 2</code>后，继续逐行执行，于是执行到了<code>b ( )</code>，这时候，<code>function b</code>的execution function便被建立，而且会先去执行<code>function b</code>里面的内容：</p><p><img src="/images/context-8.jpg" alt></p><p><code>function b</code>的execution function建立后，会开始逐行执行<code>function b</code>里面的内容，于是读到了<code>var myVar</code>;，这时候在<code>function b</code>这个execution context中的<code>myVar</code>变量被建立，但是还没被赋值，所以会是<code>undefined</code>。和上面提到的一样，由于这个<code>myVar</code>是在<code>function b</code>中的execution context所建立，所以并不会影响到其他execution context的<code>myVar</code>，这时候执行到了<code>function b</code>的 execution context中的<code>console.log(myVar)</code>，于是得到了第二个看到的<code>undefined</code>：</p><p><img src="/images/context-9.jpg" alt></p><p>最后，<code>function b</code>执行完之后，会从execution stack中离开，继续回到<code>function a</code>中的<code>b( )</code>后逐行执行，也就是<code>console.log(myVar)</code>，这时候是在function a的execution context加以执行的，因此也就得到了结果中看到的第三个2了。</p><p>最后由于<code>b ( )</code> 后面已经没有内容，<code>function a</code>执行完毕，这时候，<code>function a</code>也会从execution stack中抽离。</p><p><img src="/images/context-10.jpg" alt></p><p>最后回到Global Execution Context，如果函数中的<code>a( )</code>后面还有内容的话，会继续进行逐行执行。</p><p>由上面的例子，我们可以知道，我们是在不同的execution context中分别去声明变量<code>myVar</code>的，<strong>因此在不同的execution context，变量彼此之间不会影响</strong>，所以虽然这三个变量都叫做<code>myVar</code>，但其实是三个不同的变量。</p><p>由于我们是在不同的execution context中去声明变量，所以这其实是位于三个不同execution context中的变量，所以即使我们是在执行完<code>a( )</code>后再去调用一次<code>myVar</code>，一样会得到” 1”的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">  b();</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(myVar);  <span class="comment">// 一样会得到"1"</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>最后需要注意的是，如果是在<code>function</code>里面直接使用<code>myVar</code>这个变量，而没有通过<code>var</code>重新声明它的话，就会得到不同的结果！因为在函数作用域内加 <code>var</code> 定义的变量是局部变量，不加 <code>var</code> 定义的就成了全局变量。在未声明新的变量的情况下，在该execution context中JavaScript 引擎找不到这个变量，它就会往它的外层去寻找，最后会得到，1 ,2 ,2 ,2 的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  myVar;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  myVar = <span class="number">2</span>;</span><br><span class="line">  b();</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想成为一名优秀的JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Execution Context" scheme="https://luozongmin.com/tags/Execution-Context/"/>
    
      <category term="Execution Context Stack" scheme="https://luozongmin.com/tags/Execution-Context-Stack/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中的function constructor和prototype的建立</title>
    <link href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>https://luozongmin.com/2019/06/11/谈谈JavaScript中的function constructor和prototype的建立/</id>
    <published>2019-06-11T14:03:26.471Z</published>
    <updated>2019-06-30T04:55:33.666Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/">《谈谈JavaScript中的function constructor和new关键字》</a>这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。<a id="more"></a></p><p>在JavaScript中的函数也是一种对象，其中包含一些属性像是该函数的名称（<code>Name</code>）和该函数的内容（<code>Code</code>），但其实<code>function</code>这里面还有一个属性，这个属性就是<code>prototype</code>，这个属性会以空对象的型式呈现。</p><p>除非你是把<code>function</code>当做<code>function constructor</code>来使用，否则这个属性就没有特别的用途；但如果你是把它当做<code>function constructor</code>，通过<code>new</code>这个关键字来执行这个<code>function</code>的话，它就有特别的意义了。</p><p><img src="/images/constructor-1.jpg" alt></p><p>要进入这个<code>function</code>的<code>prototype</code>属性只要直接通过 <code>.prototype</code> 就可以了。</p><p>然而，有一点很容易令人困惑的地方，我们会以为如果我使用 <code>.prototype</code> 时，就可以直接进入该函数的原型，但实际上并不是这样的！</p><p><strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个<code>function constructor</code>所建立出来的对象的<code>prototype</code></strong>，听起来有点混乱吧…没关系，让我们来看一些代码来帮助我们理解这一概念。</p><h3 id="说明函数中的prototype-属性"><a href="#说明函数中的prototype-属性" class="headerlink" title="说明函数中的prototype 属性"></a>说明函数中的prototype 属性</h3><p><strong>1.function 中的prototype 属性一开始是空对象</strong></p><p>我们先执行上篇文章最后所写的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>到Google Chrome的console视窗中，我们输入 <code>Person.prototype</code>得到的结果会得到一个空对象，如下图：</p><p><img src="/images/constructor-2.jpg" alt></p><p><strong>2.通过function constructor 所建立的对象会继承该function 中prototype 的内容</strong></p><p>接着，让我们在<code>Person.prototype</code>里面增加一个<code>getFullName</code>的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person . prototype . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>在上面代码的第6 - 8行中，我们为<code>Person.prototype</code>添加了一个函数，所以当我们在Google Chrome的console视窗中调用<code>Person.prototype</code>时，会多了这个函数在内：</p><p><img src="/images/constructor-3.jpg" alt></p><p>刚刚，我们有提到很重要的一句话，「<strong>函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个function constructor所建立出来的对象的<code>prototype</code></strong>」。</p><p>这句话的意思其实是说<code>Person.prototype</code>并不是<code>Person.__proto__</code>，但是所有通过<code>Person</code>这个<code>function constructor</code>所建立的对象，在该实例对象的<code>__proto__</code>中，会包含有<code>Person.prototype</code>的内容。</p><p>也就是说，当我们使用<code>new</code>这个运算符来执行<code>function constructor</code>时，它会先建立一个空对象，同时将该构造函数中<code>prototype</code>这个属性的内容（<code>Person.prototype</code>），设置到该实例对象的<code>prototype</code>中，即 <code>person1.__proto__ === Person.prototype</code>的结果为<code>true</code>。</p><p>因此，当我们在Google Chrome的console中输入<code>person1.__proto__</code>时，我们就可以看到刚刚在<code>Person.prototype</code>所建立的函数<code>getFullName</code>已经继承在里面了：</p><p><img src="/images/constructor-4.jpg" alt></p><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>由于<code>Person.prototype</code>中的方法已经被继承到由<code>Person</code>这个<code>function constructor</code>所建立的实例对象<code>person1</code>中，所以这时侯，我们就可以顺利的使用 <code>person1.getFullName</code> 这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person . prototype . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1.getFullName() ) ;</span><br></pre></td></tr></table></figure><p>可以正确的执行<code>getFullName</code>这个函数并得到如下的结果：</p><p><img src="/images/constructor-5.png" alt></p><h3 id="通过function-constructor与Prototype-的实用处"><a href="#通过function-constructor与Prototype-的实用处" class="headerlink" title="通过function constructor与Prototype 的实用处"></a>通过function constructor与Prototype 的实用处</h3><p>通过这样的方法，我们可以让所有根据这个函数构造器（<code>function constructor</code>）所建立的对象都包含有某些我们想要使用的方法。如果我们有1000个对象是根据这个函数构造器所建立的，那么我们只需要使用 <code>.prototype</code>这样的方法，就可以让这1000个物件都可以使用到我们想要执行的某个<code>method</code>，这样减少了代码的复用。</p><p>有的人可能会好奇问，为什么我们不把<code>getFullName</code>这个方法直接写在函数构造式当中呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">  <span class="keyword">this</span> . getFullName  =  <span class="function"><span class="keyword">function</span> (<span class="params"> </span>)  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">this</span> . firstName +  <span class="string">' '</span>  +  <span class="keyword">this</span> . lastName ; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person . prototype . getFullName  =  function ( )  &#123; </span></span><br><span class="line"><span class="comment">  return  this . firstName +  ' '  +  this . lastName ; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意！我们不该把方法放在<code>function constructor</code> 中。</p></blockquote><p>把方法放在函数构造式中这么做虽然仍然可以正确执行并得到结果，但是这么做会有个问题，如果我们是把这个方法直接写在函数构造式中，那么每一个对象都会包含有这个方法，如果我们有1000 个对象根据这个函数构造式所建立，那么这1000 个对象都会包含这个方法在内，如此将会占据相当多的内存；但如果是建立在<code>prototype</code> 中，我们只会有一个这样的方法。</p><p>所以，为了性能上的考量，通常会把方法（<code>method</code>）放在构造函数的<code>prototype</code> 中，因为它们可以是通用的；把属性（<code>property</code>）放在构造函数当中，因为每一个对象可能都会有不同的属性内容，如此将能有效减少内存的问题。</p><p>最后，如果感觉当前缺少你要用的方法，可以自己通过这一方法去创建。</p><p>例如在json2.js源码中，为<code>Date</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code>方法添加一个<code>toJSON</code>的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype.toJSON !== <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Date</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isFinite</span>(<span class="keyword">this</span>.valueOf()) ?</span><br><span class="line">        <span class="keyword">this</span>.getUTCFullYear() + <span class="string">'-'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCMonth() + <span class="number">1</span>) + <span class="string">'-'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCDate()) + <span class="string">'T'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCHours()) + <span class="string">':'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCMinutes()) + <span class="string">':'</span> +</span><br><span class="line">      f(<span class="keyword">this</span>.getUTCSeconds()) + <span class="string">'Z'</span> : <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span>.prototype.toJSON = </span><br><span class="line">  <span class="built_in">Number</span>.prototype.toJSON = </span><br><span class="line">  <span class="built_in">Boolean</span>.prototype.toJSON = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueOf();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/&quot;&gt;《谈谈JavaScript中的function constructor和new关键字》&lt;/a&gt;这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字new来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明function constructor如何用来设定该对象的原型（prototype）。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="constructor" scheme="https://luozongmin.com/tags/constructor/"/>
    
      <category term="prototype" scheme="https://luozongmin.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中的function constructor和new关键字</title>
    <link href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://luozongmin.com/2019/06/11/谈谈JavaScript中的function constructor和new关键字/</id>
    <published>2019-06-11T09:52:41.612Z</published>
    <updated>2019-07-01T07:26:10.873Z</updated>
    
    <content type="html"><![CDATA[<p>您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？<a id="more"></a></p><p>大多数 Javascript 的新开发者不太想要使用new关键字，因为这会让代码写的像是 Java 并且在使用上会造成一点混乱；在这篇文章我会尽量尝试着去理清这些东西，并解释它是如何运作的。</p><h3 id="谈谈function-constructor"><a href="#谈谈function-constructor" class="headerlink" title="谈谈function constructor"></a>谈谈function constructor</h3><p><code>constructor</code> 翻为构造器但为了让您之后更好地理解，会直接使用 <code>constructor</code>；在 Javascript 中任何一个函数(<code>function</code>)都可以被当作 <code>constructor</code>；Javascript 并没有明确的区分两者，也就是说 <code>function</code> 可以被当作 <code>constructor</code> 或者当作一般函数调用。</p><p>而 <code>constructor</code> 的用法就是 <code>function</code> 搭配<code>new</code>关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>接着我们把<code>person</code>呼叫出来看，会得到如下的结果，<strong>通过<code>new</code>它会帮我们建立一个对象</strong>，然后里面有<code>Person</code>这个<code>function</code>里面的内容，并且变成了属性名称和属性值：</p><p><img src="/images/new-1.png" alt></p><h3 id="进一步来看new-让这个过程发生了什么"><a href="#进一步来看new-让这个过程发生了什么" class="headerlink" title="进一步来看new 让这个过程发生了什么"></a>进一步来看new 让这个过程发生了什么</h3><p>当使用<code>new</code>命令时，它后面的函数依次执行下面的4个步骤：</p><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li><li>如果函数没有return其他对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ol><p>也就是说，当我们使用<code>new</code>这个关键字时，实际上会先有一个空的对象被建立。</p><p>接着<code>People</code>这个构造函数会被执行，这个空对象的原型，指向了<code>People.prototype</code>。</p><p>我们知道当函数执行的时候，在<code>execution context</code>中会有<code>this</code>被建立，而<strong>当我们使用<code>new</code>的时候，函数里面的<code>this</code>会被指定成刚刚所建立的那个空对象</strong>。</p><p>所以当执行<code>People</code>这个<code>function</code>，执行到<code>this.firstName</code>和<code>this.lastName</code>时，因为<code>this</code>现在指称的是那个空对象，所以实际上是在帮这个空对象赋予属性名称和属性值。</p><p>在这样的过程中，<strong>只要这个构造函数<code>People</code> 没有指定<code>return</code>为其他对象，它就会直接返回给我们这个新建立的对象</strong>。</p><p>接着让我们通过一段代码来更清楚的了解这个执行的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="string">'这个函数有被执行'</span> ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>这时候在chrome 中呼叫出来的结果如下，说明了当我们使用<code>new</code> 在构造对象的时候<code>People</code> 这个<code>function</code> 确实有被执行：</p><p><img src="/images/new-2.png" alt></p><h3 id="通过new-会帮我们建立一个空的对象"><a href="#通过new-会帮我们建立一个空的对象" class="headerlink" title="通过new 会帮我们建立一个空的对象"></a>通过new 会帮我们建立一个空的对象</h3><p>现在我把我们上面的代码改成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span> (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span> . log ( <span class="keyword">this</span> ) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="comment">// console.log(person);</span></span><br></pre></td></tr></table></figure><p>这时候代码返回的结果如下，表示的确在执行这段代码的过程中帮我们建立了一个新的空对象：</p><p><img src="/images/new-3.jpg" alt></p><h3 id="函数的最后若return其他对象，则原新对象内容会被覆盖"><a href="#函数的最后若return其他对象，则原新对象内容会被覆盖" class="headerlink" title="函数的最后若return其他对象，则原新对象内容会被覆盖"></a>函数的最后若return其他对象，则原新对象内容会被覆盖</h3><p>现在，让我们把原本的代码稍微做如下修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ; </span><br><span class="line">  <span class="keyword">return</span>   &#123; <span class="string">"RETURN"</span> : <span class="string">"原本this的内容就不会被返回"</span> &#125; ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  <span class="keyword">new</span>  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>构造函数的内部若<code>return</code>其他对象，<code>new</code>命令会返回<code>return</code>语句指定的对象，将原新对象内容覆盖掉；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。返回的结果如下：</p><p><img src="/images/new-4.png" alt></p><h3 id="手写一个new实现"><a href="#手写一个new实现" class="headerlink" title="手写一个new实现"></a>手写一个new实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line"><span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line"><span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line"><span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这个手写的new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内置函数new</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(...)</span><br><span class="line">                        </span><br><span class="line"><span class="comment">// 使用手写的new，即create</span></span><br><span class="line"><span class="keyword">var</span> person = create(Person, ...)</span><br></pre></td></tr></table></figure><p>代码原理解析：</p><ol><li>用<code>new Object()</code> 的方式新建了一个对象<code>obj</code></li><li>取出第一个参数，就是我们要传入的构造函数。此外因为 <code>shift</code> 会修改原数组，所以 <code>arguments</code> 会被去除第一个参数</li><li>将 <code>obj</code> 的原型指向构造函数，这样<code>obj</code>就可以访问到构造函数原型中的属性</li><li>使用 <code>apply</code>，改变构造函数 <code>this</code> 的指向到新建的对象，这样 <code>obj</code> 就可以访问到构造函数中的属性</li><li>返回 <code>obj</code></li></ol><h3 id="function-constructor-的实际应用"><a href="#function-constructor-的实际应用" class="headerlink" title="function constructor 的实际应用"></a>function constructor 的实际应用</h3><p>由上面的方法，我们可以通过<code>function</code>的方式来建立一个新的对象，如果我们想要<strong>建立出同属性名称但不同属性值的对象内容，我们可以把对象的属性值变成参数</strong>，如此就能通过此<code>function constructor</code>建立出许多不同的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> firstName , lastName </span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName = firstName ; </span><br><span class="line">  <span class="keyword">this</span> . lastName = lastName ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span>  Person ( <span class="string">'Jay'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person1 ) ; </span><br><span class="line"><span class="keyword">var</span> person2 =  <span class="keyword">new</span>  Person ( <span class="string">'Jane'</span> ,  <span class="string">'chou'</span> ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person2 ) ;</span><br></pre></td></tr></table></figure><p>如此，我们就可以通过同一个构造函数建立出很多不同的对象：</p><p><img src="/images/new-5.png" alt></p><p>此外，我们会把根据<strong>构造器（<code>constructor</code>）所建立出来的对象称作是实例（<code>instance</code>）</strong>，这在之前的文章里也有提过。</p><h3 id="注意！如果我们忘了加上new关键字"><a href="#注意！如果我们忘了加上new关键字" class="headerlink" title="注意！如果我们忘了加上new关键字"></a>注意！如果我们忘了加上new关键字</h3><p>这里有一个地方我们需要非常留意，如果你在撰写代码的过程当中，忘记加上<code>new</code>这个关键字的话，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>  (<span class="params"> </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span> . firstName =  <span class="string">'Jay'</span> ; </span><br><span class="line">  <span class="keyword">this</span> . lastName =  <span class="string">'Chou'</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person =  Person ( ) ; </span><br><span class="line"><span class="built_in">console</span> . log ( person ) ;</span><br></pre></td></tr></table></figure><p>如此，因为JavaScript不知道你是要执行这个函数，还是要根据这个<code>function</code>去建立<code>object</code>，因次最后会返回<code>undefined</code>的结果。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>其实构造函数（function constructor）就是普通的function，只是我们可以通过这个function 来建立对象。</li><li>通过在function 前面加上new 这个运算符，它会把函数中this 这个关键字建立成一个新的对象，然后如果你没有在该函数的内部指定返回出其它对象的话，它就会自动返回这个新的对象给你。</li></ul><p>那又是如何通过<code>function constructors</code> 来设定我们的原型（<code>prototype</code>）呢？让我们在下一篇文章来谈吧！</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您是否曾困惑于 Javascript 中的new关键字呢？是否曾想理解关于 function 和 constructor 的区别是什么呢？
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="constructor" scheme="https://luozongmin.com/tags/constructor/"/>
    
      <category term="new" scheme="https://luozongmin.com/tags/new/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之对象的继承</title>
    <link href="https://luozongmin.com/2019/06/10/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>https://luozongmin.com/2019/06/10/JavaScript系列之对象的继承/</id>
    <published>2019-06-10T09:04:17.179Z</published>
    <updated>2019-06-30T05:10:33.274Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的重点讲的是关于JavaScript中对象的继承，这是面向对象编程很重要的一个方面。A 对象继承自B 对象，就能直接拥有 B 对象的所有属性和方法，作用是避免了代码的复用，节省代码量。<a id="more"></a></p><p>而大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。传统上，JavaScript 语言的继承不通过 class（ES6 引入了 class 语法，基于 class 的继承不在这里介绍），而是通过“原型对象”（<code>prototype</code>）实现，因此，这里把“继承”着重拿出来讲，就为了体现这个不同。</p><h3 id="复习原型-原型链"><a href="#复习原型-原型链" class="headerlink" title="复习原型/原型链"></a>复习原型/原型链</h3><p>JavaScript的继承得靠原型/原型链来实现，当然原型/原型链不是这篇文章的重点，之前的文章也已经介绍过了，所以这里我们来复习一下即可。</p><p>其实原型的概念很简单，我觉得用以下简短的几句话就能概括完全了：</p><ul><li>所有对象都有一个属性 <code>__proto__</code> 指向一个对象，也就是原型</li><li>每个对象的原型都可以通过 <code>constructor</code> 找到构造函数，构造函数也可以通过 <code>prototype</code> 找到原型</li><li>所有函数都可以通过 <code>__proto__</code> 找到 <code>Function</code> 对象</li><li>所有对象都可以通过 <code>__proto__</code> 找到 <code>Object</code> 对象</li><li>对象之间通过 <code>__proto__</code> 连接起来，这样称之为原型链。当前对象上不存在的属性可以通过原型链一层层往上查找，直到顶层 <code>Object</code> 对象，顶层 <code>Object</code> 对象最终指向<code>null</code></li></ul><p>我觉得原型中最重要的内容其实就这些了，没必要看太多关于原型的文章，到头来只是会越来越糊涂，如果硬要推荐原型参阅资料的话，《JavaScript高级程序设计》这本书，当之无愧！</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过上面的介绍，我们知道JavaScript中的继承是通过原型/原型链来体现的，先看几行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">f1.a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Foo.prototype.a = <span class="number">100</span>;</span><br><span class="line">Foo.prototype.b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1.a);  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.b);  <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.c);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>以上代码中，<code>f1</code>是<code>Foo</code>函数通过<code>new</code>构造出来的对象，<code>f1.a</code>是<code>f1</code>对象的基本属性，而<code>f1.b</code>是从<code>Foo.prototype</code>继承得到的，因为<code>f1.__proto__</code>指向的是<code>Foo.prototype</code>。</p><p>这里有一个重要的规则：<strong>当访问一个对象的属性时，首先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链往上找，看是否在链上，有的话就能继承这一属性，如果没有，就返回<code>undefined</code>，这就是原型链</strong>，又复习一遍咯。</p><p>看图直观一些，这里还是采用反复用的原型/原型链经典图：</p><p><img src="/images/jicheng-1.jpg" alt></p><p>上图中，访问<code>f1.a</code>时，<code>f1</code>的基本属性中有<code>a</code>，则不会继续沿着<code>__proto__</code>找，直接读出基本属性<code>a</code>的值；而访问<code>f1.b</code>时，<code>f1</code>的基本属性中没有<code>b</code>，于是沿着<code>__proto__</code>找到了<code>Foo.prototype.b</code>。</p><p>那我们如何在实际应用中区分一个属性到底是基本属性还是在原型链中的公有属性呢？这里可以好好利用一下这个属性——<code>hasOwnProperty</code>，一下就能测出谁是基本属性，当在<code>for…in…</code>循环中，需要额外注意。</p><p><img src="/images/jicheng-2.jpg" alt></p><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性，所以上图中，右边的只打印出<code>a</code>一个值，因为<code>b</code>是在<code>Foo.prototype</code>上的，不属于自身属性。</p><p>那<code>f1</code>的这个<code>hasOwnProperty()</code>方法，<code>f1</code>自身没有，<code>Foo.prototype</code>中也没有，又是从何而来呢？</p><p>还是引用那张原型/原型链经典图，从图上来看，<code>hasOwnProperty()</code>方法是从<code>Object.prototype</code>中继承来的：</p><p><img src="/images/jicheng-3.jpg" alt></p><p>所以对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，因为自身没有这一属性，就会沿着原型链一直查找到<code>Object.prototype</code>上有这一属性，如果没找到则返回<code>undefined</code>。</p><p>由于所有的对象的原型链都会最终找到<code>Object.prototype</code>，因此所有的对象都会有<code>Object.prototype</code>中的方法，比如<code>toString</code>、<code>valueOf</code>等这些公有属性，这就是所谓的“继承”。</p><p>当然这只是一个例子，你可以自定义函数和对象来实现自己的继承，这一点后续文章会有专门介绍。</p><p>这里再说一个函数的例子来加深理解吧。</p><p>我们都知道每个函数都有<code>apply</code>，<code>call</code>方法，都有<code>length</code>，<code>arguments</code>，<code>caller</code>等属性。为什么每个函数都有？这肯定是“继承”来的。在介绍<code>instanceof</code><a href="https://luozongmin.com/2019/06/05/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/">这篇文章</a>中也提到，函数是由<code>Function</code>函数创建，都继承自<code>Function.prototype</code>中的方法。不信可以在Chrome中打印出：</p><p><img src="/images/jicheng-4.jpg" alt></p><p>直接可以看到了吧，有<code>call</code>、<code>length</code>等这些属性。</p><p>那怎么还有<code>hasOwnProperty</code>呢？上图中<code>hasOwnProperty</code>右边显示<code>Object</code>，代表<code>Function.prototype</code>继承自<code>Object.prototype</code>。有疑问可以再看看这张原型/原型链经典大图，<code>Function.prototype.__proto__</code>会指向<code>Object.prototype</code>。</p><p><img src="/images/jicheng-5.jpg" alt></p><p>最后还是那句话，当你完全搞懂上面这张图的时候，就是你掌握原型、原型链的时候了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的重点讲的是关于JavaScript中对象的继承，这是面向对象编程很重要的一个方面。A 对象继承自B 对象，就能直接拥有 B 对象的所有属性和方法，作用是避免了代码的复用，节省代码量。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="继承" scheme="https://luozongmin.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>从instanceof身上深入理解原型/原型链</title>
    <link href="https://luozongmin.com/2019/06/05/%E4%BB%8Einstanceof%E8%BA%AB%E4%B8%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://luozongmin.com/2019/06/05/从instanceof身上深入理解原型原型链/</id>
    <published>2019-06-05T09:32:59.787Z</published>
    <updated>2019-06-30T05:15:21.743Z</updated>
    
    <content type="html"><![CDATA[<p>今天将延续<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。<a id="more"></a></p><p>对于原始类型（primitive type）的值，即<code>string</code>/<code>number</code>/<code>boolean</code>，你可以通过<code>typeof</code>判断其类型，但是<code>typeof</code>在判断到合成类型（complex type）的值的时候，返回值只有<code>object</code>/<code>function</code>，你不知道它到底是一个<code>object</code>对象，还是数组，也不能判断出Object 下具体是什么细分的类型，比如 <code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code> 等。</p><p>官方对<code>instanceof</code>运算符的解释是返回一个布尔值，表示对象是否为某个构造函数的实例。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>f1</code>是构造函数<code>Foo</code>的实例，所以返回<code>true</code>，但是“f1 instanceof Object”为什么也是<code>true</code>呢？</p><p>至于为什么等会再解释，先把<code>instanceof</code>判断的规则告诉大家。根据以上代码看下图：</p><p><img src="/images/instanceof-1.jpg" alt>  </p><p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数，左边变量暂称为A，右边变量暂称为B。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。</p><p>通俗一点来讲，<code>instanceof</code>的判断规则是：<strong><code>instanceof</code>会检查整个原型链，将沿着A的<code>__proto__</code>这条线来一直找，同时沿着B的<code>prototype</code>这条线来一直找，直到能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code></strong>。即上图中的 <code>f1</code>–&gt;<code>__proto__</code> 和 <code>Foo</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Foo)</code>为<code>true</code>。</p><p>按照以上规则，重新来看看“ f1 instanceof Object ”这句代码为什么是<code>true</code>？ 根据上图很容易就能看出来， f1–&gt;<code>__proto__</code>–&gt;<code>__proto__</code> 和<code>Object</code>–&gt;<code>prototype</code> 指向同一个对象，<code>console.log(f1 instanceof Object)</code>为<code>true</code>。</p><p>通过上面的规则，可以很好地解释一些比较怪异的现象，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这些就是<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>所讲的看似很混乱的东西，现在知道为何了吧。</p><p>但还有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create</code>后续会有专门文章介绍）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。但是，只要一个对象的原型不是<code>null</code>，<code>instanceof</code>运算符的判断就不会失真。</p><p>说到这里，继续贴上这幅原型/原型链的经典图，是否现在看起来没那么复杂了呢。</p><p><img src="/images/jicheng-5.jpg" alt>  </p><p>如果<a href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/">这篇文章</a>你看的比较仔细，再结合刚才介绍的<code>instanceof</code>的概念规则，相信能看懂上面这张图的内容了。</p><p>那么问题又出来了。<code>instanceof</code>这样设计，到底有什么用？到底<code>instanceof</code>想表达什么呢？</p><p>这就要重点讲讲继承了，即<code>instanceof</code>表示的就是一种继承关系，或者原型链的结构，请看后续文章介绍。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天将延续&lt;a href=&quot;https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/&quot;&gt;这篇文章&lt;/a&gt;，借助一个老朋友——instanceof运算符，将通过它以及结合多次讲的原型/原型链经典图来深入理解原型/原型链。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://luozongmin.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>【译】12个编写干净且可扩展的JavaScript技巧</title>
    <link href="https://luozongmin.com/2019/06/04/%E3%80%90%E8%AF%91%E3%80%9112%E4%B8%AA%E7%BC%96%E5%86%99%E5%B9%B2%E5%87%80%E4%B8%94%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7/"/>
    <id>https://luozongmin.com/2019/06/04/【译】12个编写干净且可扩展的JavaScript技巧/</id>
    <published>2019-06-04T05:05:56.932Z</published>
    <updated>2019-06-04T05:26:15.531Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。<a id="more"></a> </p><p>现代Web应用程序严重依赖JavaScript，尤其是单页应用程序（SPA）。借助于React，AngularJS和Vue.js等新兴框架，Web应用程序主要使用JavaScript构建。</p><p>扩展这些应用程序有时候会比较棘手，通过简单的设置，您最终可能会遇到限制并迷失在混乱的海洋中。我想分享一些小技巧，这些技巧将帮助您以有效的方式编写干净的代码。</p><p>本文面向任何技能水平的JavaScript开发人员。 但是，至少具有JavaScript中级知识的开发人员将从这些技巧中获益最多。</p><blockquote><p>原文链接：<a href="https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/" target="_blank" rel="noopener">https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/</a></p></blockquote><h3 id="分隔您的代码"><a href="#分隔您的代码" class="headerlink" title="分隔您的代码"></a>分隔您的代码</h3><p>我建议保持代码库清洁和可读的最重要的事情是具有按主题分隔的特定逻辑块（通常是函数）。如果你编写一个函数，该函数应该默认只有一个目的，不应该一次做多个事情。</p><p>此外，您应避免引起副作用，这意味着在大多数情况下，您不应更改在函数外声明的任何内容。 您将数据接收到带参数的函数中；其他一切都不应该被访问。如果您希望从函数中获取某些内容，请返回新值。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当然，如果以类似的方式使用这些函数或执行类似的操作，您可以将多个函数分组到一个模块（and/or 的类中）。例如，如果要进行许多不同的计算，请将它们拆分为可以链接的独立步骤（函数）。但是，这些函数都可以在一个文件（模块）中声明。 以下是JavaScript中的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add,</span><br><span class="line">    subtract</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">'./calculations'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subtract(<span class="number">5</span>, add(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>如果您正在编写前端JavaScript，请务必使用默认导出作为最重要的项目，并为次要项目命名导出。</p><h3 id="多个参数优先于单个对象参数"><a href="#多个参数优先于单个对象参数" class="headerlink" title="多个参数优先于单个对象参数"></a>多个参数优先于单个对象参数</h3><p>声明一个函数时，您应该总是喜欢多个参数而不是一个期望对象的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayUser</span>(<span class="params">firstName, lastName, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>. She is <span class="subst">$&#123;age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>. She is <span class="subst">$&#123;user.age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这背后的原因是，当您查看函数声明的第一行时，您能确切知道需要传递给函数的内容。</p><p>尽管函数应该受到限制 - 只做一项工作 - 但是它可能会变得更大。在函数体中扫描需要传递的变量（嵌套在对象中）将花费更多时间。有时，使用整个对象并将其传递给函数似乎更容易，但为了扩展应用程序，此设置肯定会有所帮助。</p><p>在某种程度上，声明特定参数没有意义。对我来说，它超过四个或五个功能参数。如果你的函数变大，你应该转向使用对象参数。</p><p>这里的主要原因是参数需要以特定顺序传递。 如果您有可选参数，则需要传递undefined或null。 使用对象参数，您可以简单地传递整个对象，其中顺序和未定义的值无关紧要。</p><h3 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h3><p>解构是ES6引入的一个很好的工具。它允许您从对象中获取特定字段并立即将其分配给变量。 您可以将它用于任何类型的对象或模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EXAMPLE FOR MODULES</span></span><br><span class="line"><span class="keyword">const</span> &#123; add, subtract &#125; = <span class="built_in">require</span>(<span class="string">'./calculations'</span>)</span><br></pre></td></tr></table></figure><p>只导入您需要在文件中使用的函数而不是整个模块，然后从中访问特定的函数。 同样，当您确定您确实需要一个对象作为函数参数时，也可以使用destructuring。 这仍将为您提供函数内所需内容的概述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logCountry</span>(<span class="params">&#123;name, code, language, currency, population, continent&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">`The official language of <span class="subst">$&#123;name&#125;</span> `</span></span><br><span class="line">    <span class="keyword">if</span>(code) msg += <span class="string">`(<span class="subst">$&#123;code&#125;</span>) `</span></span><br><span class="line">    msg += <span class="string">`is <span class="subst">$&#123;language&#125;</span>. <span class="subst">$&#123;population&#125;</span> inhabitants pay in <span class="subst">$&#123;currency&#125;</span>.`</span></span><br><span class="line">    <span class="keyword">if</span>(contintent) msg += <span class="string">` The country is located in <span class="subst">$&#123;continent&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'Germany'</span>,</span><br><span class="line">    code: <span class="string">'DE'</span>,</span><br><span class="line">    language <span class="string">'german'</span>,</span><br><span class="line">    currency: <span class="string">'Euro'</span>,</span><br><span class="line">    population: <span class="string">'82 Million'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'China'</span>,</span><br><span class="line">    language <span class="string">'mandarin'</span>,</span><br><span class="line">    currency: <span class="string">'Renminbi'</span>,</span><br><span class="line">    population: <span class="string">'1.4 Billion'</span>,</span><br><span class="line">    continent: <span class="string">'Asia'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正如你所看到的，我仍然知道我需要传递什么给函数 - 即使它被包装在一个对象中。要解决了解所需内容的问题，请参阅下一个提示！（顺便说一句，这也适用于React功能组件。）</p><h3 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h3><p>解构的默认值甚至基本函数参数都非常有用。首先，它们为您提供了一个可以传递给函数的值的示例。其次，您可以指出哪些值是必需的，哪些值不是。使用前面的示例，该函数的完整设置如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logCountry</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    name = <span class="string">'United States'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    code, </span></span></span><br><span class="line"><span class="function"><span class="params">    language = <span class="string">'English'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    currency = <span class="string">'USD'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    population = <span class="string">'327 Million'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    continent,</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">`The official language of <span class="subst">$&#123;name&#125;</span> `</span></span><br><span class="line">    <span class="keyword">if</span>(code) msg += <span class="string">`(<span class="subst">$&#123;code&#125;</span>) `</span></span><br><span class="line">    msg += <span class="string">`is <span class="subst">$&#123;language&#125;</span>. <span class="subst">$&#123;population&#125;</span> inhabitants pay in <span class="subst">$&#123;currency&#125;</span>.`</span></span><br><span class="line">    <span class="keyword">if</span>(contintent) msg += <span class="string">` The country is located in <span class="subst">$&#123;continent&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'Germany'</span>,</span><br><span class="line">    code: <span class="string">'DE'</span>,</span><br><span class="line">    language <span class="string">'german'</span>,</span><br><span class="line">    currency: <span class="string">'Euro'</span>,</span><br><span class="line">    population: <span class="string">'82 Million'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logCountry(&#123;</span><br><span class="line">    name: <span class="string">'China'</span>,</span><br><span class="line">    language <span class="string">'mandarin'</span>,</span><br><span class="line">    currency: <span class="string">'Renminbi'</span>,</span><br><span class="line">    population: <span class="string">'1.4 Billion'</span>,</span><br><span class="line">    continent: <span class="string">'Asia'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，有时您可能不想使用默认值，而是在未传递值时抛出错误。 然而，这通常是一个方便的技巧。</p><h3 id="数据稀缺性"><a href="#数据稀缺性" class="headerlink" title="数据稀缺性"></a>数据稀缺性</h3><p>前面的技巧引出了一个结论：最好不要传递您不需要的数据。同样，在设置函数时，这可能意味着更多的工作。但是，从长远来看，它肯定会为您提供更具可读性的代码库。确切地知道在特定位置使用哪些值是非常有价值的。</p><h3 id="行数和缩进限制"><a href="#行数和缩进限制" class="headerlink" title="行数和缩进限制"></a>行数和缩进限制</h3><p>我见过大文件 - 非常大的文件。实际上，超过3,000行代码。在这些文件中查找逻辑块是非常困难的。</p><p>因此，您应该将文件大小限制为一定数量的行。我倾向于将我的文件保存在100行代码之下。 有时候，很难分解文件，它们会增长到200-300行，在极少数情况下会增加到400行。</p><p>超过此临界值，意味着文件太杂乱，难以维护。随意创建新的模块和文件夹。您的项目应该看起来像一个森林，由树（模块部分）和分支（模块和模块文件组）组成。避免试图模仿阿尔卑斯山，在密闭区域堆积代码。</p><p>相比之下，你的实际文件应该看起来像Shire，这里和那里都有一些山丘（小水平的缩进），但一切都相对平坦。 尽量将压痕水平保持在四级以下。</p><p>也许为这些提示启用eslint规则是有帮助的！</p><h3 id="使用prettier"><a href="#使用prettier" class="headerlink" title="使用prettier"></a>使用prettier</h3><p>在团队中工作需要清晰的样式指南和格式。ESLint提供了一个巨大的规则集，您可以根据自己的需求进行自定义。还有 <code>eslint--fix</code>，它可以纠正一些错误，但不是全部。</p><p>相反，我建议使用<a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a>格式化代码。这样，开发人员不必担心代码格式化，而只需编写高质量的代码。 外观将一致并且格式自动化。</p><h3 id="使用有意义的变量名"><a href="#使用有意义的变量名" class="headerlink" title="使用有意义的变量名"></a>使用有意义的变量名</h3><p>理想情况下，应根据其内容命名变量。 以下是一些有助于您声明有意义的变量名称的指南。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数通常执行某种操作。为了解释这一点，人类使用动词 - 转换或显示，例如。在开头用动词命名函数是个好主意，例如<code>convertCurrency</code> 或 <code>displayUserName</code>。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>这些通常会包含一系列项目; 因此，将s附加到变量名称。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> students = [<span class="string">'Eddie'</span>, <span class="string">'Julia'</span>, <span class="string">'Nathan'</span>, <span class="string">'Theresa'</span>]</span><br></pre></td></tr></table></figure><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>简单地说就是尽量多接近于自然语言，这样好理解。你会问“这个人是教师吗？”→“是”或“否”。同样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isTeacher = <span class="literal">true</span> <span class="comment">// OR false</span></span><br></pre></td></tr></table></figure><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><p><code>forEach</code>, <code>map</code>, <code>reduce</code>, <code>filter</code>等是很好的原生JavaScript函数，用于处理数组和执行某些操作。 我看到很多人只是将<code>el</code> 或 <code>element</code>作为参数传递给回调函数。 虽然这很简单快捷，但您还应根据其值来命名。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cities = [<span class="string">'Berlin'</span>, <span class="string">'San Francisco'</span>, <span class="string">'Tel Aviv'</span>, <span class="string">'Seoul'</span>]</span><br><span class="line">cities.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">city</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>通常，您必须跟踪特定数据集和对象的ID。当嵌套id时，只需将其保留为id即可。在这里，我喜欢在将对象返回到前端之前将MongoDB <code>_id</code>映射到 <code>id</code>。从对象中提取<code>id</code>时，请预先添加对象的类型。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> studentId = student.id</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">id</span>: studentId &#125; = student <span class="comment">// destructuring with renaming</span></span><br></pre></td></tr></table></figure><p>该规则的一个例外是模型中的MongoDB引用。 在这里，只需在引用的模型之后命名字段即可。 这将在填充参考文档时保持清晰：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StudentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    teacher: &#123;</span><br><span class="line">        type: Schema.Types.ObjectId,</span><br><span class="line">        ref: <span class="string">'Teacher'</span>,</span><br><span class="line">        required: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="尽可能使用async-await"><a href="#尽可能使用async-await" class="headerlink" title="尽可能使用async / await"></a>尽可能使用async / await</h3><p>在可读性方面，回调是最糟糕的 - 特别是在嵌套时。Promises是一个很好的改进，但在我看来，async / await具有最好的可读性。即使对于初学者或来自其他语言的人来说，这也会有很大帮助。但是，请确保您了解其背后的概念，并且不要盲目地在任何地方使用它。</p><h3 id="模块导入顺序"><a href="#模块导入顺序" class="headerlink" title="模块导入顺序"></a>模块导入顺序</h3><p>正如我们在技巧1和2中看到的那样，将逻辑保持在正确的位置是可维护性的关键。 同样，导入不同模块的方式可以减少文件中的混淆。 我在导入不同模块时遵循一个简单的结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3rd party packages</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stores</span></span><br><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">'~/Store</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// reusable components</span></span><br><span class="line"><span class="string">import Button from '</span>~<span class="regexp">/components/</span>Button<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// utility functions</span></span><br><span class="line"><span class="string">import &#123; add, subtract &#125; from '</span>~<span class="regexp">/utils/</span>calculate<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// submodules</span></span><br><span class="line"><span class="string">import Intro from '</span>./Intro<span class="string">'</span></span><br><span class="line"><span class="string">import Selector from '</span>./Selector<span class="string">'</span></span><br></pre></td></tr></table></figure><p>我在这里使用了React组件作为示例，因为有更多类型的导入。 您应该能够根据您的具体用例进行调整。</p><h3 id="摆脱控制台"><a href="#摆脱控制台" class="headerlink" title="摆脱控制台"></a>摆脱控制台</h3><p><code>console.log</code> 是一种很好的调试方式 - 非常简单，快速，完成工作。显然，有更复杂的工具，但我认为每个开发人员仍然使用它。如果您忘记清理日志，您的控制台最终将陷入巨大的混乱。然后，您确实要在代码库中保留日志; 例如，警告和错误。</p><p>要解决此问题，您仍然可以使用<code>console.log</code> 进行调试，但对于持久日志，请使用<a href="https://www.npmjs.com/package/loglevel" target="_blank" rel="noopener">loglevel</a>或<a href="https://www.npmjs.com/package/winston" target="_blank" rel="noopener">winston</a>等库。此外，您可以使用ESLint警告控制台语句。这样你就可以轻松地全局查找<code>console...</code> 并删除这些语句。</p><p>遵循这些指导原则确实帮助我保持代码库的清洁和可扩展性。 你觉得还有什么提示特别有用的吗？请在评论中告诉我您在编码工作过程中值得推荐的内容，并请分享您用于帮助代码结构的任何其他提示！谢谢~</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript起源于早期的网络。 从作为脚本语言开始，到现在它已经发展成为一种完全成熟的编程语言，并且支持服务器端执行。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="编程技巧" scheme="https://luozongmin.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>由一段代码引发的关于Object和Function的鸡和蛋问题的思考</title>
    <link href="https://luozongmin.com/2019/06/01/%E7%94%B1%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EObject%E5%92%8CFunction%E7%9A%84%E9%B8%A1%E5%92%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://luozongmin.com/2019/06/01/由一段代码引发的关于Object和Function的鸡和蛋问题的思考/</id>
    <published>2019-06-01T10:06:56.785Z</published>
    <updated>2019-06-30T05:29:01.929Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。<a id="more"></a> </p><h3 id="鸡和蛋问题的由来"><a href="#鸡和蛋问题的由来" class="headerlink" title="鸡和蛋问题的由来"></a>鸡和蛋问题的由来</h3><p>首先<code>Object</code>和<code>Function</code>都是构造函数，而所有的构造函数都是<code>Function</code>的实例对象。 因此<code>Object</code>是<code>Function</code>的实例对象；而<code>Function.prototype</code>是<code>Object</code>的实例对象。所以这里就引伸出了一个有意思的鸡和蛋的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>那么<code>Object</code>和<code>Function</code>，谁是鸡谁是蛋呢？</p><p>接下来就来深入探究下上面这段代码所引起的鸡生蛋蛋生鸡问题，从下面这张原型/原型链经典图入手，在这个过程中深入了解 <code>Object.prototype</code>、<code>Function.prototype</code>、<code>function Object()</code> 、<code>function Function()</code> 之间的关系，这个过程可能有点烧脑，毕竟是JS的一大玄学嘛。</p><p><img src="/images/jidang-1.jpg" alt>  </p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>原型链的尽头就是<code>Object.prototype</code>（不考虑 <code>null</code> 的情况下）。<strong>所有对象均从</strong><code>Object.prototype</code><strong>继承toString() 等公共属性</strong>。</p><p><img src="/images/jidang-2.jpg" alt>   </p><p><code>Object.prototype</code> 表示 <code>Object</code> 的原型对象，实际上<code>Object.prototype</code> 并不是通过<code>Object</code>函数创建的，为什么呢？看如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'川普'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.__proto__ === Dog.prototype;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>实例对象的<code>__proto__</code>会指向构造函数的<code>prototype</code>，即<code>dog.__proto__</code>指向 <code>Dog.prototype</code>，但是<code>Object.prototype.__proto__</code>又是 <code>null</code>，所以 <code>Object.prototype</code> 并不是通过 <code>Object</code> 函数创建的，那它如何生成的？其实 <code>Object.prototype</code> 是浏览器底层根据 ECMAScript 规范创造的一个对象，所以在经典图里面只是看起来<code>Object.prototype</code> 是通过 <code>Object</code> 函数创建的，实际上并不是。</p><p><img src="/images/jidang-3.jpg" alt>  </p><h3 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h3><p><code>Function.prototype</code>和<code>Function.__proto__</code>为<strong>同一对象</strong>。</p><p><img src="/images/jidang-4.jpg" alt>  </p><p>这也意味着：<strong><code>Object</code>/<code>Array</code>等等构造函数本质上和<code>Function</code>一样，均继承于<code>Function.prototype</code>，从经典图上来看都是通过<code>new Function</code>构造出来的</strong>。</p><p>当然，<code>Function.prototype</code> 对象是一个函数（对象），其<code>__proto__</code>属性指向 <code>Object.prototype</code>，即<code>Function.prototype</code>会直接继承root（<code>Object.prototype</code>）。</p><p><img src="/images/jidang-5.jpg" alt> </p><p>通过这点我们可以弄清<strong>继承的原型链</strong>：<code>Function|Object|Array...---&gt;Function.prototype---&gt;Object.prototype(root)</code>。如下图所示：</p><p><img src="/images/jidang-6.jpg" alt> </p><h3 id="function-Object"><a href="#function-Object" class="headerlink" title="function Object()"></a>function Object()</h3><p><code>Object</code> 作为构造函数时，其<code>__proto__</code>属性指向 <code>Function.prototype</code>，即:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从经典图来看：</p><p><img src="/images/jidang-7.jpg" alt>   </p><p>使用 <code>new Object()</code> 创建实例对象o1时，实例对象o1的 <code>__proto__</code>属性指向构造函数的 <code>prototype</code> 属性，对应上图就是 <code>Object.prototype</code>，即<code>o1.__proto__ === Object.prototype</code>结果为<code>true</code>。</p><p><code>Function.prototype</code>指向的对象，它的<code>__proto__</code>会指向<code>Object.prototype</code>，因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。</p><h3 id="function-Function"><a href="#function-Function" class="headerlink" title="function Function()"></a>function Function()</h3><p><code>Function</code>也是一个函数对象，也有<code>__proto__</code>属性，既然是函数，那么它一定是被<code>Function</code>创建，所以<code>Function</code>是被自身创建的，所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/images/jidang-8.jpg" alt>  </p><p>到这里就有点烧脑了吧，我们再看下鸡生蛋蛋生鸡问题。</p><h3 id="Function-amp-Object-鸡和蛋问题"><a href="#Function-amp-Object-鸡和蛋问题" class="headerlink" title="Function &amp; Object 鸡和蛋问题"></a>Function &amp; Object 鸡和蛋问题</h3><p>由上面可知，<code>Object</code>构造函数继承了<code>Function.prototype</code>，同时<code>Function</code>构造函数继承了<code>Object.prototype</code>，这里就产生了<strong>鸡和蛋</strong>的问题。为什么会出现这种问题呢？必须首先更深入一层去理解<code>Function.prototype</code>这个对象，因为它是导致<code>Function instanceof Object</code>和<code>Object instanceof Function</code>都为<code>true</code>的原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object instanceof Function 即</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function instanceof Object 即</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object instanceof Object 即 </span></span><br><span class="line"><span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function instanceof Function 即</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据JS规范，<code>Function.prototype</code>又是个不同于一般函数（对象）的函数（对象），其中：</p><ol><li><code>Function.prototype</code>像普通函数一样可以调用，但总是返回<code>undefined</code>。</li><li>普通函数实际上是<code>Function</code>的实例，即普通函数继承于<code>Function.prototype</code>。即<code>func.__proto__ === Function.prototype</code>。</li><li><code>Function.prototype</code>继承于<code>Object.prototype</code>，并且没有<code>prototype</code>这个属性。</li><li>所以，<code>Function.prototype</code>其实是个另类的函数，可以独立于/先于<code>Function</code>产生。</li></ol><p>而<code>Object</code>本身是个（构造）函数，是<code>Function</code>的实例，即<code>Object.__proto__</code>就是<code>Function.prototype</code>。</p><p><strong>总结：先有<code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code>继承<code>Object.prototype</code>而产生，最后，<code>Function</code>和<code>Object</code>和其它构造函数继承<code>Function.prototype</code>而产生</strong>。</p><p>看到这里估计也都看烦了，是不是还是有点混乱呀？乱也很正常。那这篇文章就先让它乱着，下一篇我们将请另一个老朋友来帮忙，把它彻底理清楚，这位老朋友就是——<code>instanceof</code>，那就且听请下回分解咯。</p><p>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名前端开发者，我们都知道JS是单继承的，而Object.prototype是原型链的顶端，所有对象从它继承了包括toString()、valueOf()等等公共属性。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="Function" scheme="https://luozongmin.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>从原生JS实现jQuery的一个API中体会其设计思想</title>
    <link href="https://luozongmin.com/2019/05/31/%E4%BB%8E%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84%E4%B8%80%E4%B8%AAAPI%E4%B8%AD%E4%BD%93%E4%BC%9A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <id>https://luozongmin.com/2019/05/31/从原生JS实现jQuery的一个API中体会其设计思想/</id>
    <published>2019-05-31T14:16:34.767Z</published>
    <updated>2019-05-31T14:24:00.597Z</updated>
    
    <content type="html"><![CDATA[<p>根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？<a id="more"></a>读源代码又太繁琐，所以这里利用原生JS来实现jQuery中的addClass这个API，通过实现此过程来体会jQuery的设计思想，力求简单易懂。</p><h3 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">classes</span>)</span>&#123;&#125; <span class="comment">//可将所有输入的标签的class添加一个类</span></span><br></pre></td></tr></table></figure><h3 id="实现这个函数"><a href="#实现这个函数" class="headerlink" title="实现这个函数"></a>实现这个函数</h3><p>函数<code>addClass()</code>是输入一个类名，给选中的所有标签添加一个类，所以要用到<code>classList.add()</code>，具体实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">node, classes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">    allTag[i].classList.add(classes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在全局变量中创建一个对象，用来储存封装后的函数，这就是命名空间（名字前面统一加一个前缀）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = &#123;&#125;</span><br><span class="line">jQuery.addClass = addClass</span><br><span class="line"></span><br><span class="line">jQuery.addClass(<span class="string">'div'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>整理之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = &#123;&#125;</span><br><span class="line">jQuery.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">node, classes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">    allTag[i].classList.add(classes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.addClass(<span class="string">'div'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><h3 id="将node放到前面"><a href="#将node放到前面" class="headerlink" title="将node放到前面"></a>将node放到前面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.addClass(classes)</span><br></pre></td></tr></table></figure><p>方法一：扩展 Node 接口，直接在 <code>Node.prototype</code> 上加函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：新的接口 <code>BetterNode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    element: node,</span><br><span class="line">    addClass: <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> allTag = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allTag.length; i++) &#123;</span><br><span class="line">        allTag[i].classList.add(classes)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node2 = jQuery(<span class="string">'div'</span>)</span><br><span class="line">node2.addClass(<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>第二种叫做「无侵入」。</p><h3 id="进一步完善"><a href="#进一步完善" class="headerlink" title="进一步完善"></a>进一步完善</h3><p>给个缩写并且使其可以是节点或者选择器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodeOrSelector</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">      nodes[i]=temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeOrSelector <span class="keyword">instanceof</span> Node)&#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      <span class="number">0</span>:nodeOrSelector,</span><br><span class="line">      length:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class="line">      nodes[i].classList.add(classes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.$ = jQuery</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>)</span><br><span class="line">$div.addClass(<span class="string">'red'</span>) <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br></pre></td></tr></table></figure><h3 id="封装ajax"><a href="#封装ajax" class="headerlink" title="封装ajax"></a>封装ajax</h3><p>按照jQuery的设计思路封装一个ajax函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">url, method, body, success, fail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> request = XMLHttpResquest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                success.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                fail.call(<span class="literal">undefined</span>, request)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级改进一下满足promise规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    url,</span></span></span><br><span class="line"><span class="function"><span class="params">    method,</span></span></span><br><span class="line"><span class="function"><span class="params">    body,</span></span></span><br><span class="line"><span class="function"><span class="params">    headers</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> request = XMLHttpResquest()</span><br><span class="line">        request.open(method, url)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">            <span class="keyword">let</span> value = headers[key]</span><br><span class="line">            request.setRequestHeader(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    success.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                    fail.call(<span class="literal">undefined</span>, request)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.send(body)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据统计，全世界大约有80~90%的网站直接或间接地使用了jQuery，鉴于它如此流行，所以每一位前端工程师都应该了解和学习它。那如何才能快速理解jQuery呢？
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="https://luozongmin.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>DOM Node 的建立、删除与修改</title>
    <link href="https://luozongmin.com/2019/05/23/DOM%20Node%20%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9/"/>
    <id>https://luozongmin.com/2019/05/23/DOM Node 的建立、删除与修改/</id>
    <published>2019-05-23T10:16:51.699Z</published>
    <updated>2019-06-30T05:36:03.409Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的介绍中，我们已经理解了DOM Node的类型、以及节点之间的查找与关系。那么在今天的介绍里我将继续来说明，如何通过DOM API来建立新的节点、修改以及删除节点。<a id="more"></a></p><h3 id="DOM-节点的新增"><a href="#DOM-节点的新增" class="headerlink" title="DOM 节点的新增"></a>DOM 节点的新增</h3><h4 id="document-createElement-tagName"><a href="#document-createElement-tagName" class="headerlink" title="document.createElement(tagName)"></a>document.createElement(tagName)</h4><p>通过<code>document.createElement()</code>可以建立一个新的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure><p>在建立新的<code>div</code>元素<code>newDiv</code>后，这时候我们在浏览器上还看不到它，直到通过<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>等方法将新元素加入至指定的位置之后才会显示。</p><p>新建立的<code>newDiv</code>我们也可以同时对它指定属性，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newDiv.id = <span class="string">"myNewDiv"</span>; </span><br><span class="line">newDiv.className = <span class="string">"box"</span>;</span><br></pre></td></tr></table></figure><h4 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h4><p>之前曾介绍过，除了HTML元素节点外，还有文字节点，那么<code>document.createTextNode()</code>就是用来建立文字节点的方法。</p><p>用法很简单，直接在<code>document.createTextNode()</code>加入字符串即可。跟<code>createElement</code>一样的是，新增的TextNode在被加入至某个节点前，我们是看不到它的。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 textNode 文字节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 newDiv.appendChild 将 textNode 加入至 newDiv </span></span><br><span class="line">newDiv.appendChild(textNode);</span><br></pre></td></tr></table></figure><h4 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h4><p>在DOM规范的所有节点之中，<code>DocumentFragment</code>算是最特殊的一种，它是一种没有父层节点的<strong>最小化文件对象</strong>。可以把它看作是一个轻量化的<code>Document</code>，用如同标准文件一般的方式来保存片段的文件结构。</p><p>例如，一开始我们有一个HTML 的容器元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着我们通过<code>document.createDocumentFragment()</code>来建立<code>DocumentFragment</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得外层容器 myList</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立一个 DocumentFragment，可以把它看作一个虚拟的容器</span></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">  <span class="comment">// 生成新的 li，加入文字后置入 fragment 中。</span></span><br><span class="line">  <span class="keyword">let</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">  li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + (i+<span class="number">1</span>)));</span><br><span class="line">  fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后将组合完成的 fragment 放进 ul 容器</span></span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure><p>通过操作<code>DocumentFragment</code>与直接操作DOM最关键的区别在于<code>DocumentFragment</code>不是真实的DOM结构，所以说<code>DocumentFragment</code>的变动并不会影响目前的网页文件，也不会导致回流（reflow）或引起任何影响效果的情况发生。</p><h4 id="document-write"><a href="#document-write" class="headerlink" title="document.write()"></a>document.write()</h4><p><code>document</code>对象要将某内容写入网页也可以用<code>write()</code>方法，当浏览器读取页面，解析到<code>document.write()</code>的时候就会停下来，并且将内容输出，且不只是单纯的字符串，也可以是HTML的标签。</p><p>我们只要将对应的HTML 字符串传入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;Hello World!&lt;/h1&gt;"</span>);</span><br></pre></td></tr></table></figure><p>甚至，如果要新增一个<code>&lt;script&gt;</code>标签，并指定外部js资源也是可以的，但要注意的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写成这样， &lt;/script&gt;会变成目前 script 块的结束，导致错误 </span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;script type=\"text\javascript\" src=\"file.js\"&gt;"</span> + <span class="string">"&lt;/script&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免这种问题，要将结尾的标签这种写法 &lt;\/script&gt; 就 ok 了 </span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;script type=\"text\javascript\" src=\"file.js\"&gt;"</span> + <span class="string">"&lt;\/script&gt;"</span>);</span><br></pre></td></tr></table></figure><p>另外，需要特别注意的是，当网页已经读取完成后才执行<code>document.write()</code>，则里面的内容会完全覆盖掉目前的网页：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"Hello world!"</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面例子的<code>window.onload</code>表示网页已载入完成，此时无论网页原本有什么内容，都会被<code>&quot;Hello world!&quot;</code>所覆盖。  </p><h3 id="DOM-节点的修改与删除"><a href="#DOM-节点的修改与删除" class="headerlink" title="DOM 节点的修改与删除"></a>DOM 节点的修改与删除</h3><p>上面介绍了很多建立DOM节点的方法，除了最后的<code>document.write</code>之外，其他都只是单纯建立节点，并未输出至网页上。</p><p>那么，接下来要介绍的几个方法，则说明要如何将刚刚建立好的DOM 节点，置入到我们所需要指定的位置上。</p><h4 id="NODE-appendChild-childNode"><a href="#NODE-appendChild-childNode" class="headerlink" title="NODE.appendChild(childNode)"></a>NODE.appendChild(childNode)</h4><p><img src="/images/domnode-1.jpg" alt>  </p><p>通过<code>appendChild()</code>方法，可以将指定的<code>childNode</code>节点，加入到<code>Node</code>父容器节点的末端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 取得容器</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 建立新的 &lt;li&gt; 元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> newList = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 建立 textNode 文字节点</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 通过 appendChild 将 textNode 加入至 newList</span></span></span><br><span class="line"><span class="undefined">  newList.appendChild(textNode);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 通过 appendChild 将 newList 加入至 myList</span></span></span><br><span class="line"><span class="undefined">  myList.appendChild(newList);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="NODE-insertBefore-newNode-refNode"><a href="#NODE-insertBefore-newNode-refNode" class="headerlink" title="NODE.insertBefore(newNode, refNode)"></a>NODE.insertBefore(newNode, refNode)</h4><p><img src="/images/domnode-2.jpg" alt>  </p><p><code>insertBefore()</code>方法，则是将新节点<code>newNode</code>插入至指定的<code>refNode</code>节点的前面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 取得容器</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> myList  = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 取得 "<span class="tag">&lt;<span class="name">li</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span>" 的元素</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> refNode = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 建立 li 元素节点</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> newNode = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 建立 textNode 文字节点</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</span></span><br><span class="line"><span class="undefined">  newNode.appendChild(textNode);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 将新节点 newNode 插入 refNode 的前方</span></span></span><br><span class="line"><span class="undefined">  myList.insertBefore(newNode, refNode);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="NODE-replaceChild-newChildNode-oldChildNode"><a href="#NODE-replaceChild-newChildNode-oldChildNode" class="headerlink" title="NODE.replaceChild(newChildNode, oldChildNode)"></a>NODE.replaceChild(newChildNode, oldChildNode)</h4><p><img src="/images/domnode-3.jpg" alt>  </p><p><code>replaceChild()</code>方法，则是将原本的<code>oldNode</code>替换成指定的<code>newNode</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 取得容器</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> myList  = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 取得 "<span class="tag">&lt;<span class="name">li</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span>" 的元素</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> oldNode = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 建立 li 元素节点</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> newNode = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 建立 textNode 文字节点</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</span></span><br><span class="line"><span class="undefined">  newNode.appendChild(textNode);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 将原有的 oldNode 替换成新节点 newNode</span></span></span><br><span class="line"><span class="undefined">  myList.replaceChild(newNode, oldNode);</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br></pre></td></tr></table></figure><h4 id="NODE-removeChild-childNode"><a href="#NODE-removeChild-childNode" class="headerlink" title="NODE.removeChild(childNode)"></a>NODE.removeChild(childNode)</h4><p><img src="/images/domnode-4.jpg" alt>  </p><p><code>removeChild()</code>方法，则是将指定的<code>childNode</code>子节点移除。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 取得容器</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> myList  = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 取得 "<span class="tag">&lt;<span class="name">li</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span>" 的元素</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> removeNode = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)[<span class="number">1</span>];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 将 myList 下的 removeNode 节点移除</span></span></span><br><span class="line"><span class="undefined">  myList.removeChild(removeNode);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相信看完今天的分享，已经有能力可以通过DOM 提供的API 来进行节点的新增、修改以及删除了吧。</p><p>大家也许会发现，无论要对网页元素做出什么样的操作，我们都会基于某个节点出发对吧？</p><p>刚好呼应阿基米德的一句众所周知的名言：</p><blockquote><p>「给我一个支点，我就能撬动整个地球。」</p></blockquote><p>那么有了DOM API 的帮助后， JavaScript 也可以说：</p><blockquote><p>「给我一个节点，我就能建立整个网页世界。」</p></blockquote><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的介绍中，我们已经理解了DOM Node的类型、以及节点之间的查找与关系。那么在今天的介绍里我将继续来说明，如何通过DOM API来建立新的节点、修改以及删除节点。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://luozongmin.com/tags/DOM/"/>
    
      <category term="API" scheme="https://luozongmin.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>通过DOM API 查找节点</title>
    <link href="https://luozongmin.com/2019/05/23/%E9%80%9A%E8%BF%87DOM%20API%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9/"/>
    <id>https://luozongmin.com/2019/05/23/通过DOM API 查找节点/</id>
    <published>2019-05-23T05:59:30.325Z</published>
    <updated>2019-06-30T05:41:37.163Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇的分享当中，我们简单介绍了BOM 与DOM，也了解到JavaScript 是怎么通过它们提供的方法来与浏览器进行沟通。<a id="more"></a></p><p>当一个网页被载入到浏览器时，浏览器会首先分析这个HTML 文档，然后会依照这份HTML 的内容解析成DOM (Document Object Model，即文件对象模型)。</p><p>而DOM 是W3C 制定的一个规范，它是独立于平台与语言的标准。换言之，只要遵守这样的规范，不管是什么平台或者是什么语言开发，都可以通过DOM 提供的API 来操作DOM 的内容、结构与样式。</p><p>所以说，DOM 是网页的根本，懂得<strong>控制DOM就可以控制整个网页，做出良好的互动体验</strong>。</p><p>那么在今天的分享中，我们就继续来介绍DOM API 查找节点的方法吧。</p><h3 id="前言-script标签放哪里有区别吗？"><a href="#前言-script标签放哪里有区别吗？" class="headerlink" title="前言:script标签放哪里有区别吗？"></a>前言:script标签放哪里有区别吗？</h3><p>针对<code>&lt;script&gt;</code>标签放哪里，这个题目其实没有标准答案，一般你会看到有两种版本：</p><ul><li>放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间</li><li>放在<code>&lt;/body&gt;</code>之前</li></ul><p>还有人会说为什么放在<code>&lt;head&gt; ... &lt;/head&gt;</code>里面的JavaScript没有作用？我觉得这说的有出入，这里我们简单来讲一下问题所在。</p><p>那么我们来试试上一篇介绍过的，先以<code>document.querySelector</code>取得<code>id=&quot;hello&quot;</code>的节点，然后通过<code>textContent</code>来修改内容。</p><p>先来试试把<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>之前。在jsbin里面马上执行看看，看起来似乎很ok呢！</p><p><img src="/images/domapi-1.jpg" alt>    </p><p>接着，我们试着把<code>&lt;script&gt;</code>标签移到<code>&lt;head&gt; ... &lt;/head&gt;</code>之间：</p><p><img src="/images/domapi-2.jpg" alt>    </p><p>咦？怎么什么都没有呢？而且也没有错误信息，JavaScript真的如大家说的一样，很垃圾吗？</p><p><img src="/images/domapi-3.jpg" alt>   </p><p>冷静一下，容我解释一下。</p><p>前面说过，当一个网页被载入到浏览器时，浏览器会先分析这个HTML 文档，由上而下依序来读取解析：</p><p><img src="/images/domapi-4.jpg" alt>   </p><p>所以上面jsbin例子中，当浏览器在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间遇到<code>&lt;script&gt;</code>标签时，就会暂停解析网页，并且<strong>立即</strong>执行<code>&lt;script&gt;</code>里的内容，直到script执行完毕后再继续解析网页。</p><p>当<code>&lt;head&gt; ... &lt;/head&gt;</code>里的<code>&lt;script&gt;</code>想要尝试去寻找<code>&lt;div id=&quot;hello&quot;&gt;</code>这个标签，但因为还没解析到网页本体，所以也无从取得。</p><p>不是浏览器坏掉，也不是JavaScript太渣，而是因为我们<strong>不理解浏览器执行的原理所造成的误会</strong>。</p><p>这里是浏览器加载一个有 <code>&lt;script&gt;</code> 标签的网站所发生的事情:</p><ol><li>拉取 HTML 页面</li><li>开始解析 HTML</li><li>解析到 <code>&lt;script&gt;</code> 标签之后准备获取 script 文件.</li><li>浏览器获取script文件。同时，html 解析中断并且<strong>阻断</strong>页面上其他html的解析。</li><li>一段时间后，script下载完成并且<strong>执行</strong>。</li><li>继续解析HTML文档的其他部分（解析script之后的html代码）</li></ol><p>第4步导致了很不好的用户体验，直到script文件全部下载完成之前HTML都不能得到解析。</p><p>那么，当我们把<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>结束之前，由于DOM已经解析完成，所以<code>document.querySelector</code>就可以顺利取得<code>id=&quot;hello&quot;</code>的节点，并且把<code>&#39;HELLO&#39;</code>的字串放在网页里啦！</p><p>这样说起来，<code>&lt;script&gt;</code>标签是不是就不适合放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间呢？</p><p>也不能这么说，这点认真要讲的话之后或许可以用一整篇来说明这个。</p><h3 id="DOM-节点的选取"><a href="#DOM-节点的选取" class="headerlink" title="DOM 节点的选取"></a>DOM 节点的选取</h3><p><img src="/images/domapi-5.jpg" alt>  </p><p>上一篇文章说过，<code>document对象</code>是DOM tree的根节点，所以当我们要存取HTML时，都从<code>document</code>对象开始。而DOM的节点类型除了<strong>HTML元素节点</strong>(element nodes)外，还有<strong>文字节点</strong>(text nodes)、<strong>注释节点</strong>(comment nodes)等。</p><p>而常见的DOM 选取方法有下列这些：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的值，找到 DOM 中 id 为 'xxx' 的元素。</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 class 名称，返回所有符合条件的节点集合</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的节点集合</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'xxx'</span>); </span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure><h3 id="DOM-节点的类型"><a href="#DOM-节点的类型" class="headerlink" title="DOM 节点的类型"></a>DOM 节点的类型</h3><p>DOM 常用的节点类型有下面几种：</p><p><img src="/images/domapi-6.jpg" alt>  </p><p>可以通过节点类型常数或是对应数值来判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType === Node.DOCUMENT_NODE;   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">document</span>.nodeType === <span class="number">9</span>;   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>其他不常用或是已经废弃的部分可以参考：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType" target="_blank" rel="noopener">MDN Node.nodeType</a>一节。</p><h3 id="DOM-节点间的查找遍历-Traversing"><a href="#DOM-节点间的查找遍历-Traversing" class="headerlink" title="DOM 节点间的查找遍历(Traversing)"></a>DOM 节点间的查找遍历(Traversing)</h3><p>由于DOM 节点有分层的概念，于是节点与节点之间的关系，我们大致上可以分成以下两种：</p><ul><li><strong>父子关系</strong>：除了<code>document</code>之外，每一个节点都会有个上层的节点，我们通常称之为「父节点」 (Parent node)，而相对地，从属于自己下层的节点，就会称为「子节点」 (Child node)。</li><li><strong>兄弟关系</strong>：有同一个「父节点」的节点，那么他们彼此之间就是「兄弟节点」(Siblings node)。</li></ul><p>而隔层的节点基本上没有直接关系。</p><p><img src="/images/domapi-7.jpg" alt>  </p><p>上图中水平方向的邻层节点为父子关系，垂直方向的同层节点为兄弟关系。</p><p><strong>Node.childNodes</strong></p><p>所有的DOM节点对象都有<code>childNodes</code>属性，且此种属性无法修改。  </p><p>我们可以通过<code>Node.hasChildNodes()</code>来检查某个DOM节点是否有子节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'#hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 node 內有子元素</span></span><br><span class="line"><span class="keyword">if</span>( node.hasChildNodes() ) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以通过 node.childNodes[n] (n 为数字索引) 取得对应的节点</span></span><br><span class="line">    <span class="comment">// 注意，NodeList 对象內容为即时更新的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; node.childNodes[i].length; i++) &#123;</span><br><span class="line">       <span class="comment">// ...     </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node.childNodes</code>返回的可能会有这几种：</p><ul><li>HTML 元素节点(element nodes)</li><li>文字节点(text nodes)，包含空格</li><li>注释节点(comment nodes)</li></ul><p><strong>Node.firstChild</strong></p><p><code>Node.firstChild</code>可以取得<code>Node</code>节点的<strong>第一个</strong>子节点，如果没有子节点则返回<code>null</code>。</p><p>要注意的是，子节点包括空白节点，如下面例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// tagName 属性可以取得 node 的标签名称</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.firstChild.tagName);      <span class="comment">// undefined</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为取得的是<code>&lt;p&gt;</code>与第一个<code>&lt;span&gt;</code>中间的换行字元，所以<code>p.firstChild.tagName</code>会得到<code>undefined</code>。所以改成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// tagName 属性可以取得 node 的标签名称</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.firstChild.tagName);      <span class="comment">// "SPAN"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把中间的换行与空白移除，就会得到预期中的<code>&quot;SPAN&quot;</code>了。</p><p><strong>Node.lastChild</strong></p><p><code>Node.lastChild</code>可以取得<code>Node</code>节点的最后一个子节点，如果没有子节点则返回<code>null</code>。</p><p>与<code>Node.firstChild</code>一样的是，子节点也包括空白节点，所以像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// textContent 属性可以取得节点内的文字内容</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.lastChild.textContent);      <span class="comment">// "" (换行字元)</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到的会是一个换行字元的空字符串。</p><p>移除节点之间多余的空白后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);    </span></span><br><span class="line"><span class="javascript">  <span class="comment">// textContent 属性可以取得节点内的文字内容</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.lastChild.textContent);      <span class="comment">// "span 3"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出的就会是正确的”span 3” 啦。</p><p><strong>Node.parentNode</strong></p><p>那么相较于Child系列，<code>parentNode</code>就单纯一些。</p><p>通过<code>Node.parentNode</code>可以用来取得父元素，返回值可能会是一个元素节点(Element node)、根节点(Document node)或DocumentFragment节点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'span'</span>);   </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el.parentNode.nodeName );    <span class="comment">// "P"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Node.previousSibling</strong></p><p>看完了DOM父与子之后，接着来看看兄弟节点。</p><p>通过<code>Node.previousSibling</code>可以取得同层之间的前一个节点，如果node已经是第一个节点且前面无节点，则返回<code>null</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'span'</span>);   </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el.previousSibling );    <span class="comment">// null</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// document.querySelectorAll 会取得所有符合条件的集合，</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 而 document.querySelectorAll('span')[2] 指的是「第三个」符合条件的元素。</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span'</span>)[<span class="number">2</span>];   </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el2.previousSibling.textContent );    <span class="comment">// "span 2"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Node.nextSibling</strong></p><p>与<code>Node.previousSibling</code>类似，通过<code>Node.nextSibling</code>可以取得同层之间的下一个节点，如果node已经是最后一个节点，则返回<code>null</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// document.querySelector 会取得第一个符合条件的元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'span'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log( el.nextSibling.textContent );    <span class="comment">// "span 2"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>document.getElementsBy*与document.querySelector/ document.querySelectorAll的差异</strong></p><p>今天分享了很多关于DOM的选取以及查找遍历的方式，其中，像是<code>document.getElementById</code>以及<code>document.querySelector</code>因为取得的一定只会有一个元素/节点，所以不会有<code>index</code>与<code>length</code>属性。</p><p>而<code>document.getElementsBy**</code>(注意，这里有个s)以及<code>document.querySelectorAll</code>则分别返回HTMLCollection与NodeList。</p><p>这两者其实是有点差别的，HTMLCollection只收集HTML element 节点，而NodeList除了HTML element 节点，也包含文字节点、属性节点等。当然两者也有类似的地方，虽然不能使用数组的method，但这两种都可以用数组索引的方式来存取内容，也就是伪数组。</p><p>另一个需要注意的地方是，HTMLCollection/NodeList在大部分情况下是<strong>即时更新</strong>的，但通过<code>document.querySelector</code>/<code>document.querySelectorAll</code>取得的NodeList是<strong>静态</strong>的。</p><p>啥意思呢？举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> outerDiv = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 所有的 &lt;div&gt; 标签</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> allDivs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);    </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 2</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 清空 <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span> 下的节点   </span></span><br><span class="line"><span class="javascript">  outerDiv.innerHTML = <span class="string">''</span>;    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 因为清空了<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span> 下的节点，所以只剩下 outer</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 1</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果改成<code>document.querySelector</code>的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> outerDiv = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 所有的 &lt;div&gt; 标签</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> allDivs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 2</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">  // 清空 <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span> 下的节点   </span></span><br><span class="line"><span class="javascript">  outerDiv.innerHTML = <span class="string">''</span>;    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// document.querySelector 返回的是静态的 NodeList，不受 outerDiv 更新影响</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(allDivs.length);    <span class="comment">// 2</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么以上就是今天所要介绍的内容啦。</p><p>在后续的文章会再继续说明DOM API新增/删除/修改节点的部分，欢迎持续关注。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇的分享当中，我们简单介绍了BOM 与DOM，也了解到JavaScript 是怎么通过它们提供的方法来与浏览器进行沟通。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://luozongmin.com/tags/DOM/"/>
    
      <category term="API" scheme="https://luozongmin.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>谈谈浏览器里的JavaScript</title>
    <link href="https://luozongmin.com/2019/05/21/%E8%81%8A%E4%B8%80%E8%81%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%9A%84JavaScript/"/>
    <id>https://luozongmin.com/2019/05/21/聊一聊浏览器里的JavaScript/</id>
    <published>2019-05-21T02:39:02.534Z</published>
    <updated>2019-06-30T05:49:26.930Z</updated>
    
    <content type="html"><![CDATA[<p>在许多的网页前端教学或是文章书籍当中，你可能常常听到这样的说法：「HTML、CSS 与JavaScript 是网页前端三大要素」<a id="more"></a>，其中： </p><ul><li>HTML 负责资料与结构</li><li>CSS 负责样式与呈现</li><li>JavaScript 负责行为与互动</li></ul><p><img src="/images/dom-1.jpg" alt>   </p><p>那么，如果你跟我在学JavaScript的时候也有一样的疑问：<strong>变量、类型、对象、流程控制、函数</strong>…表面上看似基础都学会了，但…  </p><p><strong>我还是不知道怎么通过JavaScript在网页上输出”Hello World!”啊！</strong>   </p><p><img src="/images/dom-2.png" alt>   </p><p>那么相信看完今天的分享，我保证你一定可以通过JavaScript 在网页上输出”Hello World!” (嘻嘻)  </p><h3 id="浏览器里的JavaScript"><a href="#浏览器里的JavaScript" class="headerlink" title="浏览器里的JavaScript"></a>浏览器里的JavaScript</h3><p>严格来说，JavaScript (或者说ECMAScript 标准) 并没有提供网页的操作方法。  </p><p>事实上，前端开发者在网页的操作方法都是由JavaScript的执行平台，也就是<strong>浏览器</strong>提供的。这些操作方法基本上会分别由这两种对象所拥有：BOM与DOM。  </p><p>所以广泛来说，在浏览器上的JavaScript 实际上包含了以下三部分：  </p><ul><li><strong>JavaScript核心</strong> (以ECMAScript标准为基础)</li><li><strong>BOM</strong> (Browser Object Model，浏览器对象模型)</li><li><strong>DOM</strong> (Document Object Model，文件对象模型)  </li></ul><p>由于BOM与DOM是由浏览器执行环境所提供；所以换句话说，在node环境下的JavaScript就不会有这两个部分。  </p><p>前端开发者就是可以通过JavaScript 去调用BOM 与DOM 提供的API，进一步通过它们去控制浏览器的行为与网页的内容。  </p><p>那么接下来就来具体介绍一下BOM与DOM吧。  </p><h3 id="BOM-是什么"><a href="#BOM-是什么" class="headerlink" title="BOM 是什么?"></a>BOM 是什么?</h3><p><strong>BOM</strong>(<strong>Browser Object Model</strong>，浏览器对象模型)，是浏览器所有功能的核心，与网页的内容无关。  </p><p>在早期没有制定标准规范的时候，各家浏览器厂商几乎在自家浏览器上都有各自的功能，非常混乱。直到后来W3C 把各家浏览器都有的部分，以及确定已经(或未来会) 加入的功能，统一集合起来纳入了HTML5 的标准中，这也就是我们现在看到的BOM API。  </p><p>BOM 有时也有人非正式地称它为Level 0 DOM。因为它在DOM level 1 标准前就已存在，而不是真的有文件去规范这些，所以Level 0 DOM与BOM两者实际上指的是同一个东西。</p><h3 id="BOM的核心window对象"><a href="#BOM的核心window对象" class="headerlink" title="BOM的核心window对象"></a>BOM的核心window对象</h3><p><img src="/images/dom-3.jpg" alt>   </p><p>从上图可以看出BOM的核心是<code>window</code>对象。 </p><p>而<code>window</code>对象提供的属性主要为<code>document</code>、<code>location</code>、<code>navigator</code>、<code>screen</code>、<code>history</code>以及<code>frames</code>。  </p><p>在浏览器里的<code>window</code>对象会扮演着两种角色：  </p><ul><li>ECMAScript 标准里的<strong>全局对象</strong> (Global Object)</li><li>JavaScript 用来与浏览器沟通的窗口</li></ul><p>凡是<strong>在全局作用域内声明的变量、对象、函数等，都会自动变成全局对象的属性</strong>。通常这样的变量，我们会称它们叫做<strong>全局变量</strong>，可以通过window.xxx的方式取得它们。比如：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>除此之外，在全局作用域内声明的全局变量还有一个特性，就是无法使用<code>delete</code>关键字来移除： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.a);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>但若是直接通过指定<code>window</code>对象的属性则可以：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.a);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>现在我们已经知道了全局对象是怎么回事了，那么<code>window</code>对象扮演的另一个角色，<strong>用来与浏览器沟通的窗口</strong>又是什么意思呢？  </p><h3 id="浏览器内建的对话框"><a href="#浏览器内建的对话框" class="headerlink" title="浏览器内建的对话框"></a>浏览器内建的对话框</h3><p>先来个最常见的例子：alert()警告对话框：  </p><p><img src="/images/dom-4.jpg" alt>   </p><p>(alert on Chrome)</p><p>我想不管是不是刚接触JavaScript的朋友，对<code>alert</code>应该都不陌生，<code>alert</code>的完整语法其实是这样：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">"message"</span>);</span><br></pre></td></tr></table></figure><p>如同我们所熟知的全局变量一样，<code>window</code>对象下的成员，<code>window</code>是可以省略不打的。  </p><p>一行代码就可以生成一个对话框，很神奇吧？  </p><p>而这就是浏览器环境的BOM提供给JavaScript控制的功能之一。  </p><p>类似的对话框还有用来提供<strong>确定/取消</strong>的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm" target="_blank" rel="noopener">window.confirm()</a>，以及开放式问答的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt" target="_blank" rel="noopener">window.prompt()</a>对话框。  </p><p>当然BOM 提供的API 很多，包含开启/关闭视窗，改变视窗大小，计时器与取得网址等等。这些在之后的文章当中还会再细说。  </p><h3 id="DOM-是什么"><a href="#DOM-是什么" class="headerlink" title="DOM 是什么?"></a>DOM 是什么?</h3><p><strong>DOM</strong>(<strong>Document Object Model</strong>，文件对象模型)，是一个将HTML文件以树状的结构来表示的模型，而组合起来的树状图，我们称之为DOM Tree。 </p><p>简单来说，我们把HTML每个节点的关系连接起来倒着看，就好像是一棵树一样。假设我们有一个基本的HTML如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;米淇淋的个人博客&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;这是主题&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;这是一个&lt;i&gt;简单&lt;/i</span>&gt;的段落&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/domapi-5.jpg" alt>  </p><p>在最根部的地方，就是<code>document</code>，就是BOM图中<code>window</code>下面的那个。</p><p>往下可以延伸出一个个的HTML 标签，一个节点就是一个标签，往下又可以再延伸出文本节点与属性的节点。</p><p>而DOM API 就是定义了让JavaScript 可以存取、改变HTML 结构、样式和内容的方法，甚至是对节点绑定的事件。</p><p>JavaScript 就是通过DOM 提供的API 来对HTML 做存取与操作。 </p><h3 id="DOM-与-BOM-的区别"><a href="#DOM-与-BOM-的区别" class="headerlink" title="DOM 与 BOM 的区别"></a>DOM 与 BOM 的区别</h3><p>前面介绍BOM时，我们已经知道DOM的<code>document</code>其实也就是<code>window</code>对象的子对象之一。 </p><p>而 DOM 与 BOM 最大的区别在于：</p><ul><li>BOM: JavaScript 与<strong>浏览器</strong>沟通的窗口，不涉及网页内容。</li><li>DOM: JavaScript 用来控制<strong>网页</strong>的节点与内容的标准。</li></ul><p>BOM完全依赖于浏览器厂商实作本身无标准规范，而DOM有着W3C 所制定的标准来规范。</p><p>想要通过DOM API 取得节点，JavaScript 可以这样写： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的值，找到 DOM 中 id 为 'xxx' 的元素。</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 tag 名称，返回所有符合条件的 NodeList 对象(节点的集合)</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 class 名称，返回所有符合条件的 NodeList 对象。</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对给定的 Selector 条件，返回第一个 或 所有符合条件的 NodeList。</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'xxx'</span>); </span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure><p>而透过DOM API选取出来的节点，我们可以通过操作<code>textContent</code>属性来变更它的文字。</p><p>假设有一个HTML 节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"greet"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再来我们就可以先通过<code>document.querySelector()</code>方法来取得节点，然后修改<code>textContent</code>属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'#greet'</span>).textContent = <span class="string">'Hello World!'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/fuhurapivu/embed?html,js,output" target="_blank" rel="noopener">JS Bin on jsbin.com</a></p><p>看到这里，恭喜你已经可以通过JavaScript 在网页上输出”Hello World!” 啦！</p><p>在后续的内容中，我们会继续来介绍各种操作网页的DOM/BOM API。</p><p>毕竟对前端工程师来说，搞懂<strong>怎么与浏览器打交道、怎么操作网页内容</strong>，就是做好WebUI最重要的基础。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在许多的网页前端教学或是文章书籍当中，你可能常常听到这样的说法：「HTML、CSS 与JavaScript 是网页前端三大要素」
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://luozongmin.com/tags/DOM/"/>
    
      <category term="BOM" scheme="https://luozongmin.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数组常见遍历方法</title>
    <link href="https://luozongmin.com/2019/05/14/%E6%B5%85%E8%B0%88%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <id>https://luozongmin.com/2019/05/14/浅谈数组常见遍历方法/</id>
    <published>2019-05-14T10:45:13.927Z</published>
    <updated>2019-06-30T06:05:34.127Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍数组常见的遍历方法：forEach、map、filter、find、every、some、reduce，它们都有个共同点：不会改变原始数组。<a id="more"></a>   </p><p><img src="/images/shuzu-1.png" alt>   </p><p>接下来都是使用底下的基础数组来实现一些方法：  </p><ul><li>累加</li><li>比大小</li><li>分别运算</li><li>查找特定值等  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'马云'</span>,</span><br><span class="line">    money: <span class="number">2000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'马化腾'</span>,</span><br><span class="line">    money: <span class="number">1800</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'李彦宏'</span>,</span><br><span class="line">    money: <span class="number">1500</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'我'</span>,</span><br><span class="line">    money: <span class="literal">Infinity</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="forEach：遍历数组"><a href="#forEach：遍历数组" class="headerlink" title="forEach：遍历数组"></a>forEach：遍历数组</h3><p>forEach与另外几种方法有些许不同，就是除了forEach以外的几个方法都会返回值，如果在等号的左方放一个变量，那么此变量返回值将会是<code>undefined</code>(没有返回任何值)。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forEachLoop = people.forEach( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span> .log(item, index, array); <span class="comment">//（对象,索引,全部数组）</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(forEachLoop); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>其它的方法都会返回一个值或数组，以此来说就会传回原本的数组值。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapLoop = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapLoop); <span class="comment">//与原本数组资料相同</span></span><br></pre></td></tr></table></figure><h3 id="map：一一映射另一个数组"><a href="#map：一一映射另一个数组" class="headerlink" title="map：一一映射另一个数组"></a>map：一一映射另一个数组</h3><p>map会return返回的对象、值，作用上是用来处理数组返回新值产生一个新数组，要特别注意返回的值数量与原始数组长度相同，所以如果不给return，默认返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有给return 也会产生undefined</span></span><br><span class="line"><span class="keyword">var</span> mapEmpty = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapEmpty);     <span class="comment">// [undefined, undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> everyoneAdd = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line">  item.money = item.money + <span class="number">500</span> ; <span class="comment">//每个money + 500</span></span><br><span class="line">  <span class="keyword">return</span> item;              <span class="comment">//返回对象</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(everyoneAdd);   <span class="comment">// 返回每个处理后的数值，不过记得这是传参考特性，会影响到原始的对象</span></span><br><span class="line"><span class="comment">// &#123;name: "马云", money: 2500&#125;</span></span><br><span class="line"><span class="comment">// &#123;name: "马化腾", money: 2300&#125;</span></span><br><span class="line"><span class="comment">// &#123;name: "李彦宏", money: 2000&#125;</span></span><br><span class="line"><span class="comment">// &#123;name: "我", money: Infinity&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapMoneyThan1500 = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 错误示范，长度不符合时</span></span><br><span class="line"> <span class="keyword">if</span> (item.money &gt; <span class="number">1500</span> ) &#123;</span><br><span class="line"> <span class="keyword">return</span> item;               <span class="comment">//取得大于1500</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapMoneyThan1500);</span><br><span class="line"><span class="comment">// [&#123;name: "马云", money: 2000&#125;, &#123;name: "马化腾", money: 1800&#125;, undefined, &#123;name: "我", money: Infinity&#125; ]</span></span><br></pre></td></tr></table></figure><h3 id="filter：过滤掉数组中符合条件的元素"><a href="#filter：过滤掉数组中符合条件的元素" class="headerlink" title="filter：过滤掉数组中符合条件的元素"></a>filter：过滤掉数组中符合条件的元素</h3><p>filter() 检测数值元素，并返回符合条件所有元素的数组。 filter() 不会改变原始数组。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">var</span> filterEmpty = people.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(filterEmpty);    <span class="comment">// 没有给条件，会是一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterMoneyThan1500 = people.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1500</span>;       <span class="comment">// 取得大于1500</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(filterMoneyThan1500); <span class="comment">// 马云，马化腾，我 这三个对象</span></span><br></pre></td></tr></table></figure><h3 id="find：返回符合条件的数组的第一个元素的值"><a href="#find：返回符合条件的数组的第一个元素的值" class="headerlink" title="find：返回符合条件的数组的第一个元素的值"></a>find：返回符合条件的数组的第一个元素的值</h3><p>find是用来查找数组中符合条件的对象，且<strong>仅能有一个</strong>，当返回的<code>true</code>数量超过两个以上时，那会以第一个为优先，通常会用来查找特定 id。如果没有符合条件的对象，则返回<code>undefined</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findEmpty = people.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(findEmpty);          <span class="comment">// 没有条件，会是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findMoneyThan1500 = people.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1500</span>;      <span class="comment">// 取得大于1500</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(findMoneyThan1500);  <span class="comment">// 虽然满足条件的有3个，但只会返回 '马云' 这一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findMe = people.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.name === <span class="string">'我'</span>;    <span class="comment">// 找到我</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(findMe);            <span class="comment">// 我 这一对象</span></span><br></pre></td></tr></table></figure><h3 id="every：验证数组中是否每个元素都满足指定的条件"><a href="#every：验证数组中是否每个元素都满足指定的条件" class="headerlink" title="every：验证数组中是否每个元素都满足指定的条件"></a>every：验证数组中是否每个元素都满足指定的条件</h3><p>验证全部的结果，当全部的值都为 <code>true</code> 时，则最终会得到 <code>true</code>；只要其中之一为 <code>false</code>，则返回 <code>false</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ans = people.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1800</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans); <span class="comment">// false: 只要有部分不符合，则为 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans2 = people.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">500</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans2); <span class="comment">// true: 大家钱都超过 500</span></span><br></pre></td></tr></table></figure><h3 id="some：验证数组中是否有元素满足指定的条件"><a href="#some：验证数组中是否有元素满足指定的条件" class="headerlink" title="some：验证数组中是否有元素满足指定的条件"></a>some：验证数组中是否有元素满足指定的条件</h3><p>与前者类似，但只要部分为 <code>true</code>，则返回 <code>true</code>；全部为 <code>false</code> 时返回值才会为 <code>false</code>。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ans = people.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &gt; <span class="number">1800</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans); <span class="comment">// true: 只要有部分符合，则为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans2 = people.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.money &lt; <span class="number">500</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ans2); <span class="comment">// false: 大家钱都不少于 500</span></span><br></pre></td></tr></table></figure><h3 id="reduce：将数组合成一个值"><a href="#reduce：将数组合成一个值" class="headerlink" title="reduce：将数组合成一个值"></a>reduce：将数组合成一个值</h3><p>reduce是其中最为特殊的，首先他返回的参数与之前的不同，它会接收到前一个返回的值供下一个对象使用，很适合用在累加与对比上，返回的可以是数字也可以是数组。</p><ul><li>accumulator: 前一个参数，如果是第一个数组的话，值是以另外传入或初始化的值</li><li>currentValue: 当前值</li><li>currentIndex: 当前索引</li><li>array: 全部数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceEmpty = people.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(reduceEmpty);                 <span class="comment">// 沒有条件，会是 undefined</span></span><br></pre></td></tr></table></figure><p>可以通过与前一个相加的方式，累加数组中所有的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">people.pop(); <span class="comment">// 我的钱深不可测，先移除掉</span></span><br><span class="line"><span class="keyword">var</span> reducePlus = people.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 分別是前一个返回值, 当前值, 当前索引值</span></span><br><span class="line">  <span class="built_in">console</span>.log(accumulator, currentValue, currentIndex);</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue.money;  <span class="comment">// 与前一个值相加</span></span><br><span class="line">&#125;, <span class="number">0</span>);                                      <span class="comment">// 传入初始化值为 0</span></span><br><span class="line"><span class="built_in">console</span>.log(reducePlus);                    <span class="comment">// 总和为 5300</span></span><br></pre></td></tr></table></figure><p>也可以相互对比，取出最高的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceBestOne = people.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reduce'</span>, accumulator, currentValue, currentIndex)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(accumulator, currentValue.money); <span class="comment">// 与前一个值比较哪个更大</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reduceBestOne);                  <span class="comment">// 最大值为 2000</span></span><br></pre></td></tr></table></figure><p>reduce功能很强大，其余几种遍历方法可以用reduce方法来代替，这里只列出map被reduce代替的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map方法</span></span><br><span class="line"><span class="keyword">var</span> mapMoneyDouble = people.map( <span class="function"><span class="keyword">function</span> (<span class="params"> item, index, array </span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> item.money*<span class="number">2</span>;               <span class="comment">//钱翻倍</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span> .log(mapMoneyDouble); <span class="comment">// 4000, 3600, 3000, Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce方法实现同样的功能</span></span><br><span class="line"><span class="keyword">var</span> reduceMoneyDouble = people.reduce( <span class="function"><span class="keyword">function</span> (<span class="params"> accumulator, currentValue, currentIndex, array </span>) </span>&#123;             <span class="comment">//钱翻倍</span></span><br><span class="line">  accumulator.push(currentValue.money*<span class="number">2</span>);                <span class="comment">//钱翻倍</span></span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;,[]);</span><br><span class="line"><span class="built_in">console</span> .log(reduceMoneyDouble); <span class="comment">// 4000, 3600, 3000, Infinity</span></span><br></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍数组常见的遍历方法：forEach、map、filter、find、every、some、reduce，它们都有个共同点：不会改变原始数组。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="数组" scheme="https://luozongmin.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【译】谈谈“typeof null为object”这一bug的由来</title>
    <link href="https://luozongmin.com/2019/05/11/%E3%80%90%E8%AF%91%E3%80%91%E8%B0%88%E8%B0%88%E2%80%9Ctypeof%20null%E4%B8%BAobject%E2%80%9D%E8%BF%99%E4%B8%80bug%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>https://luozongmin.com/2019/05/11/【译】谈谈“typeof null为object”这一bug的由来/</id>
    <published>2019-05-11T02:36:21.915Z</published>
    <updated>2019-05-11T02:54:52.027Z</updated>
    
    <content type="html"><![CDATA[<p>很多前端初级开发者也许并不深究typeof null为何为Object？想更深地了解这一bug的由来，可以参阅Dr. Axel Rauschmayer关于”typeof null”的历史这篇文章。<a id="more"></a>     </p><blockquote><p>原文链接：<a href="http://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">http://www.2ality.com/2013/10/typeof-null.html</a></p></blockquote><p>我看了下C语言关于<code>typeof</code>的规范，它对于<code>typeof null</code>为何结果是’<code>object</code>’有更好的解释。  </p><p>在JavaScript中，<code>typeof null</code>的结果是’<code>Object</code>‘，它错误地暗示<code>null</code>是一个对象，实际上它是一个原始值。我在<a href="https://luozongmin.com/2019/05/09/JS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86/">上一篇文章</a>也提到了这是JS的一大bug，不幸的是这并不能解决，因为这将破坏现有规范，接下来解释下这个bug的历史。  </p><p>“<code>typeof null</code>”的错误从JavaScripts第一个版本开始就已经存在了。在这个版本，值以32位为单位存储，由小型标签（1-3位）和值的实际数据组成。类型标签存储在单元的低位中。 其中有五种：   </p><ul><li>000: <code>object</code>. 数据是对象的引用。</li><li>1: <code>int</code>. 数据是31位有符号整数。</li><li>010: <code>double</code>. 数据是对双浮点数的引用。</li><li>100: <code>string</code>. 数据是对字符串的引用。</li><li>110: <code>boolean</code>. 数据是布尔值。</li></ul><p>也就是说，最低位是1，然后类型标签只有1位长，即<code>int</code>型。 或者最低位为0，那么类型标签的长度为3位，为其余4种类型提供了两个附加位。  </p><p>但有2个值是特殊的：  </p><ul><li><code>undefined</code>（JSVAL_VOID）是整数−2^30（整数范围之外的数字）。</li><li><code>null</code>(JSVAL_NULL) 为机器码NULL的空指针，或者说：为0的object类型标签。   </li></ul><p>现在应该明白为什么<code>typeof</code>认为<code>null</code>是一个对象：它检测一个他的类型标签并且返回”<code>object</code>”。 以下是<code>typeof</code>的引擎代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">JS_PUBLIC_API(JSType)</span><br><span class="line">   JS_TypeOfValue(JSContext *cx, jsval v)</span><br><span class="line">   &#123;</span><br><span class="line">       JSType type = JSTYPE_VOID;</span><br><span class="line">       JSObject *obj;</span><br><span class="line">       JSObjectOps *ops;</span><br><span class="line">       JSClass *clasp;</span><br><span class="line"></span><br><span class="line">       CHECK_REQUEST(cx);</span><br><span class="line">       <span class="keyword">if</span> (JSVAL_IS_VOID(v)) &#123;  <span class="comment">// (1)</span></span><br><span class="line">           type = JSTYPE_VOID;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_OBJECT(v)) &#123;  <span class="comment">// (2)</span></span><br><span class="line">           obj = JSVAL_TO_OBJECT(v);</span><br><span class="line">           <span class="keyword">if</span> (obj &amp;&amp;</span><br><span class="line">               (ops = obj-&gt;<span class="built_in">map</span>-&gt;ops,</span><br><span class="line">                ops == &amp;js_ObjectOps</span><br><span class="line">                ? (clasp = OBJ_GET_CLASS(cx, obj),</span><br><span class="line">                   clasp-&gt;call || clasp == &amp;js_FunctionClass) <span class="comment">// (3,4)</span></span><br><span class="line">                : ops-&gt;call != <span class="number">0</span>)) &#123;  <span class="comment">// (3)</span></span><br><span class="line">               type = JSTYPE_FUNCTION;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               type = JSTYPE_OBJECT;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_NUMBER(v)) &#123;</span><br><span class="line">           type = JSTYPE_NUMBER;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_STRING(v)) &#123;</span><br><span class="line">           type = JSTYPE_STRING;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JSVAL_IS_BOOLEAN(v)) &#123;</span><br><span class="line">           type = JSTYPE_BOOLEAN;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述代码执行的步骤如下：  </p><ul><li>（1）引擎首先检测值是否是<code>undefined</code>(VOID)，它通过<code>==</code>做了这样的比较：  </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSVAL_IS_VOID(v)  ((v) == JSVAL_VOID)</span></span><br></pre></td></tr></table></figure><ul><li><p>下一个（2）是检测该值是否具有<code>object type</code>。如果它可使用<code>call</code>被调用（3）或其存在内部属性<code>[[Class]]</code>标记为函数（4），则v是函数。 否则，它是一个对象。 这是由<code>typeof null</code>生成的结果。  </p></li><li><p>后续检查是针对<code>number</code>，<code>string</code>和<code>boolean</code>，甚至没有明确检查<code>null</code>。这可以由以下C语言宏执行。  </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JSVAL_IS_NULL(v)  ((v) == JSVAL_NULL)`</span></span><br></pre></td></tr></table></figure><p>这看似是一个非常明显的bug，但不要忘记，第一个版本的JavaScript完成只用了极少的时间，具体可以看看<a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" target="_blank" rel="noopener">JavaScript的诞生</a>。   </p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多前端初级开发者也许并不深究typeof null为何为Object？想更深地了解这一bug的由来，可以参阅Dr. Axel Rauschmayer关于”typeof null”的历史这篇文章。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS中一切都是对象吗？看这一篇就知道了</title>
    <link href="https://luozongmin.com/2019/05/09/JS%E4%B8%AD%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E7%9F%A5%E9%81%93%E4%BA%86/"/>
    <id>https://luozongmin.com/2019/05/09/JS中一切都是对象吗？看这一篇就知道了/</id>
    <published>2019-05-09T07:48:37.688Z</published>
    <updated>2019-06-30T06:07:12.480Z</updated>
    
    <content type="html"><![CDATA[<p>当你刚开始学习JavaScript时，你是否有遇到许多书籍，教程以及那些说“JavaScript中的所有内容都是对象”的人？这算是一个JavaScript中老生常谈的话题了，虽然它并不是100％正确（JavaScript中不是所有都是对象），但其实这种说法又有那么一点说得过去，这可能有点自相矛盾。<a id="more"></a>   </p><p><img src="/images/object-1.jpg" alt>     </p><p>想必有点疑惑吧，那么造成这种现象的原因是什么呢？接下来就由我一一道来。  </p><h4 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h4><p>说起一切都是对象这种说法的由来，就要好好提一下历史因素了。  </p><p>1995年，JavaScript诞生之年，Netscape公司（JavaScript的设计者）与Sun公司（Java语言的发明者和所有者）合作开发一种可以嵌入网页的脚本语言，将JavaScript的数据结构借鉴Java而设计，包括将值分成原始值和对象两大类。   </p><p><strong>Java中一切皆对象，但基本类型却不是对象，为了解决这个问题，Java让每个基本类型都对应了一个包装器类型</strong>。包装器类型将基本类型包装起来，添加了属性和方法，包装器类型即为对象，所以可以这么说Java中的一切都可以充当对象，不会说的那么绝对。  </p><p>因此借鉴了Java数据结构的JavaScript也同样在基本类型中各对应了一个包装器类型，JavaScript中的一切都可以充当对象，接下来将详细进行介绍。  </p><h4 id="原始类型与对象"><a href="#原始类型与对象" class="headerlink" title="原始类型与对象"></a>原始类型与对象</h4><p>JavaScript中值可以分为两大类：原始类型和对象。  </p><p><strong>定义</strong>  </p><p>在JavaScript中，有六种原始数据类型：  </p><ul><li>Boolean - <code>true</code> 或 <code>false</code></li><li>null - 用 <code>type of</code> 检验 <code>null</code> 数据类型时为 <code>Object</code> ，但它不是对象，这是JS的一个bug</li><li>undefined</li><li>number - JavaScript中的所有数字都是浮点数，没有整数</li><li>string</li><li>symbol (ES6)</li></ul><p>除去上面的原始数据类型，所有其他值都是对象。对象可以进一步分为：  </p><ul><li>原始值的包装类型：<code>Boolean</code>,<code>Number</code>,<code>String</code>. - 很少直接使用。  </li><li>以下类型生成的对象也可以通过构造函数创建：</li></ul><ol><li>[] 类同于 new Array()</li><li>{} 类同于 new Object()</li><li>function() {} 类同于 new Function()</li><li>/\s<em>/ 类同于 new RegExp(“\s</em>“) </li></ol><ul><li>Dates: new Date(“2011-12-24”)  </li></ul><p><strong>不同点</strong>  </p><p>第一个不同点： </p><p>原始类型没有附加方法; 所以你永远不会看到<code>undefined.toString（）</code>。 也正因为如此，原始类型是不可变的，因为它们没有附加的方法可以改变它：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"boy"</span>;</span><br><span class="line">s.bar = <span class="string">"girl"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.bar); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>而默认情况下，对象是可变的，可以添加方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.foo = <span class="number">123</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(obj.foo); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>第二个不同点：</p><p>此外，与作为引用存储的对象不同，原始类型作为值本身存储。 这在执行相等性检查时会产生影响：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dog"</span> === <span class="string">"dog"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">14</span> === <span class="number">14</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#123;&#125; === &#123;&#125;; <span class="comment">// false</span></span><br><span class="line">[] === []; <span class="comment">// false</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) === (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>原始类型按值存储，对象通过引用存储，存储地址也不同，原始类型直接存放在栈中，而对象是存放在堆里的，具体可以看之前写的关于<a href="https://luozongmin.com/2019/04/22/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/">内存空间</a>这篇文章。  </p><h4 id="原始值及其包装器"><a href="#原始值及其包装器" class="headerlink" title="原始值及其包装器"></a>原始值及其包装器</h4><p>三个基本类型<code>string</code>，<code>number</code>和<code>boolean</code>，它们有时被当做包装器类型，并且在原始值和包装类型之间进行转换很简单：  </p><ul><li>原始类型 to 包装类型: <code>new String(&quot;abc&quot;)</code></li><li>包装类型 to 原始类型: <code>new String(&quot;abc&quot;).valueOf()</code> </li></ul><p>比如字符串<code>“abc”</code>之类的原始值与<code>new String（“abc”）</code>之类的包装器实例有根本上的不同。 例如（用<code>typeof</code>和<code>instanceof</code>判断时）：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">"pet"</span>;  <span class="comment">//"string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"pet"</span>);  <span class="comment">//"object"</span></span><br><span class="line">    </span><br><span class="line"><span class="string">"pet"</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"pet"</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>;  <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line"><span class="string">"pet"</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"pet"</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>其实包装器实例就是一个对象，没办法在JavaScript中比较对象，甚至不能通过非严格相等 ==： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"pet"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"pet"</span>);</span><br><span class="line">a == b;  <span class="comment">// false</span></span><br><span class="line">a == a;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此JavaScript中的一切都可以充当对象，而JavaScript中的一切都是对象这种说法是欠妥的。</p><h4 id="临时包装（Auto-Boxing）"><a href="#临时包装（Auto-Boxing）" class="headerlink" title="临时包装（Auto-Boxing）"></a>临时包装（Auto-Boxing）</h4><p>有趣的是，原始字符串和对象的构造函数都是<code>String</code>函数。 更有趣的是你可以在原始字符串上调用<code>.constructor</code>这个方法，可是之前说过原始类型不能有方法，咋回事呢？先看下面的代码： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pet = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"dog"</span>)</span><br><span class="line">pet.constructor === <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">"dog"</span>).constructor === <span class="built_in">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码所发生的事情是一个叫做Auto-Boxing的过程，我觉得翻译成中文是“临时包装”比较适宜。 当您尝试在某些基本类型上调用属性或方法时，JavaScript首先将其转换为临时包装器对象，并访问其上的属性/方法，而不会影响原始属性。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pet = <span class="string">"dog"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pet.length); <span class="comment">// 3</span></span><br><span class="line">pet === <span class="string">"dog"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，要访问属性<code>length</code>，JavaScript发生临时包装过程将<code>pet</code>转换为包装器对象，访问完包装器对象的<code>length</code>属性，然后将其丢弃。 这样做不会影响<code>pet</code>（<code>pet</code>仍然是一个原始字符串）。  </p><p>这也解释了为什么JavaScript在尝试将属性分配给基本类型时不会出问题，因为赋值是在该临时包装器对象上完成的，而不是基本类型本身，比如： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;</span><br><span class="line">foo.bar = <span class="string">"lzm"</span>; <span class="comment">// 是在临时包装器对象上完成的赋值</span></span><br><span class="line">foo.bar; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>但原始类型<code>undefined</code>和<code>null</code>，都是没有包装器对象的，当你尝试赋予属性时，它会报错。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line">foo.bar = <span class="string">"lzm"</span>; <span class="comment">// Uncaught TypeError: Cannot set property 'bar' of null</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1.并非JavaScript中的所有内容都是对象，应该说所有内容都可以充当对象。</p><p>2.JavaScript中有6种原始类型。</p><p>3.所有不是原始类型的值都是一个对象。</p><p>4.字符串，布尔值和数字可以表示为基本类型，但作为包装器类型时也可以表示为对象。</p><p>5.由于名为autoboxing的JavaScript特性，某些原始类型（字符串，数字，布尔值）似乎表现得有点像对象。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的GitHub博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你刚开始学习JavaScript时，你是否有遇到许多书籍，教程以及那些说“JavaScript中的所有内容都是对象”的人？这算是一个JavaScript中老生常谈的话题了，虽然它并不是100％正确（JavaScript中不是所有都是对象），但其实这种说法又有那么一点说得过去，这可能有点自相矛盾。
    
    </summary>
    
      <category term="JavaScript" scheme="https://luozongmin.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://luozongmin.com/tags/JavaScript/"/>
    
      <category term="对象" scheme="https://luozongmin.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
